/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository

'Shell commands' plugin for Obsidian.
Copyright (C) 2021 - 2022 Jarkko Linnanvirta

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
*/

'use strict';

var obsidian = require('obsidian');
var child_process = require('child_process');
var os = require('os');
var path = require('path');
var electron = require('electron');
var fs = require('fs');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Modal extends obsidian.Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
        this._isOpen = false;
    }
    onOpen() {
        this._isOpen = true;
        // Make the modal scrollable if it has more content than what fits in the screen.
        this.modalEl.addClass("SC-modal", "SC-scrollable");
        // Approve the modal by pressing the enter key (if enabled).
        if (this.plugin.settings.approve_modals_by_pressing_enter_key) {
            this.scope.register([], "enter", (event) => {
                // Check that no textarea is focused and no autocomplete menu is open.
                if (0 === document.querySelectorAll("textarea:focus").length &&
                    0 === document.querySelectorAll("div.SC-autocomplete").length) {
                    // No textareas with focus and no open autocomplete menus were found.
                    this.approve();
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
        }
    }
    isOpen() {
        return this._isOpen;
    }
    setTitle(title) {
        this.titleEl.innerText = title;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class ConfirmationModal extends SC_Modal {
    constructor(plugin, title, question, yes_button_text) {
        super(plugin);
        this.question = question;
        this.yes_button_text = yes_button_text;
        this.approved = false;
        this.setTitle(title);
        this.promise = new Promise((resolve) => {
            this.resolve_promise = resolve;
        });
    }
    onOpen() {
        super.onOpen();
        // Display the question
        this.modalEl.createEl("p", { text: this.question });
        // Display the yes button
        new obsidian.Setting(this.modalEl)
            .addButton(button => button
            .setButtonText(this.yes_button_text)
            .onClick(() => this.approve()));
    }
    approve() {
        // Got a confirmation from a user
        this.resolve_promise(true);
        this.approved = true;
        this.close();
    }
    onClose() {
        super.onClose();
        if (!this.approved) { // TODO: Find out if there is a way to not use this kind of flag property. Can the status be checked from the promise itself?
            this.resolve_promise(false);
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * If true, logging stuff to console.log() will be enabled.
 * Might also enable some testing {{variables}} in the future, perhaps.
 */
let DEBUG_ON = false;
function setDEBUG_ON(value) {
    DEBUG_ON = value;
}
/**
 * Calls console.log(), but only if debugging is enabled.
 * @param message
 */
function debugLog(message) {
    if (DEBUG_ON) {
        console.log(message);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class IDGenerator {
    constructor(reserved_ids = [], min_length = 10, characters = "abcdefghijklmnopqrstuvwxyz0123456789") {
        this.reserved_ids = reserved_ids;
        this.min_length = min_length;
        this.characters = characters;
    }
    addReservedID(id) {
        debugLog(IDGenerator.name + ": Adding id " + id + " to the list of reserved ids.");
        this.reserved_ids.push(id);
    }
    generateID() {
        let generated_id = "";
        while (generated_id.length < this.min_length || this.isIDReserved(generated_id)) {
            generated_id += this.generateCharacter();
        }
        this.reserved_ids.push(generated_id);
        debugLog(IDGenerator.name + ": Generated id " + generated_id);
        return generated_id;
    }
    getReservedIDs() {
        return this.reserved_ids;
    }
    generateCharacter() {
        return this.characters.charAt(Math.floor(Math.random() * this.characters.length));
    }
    isIDReserved(id) {
        return this.reserved_ids.contains(id);
    }
}
const id_generator = new IDGenerator();
function getIDGenerator() {
    return id_generator;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function getVaultAbsolutePath(app) {
    // Original code was copied 2021-08-22 from https://github.com/phibr0/obsidian-open-with/blob/84f0e25ba8e8355ff83b22f4050adde4cc6763ea/main.ts#L66-L67
    // But the code has been rewritten 2021-08-27 as per https://github.com/obsidianmd/obsidian-releases/pull/433#issuecomment-906087095
    const adapter = app.vault.adapter;
    if (adapter instanceof obsidian.FileSystemAdapter) {
        return adapter.getBasePath();
    }
    return null;
}
function getPluginAbsolutePath(plugin) {
    return normalizePath2(path__namespace.join(getVaultAbsolutePath(plugin.app), plugin.app.vault.configDir, "plugins", plugin.getPluginId()));
}
/**
 * For some reason there is no Platform.isWindows .
 */
function isWindows() {
    return process.platform === "win32";
}
/**
 * This is just a wrapper around platform() in order to cast the type to PlatformId.
 * TODO: Consider renaming this to getPlatformId().
 */
function getOperatingSystem() {
    // @ts-ignore In theory, platform() can return an OS name not included in OperatingSystemName. But as Obsidian
    // currently does not support anything else than Windows, Mac and Linux (except mobile platforms, but they are
    // ruled out by the manifest of this plugin), it should be safe to assume that the current OS is one of those
    // three.
    return os.platform();
}
function getView(app) {
    const view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (!view) {
        debugLog("getView(): Could not get a view. Will return null.");
        return null;
    }
    return view;
}
function getEditor(app) {
    const view = getView(app);
    if (null === view) {
        // Could not get a view.
        return null;
    }
    // Ensure that view.editor exists! It exists at least if this is a MarkDownView.
    if ("editor" in view) {
        // Good, it exists.
        // @ts-ignore We already know that view.editor exists.
        return view.editor;
    }
    // Did not find an editor.
    debugLog("getEditor(): 'view' does not have a property named 'editor'. Will return null.");
    return null;
}
function cloneObject(object) {
    return Object.assign({}, object);
}
/**
 * Merges two or more objects together. If they have same property names, former objects' properties get overwritten by later objects' properties.
 *
 * @param objects
 */
function combineObjects(...objects) {
    return Object.assign({}, ...objects);
}
function mergeSets(set1, set2) {
    return new Set([...set1, ...set2]);
}
/**
 * Returns a new Set cloned from 'from_set', with all items presented in 'remove' removed from it.
 *
 * @param from_set
 * @param remove Can be either a Set of removable items, or a single item.
 */
function removeFromSet(from_set, remove) {
    const reduced_set = new Set(from_set);
    if (remove instanceof Set) {
        for (const removable of remove) {
            reduced_set.delete(removable);
        }
    }
    else {
        reduced_set.delete(remove);
    }
    return reduced_set;
}
/**
 * Same as normalizePath(), but fixes these glitches:
 * - Leading forward slashes / backward slashes should not be removed.
 * - \ should not be converted to / if platform is Windows. In other words, / should be converted to \ if platform is Windows.
 *
 * TODO: I've opened a discussion about this on Obsidian's forums. If anything new comes up in the discussion, make changes accordingly. https://forum.obsidian.md/t/normalizepath-removes-a-leading/24713
 */
function normalizePath2(path) {
    // 1. Preparations
    path = path.trim();
    const leading_slashes_regexp = /^[/\\]*/gu; // Get as many / or \ slashes as there are in the very beginning of path. Can also be "" (an empty string).
    let leading_slashes = leading_slashes_regexp.exec(path)[0];
    // 2. Run the original normalizePath()
    path = obsidian.normalizePath(path);
    // 3. Fixes
    // Check that correct slashes are used.
    if (isWindows()) {
        // The platform is Windows.
        // Convert / to \
        path = path.replace(/\//gu, "\\"); // Need to use a regexp instead of a normal "/" -> "\\" replace because the normal replace would only replace first occurrence of /.
        leading_slashes = leading_slashes.replace(/\//gu, "\\"); // Same here.
    }
    // Now ensure that path still contains leading slashes (if there were any before calling normalizePath()).
    // Check that the path should have a similar set of leading slashes at the beginning. It can be at least "/" (on linux/Mac), or "\\" (on Windows when it's a network path), in theory even "///" or "\\\\\" whatever.
    // normalizePath() seems to remove leading slashes (and they are needed to be re-added), but it's needed to check first, otherwise the path would have double leading slashes if normalizePath() gets fixed in the future.
    if (leading_slashes.length && path.slice(0, leading_slashes.length) !== leading_slashes) {
        // The path does not contain the required set of leading slashes, so add them.
        path = leading_slashes + path;
    }
    // 4. Done
    return path;
}
function extractFileName(file_path, with_extension = true) {
    if (with_extension) {
        return path__namespace.parse(file_path).base;
    }
    else {
        return path__namespace.parse(file_path).name;
    }
}
function extractFileParentPath(file_path) {
    return path__namespace.parse(file_path).dir;
}
function joinObjectProperties(object, glue) {
    let result = "";
    for (const property_name in object) {
        if (result.length) {
            result += glue;
        }
        // @ts-ignore
        result += object[property_name];
    }
    return result;
}
/**
 * Removes all duplicates from an array.
 *
 * Idea is copied 2021-10-06 from https://stackoverflow.com/a/33121880/2754026
 */
function uniqueArray(array) {
    return [...new Set(array)];
}
/**
 * Opens a web browser in the specified URL.
 * @param url
 */
function gotoURL(url) {
    electron.shell.openExternal(url); // This returns a promise, but it can be ignored as there's nothing to do after opening the browser.
}
function generateObsidianCommandName(plugin, shell_command, alias) {
    const prefix = plugin.settings.obsidian_command_palette_prefix;
    if (alias) {
        // If an alias is set for the command, Obsidian's command palette should display the alias text instead of the actual command.
        return prefix + alias;
    }
    return prefix + shell_command;
}
function isInteger(value, allow_minus) {
    if (allow_minus) {
        return !!value.match(/^-?\d+$/u);
    }
    else {
        return !!value.match(/^\d+$/u);
    }
}
/**
 * Translates 1-indexed caret line and column to a 0-indexed EditorPosition object. Also translates a possibly negative line
 * to a positive line from the end of the file, and a possibly negative column to a positive column from the end of the line.
 * @param editor
 * @param caret_line
 * @param caret_column
 */
function prepareEditorPosition(editor, caret_line, caret_column) {
    // Determine line
    if (caret_line < 0) {
        // Negative line means to calculate it from the end of the file.
        caret_line = Math.max(0, editor.lastLine() + caret_line + 1);
    }
    else {
        // Positive line needs just a small adjustment.
        // Editor line is zero-indexed, line numbers are 1-indexed.
        caret_line -= 1;
    }
    // Determine column
    if (caret_column < 0) {
        // Negative column means to calculate it from the end of the line.
        caret_column = Math.max(0, editor.getLine(caret_line).length + caret_column + 1);
    }
    else {
        // Positive column needs just a small adjustment.
        // Editor column is zero-indexed, column numbers are 1-indexed.
        caret_column -= 1;
    }
    return {
        line: caret_line,
        ch: caret_column,
    };
}
function getSelectionFromTextarea(textarea_element, return_null_if_empty) {
    const selected_text = textarea_element.value.substring(textarea_element.selectionStart, textarea_element.selectionEnd);
    return "" === selected_text && return_null_if_empty ? null : selected_text;
}
/**
 * Creates an HTMLElement (with freely decidable tag) and adds the given content into it as normal text. No HTML formatting
 * is supported, i.e. possible HTML special characters are shown as-is. Newline characters are converted to <br> elements.
 *
 * @param tag
 * @param content
 * @param parent_element
 */
function createMultilineTextElement(tag, content, parent_element) {
    const content_element = parent_element.createEl(tag);
    // Insert content line-by-line
    const content_lines = content.split(/\r\n|\r|\n/g); // Don't use ( ) with | because .split() would then include the newline characters in the resulting array.
    content_lines.forEach((content_line, content_line_index) => {
        // Insert the line.
        content_element.insertAdjacentText("beforeend", content_line);
        // Insert a linebreak <br> if needed.
        if (content_line_index < content_lines.length - 1) {
            content_element.insertAdjacentHTML("beforeend", "<br>");
        }
    });
    return content_element;
}
function randomInteger(min, max) {
    const range = max - min + 1;
    return min + Math.floor(Math.random() * range);
}
/**
 * Does the following prefixings:
 *   \ will become \\
 *   [ will become \[
 *   ] will become \]
 *   ( will become \(
 *   ) will become \)
 *
 * @param content
 */
function escapeMarkdownLinkCharacters(content) {
    return content.replace(/[\\()\[\]]/gu, "\\$&");
}
function copyToClipboard(text) {
    return electron.clipboard.writeText(text);
}
async function getFileContentWithoutYAML(app, file) {
    return new Promise((resolve) => {
        // The logic is borrowed 2022-09-01 from https://forum.obsidian.md/t/how-to-get-current-file-content-without-yaml-frontmatter/26197/2
        // Thank you, endorama! <3
        const file_content = app.vault.read(file);
        file_content.then((file_content) => {
            const frontmatter_cache = app.metadataCache.getFileCache(file).frontmatter;
            if (frontmatter_cache) {
                // A YAML frontmatter is present in the file.
                const frontmatter_end_line_number = frontmatter_cache.position.end.line + 1; // + 1: Take the last --- line into account, too.
                const file_content_without_frontmatter = file_content.split("\n").slice(frontmatter_end_line_number).join("\n");
                return resolve(file_content_without_frontmatter);
            }
            else {
                // No YAML frontmatter is present in the file.
                // Return the whole file content, because there's nothing to remove.
                return resolve(file_content);
            }
        });
    });
}

/**
 * Escapes a string that will be used as a pattern in a regular expression.
 *
 * Note that this does not escape minus: - . It's probably ok as long as you won't wrap the result of this function in square brackets [ ] . For more information, read a comment by coolaj86 on Nov 29, 2019 at 2:44 in this Stack Overflow answer: https://stackoverflow.com/a/6969486/2754026
 *
 * Copied 2022-03-10 from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping
 * Modifications:
 *  - Added TypeScript data type hints for the parameter and return value.
 *  - Added 'export' keyword.
 *  - Added this JSDoc.
 *  - No other changes.
 *
 * @param string
 * @return string
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * Variables that can be used to inject values to shell commands using {{variable:argument}} syntax.
 */
class Variable {
    constructor(plugin) {
        this.plugin = plugin;
        /**
         * If this is false, the variable can be assigned a default value that can be used in situations where the variable is unavailable.
         * @protected
         */
        this.always_available = true;
        this.app = plugin.app;
        this.reset(); // This is also called in parseShellCommandVariables(), but call it here just in case.
    }
    /**
     * Variable instances are reused multiple times. This method resets all properties that are modified during usage:
     *  - error_messages
     *  - arguments
     */
    reset() {
        this.error_messages = [];
        this.arguments = {};
    }
    getValue(t_shell_command = null, sc_event = null, 
    /**
     * Will parse variables in a default value (only used if this variable is not available this time). The callback
     * is only used, if t_shell_command is given. Set to null, if no variable parsing is needed for default values.
     * */
    default_value_parser = null) {
        return new Promise((resolve) => {
            if (this.isAvailable(sc_event)) {
                // The variable can be used.
                this.generateValue(sc_event).then((value) => {
                    resolve({
                        value: value,
                        error_messages: this.error_messages,
                        succeeded: this.error_messages.length === 0,
                    });
                });
            }
            else {
                // The variable is not available in this situation.
                // Check what should be done.
                const default_value_configuration = t_shell_command?.getDefaultValueConfigurationForVariable(this); // The method can return undefined, and t_shell_command can be null.
                const default_value_type = default_value_configuration ? default_value_configuration.type : "show-errors";
                const debug_message_base = "Variable " + this.getFullName() + " is not available. ";
                switch (default_value_type) {
                    case "show-errors":
                        // Generate error messages by calling generateValue().
                        debugLog(debug_message_base + "Will prevent shell command execution and show visible error messages.");
                        // TODO: Availability errors generation should be moved to happen in a different method than .generateValue(), which should only be called when the variable is available.
                        this.generateValue(sc_event).then(() => {
                            resolve({
                                value: null,
                                error_messages: this.error_messages,
                                succeeded: false,
                            });
                        });
                        break;
                    case "cancel-silently":
                        // Prevent execution, but do not show any errors
                        debugLog(debug_message_base + "Will prevent shell command execution silently without visible error messages.");
                        return resolve({
                            value: null,
                            error_messages: [],
                            succeeded: false,
                        });
                    case "value":
                        // Return a default value.
                        debugLog(debug_message_base + "Will use a default value: " + default_value_configuration.value);
                        if (default_value_parser) {
                            // Parse possible variables in the default value.
                            default_value_parser(default_value_configuration.value).then((default_value_parsing_result) => {
                                return resolve({
                                    value: default_value_parsing_result.succeeded
                                        ? default_value_parsing_result.parsed_content
                                        : default_value_parsing_result.original_content,
                                    error_messages: default_value_parsing_result.error_messages,
                                    succeeded: default_value_parsing_result.succeeded,
                                });
                            });
                        }
                        else {
                            // No variable parsing is wanted.
                            return resolve({
                                value: default_value_configuration.value,
                                error_messages: [],
                                succeeded: true,
                            });
                        }
                }
            }
        });
    }
    getParameters() {
        const child_class = this.constructor;
        return child_class.parameters;
    }
    getParameterSeparator() {
        const child_class = this.constructor;
        return child_class.parameter_separator;
    }
    getPattern() {
        const error_prefix = this.variable_name + ".getPattern(): ";
        let pattern = '\\{\\{!?' + escapeRegExp(this.variable_name);
        for (const parameter_name in this.getParameters()) {
            const parameter = this.getParameters()[parameter_name];
            let parameter_type_pattern = this.getParameterSeparator(); // Here this.parameter_separator (= : ) is included in the parameter value just so that it's not needed to do nested parenthesis to accomplish possible optionality: (:())?. parseShellCommandVariables() will remove the leading : .
            // Check should we use parameter.options or parameter.type.
            if (undefined === parameter.options &&
                undefined === parameter.type) {
                // Neither is defined :(
                throw Error(error_prefix + "Parameter '" + parameter_name + "' should define either 'type' or 'options', neither is defined!");
            }
            else if (undefined !== parameter.options &&
                undefined !== parameter.type) {
                // Both are defined :(
                throw Error(error_prefix + "Parameter '" + parameter_name + "' should define either 'type' or 'options', not both!");
            }
            else if (undefined !== parameter.options) {
                // Use parameter.options
                parameter_type_pattern += parameter.options.join("|" + this.getParameterSeparator()); // E.g. "absolute|:relative" for {{file_path:mode}} variable's 'mode' parameter.
            }
            else {
                // Use parameter.type
                switch (parameter.type) {
                    case "string":
                        parameter_type_pattern += ".*?";
                        break;
                    case "integer":
                        parameter_type_pattern += "\\d+";
                        break;
                    default:
                        throw Error(error_prefix + "Parameter '" + parameter_name + "' has an unrecognised type: " + parameter.type);
                }
            }
            // Add the subpattern to 'pattern'.
            pattern += "(" + parameter_type_pattern + ")";
            if (!parameter.required) {
                // Make the parameter optional.
                pattern += "?";
            }
        }
        pattern += '\\}\\}';
        return pattern;
    }
    getParameterNames() {
        return Object.getOwnPropertyNames(this.getParameters());
    }
    /**
     * @param parameter_name
     * @param argument At this point 'argument' is always a string, but this method may convert it to another data type, depending on the parameter's data type.
     */
    setArgument(parameter_name, argument) {
        const parameter_type = this.getParameters()[parameter_name].type ?? "string"; // If the variable uses "options" instead of "type", then the type is always "string".
        switch (parameter_type) {
            case "string":
                this.arguments[parameter_name] = argument;
                break;
            case "integer":
                this.arguments[parameter_name] = parseInt(argument);
                break;
        }
    }
    newErrorMessage(message) {
        const prefix = "{{" + this.variable_name + "}}: ";
        this.error_messages.push(prefix + message);
        debugLog(prefix + message);
    }
    newErrorMessages(messages) {
        messages.forEach((message) => {
            this.newErrorMessage(message);
        });
    }
    getAutocompleteItems() {
        // Check if the variable has at least one _mandatory_ parameter.
        let parameter_indicator = "";
        const parameter_names = Object.getOwnPropertyNames(this.getParameters())
            .filter(parameter_name => this.getParameters()[parameter_name].required === true) // Only include mandatory parameters
        ;
        if (parameter_names.length > 0) {
            parameter_indicator = Variable.parameter_separator; // When the variable name ends with a parameter separator character, it indicates to a user that an argument should be supplied.
        }
        return [
            // Normal variable
            {
                value: "{{" + this.variable_name + parameter_indicator + "}}",
                help_text: (this.help_text + " " + this.getAvailabilityText()).trim(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped version of the variable
            {
                value: "{{!" + this.variable_name + parameter_indicator + "}}",
                help_text: (this.help_text + " " + this.getAvailabilityText()).trim(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>" + this.getFullName() + "</strong>";
    }
    /**
     * Returns the Variable's name wrapped in {{ and }}.
     *
     * TODO: Change hardcoded {{ }} entries to use this method all around the code.
     */
    getFullName() {
        return "{{" + this.variable_name + "}}";
    }
    /**
     * Returns a unique string that can be used in default value configurations.
     * @return Normal variable name, if this is a built-in variable; or an ID string if this is a CustomVariable.
     */
    getIdentifier() {
        return this.getFullName();
    }
    /**
     * Tells whether the variable can be currently accessed. If you want to know if the variable can sometimes be inaccessible,
     * use isAlwaysAvailable() instead.
     */
    isAvailable(sc_event) {
        return true; // If the variable is always available, return true. If not, the variable should override this method.
    }
    /**
     * This can be used to determine if the variable can sometimes be unavailable. Used in settings to allow a user to define
     * default values for variables that are not always available, filtering out always available variables for which default
     * values would not make sense.
     */
    isAlwaysAvailable() {
        return this.always_available;
    }
    /**
     * For variables that are always available, returns an empty string.
     */
    getAvailabilityText() {
        return "";
    }
    /**
     * Same as getAvailabilityText(), but removes HTML from the result.
     */
    getAvailabilityTextPlain() {
        return this.getAvailabilityText().replace(/<\/?strong>/ig, ""); // Remove <strong> and </strong> markings from the help text
    }
}
Variable.parameter_separator = ":";
/**
 * A definition for what parameters this variables takes.
 * @protected
 */
Variable.parameters = {};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Output extends Variable {
    constructor(plugin, output_content) {
        super(plugin);
        this.output_content = output_content;
        this.variable_name = "output";
        this.help_text = "Gives text outputted by a shell command after it's executed.";
    }
    generateValue() {
        return Promise.resolve(this.output_content);
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> in <em>output wrappers</em>, cannot be used as input for shell commands.";
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Escaper {
    constructor(raw_value) {
        this.raw_value = raw_value;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * Prefixes all characters that are not letters, numbers or underscores with a prefix character that can be defined by child classes.
 */
class AllSpecialCharactersEscaper extends Escaper {
    escape() {
        return this.raw_value.replace(/[^\w\d]/gu, (special_character) => {
            // Do the replacing in a function in order to avoid a possible $ character to be interpreted by JavaScript to interact with the regex.
            // More information: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter (referenced 2021-11-02.
            return this.prefix + special_character;
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class ShEscaper extends AllSpecialCharactersEscaper {
    constructor() {
        super(...arguments);
        this.prefix = "\\"; // In *sh, escaping should use a backslash, e.g. "Hello, world!" becomes \"Hello\,\ world\!\"
    }
    escape() {
        return this.replace_newlines(super.escape());
    }
    /**
     * Converts escaped newline characters to a form that the Bourne family shells will interpret as literal newlines,
     * not as ignorable characters.
     *
     * @param escaped_value
     * @private
     */
    replace_newlines(escaped_value) {
        return escaped_value
            .replaceAll(this.prefix + "\r", this.prefix + this.prefix + "r") // Replace a real linefeed with a literal "\\r".
            .replaceAll(this.prefix + "\n", this.prefix + this.prefix + "n") // Replace a real newline with a literal "\\n".
        ;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PowerShellEscaper extends AllSpecialCharactersEscaper {
    constructor() {
        super(...arguments);
        this.prefix = "`"; // In PowerShell, escaping should use a ` character, e.g. "Hello, world!" becomes `"Hello`,` world`!`"
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function escapeValue(shell, raw_value) {
    shell = extractFileName(shell.toLowerCase());
    let escaper;
    switch (shell) {
        case "bash":
        case "dash":
        case "zsh":
        case "sh": // May sometimes appear when using the "Use system default (sh)" option as a default shell.
            escaper = new ShEscaper(raw_value);
            break;
        case "powershell.exe": // PowerShell 5 is only available for Windows.
        case "pwsh.exe": // In Windows.
        case "pwsh": // In Linux and Mac. (SC does not actually support using PowerShell on Linux/Mac just yet, but support can be added).
            escaper = new PowerShellEscaper(raw_value);
            break;
        case "cmd.exe":
            // Exception: There is no escaping support for CMD, so all values will be left unescaped when CMD is used. :(
            return raw_value;
        default:
            // Shell was not recognised.
            new obsidian.Notice("EscapeValue(): Unrecognised shell: " + shell);
            throw new Error("EscapeValue(): Unrecognised shell: " + shell);
    }
    return escaper.escape();
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Clipboard extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "clipboard";
        this.help_text = "Gives the content you last copied to your clipboard.";
    }
    generateValue() {
        return Promise.resolve(electron.clipboard.readText());
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class EditorVariable extends Variable {
    requireEditor() {
        this.editor = getEditor(this.app);
        if (null === this.editor) {
            // No editor.
            this.newErrorMessage("Could not get an editor instance! Please create a discussion in GitHub.");
            return false;
        }
        return true;
    }
    /**
     * Can be made protected if needed to be accessed by subclasses.
     * @private
     */
    requireView() {
        this.view = getView(this.app);
        if (null === this.view) {
            // No view.
            this.newErrorMessage("Could not get a view instance! Please create a discussion in GitHub.");
            return false;
        }
        return true;
    }
    isViewModeSource() {
        if (!this.requireView()) {
            return false;
        }
        const view_mode = this.view.getMode(); // "preview" or "source" (can also be "live" but I don't know when that happens)
        switch (view_mode) {
            case "preview":
                // The leaf is in preview mode, which makes things difficult.
                // FIXME: Make it possible to use this feature also in preview mode.
                debugLog("EditorVariable: 'view' is in preview mode, and the poor guy who wrote this code, does not know how to return an editor instance that could be used for getting text selection.");
                this.newErrorMessage("You need to turn editing mode on, unfortunately this variable does not work in preview mode.");
                return false;
            case "source":
                // Good, the editor is in "source" mode, so it's possible to get a selection.
                return true;
            default:
                throw new Error("EditorVariable: Unrecognised view mode: " + view_mode);
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022:
 *  - Vinay Rajur (created most of the content of the Variable_CaretPosition class)
 *  - Jarkko Linnanvirta (some minor/structural changes)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact:
 *  - Vinay Rajur: https://github.com/vrajur
 *  - Jarkko Linnanvirta: https://github.com/Taitava/
 */
class Variable_CaretPosition extends EditorVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "caret_position";
        this.help_text = "Gives the line number and column position of the current caret position as 'line:column'. Get only the line number using {{caret_position:line}}, and only the column with {{caret_position:column}}. Line and column numbers are 1-indexed.";
        this.always_available = false;
    }
    generateValue() {
        return new Promise((resolve) => {
            // Check that we are able to get an editor
            if (!this.requireEditor()) {
                // Nope.
                return resolve(null);
            }
            const position = this.editor.getCursor('to');
            const line = position.line + 1; // editor position is zero-indexed, line numbers are 1-indexed
            const column = position.ch + 1; // editor position is zero-indexed, column positions are 1-indexed
            if (Object.keys(this.arguments).length > 0) {
                switch (this.arguments.mode.toLowerCase()) {
                    case "line":
                        return resolve(`${line}`);
                    case "column":
                        return resolve(`${column}`);
                    default:
                        this.newErrorMessage("Unrecognised argument: " + this.arguments.mode);
                        return resolve(null);
                }
            }
            else {
                // default case when no args provided
                return resolve(`${line}:${column}`);
            }
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + "}}",
                help_text: "Gives the line number and column position of the current caret position as 'line:column'. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable"
            },
            {
                value: "{{" + this.variable_name + ":line}}",
                help_text: "Gives the line number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable"
            },
            {
                value: "{{" + this.variable_name + ":column}}",
                help_text: "Gives the column number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable"
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + "}}",
                help_text: "Gives the line number and column position of the current caret position as 'line:column'. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":line}}",
                help_text: "Gives the line number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":column}}",
                help_text: "Gives the column number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{caret_position}}</strong>, <strong>{{caret_position:line}}</strong> or <strong>{{caret_position:column}}</strong>";
    }
    isAvailable() {
        return !!getEditor(this.app);
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> when a note pane is open, not in graph view, nor when viewing non-text files.";
    }
}
Variable_CaretPosition.parameters = {
    mode: {
        options: ["line", "column"],
        required: false,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Date extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "date";
        this.help_text = "Gives a date/time stamp as per your liking. The \"format\" part can be customized and is mandatory. Formatting options: https://momentjs.com/docs/#/displaying/format/";
    }
    generateValue() {
        return Promise.resolve(obsidian.moment().format(this.arguments.format));
    }
}
Variable_Date.parameters = {
    format: {
        type: "string",
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * TODO: Consider creating a decorator class for TFolder and moving this function to be a method in it.
 *
 * @param app
 * @param folder
 * @param mode
 */
function getFolderPath(app, folder, mode) {
    switch (mode.toLowerCase()) {
        case "absolute":
            return normalizePath2(getVaultAbsolutePath(app) + "/" + folder.path);
        case "relative":
            if (folder.isRoot()) {
                // Obsidian API does not give a correct folder.path value for the vault's root folder.
                // TODO: See this discussion and apply possible changes if something will come up: https://forum.obsidian.md/t/vault-root-folders-relative-path-gives/24857
                return ".";
            }
            else {
                // This is a normal subfolder
                return normalizePath2(folder.path); // Normalize to get a correct slash between directories depending on platform. On Windows it should be \ .
            }
    }
}
/**
 * TODO: Consider creating a decorator class for TFile and moving this function to be a method in it.
 *
 * @param app
 * @param file
 * @param mode
 */
function getFilePath(app, file, mode) {
    switch (mode.toLowerCase()) {
        case "absolute":
            return normalizePath2(getVaultAbsolutePath(app) + "/" + file.path);
        case "relative":
            return normalizePath2(file.path); // Normalize to get a correct slash depending on platform. On Windows it should be \ .
    }
}
/**
 * TODO: Consider creating a decorator class for TFile and moving this function to be a method in it.
 * @param file
 * @param with_dot
 */
function getFileExtension(file, with_dot) {
    const file_extension = file.extension;
    // Should the extension be given with or without a dot?
    if (with_dot) {
        // A preceding dot must be included.
        if (file_extension.length > 0) {
            // But only if the extension is not empty.
            return "." + file_extension;
        }
    }
    // No dot should be included, or the extension is empty
    return file_extension;
}
function getFileTags(app, file) {
    const cache = app.metadataCache.getFileCache(file);
    const tags = uniqueArray(obsidian.getAllTags(cache)); // If a tag is defined multiple times in the same file, getTags() returns it multiple times, so use uniqueArray() to iron out duplicates.
    // Remove preceding hash characters. E.g. #tag becomes tag
    tags.forEach((tag, index) => {
        tags[index] = tag.replace("#", "");
    });
    return tags;
}
/**
 * @param app
 * @param file
 * @param property_path
 * @return string|string[] Either a result string, or an array of error messages.
 */
function getFileYAMLValue(app, file, property_path) {
    const error_messages = [];
    const property_parts = property_path.split(".");
    // Validate all property names along the path
    property_parts.forEach((property_name) => {
        if (0 === property_name.length) {
            error_messages.push("YAML property '" + property_path + "' has an empty property name. Remove possible double dots or a preceding/trailing dot.");
        }
    });
    if (error_messages.length > 0) {
        // Failure in property name(s).
        return error_messages;
    }
    const frontmatter = app.metadataCache.getFileCache(file)?.frontmatter;
    // Check that a YAML section is available in the file
    if (undefined === frontmatter) {
        // No it ain't.
        error_messages.push("No YAML frontmatter section is defined for the current file.");
        return error_messages;
    }
    else {
        // A YAML section is available.
        // Read the property's value.
        return nested_read(property_parts, property_path, frontmatter);
    }
    /**
     * @param property_parts Property path split into parts (= property names). The deeper the nesting goes, the fewer values will be left in this array.
     * @param property_path The original, whole property path string.
     * @param yaml_object
     * @return string|string[] Either a result string, or an array of error messages.
     */
    function nested_read(property_parts, property_path, yaml_object) {
        let property_name = property_parts.shift();
        // Check if the property name is a negative numeric index.
        if (property_name.match(/^-\d+$/u)) {
            // The property name is a negative number.
            // Check that yaml_object contains at least one element.
            const yaml_object_keys = Object.getOwnPropertyNames(yaml_object).filter(key => key !== "length"); // All _really custom_ yaml keys, not .length
            if (yaml_object_keys.length > 0) {
                // Check if yaml_object happens to be an indexed list.
                let is_indexed_list = true;
                yaml_object_keys.forEach((key) => {
                    if (!key.match(/^\d+$/u)) {
                        // At least one non-numeric key was found, so consider the object not to be an indexed list.
                        is_indexed_list = false;
                    }
                });
                if (is_indexed_list) {
                    // The object is an indexed list and property_name is a negative index number.
                    // Translate property_name to a positive index from the end of the list.
                    property_name = Math.max(0, // If a greatly negative index is used (e.g. -999), don't allow the new index to be negative again.
                    yaml_object_keys.length
                        + parseInt(property_name) // Although + is used, this will be a subtraction, because property_name is prefixed with a minus.
                    ).toString();
                }
            }
        }
        // Get a value
        const property_value = yaml_object[property_name];
        // Check if the value is either: not found, object, or literal.
        if (undefined === property_value) {
            // Property was not found.
            error_messages.push("YAML property '" + property_name + "' is not found.");
            return error_messages;
        }
        else if ("object" === typeof property_value) {
            // The value is an object.
            // Check if we have still dot notation parts left in the property path.
            if (0 === property_parts.length) {
                // No dot notation parts are left.
                // Freak out.
                const nested_elements_keys = Object.getOwnPropertyNames(property_value);
                if (nested_elements_keys.length > 0) {
                    error_messages.push("YAML property '" + property_name + "' contains a nested element with keys: " + nested_elements_keys.join(", ") + ". Use e.g. '" + property_path + "." + nested_elements_keys[0] + "' to get its value.");
                }
                else {
                    error_messages.push("YAML property '" + property_name + "' contains a nested element. Use a property name that points to a literal value instead.");
                }
                return error_messages;
            }
            else {
                // Dot notation path still has another property name left, so continue the hunt.
                return nested_read(property_parts, property_path, property_value);
            }
        }
        else {
            // The value is literal, i.e. a string or number.
            if (property_parts.length > 0) {
                error_messages.push("YAML property '" + property_name + "' gives already a literal value '" + property_value.toString() + "', but the argument '" + property_path + "' assumes the property would contain a nested element with the key '" + property_parts[0] + "'.");
                return error_messages;
            }
            else {
                return property_value.toString();
            }
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class FileVariable extends Variable {
    constructor() {
        super(...arguments);
        this.always_available = false;
    }
    getFile() {
        const current_file = this.getActiveFile();
        if (!current_file) {
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null;
        }
        return current_file;
    }
    isAvailable() {
        const current_file = this.getActiveFile();
        return !!current_file;
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> when the active pane contains a file, not in graph view or other non-file view.";
    }
    getActiveFile() {
        return this.app.workspace.getActiveFile();
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_FileExtension extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "file_extension";
        this.help_text = "Gives the current file name's ending. Use {{file_extension:with-dot}} to include a preceding dot. If the extension is empty, no dot is added. {{file_extension:no-dot}} never includes a dot.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const file = this.getFile();
            if (!file) {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
            return resolve(getFileExtension(file, this.arguments.dot === "with-dot"));
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":no-dot}}",
                help_text: "Gives the current file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":with-dot}}",
                help_text: "Gives the current file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":no-dot}}",
                help_text: "Gives the current file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":with-dot}}",
                help_text: "Gives the current file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{file_extension:with-dot}}</strong> or <strong>{{file_extension:no-dot}}</strong>";
    }
}
Variable_FileExtension.parameters = {
    "dot": {
        options: ["with-dot", "no-dot"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_FileName extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "file_name";
        this.help_text = "Gives the current file name with a file extension. If you need it without the extension, use {{title}} instead.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const file = this.getFile();
            if (!file) {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
            return resolve(file.name);
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_FilePath extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "file_path";
        this.help_text = "Gives path to the current file, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (active_file) {
                return resolve(getFilePath(this.app, active_file, this.arguments.mode));
            }
            else {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{file_path:relative}}</strong> or <strong>{{file_path:absolute}}</strong>";
    }
}
Variable_FilePath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class FolderVariable extends FileVariable {
    getFolder() {
        // Get current file's parent folder.
        const file = this.getFile();
        if (!file) {
            return null;
        }
        const current_folder = file.parent;
        if (!current_folder) {
            // No parent folder.
            this.newErrorMessage("The current file does not have a parent for some strange reason.");
            return null;
        }
        return current_folder;
    }
    isAvailable() {
        // Normal check: ensure a file pane is open and focused.
        if (!super.isAvailable()) {
            return false;
        }
        // Check that a parent folder is available. (If not, it's strange.)
        return !!this.getFile().parent;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_FolderName extends FolderVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "folder_name";
        this.help_text = "Gives the current file's parent folder name. No ancestor folders are included.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const folder = this.getFolder();
            if (!folder) {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
            return resolve(folder.name); // TODO: Consider changing to `folder.isRoot() ? "." : folder.name;` as is done in Variable_NewNoteFileName.
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_FolderPath extends FolderVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "folder_path";
        this.help_text = "Gives path to the current file's parent folder, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const folder = this.getFolder();
            if (folder) {
                return resolve(getFolderPath(this.app, folder, this.arguments.mode));
            }
            else {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file's parent folder, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file's parent folder, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file's parent folder, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file's parent folder, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{folder_path:relative}}</strong> or <strong>{{folder_path:absolute}}</strong>";
    }
}
Variable_FolderPath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    }
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Selection extends EditorVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "selection";
        this.help_text = "Gives the currently selected text.";
        this.always_available = false;
    }
    async generateValue() {
        // Check that we are able to get an editor
        if (!this.requireEditor()) {
            // Nope.
            return null;
        }
        // Check the view mode
        if (this.isViewModeSource()) {
            // Good, the editor is in "source" mode, so it's possible to get a selection.
            if (this.editor.somethingSelected()) {
                return this.editor.getSelection();
            }
            return "";
        }
        return null;
    }
    isAvailable() {
        const view = getView(this.app);
        return view && getEditor(this.app) && view.getMode() === "source";
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> in <em>Editing</em>/<em>Live preview</em> mode, <strong>not</strong> in <em>Reading</em> mode.";
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Tags extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "tags";
        this.help_text = "Gives all tags defined in the current note. Replace the \"separator\" part with a comma, space or whatever characters you want to use as a separator between tags. A separator is always needed to be defined.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (active_file) {
                // We do have an active file
                return resolve(getFileTags(this.app, active_file).join(this.arguments.separator));
            }
            else {
                // No file is active at the moment
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
        });
    }
}
Variable_Tags.parameters = {
    separator: {
        type: "string",
        required: true,
    }
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Title extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "title";
        this.help_text = "Gives the current file name without a file extension. If you need it with the extension, use {{file_name}} instead.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (active_file) {
                return resolve(active_file.basename);
            }
            return resolve(null);
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_VaultPath extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "vault_path";
        this.help_text = "Gives the Obsidian vault's absolute path from the root of the filesystem. This is the same that is used as a default working directory if you do not define one manually. If you define a working directory manually, this variable won't give you your manually defined directory, it always gives the vault's root directory.";
    }
    generateValue() {
        return Promise.resolve(getVaultAbsolutePath(this.app));
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Workspace extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "workspace";
        this.help_text = "Gives the current workspace's name.";
        this.always_available = false;
    }
    generateValue() {
        return new Promise((resolve) => {
            // Idea how to access the workspaces plugin is copied 2021-09-15 from https://github.com/Vinzent03/obsidian-advanced-uri/blob/f7ef80d5252481242e69496208e925874209f4aa/main.ts#L168-L179
            // @ts-ignore internalPlugins exists although it's not in obsidian.d.ts.
            const workspaces_plugin = this.app.internalPlugins?.plugins?.workspaces;
            if (!workspaces_plugin) {
                this.newErrorMessage("Workspaces core plugin is not found for some reason. Please create a discussion in GitHub.");
                return resolve(null);
            }
            else if (!workspaces_plugin.enabled) {
                this.newErrorMessage("Workspaces core plugin is not enabled.");
                return resolve(null);
            }
            const workspace_name = workspaces_plugin.instance?.activeWorkspace;
            if (!workspace_name) {
                this.newErrorMessage("Could not figure out the current workspace's name. Probably you have not loaded a workspace. You can do it e.g. via \"Manage workspaces\" from the left side panel.");
                return resolve(null);
            }
            // All ok
            return resolve(workspace_name);
        });
    }
    isAvailable() {
        // @ts-ignore internalPlugins exists, although it's not in obsidian.d.ts.
        const workspaces_plugin = this.app.internalPlugins?.plugins?.workspaces;
        return workspaces_plugin && workspaces_plugin.enabled && workspaces_plugin.instance?.activeWorkspace;
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> when the Workspaces core plugin is enabled.";
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_Passthrough extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "passthrough";
        this.help_text = "Gives the same value that is passed as an argument. Used for testing special characters' escaping.";
    }
    generateValue() {
        // Simply return the argument that was received.
        return Promise.resolve(this.arguments.value);
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> in debug mode.";
    }
}
Variable_Passthrough.parameters = {
    value: {
        type: "string",
        required: true,
    }
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_YAMLValue extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "yaml_value";
        this.help_text = "Reads a single value from the current file's frontmatter. Takes a property name as an argument. You can access nested properties with dot notation: property1.property2";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (active_file) {
                // We do have an active file
                const result = this.getFileYAMLValue(active_file);
                if (Array.isArray(result)) {
                    // The result contains error message(s).
                    this.newErrorMessages(result);
                    return resolve(null);
                }
                else {
                    // The result is ok, it's a string.
                    return resolve(result);
                }
            }
            else {
                // No file is active at the moment
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
        });
    }
    getFileYAMLValue(active_file) {
        if (!this.yaml_value_cache) {
            this.yaml_value_cache = getFileYAMLValue(this.app, active_file, this.arguments.property_name);
        }
        return this.yaml_value_cache;
    }
    reset() {
        super.reset();
        this.yaml_value_cache = undefined;
    }
    isAvailable() {
        if (!super.isAvailable()) {
            return false;
        }
        const active_file = this.getFile();
        return typeof this.getFileYAMLValue(active_file) === "string";
    }
}
Variable_YAMLValue.parameters = {
    property_name: {
        type: "string",
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class EventVariable extends Variable {
    constructor() {
        super(...arguments);
        this.always_available = false;
    }
    /**
     * Every subclass should call this method in their generateValue() before returning a value. If this method returns false,
     * then a variable should not generate a value, as the dependent SC_Event is unavailable.
     *
     * TODO: Change the error system to throw exceptions instead of relying on return values.
     *
     * @protected
     */
    checkSC_EventSupport(sc_event) {
        // 1. Check generally that an event is happening.
        // (Maybe this check is not so important anymore, as sc_event is now received as a parameter instead of from a property, but check just in case.)
        if (!sc_event) {
            this.newErrorMessage("This variable can only be used during events: " + this.getSummaryOfSupportedEvents());
            return false;
        }
        // 2. Check particularly which event it is.
        if (!this.supportsSC_Event(sc_event.getClass())) {
            this.newErrorMessage("This variable does not support event '" + sc_event.static().getTitle() + "'. Supported events: " + this.getSummaryOfSupportedEvents());
            return false;
        }
        return true;
    }
    supportsSC_Event(sc_event_class) {
        return this.supported_sc_events.contains(sc_event_class);
    }
    getSummaryOfSupportedEvents() {
        const sc_event_titles = [];
        this.supported_sc_events.forEach((sc_event_class) => {
            sc_event_titles.push(sc_event_class.getTitle());
        });
        return sc_event_titles.join(", ");
    }
    isAvailable(sc_event) {
        if (!sc_event) {
            return false;
        }
        return this.supportsSC_Event(sc_event.getClass());
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> in events: " + this.getSummaryOfSupportedEvents() + ".";
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
const DocumentationMainLink = "https://publish.obsidian.md/shellcommands";
const DocumentationBuiltInVariablesLink = "https://publish.obsidian.md/shellcommands/Variables/Variables+-+general+principles#All+variables";
const DocumentationCustomVariablesLink = "https://publish.obsidian.md/shellcommands/Variables/Custom+variables";
const DocumentationAutocompleteLink = "https://publish.obsidian.md/shellcommands/Variables/Autocomplete/Autocomplete";
const DocumentationEventsFolderLink = "https://publish.obsidian.md/shellcommands/Events/";
const DocumentationPATHAugmentationsLink = "https://publish.obsidian.md/shellcommands/Environments/Additions+to+the+PATH+environment+variable";
const DocumentationOutputWrappersLink = "https://publish.obsidian.md/shellcommands/Output+handling/Output+wrappers";
const DocumentationOutputHandlingModeLink = "https://publish.obsidian.md/shellcommands/Output+handling/Realtime+output+handling";
const GitHubLink = "https://github.com/Taitava/obsidian-shellcommands";
const ChangelogLink = "https://github.com/Taitava/obsidian-shellcommands/blob/main/CHANGELOG.md";
const LicenseLink = "https://github.com/Taitava/obsidian-shellcommands/blob/main/LICENSE";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * Named SC_Event instead of just Event, because Event is a class in JavaScript.
 */
class SC_Event {
    constructor(plugin) {
        /**
         * If true, changing the enabled/disabled status of the event permits registering the event immediately, so it can activate
         * anytime. Usually true, but can be set to false if immediate registering tends to trigger the event unnecessarily.
         *
         * Events are always registered when loading the plugin, regardless of this property.
         * @protected
         */
        this.register_after_changing_settings = true;
        this.event_registrations = {};
        this.default_configuration = {
            enabled: false,
        };
        this.plugin = plugin;
        this.app = plugin.app;
        this.subclass_instance = this; // Stores a subclass reference, not a base class reference.
    }
    getClass() {
        return this.subclass_instance.constructor;
    }
    canRegisterAfterChangingSettings() {
        return this.register_after_changing_settings;
    }
    register(t_shell_command) {
        const event_reference = this._register(t_shell_command);
        if (event_reference) {
            this.plugin.registerEvent(event_reference);
            this.event_registrations[t_shell_command.getId()] = event_reference;
        }
    }
    unregister(t_shell_command) {
        // Check if an EventRef is available.
        if (undefined === this.event_registrations[t_shell_command.getId()]) {
            // The event was registered without an EventRef object.
            // Provide a TShellCommand to _unregister() so it can do a custom unregistering.
            this._unregister(t_shell_command);
        }
        else {
            // The event registration had created an EventRef object.
            // Provide the EventRef to _unregister() and forget it afterwards.
            this._unregister(this.event_registrations[t_shell_command.getId()]);
            delete this.event_registrations[t_shell_command.getId()];
        }
    }
    /**
     * Executes a shell command.
     * @param t_shell_command
     * @param parsing_process SC_MenuEvent can use this to pass an already started ParsingProcess instance. If omitted, a new ParsingProcess will be created.
     */
    async trigger(t_shell_command, parsing_process) {
        // Execute the shell command.
        const executor = new ShellCommandExecutor(this.plugin, t_shell_command, this);
        await executor.doPreactionsAndExecuteShellCommand(parsing_process);
    }
    static getCode() {
        return this.event_code;
    }
    static getTitle() {
        return this.event_title;
    }
    getSummaryOfEventVariables() {
        const variable_names = [];
        this.getEventVariables().forEach((variable) => {
            variable_names.push("{{" + variable.variable_name + "}}");
        });
        return variable_names.join(", ");
    }
    getEventVariables() {
        const event_variables = [];
        this.plugin.getVariables().forEach((variable) => {
            // Check if the variable is an EventVariable
            if (variable instanceof EventVariable) {
                // Yes it is.
                // Check if the variable supports this particular event.
                if (variable.supportsSC_Event(this.getClass())) {
                    // Yes it supports.
                    event_variables.push(variable);
                }
            }
        });
        return event_variables;
    }
    /**
     * Can be overridden in child classes that need custom settings fields.
     *
     * @param enabled
     */
    getDefaultConfiguration(enabled) {
        const configuration = cloneObject(this.default_configuration);
        configuration.enabled = enabled;
        return configuration;
    }
    getConfiguration(t_shell_command) {
        return t_shell_command.getEventConfiguration(this);
    }
    /**
     * Can be overridden in child classes to provide custom configuration fields for ShellCommandsExtraOptionsModal.
     *
     * @param extra_settings_container
     */
    createExtraSettingsFields(extra_settings_container, t_shell_command) {
        // Most classes do not define custom settings, so for those classes this method does not need to do anything.
    }
    /**
     * Returns all the TShellCommand instances that have enabled this event.
     */
    getTShellCommands() {
        const enabled_t_shell_commands = [];
        Object.values(this.plugin.getTShellCommands()).forEach((t_shell_command) => {
            // Check if this event has been enabled for the shell command.
            if (t_shell_command.isSC_EventEnabled(this.static().event_code)) {
                // Yes, it's enabled.
                enabled_t_shell_commands.push(t_shell_command);
            }
        });
        return enabled_t_shell_commands;
    }
    static() {
        return this.constructor;
    }
    /**
     * Child classes can override this to hook into a situation where a user has enabled an event in settings.
     *
     * @param t_shell_command The TShellCommand instance for which this SC_Event was enabled for.
     */
    onAfterEnabling(t_shell_command) {
        // If an SC_Event does not override this hook method, do nothing.
    }
    static getDocumentationLink() {
        return DocumentationEventsFolderLink + encodeURIComponent(this.event_title);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_WorkspaceEvent extends SC_Event {
    _register(t_shell_command) {
        // @ts-ignore TODO: Find a way to get a dynamic type for this.workspace_event .
        return this.app.workspace.on(this.workspace_event, this.getTrigger(t_shell_command));
    }
    _unregister(event_reference) {
        this.app.workspace.offref(event_reference);
    }
    getTrigger(t_shell_command) {
        return async (...parameters /* Need to have this ugly parameter thing so that subclasses can define their own parameters. */) => await this.trigger(t_shell_command);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_MenuEvent extends SC_WorkspaceEvent {
    async addTShellCommandToMenu(t_shell_command, menu) {
        // Create the menu item as soon as possible. (If it's created after 'await parsing_process.process()' below, it won't be shown in the menu for some reason, at least in Obsidian 0.16.1).
        // No title is set here, it will be set later.
        let menu_item;
        menu.addItem(item => menu_item = item
            .setIcon(t_shell_command.getIconId()) // Icon id can be null.
            .onClick(async () => {
            await this.trigger(t_shell_command, parsing_process);
        }));
        // Parse shell command variables to get a title
        let title = t_shell_command.getAliasOrShellCommand(); // May contain unparsed variables.
        let parsing_process;
        if (this.plugin.settings.preview_variables_in_command_palette) {
            // Start a parsing process
            parsing_process = t_shell_command.createParsingProcess(this);
            if (await parsing_process.process()) {
                // Parsing succeeded.
                const parsing_results = parsing_process.getParsingResults();
                title = parsing_results["alias"].parsed_content || parsing_results["shell_command"].parsed_content; // Try to use a parsed alias, but if no alias is available, use a parsed shell command instead.
            }
            // If parsing process fails, the failed process can be passed to this.trigger(). The execution will eventually be cancelled and error messages displayed (if displaying is allowed).
        }
        // Update menu item title.
        menu_item.setTitle(title);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_AbstractFileMenuEvent extends SC_MenuEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "file-menu";
    }
    getTrigger(t_shell_command) {
        return async (menu, file, source, leaf) => {
            // Check that it's the correct menu: if the SC_Event requires a file menu, 'file' needs to be a TFile, otherwise it needs to be a TFolder.
            if ((this.file_or_folder === "folder" && file instanceof obsidian.TFolder) || (this.file_or_folder === "file" && file instanceof obsidian.TFile)) {
                // The menu is correct.
                // File/folder for declareExtraVariables()
                switch (this.file_or_folder) {
                    case "file":
                        this.file = file;
                        break;
                    case "folder":
                        this.folder = file;
                        break;
                }
                await this.addTShellCommandToMenu(t_shell_command, menu);
            }
        };
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FileMenu extends SC_AbstractFileMenuEvent {
    constructor() {
        super(...arguments);
        this.file_or_folder = "file";
    }
    getFile() {
        return this.file;
    }
    getFolder() {
        return this.file.parent;
    }
}
SC_Event_FileMenu.event_code = "file-menu";
SC_Event_FileMenu.event_title = "File menu";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_VaultEvent extends SC_Event {
    _register(t_shell_command) {
        // @ts-ignore TODO: Find a way to get a dynamic type for this.vault_event .
        return this.app.vault.on(this.vault_event, this.getTrigger(t_shell_command));
    }
    _unregister(event_reference) {
        this.app.vault.offref(event_reference);
    }
    getTrigger(t_shell_command) {
        return async (file, ...extra_arguments /* Needed for SC_Event_FileRenamed and SC_Event_FolderRenamed to be able to define an additional parameter.*/) => {
            // Check that it's the correct type of file: if the SC_Event requires a file, 'file' needs to be a TFile, otherwise it needs to be a TFolder.
            if ((this.file_or_folder === "folder" && file instanceof obsidian.TFolder) || (this.file_or_folder === "file" && file instanceof obsidian.TFile)) {
                // The file type is correct.
                // File/folder for declareExtraVariables()
                switch (this.file_or_folder) {
                    case "file":
                        this.file = file;
                        break;
                    case "folder":
                        this.folder = file;
                        break;
                }
                await this.trigger(t_shell_command);
            }
        };
    }
    /**
     * This should only be called if file_or_folder is "file"!
     */
    getFile() {
        return this.file;
    }
    /**
     * This can be called whether file_or_folder is "file" or "folder".
     */
    getFolder() {
        switch (this.file_or_folder) {
            case "file":
                return this.file.parent;
            case "folder":
                return this.folder;
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FileCreated extends SC_VaultEvent {
    constructor() {
        super(...arguments);
        this.vault_event = "create";
        this.file_or_folder = "file";
    }
}
SC_Event_FileCreated.event_code = "file-created";
SC_Event_FileCreated.event_title = "File created";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FileContentModified extends SC_VaultEvent {
    constructor() {
        super(...arguments);
        this.vault_event = "modify";
        this.file_or_folder = "file";
    }
}
SC_Event_FileContentModified.event_code = "file-content-modified";
SC_Event_FileContentModified.event_title = "File content modified";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FileDeleted extends SC_VaultEvent {
    constructor() {
        super(...arguments);
        this.vault_event = "delete";
        this.file_or_folder = "file";
    }
}
SC_Event_FileDeleted.event_code = "file-deleted";
SC_Event_FileDeleted.event_title = "File deleted";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_VaultMoveOrRenameEvent extends SC_VaultEvent {
    constructor() {
        super(...arguments);
        this.vault_event = "rename";
    }
    getTrigger(t_shell_command) {
        // Get a trigger from the parent class (SC_VaultEvent).
        const trigger = super.getTrigger(t_shell_command);
        return async (abstract_file, old_relative_path) => {
            // Detect if the file/folder was moved or renamed.
            // If the file/folder name has stayed the same, conclude that the file has been MOVED, not renamed. Otherwise, conclude the opposite.
            const old_file_name = extractFileName(old_relative_path);
            const new_file_name = abstract_file.name;
            const event_type = (old_file_name === new_file_name) ? "move" : "rename"; // Tells what really happened. this.move_or_rename tells what is the condition for the event to trigger.
            // Only proceed the triggering, if the determined type equals the one defined by the event class.
            if (event_type === this.move_or_rename) {
                // The event type is correct.
                // File and folder for declareExtraVariables()
                switch (this.file_or_folder) {
                    case "file":
                        this.file_old_relative_path = old_relative_path;
                        this.folder_old_relative_path = extractFileParentPath(old_relative_path);
                        break;
                    case "folder":
                        this.folder_old_relative_path = old_relative_path;
                        break;
                }
                // Call the normal trigger function.
                await trigger(abstract_file);
            }
        };
    }
    getFolderOldRelativePath() {
        return this.folder_old_relative_path;
    }
    getFileOldRelativePath() {
        return this.file_old_relative_path;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FileRenamed extends SC_VaultMoveOrRenameEvent {
    constructor() {
        super(...arguments);
        this.move_or_rename = "rename";
        this.file_or_folder = "file";
    }
}
SC_Event_FileRenamed.event_code = "file-renamed";
SC_Event_FileRenamed.event_title = "File renamed";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FileMoved extends SC_VaultMoveOrRenameEvent {
    constructor() {
        super(...arguments);
        this.move_or_rename = "move";
        this.file_or_folder = "file";
    }
}
SC_Event_FileMoved.event_code = "file-moved";
SC_Event_FileMoved.event_title = "File moved";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFileName extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_file_name";
        this.help_text = "Gives the event related file name with a file extension. If you need it without the extension, use {{event_title}} instead.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            return resolve(sc_event.getFile().name);
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFilePath extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_file_path";
        this.help_text = "Gives path to the event related file, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const file = sc_event.getFile();
            return resolve(getFilePath(this.app, file, this.arguments.mode));
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the event related file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the event related file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the event related file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the event related file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_file_path:relative}}</strong> or <strong>{{event_file_path:absolute}}</strong>";
    }
}
Variable_EventFilePath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FolderMenu extends SC_AbstractFileMenuEvent {
    constructor() {
        super(...arguments);
        this.file_or_folder = "folder";
    }
    getFolder() {
        return this.folder;
    }
}
SC_Event_FolderMenu.event_code = "folder-menu";
SC_Event_FolderMenu.event_title = "Folder menu";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FolderCreated extends SC_VaultEvent {
    constructor() {
        super(...arguments);
        this.vault_event = "create";
        this.file_or_folder = "folder";
    }
}
SC_Event_FolderCreated.event_code = "folder-created";
SC_Event_FolderCreated.event_title = "Folder created";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FolderDeleted extends SC_VaultEvent {
    constructor() {
        super(...arguments);
        this.vault_event = "delete";
        this.file_or_folder = "folder";
    }
}
SC_Event_FolderDeleted.event_code = "folder-deleted";
SC_Event_FolderDeleted.event_title = "Folder deleted";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FolderRenamed extends SC_VaultMoveOrRenameEvent {
    constructor() {
        super(...arguments);
        this.move_or_rename = "rename";
        this.file_or_folder = "folder";
    }
}
SC_Event_FolderRenamed.event_code = "folder-renamed";
SC_Event_FolderRenamed.event_title = "Folder renamed";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_FolderMoved extends SC_VaultMoveOrRenameEvent {
    constructor() {
        super(...arguments);
        this.move_or_rename = "move";
        this.file_or_folder = "folder";
    }
}
SC_Event_FolderMoved.event_code = "folder-moved";
SC_Event_FolderMoved.event_title = "Folder moved";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFolderName extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_folder_name";
        this.help_text = "File events: Gives the event related file's parent folder name. Folder events: Gives the selected folder's name. No ancestor folders are included.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FolderMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
            SC_Event_FolderCreated,
            SC_Event_FolderDeleted,
            SC_Event_FolderMoved,
            SC_Event_FolderRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const folder = sc_event.getFolder();
            return resolve(folder.name); // TODO: Consider changing to `folder.isRoot() ? "." : folder.name;` as is done in Variable_NewNoteFileName.
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFolderPath extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_folder_path";
        this.help_text = "File events: Gives path to the event related file's parent folder. Folder events: Gives path to the event related folder. The path is either absolute from the root of the file system, or relative from the root of the Obsidian vault.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FolderMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
            SC_Event_FolderCreated,
            SC_Event_FolderDeleted,
            SC_Event_FolderMoved,
            SC_Event_FolderRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const folder = sc_event.getFolder();
            return resolve(getFolderPath(this.app, folder, this.arguments.mode));
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "File events: Gives path to the event related file's parent folder. Folder events: Gives path to the event related folder. The path is absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "File events: Gives path to the event related file's parent folder. Folder events: Gives path to the event related folder. The path is relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "File events: Gives path to the event related file's parent folder. Folder events: Gives path to the event related folder. The path is absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "File events: Gives path to the event related file's parent folder. Folder events: Gives path to the event related folder. The path is relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_folder_path:relative}}</strong> or <strong>{{event_folder_path:absolute}}</strong>";
    }
}
Variable_EventFolderPath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventTitle extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_title";
        this.help_text = "Gives the event related file name without a file extension. If you need it with the extension, use {{event_file_name}} instead.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            return resolve(sc_event.getFile().basename);
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFileExtension extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_file_extension";
        this.help_text = "Gives the event related file name's ending. Use {{event_file_extension:with-dot}} to include a preceding dot. If the extension is empty, no dot is added. {{event_file_extension:no-dot}} never includes a dot.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const file = sc_event.getFile();
            return resolve(getFileExtension(file, this.arguments.dot === "with-dot"));
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":no-dot}}",
                help_text: "Gives the event related file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":with-dot}}",
                help_text: "Gives the event related file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":no-dot}}",
                help_text: "Gives the event related file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":with-dot}}",
                help_text: "Gives the event related file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_file_extension:with-dot}}</strong> or <strong>{{event_file_extension:no-dot}}</strong>";
    }
}
Variable_EventFileExtension.parameters = {
    "dot": {
        options: ["with-dot", "no-dot"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventTags extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_tags";
        this.help_text = "Gives all tags defined in the event related note. Replace the \"separator\" part with a comma, space or whatever characters you want to use as a separator between tags. A separator is always needed to be defined.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const file = sc_event.getFile();
            return resolve(getFileTags(this.app, file).join(this.arguments.separator));
        });
    }
}
Variable_EventTags.parameters = {
    separator: {
        type: "string",
        required: true,
    }
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventYAMLValue extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_yaml_value";
        this.help_text = "Reads a single value from the event related file's frontmatter. Takes a property name as an argument. You can access nested properties with dot notation: property1.property2";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const file = sc_event.getFile();
            const result = this.getFileYAMLValue(file);
            if (Array.isArray(result)) {
                // The result contains error message(s).
                this.newErrorMessages(result);
                return resolve(null);
            }
            else {
                // The result is ok, it's a string.
                return resolve(result);
            }
        });
    }
    getFileYAMLValue(active_file) {
        if (!this.yaml_value_cache) {
            this.yaml_value_cache = getFileYAMLValue(this.app, active_file, this.arguments.property_name);
        }
        return this.yaml_value_cache;
    }
    reset() {
        super.reset();
        this.yaml_value_cache = undefined;
    }
    isAvailable(sc_event) {
        if (!super.isAvailable(sc_event)) {
            return false;
        }
        const active_file = sc_event.getFile();
        return typeof this.getFileYAMLValue(active_file) === "string";
    }
}
Variable_EventYAMLValue.parameters = {
    property_name: {
        type: "string",
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022:
 *  - Vinay Rajur (created most of the content of the Variable_CaretPosition class)
 *  - Jarkko Linnanvirta (some minor/structural changes)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact:
 *  - Vinay Rajur: https://github.com/vrajur
 *  - Jarkko Linnanvirta: https://github.com/Taitava/
 */
class Variable_Environment extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "environment";
        this.help_text = "Gives an environment variable's value. It's an original value received when Obsidian was started.";
        this.always_available = false;
    }
    generateValue() {
        // Check that the requested environment variable exists.
        return new Promise((resolve) => {
            if (this.isAvailable()) {
                // Yes, it exists.
                return resolve(process.env[this.arguments.variable]);
            }
            else {
                // It does not exist.
                // Freak out.
                this.newErrorMessage(`Environment variable named '${this.arguments.variable}' does not exist.`);
                return resolve(null);
            }
        });
    }
    getHelpName() {
        return "<strong>{{environment:variable}}</strong>";
    }
    isAvailable() {
        return undefined !== process.env[this.arguments.variable];
    }
    getAvailabilityText() {
        return "<strong>Only available</strong> if the passed environment variable name exists.";
    }
}
Variable_Environment.parameters = {
    variable: {
        type: "string",
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventOldFileName extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_old_file_name";
        this.help_text = "Gives the renamed file's old name with a file extension. If you need it without the extension, use {{event_old_title}} instead.";
        this.supported_sc_events = [
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            return resolve(extractFileName(sc_event.getFileOldRelativePath(), true));
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventOldFilePath extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_old_file_path";
        this.help_text = "Gives the renamed/moved file's old path, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
        this.supported_sc_events = [
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const file_old_relative_path = sc_event.getFileOldRelativePath();
            switch (this.arguments.mode.toLowerCase()) {
                case "relative":
                    return resolve(normalizePath2(file_old_relative_path));
                case "absolute":
                    return resolve(normalizePath2(getVaultAbsolutePath(this.app) + "/" + file_old_relative_path));
            }
            this.newErrorMessage("Unrecognized mode parameter: " + this.arguments.mode);
            return resolve(null);
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives the renamed/moved file's old path, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives the renamed/moved file's old path, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives the renamed/moved file's old path, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives the renamed/moved file's old path, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_file_path:relative}}</strong> or <strong>{{event_file_path:absolute}}</strong>";
    }
}
Variable_EventOldFilePath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventOldFolderName extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_old_folder_name";
        this.help_text = "File events: Gives the moved file's old parent folder's name. Folder events: Gives the renamed folder's old name.";
        this.supported_sc_events = [
            SC_Event_FileMoved,
            SC_Event_FolderRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            return resolve(extractFileName(sc_event.getFolderOldRelativePath()));
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventOldFolderPath extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_old_folder_path";
        this.help_text = "File events: Gives the moved file's old parent folder's path. Folder events: Gives the renamed/moved folder's old path. The path is either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
        this.supported_sc_events = [
            SC_Event_FileMoved,
            SC_Event_FolderMoved,
            SC_Event_FolderRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const folder_old_relative_path = sc_event.getFolderOldRelativePath();
            switch (this.arguments.mode.toLowerCase()) {
                case "relative":
                    return resolve(normalizePath2(folder_old_relative_path));
                case "absolute":
                    return resolve(normalizePath2(getVaultAbsolutePath(this.app) + "/" + folder_old_relative_path));
            }
            this.newErrorMessage("Unrecognized mode parameter: " + this.arguments.mode);
            return resolve(null);
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "File events: Gives the moved file's old parent folder's path. Folder events: Gives the renamed/moved folder's old path. The path is absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "File events: Gives the moved file's old parent folder's path. Folder events: Gives the renamed/moved folder's old path. The path is relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "File events: Gives the moved file's old parent folder's path. Folder events: Gives the renamed/moved folder's old path. The path is absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "File events: Gives the moved file's old parent folder's path. Folder events: Gives the renamed/moved folder's old path. The path is relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_file_path:relative}}</strong> or <strong>{{event_file_path:absolute}}</strong>";
    }
}
Variable_EventOldFolderPath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventOldTitle extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_old_title";
        this.help_text = "Gives the renamed file's old name without a file extension. If you need it with the extension, use {{event_old_file_name}} instead.";
        this.supported_sc_events = [
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            return resolve(extractFileName(sc_event.getFileOldRelativePath(), false));
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_NewNoteFolderName extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "new_note_folder_name";
        this.help_text = "Gives the folder name for \"Default location for new notes\" (a setting in Obsidian). No ancestor folders are included.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const current_file = this.app.workspace.getActiveFile(); // Needed just in case new notes should be created in the same folder as the currently open file.
            const folder = this.app.fileManager.getNewFileParent(current_file ? current_file.path : ""); // If no file is open, use an empty string as instructed in .getNewFileParent()'s documentation.
            if (!folder) {
                this.newErrorMessage("Cannot determine a folder name for new notes. Please create a discussion in GitHub."); // I guess this never happens.
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
            return resolve(folder.isRoot() ? "." : folder.name); // If the folder is the vault's root folder, return "." instead of " " (a space character). I don't know why the name is " " when the folder is root.
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_NewNoteFolderPath extends Variable {
    constructor() {
        super(...arguments);
        this.variable_name = "new_note_folder_path";
        this.help_text = "Gives path to the \"Default location for new notes\" folder (a setting in Obsidian), either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const current_file = this.app.workspace.getActiveFile(); // Needed just in case new notes should be created in the same folder as the currently open file.
            const folder = this.app.fileManager.getNewFileParent(current_file ? current_file.path : ""); // If no file is open, use an empty string as instructed in .getNewFileParent()'s documentation.
            if (folder) {
                return resolve(getFolderPath(this.app, folder, this.arguments.mode));
            }
            else {
                this.newErrorMessage("Cannot determine a folder path for new notes. Please create a discussion in GitHub."); // I guess this never happens.
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
        });
    }
    getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the \"Default location for new notes\" folder (a setting in Obsidian), absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the \"Default location for new notes\" folder (a setting in Obsidian), relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the \"Default location for new notes\" folder (a setting in Obsidian), absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the \"Default location for new notes\" folder (a setting in Obsidian), relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{folder_path:relative}}</strong> or <strong>{{folder_path:absolute}}</strong>";
    }
}
Variable_NewNoteFolderPath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    }
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_FileURI extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "file_uri";
        this.help_text = "Gives an Obsidian URI that opens the current file.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (active_file) {
                return resolve(this.plugin.getObsidianURI("open", {
                    file: obsidian.normalizePath(active_file.path), // Use normalizePath() instead of normalizePath2() because / should not be converted to \ on Windows because this is used as a URI, not as a file system path.
                }));
            }
            else {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFileURI extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_file_uri";
        this.help_text = "Gives an Obsidian URI that opens the event related file.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            const file = sc_event.getFile();
            return resolve(this.plugin.getObsidianURI("open", {
                file: obsidian.normalizePath(file.path), // Use normalizePath() instead of normalizePath2() because / should not be converted to \ on Windows because this is used as a URI, not as a file system path.
            }));
        });
    }
}

class Variable_NoteContent extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "note_content";
        this.help_text = "Gives the current note's content without YAML frontmatter. If you need YAML included, use {{file_content}} instead.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (!active_file) {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
            getFileContentWithoutYAML(this.app, active_file).then((file_content_without_yaml) => {
                resolve(file_content_without_yaml);
            });
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventNoteContent extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_note_content";
        this.help_text = "Gives the event related file's content without YAML frontmatter. If you need YAML included, use {{event_file_content}} instead.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            getFileContentWithoutYAML(this.app, sc_event.getFile()).then((file_content) => {
                return resolve(file_content);
            });
        });
    }
}

class Variable_FileContent extends FileVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "file_content";
        this.help_text = "Gives the current file's content, including YAML frontmatter. If you need YAML excluded, use {{note_content}} instead.";
    }
    generateValue() {
        return new Promise((resolve) => {
            const active_file = this.getFile();
            if (!active_file) {
                return resolve(null); // null indicates that getting a value has failed and the command should not be executed.
            }
            // Retrieve file content.
            app.vault.read(active_file).then((file_content) => resolve(file_content));
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_EventFileContent extends EventVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "event_file_content";
        this.help_text = "Gives the event related file's content, including YAML frontmatter. If you need YAML excluded, use {{event_note_content}} instead.";
        this.supported_sc_events = [
            SC_Event_FileMenu,
            SC_Event_FileCreated,
            SC_Event_FileContentModified,
            SC_Event_FileDeleted,
            SC_Event_FileMoved,
            SC_Event_FileRenamed,
        ];
    }
    generateValue(sc_event) {
        return new Promise((resolve) => {
            if (!this.checkSC_EventSupport(sc_event)) {
                return resolve(null);
            }
            // Retrieve file content.
            app.vault.read(sc_event.getFile()).then((file_content) => resolve(file_content));
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Variable_CaretParagraph extends EditorVariable {
    constructor() {
        super(...arguments);
        this.variable_name = "caret_paragraph";
        this.help_text = "Gives a text line at the current caret position.";
    }
    async generateValue() {
        if (!this.requireEditor() || !this.isViewModeSource()) {
            return null;
        }
        const caretPosition = this.editor.getCursor('to');
        return this.editor.getLine(caretPosition.line);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function loadVariables(plugin) {
    const variables = new VariableSet([]);
    // Load CustomVariables
    // Do this before loading built-in variables so that these user-defined variables will appear first in all lists containing variables.
    plugin.getCustomVariableInstances().forEach((custom_variable_instance) => {
        variables.add(custom_variable_instance.createCustomVariable());
    });
    // Load built-in variables.
    const built_in_variables = [
        // Normal variables
        new Variable_CaretParagraph(plugin),
        new Variable_CaretPosition(plugin),
        new Variable_Clipboard(plugin),
        new Variable_Date(plugin),
        new Variable_Environment(plugin),
        new Variable_FileContent(plugin),
        new Variable_FileExtension(plugin),
        new Variable_FileName(plugin),
        new Variable_FilePath(plugin),
        new Variable_FileURI(plugin),
        new Variable_FolderName(plugin),
        new Variable_FolderPath(plugin),
        new Variable_NewNoteFolderName(plugin),
        new Variable_NewNoteFolderPath(plugin),
        new Variable_NoteContent(plugin),
        // Variable_Output is not loaded here, because it's only used in OutputWrappers.
        new Variable_Selection(plugin),
        new Variable_Tags(plugin),
        new Variable_Title(plugin),
        new Variable_VaultPath(plugin),
        new Variable_Workspace(plugin),
        new Variable_YAMLValue(plugin),
        // Event variables
        new Variable_EventFileContent(plugin),
        new Variable_EventFileExtension(plugin),
        new Variable_EventFileName(plugin),
        new Variable_EventFilePath(plugin),
        new Variable_EventFileURI(plugin),
        new Variable_EventFolderName(plugin),
        new Variable_EventFolderPath(plugin),
        new Variable_EventNoteContent(plugin),
        new Variable_EventOldFileName(plugin),
        new Variable_EventOldFilePath(plugin),
        new Variable_EventOldFolderName(plugin),
        new Variable_EventOldFolderPath(plugin),
        new Variable_EventOldTitle(plugin),
        new Variable_EventTags(plugin),
        new Variable_EventTitle(plugin),
        new Variable_EventYAMLValue(plugin),
    ];
    if (DEBUG_ON) {
        // Variables that are only designed for 'Shell commands test suite'.
        built_in_variables.push(new Variable_Passthrough(plugin));
    }
    for (const built_in_variable of built_in_variables) {
        // JavaScript's Set does not have a method to add multiple items at once, so need to iterate them and add one-by-one.
        variables.add(built_in_variable);
    }
    return variables;
}
class VariableSet extends Set {
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * @param plugin
 * @param content
 * @param shell Used to determine how to escape special characters in variable values. Can be null, if no escaping is wanted.
 * @param t_shell_command Will only be used to read default value configurations. Can be null if no TShellCommand is available, but then no default values can be accessed.
 * @param sc_event Use undefined, if parsing is not happening during an event.
 * @param variables If you want to parse only a certain set of variables, define them in this parameter. If this is omitted, all variables will be parsed.
 * @param raw_value_augmenter A callback that will be called before every substitution. Allows modifying or completely changing the resulted variable values.
 * @param escaped_value_augmenter Same as raw_value_augmenter, but called after escaping the value. Can be used to for example wrap values in html elements for displaying purposes.
 * @return ParsingResult
 */
async function parseVariables(plugin, content, shell, t_shell_command, sc_event, variables = plugin.getVariables(), raw_value_augmenter = null, escaped_value_augmenter = null) {
    debugLog("parseVariables(): Starting to parse " + content + " with " + variables.size + " variables.");
    // Initialize a parsing result object
    const parsing_result = {
        original_content: content,
        parsed_content: null,
        succeeded: false,
        error_messages: [],
        count_parsed_variables: 0,
    };
    parsing_result.parsed_content = content; // Create a copy of the variable because we don't want to alter the original value of 'content' during iterating its regex matches. Originally this copy was just another local variable, but now it's changed to be a property in an object.
    for (const variable of variables) {
        const pattern = new RegExp(variable.getPattern(), "igu"); // i: case-insensitive; g: match all occurrences instead of just the first one. u: support 4-byte unicode characters too.
        const parameter_names = variable.getParameterNames();
        let argument_matches; // Need to prefix with _ because JavaScript reserves the variable name 'arguments'.
        while ((argument_matches = pattern.exec(content)) !== null) {
            // Make sure the variable does not contain old arguments or old error messages. Needed because variable instances are reused between parsing calls.
            variable.reset();
            // Count how many times any variables have appeared.
            parsing_result.count_parsed_variables++;
            // Remove stuff that should not be iterated in a later loop.
            const _arguments = argument_matches.filter((value /* Won't be used */, key) => {
                return "number" === typeof key;
                // This leaves out for example the following non-numeric keys (and their values):
                // - "groups"
                // - "index"
                // - "input"
                // In the future, there can also come more elements that will be skipped. E.g. "indices". See: https://github.com/nothingislost/obsidian-dynamic-highlights/issues/25#issuecomment-1038563990 (referenced 2022-02-22).
            });
            // Get the {{variable}} string that will be substituted (= replaced with the actual value of the variable).
            const substitute = _arguments.shift(); // '_arguments[0]' contains the whole match, not just an argument. Get it and remove it from '_arguments'.
            // Iterate all arguments
            for (const i in _arguments) {
                // Check that the argument is not omitted. It can be omitted (= undefined), if the parameter is optional.
                if (undefined !== _arguments[i]) {
                    // The argument is present.
                    const argument = _arguments[i].slice(1); // .slice(1): Remove a preceding :
                    const parameter_name = parameter_names[i];
                    variable.setArgument(parameter_name, argument);
                }
            }
            // Should the variable's value be escaped? (Usually yes).
            let escape = true;
            if ("{{!" === substitute.slice(0, 3)) { // .slice(0, 3) = get characters 0...2, so stop before 3. The 'end' parameter is confusing.
                // The variable usage begins with {{! instead of {{
                // This means the variable's value should NOT be escaped.
                escape = false;
            }
            if (!shell) {
                // Escaping is forced OFF.
                escape = false;
            }
            // Render the variable
            const variable_value_result = await variable.getValue(t_shell_command, sc_event, 
            // Define a recursive callback that can be used to parse possible variables in a default value of the current variable.
            (raw_default_value) => {
                // Avoid circular references by removing the current variable from the set of parseable variables.
                // This will cumulate in deep nested parsing: Possible deeper parsing rounds will always have narrower
                // and narrower sets of variables to parse.
                const reduced_variables = removeFromSet(variables, variable);
                return parseVariables(plugin, raw_default_value, null, // Disable escaping special characters at this phase to avoid double escaping, as escaping will be done later.
                t_shell_command, sc_event, reduced_variables, raw_value_augmenter, escaped_value_augmenter);
            });
            // Allow custom modification of the raw value.
            if (raw_value_augmenter) {
                // The augmenter can modify the content of the variable_value_result object.
                raw_value_augmenter(variable, variable_value_result);
            }
            const raw_variable_value = variable_value_result.value;
            // Check possible error messages that might have come from rendering.
            if (variable_value_result.succeeded) {
                // Parsing was ok.
                // Escape the value if needed.
                let use_variable_value;
                if (escape) {
                    // Use an escaped value.
                    use_variable_value = escapeValue(shell, raw_variable_value);
                }
                else {
                    // No escaping is wanted, so use the raw value.
                    use_variable_value = raw_variable_value;
                }
                // Augment the escaped value, if wanted.
                if (escaped_value_augmenter) {
                    use_variable_value = escaped_value_augmenter(variable, use_variable_value);
                }
                // Replace the variable name with the variable value.
                parsing_result.parsed_content = parsing_result.parsed_content.replace(substitute, () => {
                    // Do the replacing in a function in order to avoid a possible $ character to be interpreted by JavaScript to interact with the regex.
                    // More information: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter (referenced 2021-11-02.)
                    return use_variable_value;
                });
            }
            else {
                // There has been problem(s) with this variable.
                debugLog("parseVariables(): Parsing content " + content + " failed.");
                parsing_result.succeeded = false;
                parsing_result.parsed_content = null;
                parsing_result.error_messages = variable_value_result.error_messages; // Returning now prevents parsing rest of the variables.
                return parsing_result;
            }
        }
    }
    debugLog("parseVariables(): Parsing content " + content + " succeeded.");
    parsing_result.succeeded = true;
    return parsing_result;
}
/**
 * Reads all variables from the content string, and returns a VariableSet containing all the found variables.
 *
 * This is needed in situations where variables will not be parsed (= variable values are not needed), but where it's just
 * needed to know what variables e.g. a shell command relies on.
 *
 * @param plugin
 * @param content
 */
function getUsedVariables(plugin, content) {
    const search_for_variables = plugin.getVariables();
    const found_variables = new VariableSet();
    for (const variable of search_for_variables) {
        const pattern = new RegExp(variable.getPattern(), "igu"); // i: case-insensitive; g: match all occurrences instead of just the first one. u: support 4-byte unicode characters too.
        if (pattern.exec(content) !== null) {
            // This variable was found.
            found_variables.add(variable);
        }
    }
    return found_variables;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel {
    /**
     * @param plugin
     * @param t_shell_command
     * @param shell_command_parsing_result
     * @param outputHandlingMode
     * @param processTerminator Will be called if user decides to end the process. Set to null if the process has already ended.
     */
    constructor(plugin, t_shell_command, shell_command_parsing_result, outputHandlingMode, processTerminator) {
        this.plugin = plugin;
        this.t_shell_command = t_shell_command;
        this.shell_command_parsing_result = shell_command_parsing_result;
        this.outputHandlingMode = outputHandlingMode;
        this.processTerminator = processTerminator;
        this.app = plugin.app;
        this.initialize();
    }
    /**
     * Can be overridden in child classes in order to vary the title depending on output_stream.
     * @param output_stream
     */
    static getTitle(output_stream) {
        return this.title;
    }
    /**
     * Sub classes can do here initializations that are common to both handleBuffered() and handleRealtime().
     *
     * Inits could be done in contructor(), too, but this is cleaner - no need to deal with parameters and no need for a super()
     * call.
     *
     * @protected
     */
    initialize() {
        // Do nothing by default.
    }
    async handleBuffered(output, error_code, enableOutputWrapping = true) {
        this.requireHandlingMode("buffered");
        // Qualify output
        if (OutputChannel.isOutputEmpty(output)) {
            // The output is empty
            if (!this.static().accepts_empty_output) {
                // This OutputChannel does not accept empty output, i.e. empty output should be just ignored.
                debugLog(this.constructor.name + ".handleBuffered(): Ignoring empty output.");
                return;
            }
        }
        debugLog(this.constructor.name + ".handleBuffered(): Handling output...");
        // Output is ok.
        // Handle it.
        await this._handleBuffered(await this.prepare_output(output, enableOutputWrapping), error_code);
        debugLog("Output handling is done.");
    }
    /**
     * @param outputStreamName
     * @param outputContent
     * @param enableOutputWrapping No caller actually sets this to false at the moment, unlike the handleBuffered() method's counterpart. But have this just in case.
     */
    async handleRealtime(outputStreamName, outputContent, enableOutputWrapping = true) {
        this.requireHandlingMode("realtime");
        // Qualify output
        if ("" === outputContent) {
            // The output is empty
            if (!this.static().accepts_empty_output) {
                // This OutputChannel does not accept empty output, i.e. empty output should be just ignored.
                debugLog(this.constructor.name + ".handleRealtime(): Ignoring empty output.");
                return;
            }
        }
        debugLog(this.constructor.name + ".handleRealtime(): Handling output...");
        // Output is ok.
        // If allowed, wrap the output with output wrapper text.
        if (enableOutputWrapping) {
            // Wrap output (but only if a wrapper is defined)
            outputContent = await this.wrapOutput(outputStreamName, outputContent);
        }
        // Handle it.
        await this._handleRealtime(outputContent, outputStreamName);
        debugLog("Output handling is done.");
    }
    _endRealtime(exitCode) {
        // Do nothing by default.
    }
    /**
     * When a shell command is executed in "realtime" mode, a separate ending call should be made in order to pass an
     * exit code to the OutputChannel. Some OutputChannels display the code to user, but most do not.
     *
     * @param exitCode
     */
    endRealtime(exitCode) {
        this.requireHandlingMode("realtime");
        this._endRealtime(exitCode);
    }
    requireHandlingMode(requiredMode) {
        if (this.outputHandlingMode !== requiredMode) {
            throw new Error("this.outputHandlingMode must be '" + requiredMode + "'.");
        }
    }
    static acceptsOutputStream(output_stream) {
        return this.accepted_output_streams.contains(output_stream);
    }
    /**
     * Does the following preparations:
     *  - Combines output streams (if wanted by the OutputChannel).
     *  - Wraps output (if defined in shell command configuration).
     * @param output_streams
     * @param enableOutputWrapping
     * @private
     */
    async prepare_output(output_streams, enableOutputWrapping) {
        const wrapOutputIfEnabled = async (outputStreamName, outputContent) => {
            if (enableOutputWrapping) {
                // Wrap output content.
                return await this.wrapOutput(outputStreamName, outputContent);
            }
            else {
                // Wrapping is disabled, return unmodified output content.
                return outputContent;
            }
        };
        const wrap_outputs_separately = async () => {
            const wrapped_output_streams = {};
            let output_stream_name;
            for (output_stream_name in output_streams) {
                wrapped_output_streams[output_stream_name] = await wrapOutputIfEnabled(output_stream_name, output_streams[output_stream_name]);
            }
            return wrapped_output_streams;
        };
        // Check if outputs should be combined.
        const combineOutputStreams = this.static().combine_output_streams;
        if (combineOutputStreams) {
            // Combine output strings into a single string.
            // Can output wrapping be combined?
            if (this.t_shell_command.isOutputWrapperStdoutSameAsStderr()) {
                // Output wrapping can be combined.
                return await wrapOutputIfEnabled("stdout", joinObjectProperties(output_streams, combineOutputStreams));
            }
            else {
                // Output wrapping needs to be done separately.
                const wrapped_output_streams = await wrap_outputs_separately();
                return joinObjectProperties(wrapped_output_streams, combineOutputStreams); // Use combineOutputStreams as a glue string.
            }
        }
        else {
            // Do not combine, handle each stream separately
            return await wrap_outputs_separately();
        }
    }
    /**
     * Surrounds the given output text with an output wrapper. If no output wrapper is defined, returns the original
     * output text without any modifications.
     */
    async wrapOutput(output_stream, output_content) {
        // Get preparsed output wrapper content. It has all other variables parsed, except {{output}}.
        const parsing_result_key = "output_wrapper_" + output_stream;
        const output_wrapper_content = this.shell_command_parsing_result[parsing_result_key];
        // Check if output wrapper content exists.
        if (undefined === output_wrapper_content) {
            // No OutputWrapper is defined for this shell command.
            // Return the output text without modifications.
            debugLog("Output wrapping: No wrapper is defined for '" + output_stream + "'.");
            return output_content;
        }
        // Parse the {{output}} variable
        const output_variable = new Variable_Output(this.plugin, output_content);
        const parsing_result = await parseVariables(this.plugin, output_wrapper_content, null, // No shell anymore, so no need for escaping.
        this.t_shell_command, null, // No support for {{event_*}} variables is needed, because they are already parsed in output_wrapper_content. This phase only parses {{output}} variable, nothing else.
        new VariableSet([output_variable]));
        // Inspect the parsing result. It should always succeed, as the {{output}} variable should not give any errors.
        if (parsing_result.succeeded) {
            // Succeeded.
            debugLog("Output wrapping: Wrapping " + output_stream + " succeeded.");
            return parsing_result.parsed_content;
        }
        else {
            // Failed for some reason.
            this.plugin.newError("Output wrapping failed, see error(s) below.");
            this.plugin.newErrors(parsing_result.error_messages);
            throw new Error("Output wrapping failed: Parsing {{output}} resulted in error(s): " + parsing_result.error_messages.join(" "));
        }
    }
    /**
     * Can be moved to a global function isOutputStreamEmpty() if needed.
     * @param output
     * @private
     */
    static isOutputEmpty(output) {
        if (undefined !== output.stderr) {
            return false;
        }
        return undefined === output.stdout || "" === output.stdout;
    }
    static() {
        return this.constructor;
    }
}
OutputChannel.accepted_output_streams = ["stdout", "stderr"];
OutputChannel.accepts_empty_output = false;
/**
 * Determines if the output channel wants to handle a unified output or not. If yes, this property should define a
 * delimiter string that will be used as a glue between different output streams.
 *
 * @protected
 */
OutputChannel.combine_output_streams = false;
/**
 * Used in OutputModal to redirect output based on hotkeys. If this is undefined, then the output channel is completely
 * excluded from OutputModal.
 */
OutputChannel.hotkey_letter = undefined;

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_Notification extends OutputChannel {
    constructor() {
        super(...arguments);
        /**
         * All received output cumulatively. Subsequent handlings will then use the whole output, not just new parts.
         * Only used in "realtime" mode.
         *
         * @private
         */
        this.realtimeContentBuffer = "";
        /**
         * A flag for indicating that if any stderr output has happened, all subsequent handlings should format the output
         * Notice message with error formatting (i.e. show [...] at the beginning of the message).
         * @private
         */
        this.realtimeHasStderrOccurred = false;
    }
    static getTitle(output_stream) {
        switch (output_stream) {
            case "stdout":
                return "Notification balloon";
            case "stderr":
                return "Error balloon";
        }
    }
    async _handleBuffered(output, error_code) {
        // Iterate output streams.
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, two
        // notifications will be created.
        let output_stream_name;
        for (output_stream_name in output) {
            const output_message = output[output_stream_name];
            this.notify(output_stream_name, output_message, error_code);
        }
    }
    async _handleRealtime(outputContent, outputStreamName) {
        // Append new content
        this.realtimeContentBuffer += outputContent;
        // Raise a flag if seeing 'stderr' output.
        if ("stderr" === outputStreamName) {
            this.realtimeHasStderrOccurred = true;
        }
        // Does a Notice exist already?
        if (this.realtimeNotice) {
            // Reuse an existing Notice.
            // Should output be formatted as an error message?
            let updatedMessage;
            if (this.realtimeHasStderrOccurred) {
                // Apply error formatting to output
                updatedMessage = OutputChannel_Notification.formatErrorMessage(this.realtimeContentBuffer, null);
            }
            else {
                // Use output as-is
                updatedMessage = this.realtimeContentBuffer;
            }
            // Use the updated output
            this.realtimeNotice.setMessage(updatedMessage);
            // Update notice hiding timeout
            window.clearTimeout(this.realtimeNoticeTimeout); // Remove old timeout
            this.handleNotificationHiding(outputStreamName); // Add new timeout
        }
        else {
            // Create a new Notice.
            this.realtimeNotice = this.notify(this.realtimeHasStderrOccurred ? "stderr" : "stdout", this.realtimeContentBuffer, null, 0);
            // Create a timeout for hiding the Notice
            this.handleNotificationHiding(outputStreamName);
        }
        // Terminating button
        // @ts-ignore Notice.noticeEl belongs to Obsidian's PRIVATE API, and it may change without a prior notice. Only
        // create the button if noticeEl exists and is an HTMLElement.
        const noticeEl = this.realtimeNotice.noticeEl;
        if (undefined !== noticeEl && noticeEl instanceof HTMLElement) {
            this.plugin.createRequestTerminatingButton(noticeEl, this.processTerminator);
        }
    }
    _endRealtime(exitCode) {
        if (exitCode !== 0 || this.realtimeHasStderrOccurred) {
            // If a Notice exists, update it with the exitCode
            this.realtimeNotice?.setMessage(OutputChannel_Notification.formatErrorMessage(this.realtimeContentBuffer, exitCode));
        }
        // Remove terminating button
        // @ts-ignore Notice.noticeEl belongs to Obsidian's PRIVATE API, and it may change without a prior notice. Only
        // create the button if noticeEl exists and is an HTMLElement.
        const noticeEl = this.realtimeNotice?.noticeEl;
        if (undefined !== noticeEl && noticeEl instanceof HTMLElement) {
            noticeEl.find(".SC-icon-terminate-process")?.remove(); // ? = Only try to remove if the button exists. It does not exist if .setMessage() was called above as it overwrites all content in the Notice.
        }
    }
    /**
     *
     * @param outputStreamName
     * @param outputContent
     * @param exitCode
     * @param noticeTimeout Allows overriding the notice/error timeout setting.
     * @private
     */
    notify(outputStreamName, outputContent, exitCode, noticeTimeout) {
        switch (outputStreamName) {
            case "stdout":
                // Normal output
                return this.plugin.newNotification(outputContent, noticeTimeout ?? undefined);
            case "stderr":
                // Error output
                return this.plugin.newError(OutputChannel_Notification.formatErrorMessage(outputContent, exitCode), noticeTimeout ?? undefined);
        }
    }
    static formatErrorMessage(outputContent, exitCode) {
        if (null === exitCode) {
            // If a "realtime" process is not finished, there is no exit code yet.
            // @ts-ignore Yea I know "..." is not a number nor null. :)
            exitCode = "...";
        }
        return "[" + exitCode + "]: " + outputContent;
    }
    handleNotificationHiding(outputStreamName) {
        // Hide by timeout
        let normalTimeout;
        switch (outputStreamName) {
            case "stdout":
                normalTimeout = this.plugin.getNotificationMessageDurationMs();
                break;
            case "stderr":
                normalTimeout = this.plugin.getErrorMessageDurationMs();
                break;
        }
        this.realtimeNoticeTimeout = window.setTimeout(() => {
            // Hide the Notice
            this.realtimeNotice.hide();
            this.realtimeNotice = undefined;
            this.realtimeNoticeTimeout = undefined;
        }, normalTimeout);
        // Subscribe to Notice's click event.
        // @ts-ignore Notice.noticeEl belongs to Obsidian's PRIVATE API, and it may change without a prior notice. Only
        // define the click listener if noticeEl exists and is an HTMLElement.
        const noticeEl = this.realtimeNotice.noticeEl;
        if (undefined !== noticeEl && noticeEl instanceof HTMLElement) {
            noticeEl.onClickEvent(() => {
                window.clearTimeout(this.realtimeNoticeTimeout); // Make sure timeout will not accidentally try to later hide an already hidden Notification.
                this.realtimeNoticeTimeout = undefined;
                this.realtimeNotice = undefined; // Give a signal to _handleRealtime() that if new output comes, a new Notice should be created.
            });
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_CurrentFile extends OutputChannel {
    async _handleBuffered(outputContent) {
        this.handle(outputContent);
    }
    async _handleRealtime(outputContent) {
        this.handle(outputContent);
    }
    handle(output_message) {
        const editor = getEditor(this.app);
        const view = getView(this.app);
        if (null === editor) {
            // For some reason it's not possible to get an editor.
            this.plugin.newError("Could not get an editor instance! Please create a discussion in GitHub. The command output is in the next error box:");
            this.plugin.newError(output_message); // Good to output it at least some way.
            debugLog("OutputChannel_CurrentFile: Could not get an editor instance.");
            return;
        }
        // Check if the view is in source mode
        if (null === view) {
            // For some reason it's not possible to get an editor, but it's not a big problem.
            debugLog("OutputChannel_CurrentFile: Could not get a view instance.");
        }
        else {
            // We do have a view
            if ("source" !== view.getMode()) {
                // Warn that the output might go to an unexpected place in the note file.
                this.plugin.newNotification("Note that your active note is not in 'Edit' mode! The output comes visible when you switch to 'Edit' mode again!");
            }
        }
        // Insert into the current file
        this.insertIntoEditor(editor, output_message);
    }
}
/**
 * There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, they
 * will be joined together with " " as a separator.
 * @protected
 */
OutputChannel_CurrentFile.combine_output_streams = " ";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_CurrentFileCaret extends OutputChannel_CurrentFile {
    /**
     * Inserts text into the given editor, at caret position.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        editor.replaceSelection(output_message);
    }
}
OutputChannel_CurrentFileCaret.title = "Current file: caret position";
OutputChannel_CurrentFileCaret.hotkey_letter = "R";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_CurrentFileTop extends OutputChannel_CurrentFile {
    /**
     * Inserts text into the given editor, at top.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        const top_position = editor.offsetToPos(0);
        editor.replaceRange(output_message, top_position);
    }
}
OutputChannel_CurrentFileTop.title = "Current file: top";
OutputChannel_CurrentFileTop.hotkey_letter = "T";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_StatusBar extends OutputChannel {
    constructor() {
        super(...arguments);
        /**
         * All received output cumulatively. Subsequent handlings will then use the whole output, not just new parts.
         * Only used in "realtime" mode.
         *
         * @private
         */
        this.realtimeContentBuffer = "";
    }
    async _handleBuffered(outputContent) {
        this.setStatusBarContent(outputContent);
    }
    async _handleRealtime(outputContent) {
        this.realtimeContentBuffer += outputContent;
        this.setStatusBarContent(this.realtimeContentBuffer);
    }
    setStatusBarContent(outputContent) {
        const status_bar_element = this.plugin.getOutputStatusBarElement();
        outputContent = outputContent.trim();
        // Full output (shown when hovering with mouse)
        status_bar_element.setAttr("aria-label", outputContent);
        // Show last line permanently.
        const output_message_lines = outputContent.split(/(\r\n|\r|\n)/u);
        const last_output_line = output_message_lines[output_message_lines.length - 1];
        status_bar_element.setText(last_output_line);
    }
}
OutputChannel_StatusBar.title = "Status bar";
OutputChannel_StatusBar.accepts_empty_output = true;
OutputChannel_StatusBar.hotkey_letter = "S";
/**
 * Combine stdout and stderr (in case both of them happen to be present).
 * @protected
 */
OutputChannel_StatusBar.combine_output_streams = os.EOL + os.EOL;

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_CurrentFileBottom extends OutputChannel_CurrentFile {
    /**
     * Inserts text into the given editor, at bottom.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        const bottom_position = {
            ch: editor.getLine(editor.lastLine()).length,
            line: editor.lastLine(), // ... the last line.
        }; // *) But do not subtract 1, because ch is zero-based, so when .length is used without -1, we are pointing AFTER the last character.
        editor.replaceRange(output_message, bottom_position);
    }
}
OutputChannel_CurrentFileBottom.title = "Current file: bottom";
OutputChannel_CurrentFileBottom.hotkey_letter = "B";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_Clipboard extends OutputChannel {
    constructor() {
        super(...arguments);
        /**
         * All received output cumulatively. Subsequent handlings will then use the whole output, not just new parts.
         * Only used in "realtime" mode.
         *
         * @private
         */
        this.realtimeContentBuffer = "";
    }
    async _handleBuffered(outputContent) {
        await copyToClipboard(outputContent);
        this.notify(outputContent);
    }
    async _handleRealtime(outputContent) {
        this.realtimeContentBuffer += outputContent;
        await copyToClipboard(this.realtimeContentBuffer);
        this.notify(this.realtimeContentBuffer);
    }
    notify(output_message) {
        if (this.plugin.settings.output_channel_clipboard_also_outputs_to_notification) {
            // Notify the user so they know a) what was copied to clipboard, and b) that their command has finished execution.
            this.plugin.newNotification("Copied to clipboard: " + os.EOL + output_message + os.EOL + os.EOL + "(Notification can be turned off in settings.)");
        }
    }
}
OutputChannel_Clipboard.title = "Clipboard";
OutputChannel_Clipboard.hotkey_letter = "L";
/**
 * There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, they
 * will be joined together with " " as a separator.
 * @protected
 */
OutputChannel_Clipboard.combine_output_streams = " "; // TODO: Change to "" as there should be no extra space between stdout and stderr. Compare it to the terminal: AFAIK there is no separation between stdout and stderr outputs, just that typically each output ends with a newline.

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * TODO: Move this to TShellCommand.
 */
function getHotkeysForShellCommand(plugin, shell_command_id) {
    // Retrieve all hotkeys set by user.
    // @ts-ignore
    const app_custom_hotkeys = plugin.app.hotkeyManager?.customKeys;
    if (!app_custom_hotkeys) {
        debugLog("getHotkeysForShellCommand() failed, will return an empty array.");
        return [];
    }
    // Get only our hotkeys.
    const hotkey_index = plugin.getPluginId() + ":" + plugin.generateObsidianCommandId(shell_command_id); // E.g. "obsidian-shellcommands:shell-command-0"
    debugLog("getHotkeysForShellCommand() succeeded.");
    return app_custom_hotkeys[hotkey_index] ?? []; // If no hotkey array is set for this command, return an empty array. Although I do believe that all commands do have an array anyway, but have this check just in case.
}
/**
 * TODO: Is there a way to make Obsidian do this conversion for us? Check this: https://github.com/pjeby/hotkey-helper/blob/c8a032e4c52bd9ce08cb909cec15d1ed9d0a3439/src/plugin.js#L4-L6
 *
 * @param hotkey
 * @constructor
 */
function HotkeyToString(hotkey) {
    const keys = [];
    hotkey.modifiers.forEach((modifier) => {
        let modifier_key = modifier.toString(); // This is one of 'Mod' | 'Ctrl' | 'Meta' | 'Shift' | 'Alt'
        if ("Mod" === modifier_key) {
            // Change "Mod" to something more meaningful.
            modifier_key = CmdOrCtrl(); // isMacOS should also be true if the device is iPhone/iPad. Can be handy if this plugin gets mobile support some day.
        }
        keys.push(modifier_key);
    });
    keys.push(hotkey.key); // This is something like a letter ('A', 'B' etc) or space/enter/whatever.
    return keys.join(" + ");
}
function CmdOrCtrl() {
    return obsidian.Platform.isMacOS ? "Cmd" : "Ctrl";
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_Modal extends OutputChannel {
    initialize() {
        // Initialize a modal (but don't open yet)
        this.modal = new OutputModal(this.plugin, this.t_shell_command, this.shell_command_parsing_result, this.processTerminator);
    }
    async _handleBuffered(outputs, error_code) {
        // Pass outputs to modal
        this.modal.setOutputContents(outputs);
        // Define a possible error code to be shown on the modal.
        if (error_code !== null) {
            this.modal.setExitCode(error_code);
        }
        // Done
        this.modal.open();
    }
    async _handleRealtime(outputContent, outputStreamName) {
        this.modal.addOutputContent(outputStreamName, outputContent);
        if (!this.modal.isOpen()) {
            this.modal.open();
        }
    }
    /**
     * @param exitCode Can be null if user terminated the process by clicking a button. In other places exitCode can be null if process is still running, but here that cannot be the case.
     *
     * @protected
     */
    _endRealtime(exitCode) {
        // Delete terminator button as the process is already ended.
        this.modal.removeProcessTerminatorButton();
        // Pass exitCode to the modal
        this.modal.setExitCode(exitCode);
    }
}
OutputChannel_Modal.title = "Ask after execution";
class OutputModal extends SC_Modal {
    constructor(plugin, t_shell_command, shell_command_parsing_result, processTerminator) {
        super(plugin);
        this.processTerminator = processTerminator;
        this.exit_code = null;
        this.outputFields = {};
        this.t_shell_command = t_shell_command;
        this.shell_command_parsing_result = shell_command_parsing_result;
        this.createOutputFields();
    }
    /**
     * Called when doing "buffered" output handling.
     *
     * @param outputs
     */
    setOutputContents(outputs) {
        Object.getOwnPropertyNames(outputs).forEach((outputStreamName) => {
            const outputField = this.outputFields[outputStreamName];
            // Set field value
            const textareaComponent = outputField.components.first();
            const outputContent = outputs[outputStreamName];
            textareaComponent.setValue(outputContent);
            // Make field visible (if it's not already)
            outputField.settingEl.matchParent(".SC-hide").removeClass("SC-hide");
        });
    }
    /**
     * Called when doing "realtime" output handling.
     *
     * @param outputStreamName
     * @param outputContent
     */
    addOutputContent(outputStreamName, outputContent) {
        const outputField = this.outputFields[outputStreamName];
        // Update field value
        const textareaComponent = outputField.components.first();
        textareaComponent.setValue(textareaComponent.getValue() + outputContent);
        // Make field visible (if it's not already)
        outputField.settingEl.matchParent(".SC-hide")?.removeClass("SC-hide");
    }
    onOpen() {
        super.onOpen();
        this.modalEl.addClass("SC-modal-output");
        // Heading
        const heading = this.shell_command_parsing_result.alias;
        this.titleEl.innerText = heading ? heading : "Shell command output"; // TODO: Use this.setTitle() instead.
        // Shell command preview
        this.modalEl.createEl("pre", { text: this.shell_command_parsing_result.shell_command, attr: { class: "SC-no-margin SC-wrappable" } }); // no margin so that exit code will be close.
        // Container for terminating button and exit code
        const processResultContainer = this.modalEl.createDiv();
        // 'Request to terminate the process' icon button
        if (this.processTerminator) {
            this.processTerminatorButtonContainer = processResultContainer.createEl('span');
            this.plugin.createRequestTerminatingButton(this.processTerminatorButtonContainer, this.processTerminator);
        }
        // Exit code (put on same line with process terminator button, if exists)
        this.exitCodeElement = processResultContainer.createEl("small", { text: "Executing...", attr: { style: "font-weight: bold;" } }); // Show "Executing..." before an actual exit code is received.
        if (this.exit_code !== null) {
            this.displayExitCode();
        }
        // Output fields
        this.modalEl.insertAdjacentElement("beforeend", this.outputFieldsContainer);
        // Focus on the first output field
        this.focusFirstField();
        // A tip about selecting text.
        this.modalEl.createDiv({
            text: "Tip! If you select something, only the selected text will be used.",
            attr: { class: "setting-item-description" /* A CSS class defined by Obsidian. */ },
        });
    }
    createOutputFields() {
        // Create a parent-less container. onOpen() will place it in the correct place.
        this.outputFieldsContainer = document.createElement('div');
        // Create field containers in correct order
        let stdoutFieldContainer;
        let stderrFieldContainer;
        switch (this.t_shell_command.getOutputChannelOrder()) {
            case "stdout-first": {
                stdoutFieldContainer = this.outputFieldsContainer.createDiv();
                stderrFieldContainer = this.outputFieldsContainer.createDiv();
                break;
            }
            case "stderr-first": {
                stderrFieldContainer = this.outputFieldsContainer.createDiv();
                stdoutFieldContainer = this.outputFieldsContainer.createDiv();
                break;
            }
        }
        // Create fields
        this.outputFields.stdout = this.createOutputField("stdout", stdoutFieldContainer);
        this.outputFields.stderr = this.createOutputField("stderr", stderrFieldContainer);
        // Hide the fields' containers at the beginning. They will be shown when content is added.
        stdoutFieldContainer.addClass("SC-hide");
        stderrFieldContainer.addClass("SC-hide");
    }
    createOutputField(output_stream, containerElement) {
        let output_textarea;
        containerElement.createEl("hr", { attr: { class: "SC-no-margin" } });
        // Output stream name
        new obsidian.Setting(containerElement)
            .setName(output_stream)
            .setHeading()
            .setClass("SC-no-bottom-border");
        // Textarea
        const textarea_setting = new obsidian.Setting(containerElement)
            .addTextArea(textarea => output_textarea = textarea);
        textarea_setting.infoEl.addClass("SC-hide"); // Make room for the textarea by hiding the left column.
        textarea_setting.settingEl.addClass("SC-output-channel-modal-textarea-container", "SC-no-top-border");
        // Add controls for redirecting the output to another channel.
        const redirect_setting = new obsidian.Setting(containerElement)
            .setDesc("Redirect:")
            .setClass("SC-no-top-border")
            .setClass("SC-output-channel-modal-redirection-buttons-container") // I think this calls actually HTMLDivElement.addClass(), so it should not override the previous .setClass().
        ;
        const outputChannels = getOutputChannelClasses();
        Object.getOwnPropertyNames(outputChannels).forEach((output_channel_name) => {
            const outputChannelClass = outputChannels[output_channel_name];
            // Ensure this channel is not excluded by checking that is has a hotkey defined.
            if (outputChannelClass.hotkey_letter) {
                // Ensure the output channel accepts this output stream. E.g. OutputChannel_OpenFiles does not accept "stderr".
                if (outputChannelClass.acceptsOutputStream(output_stream)) {
                    const textarea_element = textarea_setting.settingEl.find("textarea");
                    // Define an output handler
                    const handle_output = async () => {
                        // Redirect output to the selected channel
                        const output_streams = {};
                        output_streams[output_stream] =
                            getSelectionFromTextarea(textarea_element, true) // Use the selection, or...
                                ?? output_textarea.getValue() // ...use the whole text, if nothing is selected.
                        ;
                        const outputChannel = initializeOutputChannel(output_channel_name, this.plugin, this.t_shell_command, this.shell_command_parsing_result, "buffered", // Use "buffered" mode even if this modal was opened in "realtime" mode, because at this point the output redirection is a single-time job, not recurring.
                        this.processTerminator);
                        await outputChannel.handleBuffered(output_streams, this.exit_code, false); // false: Disable output wrapping as it's already wrapped before the output content was passed to this modal.
                    };
                    // Create the button
                    let redirect_button;
                    redirect_setting.addButton((button) => {
                        redirect_button = button;
                        button.onClick(async (event) => {
                            // Handle output
                            await handle_output();
                            // Finish
                            if (event.ctrlKey) {
                                // Special click, control/command key is pressed.
                                // Close the modal.
                                this.close();
                            }
                            else {
                                // Normal click, control key is not pressed.
                                // Do not close the modal.
                                textarea_element.focus(); // Bring the focus back to the textarea in order to show a possible highlight (=selection) again.
                            }
                        });
                    });
                    // Define button texts and assign hotkeys
                    const output_channel_title = outputChannelClass.getTitle(output_stream);
                    // Button text
                    redirect_button.setButtonText(output_channel_title);
                    // Tips about hotkeys
                    redirect_button.setTooltip(`Redirect: Normal click OR ${CmdOrCtrl()} + ${outputChannelClass.hotkey_letter}.`
                        + os.EOL + os.EOL +
                        `Redirect and close the modal: ${CmdOrCtrl()} + click OR ${CmdOrCtrl()} + Shift + ${outputChannelClass.hotkey_letter}.`);
                    // 1. hotkey: Ctrl/Cmd + number: handle output
                    this.scope.register(["Ctrl"], outputChannelClass.hotkey_letter, handle_output);
                    // 2. hotkey: Ctrl/Cmd + Shift + number: handle output and close the modal.
                    this.scope.register(["Ctrl", "Shift"], outputChannelClass.hotkey_letter, () => {
                        handle_output().then(); // then(): No need to wait for output handling to finish before closing the modal.
                        this.close();
                    });
                }
            }
        });
        return textarea_setting;
    }
    removeProcessTerminatorButton() {
        if (this.processTerminatorButtonContainer) {
            this.processTerminatorButtonContainer.remove();
        }
    }
    /**
     * Should be called only if an exit code was received.
     *
     * @param exit_code Can be null if user terminated the process by clicking a button.
     */
    setExitCode(exit_code) {
        this.exit_code = exit_code;
        // Try to show the exit code.
        if (this.isOpen()) {
            if (null === this.exit_code) {
                // User has terminated the process, so there's no exit code even though the process has ended.
                this.exitCodeElement.innerText = "User terminated";
            }
            else {
                // displayExistCode() can only be called if onOpen() has been called before.
                // If onOpen() will be called later, it will call displayExitCode() itself when it sees that this.exit_code is defined.
                this.displayExitCode();
            }
        }
    }
    displayExitCode() {
        this.exitCodeElement.innerText = "Exit code: " + this.exit_code.toString();
    }
    focusFirstField() {
        switch (this.t_shell_command.getOutputChannelOrder()) {
            case "stdout-first": {
                this.outputFields.stdout.controlEl.find("textarea").focus();
                break;
            }
            case "stderr-first": {
                this.outputFields.stderr.controlEl.find("textarea").focus();
                break;
            }
        }
    }
    approve() {
        // No need to perform any action, just close the modal.
        this.close();
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputChannel_OpenFiles extends OutputChannel {
    _handleBuffered(output, error_code) {
        let handlingPipeline = Promise.resolve();
        let output_stream_name;
        for (output_stream_name in output) {
            handlingPipeline = handlingPipeline.finally(() => {
                return this.handle(output[output_stream_name]);
            });
        }
        return handlingPipeline;
    }
    _handleRealtime(outputContent) {
        return this.handle(outputContent);
    }
    handle(outputContent) {
        return new Promise((resolve) => {
            // Read file definitions. Usually there's just one, but there can be many. Definitions are separated by newline
            // characters. Each file definition defines one file to be opened.
            const file_definitions_string = outputContent.trim(); // Contains at least file name(s), and MAYBE: a caret position, new pane option, and view state
            const file_definitions = file_definitions_string.split(/[\r\n]+/u);
            // Iterate all file definitions that should be opened.
            let opening_pipeline = Promise.resolve();
            for (const file_definition of file_definitions) {
                // Chain each file opening to happen one after another. If one file opening fails for whatever reason, it
                // is ok to continue to open the next file. This is why .finally() is used instead of .then().
                opening_pipeline = opening_pipeline.finally(() => {
                    return this.interpretFileOpeningDefinition(file_definition);
                });
            }
            opening_pipeline.finally(() => resolve() /* Tell that all openings have been processed. */);
        });
    }
    interpretFileOpeningDefinition(file_definition) {
        return new Promise((resolve, reject) => {
            debugLog("OutputChannel_OpenFiles: Interpreting file opening definition: " + file_definition);
            // Get parts that define different details about how the file should be opened
            const file_definition_parts = file_definition.split(":");
            // The first part is always the file path
            let open_file_path = file_definition_parts.shift();
            // On Windows: Check if an absolute path was split incorrectly. (E.g. a path starting with "C:\...").
            if (isWindows() && file_definition_parts.length > 0) {
                const combined_path = open_file_path + ":" + file_definition_parts[0];
                if (path__namespace.isAbsolute(combined_path)) {
                    // Yes, the first two parts do form an absolute path together, so they should not be split.
                    open_file_path = combined_path;
                    file_definition_parts.shift(); // Remove the second part so that it won't be accidentally processed in the 'Special features' part.
                }
            }
            // Trim the file path, for being able to use cleaner separation between file name and other parts, e.g: MyFile.md : new-pane
            open_file_path = open_file_path.trim();
            // Special features
            const caret_parts = []; // If caret position is present in file_definition_parts, the first item in this array will be the caret line, the second will be the column. If more parts are present, they will be used for making selections.
            let newLeaf = false;
            let can_create_file = false;
            let file_definition_interpreting_failed = false;
            file_definition_parts.forEach((file_definition_part) => {
                file_definition_part = file_definition_part.toLocaleLowerCase().trim(); // .trim() is for being able to use cleaner separation between e.g. different selections: MyFile.md:1:1:1:-1 : 5:1:5:-1
                // Determine the part type
                if (isInteger(file_definition_part, true)) {
                    // This is a number, so consider it as a caret position part.
                    caret_parts.push(parseInt(file_definition_part));
                }
                else {
                    const multipleNewPartsErrorMessage = "Cannot open file: Only one of the following can be defined: new-pane, new-tab, or new-window.";
                    switch (file_definition_part) {
                        case "new-pane":
                            // Ensure no new-* definition is used before.
                            if (newLeaf === false) {
                                newLeaf = "split";
                            }
                            else {
                                this.plugin.newError(multipleNewPartsErrorMessage);
                                file_definition_interpreting_failed = true;
                            }
                            break;
                        case "new-tab":
                            // Ensure no new-* definition is used before.
                            if (newLeaf === false) {
                                newLeaf = "tab";
                            }
                            else {
                                this.plugin.newError(multipleNewPartsErrorMessage);
                                file_definition_interpreting_failed = true;
                            }
                            break;
                        case "new-window":
                            // Ensure no new-* definition is used before.
                            if (newLeaf === false) {
                                newLeaf = "window";
                            }
                            else {
                                this.plugin.newError(multipleNewPartsErrorMessage);
                                file_definition_interpreting_failed = true;
                            }
                            break;
                        case "can-create-file":
                            can_create_file = true;
                            break;
                        default:
                            this.plugin.newError("Cannot open file: Unrecognised definition part: " + file_definition_part + " in " + file_definition);
                            file_definition_interpreting_failed = true;
                    }
                }
            });
            if (file_definition_interpreting_failed) {
                reject();
                return;
            }
            // Ensure the path is relative
            if (path__namespace.isAbsolute(open_file_path)) {
                // The path is absolute.
                // Check if it can be converted to relative.
                const vault_absolute_path = getVaultAbsolutePath(this.app);
                if (open_file_path.toLocaleLowerCase().startsWith(vault_absolute_path.toLocaleLowerCase())) {
                    // Converting to relative is possible
                    open_file_path = open_file_path.substr(vault_absolute_path.length); // Get everything after the point where the vault path ends.
                }
                else {
                    // Cannot convert to relative, because the file does not reside in the vault
                    this.plugin.newError("Cannot open file '" + open_file_path + "' as the path is outside this vault.");
                    reject();
                    return;
                }
            }
            // Clean up the file path
            open_file_path = obsidian.normalizePath(open_file_path); // normalizePath() is used on purpose, instead of normalizePath2(), because backslashes \ should be converted to forward slashes /
            this.openFileInTab(open_file_path, newLeaf, can_create_file).then(() => {
                // The file is now open
                // Check, did we have a caret position available. If not, do nothing.
                const count_caret_parts = caret_parts.length;
                if (count_caret_parts > 0) {
                    // Yes, a caret position was defined in the output.
                    // Ensure the correct amount of caret position parts.
                    // 0 parts: no caret positioning needs to be done (but in this part of code the amount of parts is always greater than 0).
                    // 1 part: caret line is defined, no column.
                    // 2 parts: caret line and column are defined.
                    // 3 parts: NOT ALLOWED.
                    // 4 parts: selection starting position (line, column) and selection end position (line, column) are defined.
                    // 5 parts or more: NOT ALLOWED. Exception: any number of sets of four parts is allowed, i.e. 8 parts, 12 parts, 16 parts etc. are allowed as they can define multiple selections.
                    const error_message_base = "File opened, but caret cannot be positioned due to an incorrect amount (" + count_caret_parts + ") of numeric values in the output: " + file_definition + os.EOL + os.EOL;
                    if (count_caret_parts == 3) {
                        // Incorrect amount of caret parts
                        this.plugin.newError(error_message_base + "Three numeric parts is an incorrect amount, correct would be 1,2 or 4 parts.");
                        reject();
                        return;
                    }
                    else if (count_caret_parts > 4 && count_caret_parts % 4 !== 0) {
                        // Incorrect amount of caret parts
                        this.plugin.newError(error_message_base + "Perhaps too many numeric parts are defined? If more than four parts are defined, make sure to define complete sets of four parts. The amount of numeric parts needs to be dividable by 4.");
                        reject();
                        return;
                    }
                    // Even though the file is already loaded, rendering it may take some time, thus the height of the content may increase.
                    // For this reason, there needs to be a tiny delay before setting the caret position. If the caret position is set immediately,
                    // the caret will be placed in a correct position, but it might be that the editor does not scroll into correct position, so the
                    // caret might be out of the view, even when it's in a correct place. (Obsidian version 0.13.23).
                    window.setTimeout(() => {
                        const editor = getEditor(this.app);
                        if (editor) {
                            if (count_caret_parts >= 4) {
                                // Selection mode
                                // There can be multiple selections defined
                                const selections = [];
                                while (caret_parts.length) {
                                    const from_line = caret_parts.shift();
                                    const from_column = caret_parts.shift();
                                    const to_line = caret_parts.shift();
                                    const to_column = caret_parts.shift();
                                    selections.push({
                                        anchor: prepareEditorPosition(editor, from_line, from_column),
                                        head: prepareEditorPosition(editor, to_line, to_column),
                                    });
                                }
                                editor.setSelections(selections);
                            }
                            else {
                                // Simple caret mode
                                const caret_line = caret_parts[0];
                                const caret_column = caret_parts[1] ?? 1;
                                editor.setCursor(prepareEditorPosition(editor, caret_line, caret_column));
                            }
                            // After placing carets / selecting text, have a small delay after allowing to open another file (in case multiple files are opened in a row). This allows the selection to be remembered in the pane's history.
                            window.setTimeout(resolve, 300); // If you change this ADDITIONAL delay, remember to change it in the documentation, too.
                        }
                        else {
                            // No editor
                            this.plugin.newError("File opened, but caret cannot be positioned because no editor was found.");
                            reject();
                        }
                    }, 500); // 500ms is probably long enough even if a new tab is opened (takes more time than opening a file into an existing tab). This can be made into a setting sometime. If you change this, remember to change it in the documentation, too.
                }
                else {
                    // No caret parts exist. All is done now.
                    resolve();
                }
            }, (error_message) => {
                if (typeof error_message === "string") {
                    // Opening the file has failed.
                    this.plugin.newError(error_message);
                }
                else {
                    // Some other runtime error has occurred.
                    throw error_message;
                }
                reject();
            });
        });
    }
    openFileInTab(file_path, newLeaf, can_create_file) {
        // Ensure that the file exists (or can be created)
        const source_path = ""; // TODO: When adding an option for creating new files, read this documentation from Obsidian API's getNewFileParent(): "sourcePath – The path to the current open/focused file, used when the user wants new files to be created “in the same folder”. Use an empty string if there is no active file."
        const file_exists_or_can_be_created = can_create_file || null !== this.app.metadataCache.getFirstLinkpathDest(file_path, source_path);
        if (file_exists_or_can_be_created) {
            // Yes, the file exists (or can be created)
            return this.app.workspace.openLinkText(file_path, source_path, newLeaf);
        }
        else {
            // No, the file does not exist, and it may not be created.
            return Promise.reject("Cannot open file '" + file_path + "', as it does not exist. (If you want to allow file creation, add :can-create-file to the shell command output.)");
        }
    }
}
OutputChannel_OpenFiles.title = "Open files";
OutputChannel_OpenFiles.hotkey_letter = "O";
/**
 * This output channel is not suitable for stderr, as stderr can contain unexpected messages.
 * @protected
 */
OutputChannel_OpenFiles.accepted_output_streams = ["stdout"];

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
const outputChannelClasses = {};
// Register output channels
registerOutputChannel("notification", OutputChannel_Notification);
registerOutputChannel("current-file-caret", OutputChannel_CurrentFileCaret);
registerOutputChannel("current-file-top", OutputChannel_CurrentFileTop);
registerOutputChannel("current-file-bottom", OutputChannel_CurrentFileBottom);
registerOutputChannel("open-files", OutputChannel_OpenFiles);
registerOutputChannel("status-bar", OutputChannel_StatusBar);
registerOutputChannel("clipboard", OutputChannel_Clipboard);
registerOutputChannel("modal", OutputChannel_Modal);
/**
 * This function is designed to be called after a 'Wait until finished' type of shell command finishes its execution.
 *
 * @param plugin
 * @param t_shell_command
 * @param shell_command_parsing_result
 * @param stdout
 * @param stderr
 * @param error_code TODO: Rename to exitCode everywhere in the codebase.
 * @param output_channels
 */
function handleBufferedOutput(plugin, t_shell_command, shell_command_parsing_result, stdout, stderr, error_code, output_channels) {
    // Terminology: Stream = outputs stream from a command, can be "stdout" or "stderr". Channel = a method for this application to present the output ot user, e.g. "notification".
    const shell_command_configuration = t_shell_command.getConfiguration(); // TODO: Refactor OutputChannels to use TShellCommand instead of the configuration objects directly.
    // Insert stdout and stderr to an object in a correct order
    let output = {};
    if (stdout.length && stderr.length) {
        // Both stdout and stderr have content
        // Decide the output order == Find out which data stream should be processed first, stdout or stderr.
        switch (shell_command_configuration.output_channel_order) {
            case "stdout-first":
                output = {
                    stdout: stdout,
                    stderr: stderr,
                };
                break;
            case "stderr-first":
                output = {
                    stderr: stderr,
                    stdout: stdout,
                };
                break;
        }
    }
    else if (stdout.length) {
        // Only stdout has content
        output = {
            stdout: stdout,
        };
    }
    else if (stderr.length) {
        // Only stderr has content
        output = {
            stderr: stderr,
        };
    }
    else {
        // Neither stdout nor stderr have content
        // Provide empty output, some output channels will process it, while other will just ignore it.
        output = {
            "stdout": "",
        };
    }
    // Should stderr be processed same time with stdout?
    if (output_channels.stdout === output_channels.stderr) {
        // Stdout and stderr use the same channel.
        // Make one handling call.
        handle_stream(plugin, t_shell_command, shell_command_parsing_result, output_channels.stdout, output, error_code);
    }
    else {
        // Stdout and stderr use different channels.
        // Make two handling calls.
        let output_stream_name;
        for (output_stream_name in output) {
            const output_channel_name = output_channels[output_stream_name];
            const output_message = output[output_stream_name];
            const separated_output = {};
            separated_output[output_stream_name] = output_message;
            handle_stream(plugin, t_shell_command, shell_command_parsing_result, output_channel_name, separated_output, error_code);
        }
    }
}
async function handle_stream(plugin, t_shell_command, shell_command_parsing_result, output_channel_name, output, error_code) {
    // Check if the output should be ignored
    if ("ignore" !== output_channel_name) {
        // The output should not be ignored.
        // Check that an output channel class exists
        if (undefined === outputChannelClasses[output_channel_name]) {
            throw new Error("No output channel class found for channel '" + output_channel_name + "'.");
        }
        // Instantiate the channel
        const outputChannel = initializeOutputChannel(output_channel_name, plugin, t_shell_command, shell_command_parsing_result, "buffered", null);
        // Perform handling the output
        await outputChannel.handleBuffered(output, error_code);
    }
}
function startRealtimeOutputHandling(plugin, tShellCommand, shellCommandParsingResult, outputChannelCodes, processTerminator) {
    const outputChannels = {};
    // stdout
    if ("ignore" !== outputChannelCodes.stdout) {
        outputChannels.stdout = initializeOutputChannel(outputChannelCodes.stdout, plugin, tShellCommand, shellCommandParsingResult, "realtime", processTerminator);
    }
    // stderr
    if ("ignore" !== outputChannelCodes.stderr) {
        if (outputChannelCodes.stderr === outputChannelCodes.stdout) {
            // stderr should use the same channel instance as stdout.
            outputChannels.stderr = outputChannels.stdout;
        }
        else {
            // stderr uses a different channel than stdout.
            outputChannels.stderr = initializeOutputChannel(outputChannelCodes.stderr, plugin, tShellCommand, shellCommandParsingResult, "realtime", processTerminator);
        }
    }
    return outputChannels;
}
function getOutputChannelsOptionList(output_stream) {
    const list = { ignore: "Ignore" };
    for (const name in outputChannelClasses) {
        const channelClass = outputChannelClasses[name];
        // Check that the stream is suitable for the channel
        if (channelClass.acceptsOutputStream(output_stream)) {
            list[name] = channelClass.getTitle(output_stream);
        }
    }
    return list;
}
function getOutputChannelClasses() {
    return outputChannelClasses;
}
function initializeOutputChannel(channelCode, plugin, tShellCommand, shellCommandParsingResult, outputHandlingMode, processTerminator) {
    // @ts-ignore TODO: Find out how to tell TypeScript that a subclass is being instatiated instead of the abstract base class:
    return new outputChannelClasses[channelCode](plugin, tShellCommand, shellCommandParsingResult, outputHandlingMode, processTerminator);
}
function registerOutputChannel(channelCode, channelClass) {
    if (undefined !== outputChannelClasses[channelCode]) {
        throw new Error("OutputChannel named '" + channelCode + "' is already registered!");
    }
    outputChannelClasses[channelCode] = channelClass;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
const PlatformShells = {
    darwin: {
        "/bin/bash": "Bash",
        "/bin/dash": "Dash",
        "/bin/zsh": "Zsh (Z shell)",
    },
    linux: {
        "/bin/bash": "Bash",
        "/bin/dash": "Dash",
        "/bin/zsh": "Zsh (Z shell)",
    },
    win32: {
        "pwsh.exe": "PowerShell Core",
        "PowerShell.exe": "PowerShell 5",
        "CMD.EXE": "cmd.exe",
    },
};
function getUsersDefaultShell() {
    if (isWindows()) {
        return process.env.ComSpec;
    }
    else {
        return process.env.SHELL;
    }
}
function isShellSupported(shell) {
    const shell_file_name = extractFileName(shell);
    const supported_shells = Object.getOwnPropertyNames(PlatformShells[getOperatingSystem()]);
    // Linux and macOS: Add the ambiguous 'sh' as a supported shell. It's not present in PlatformShells, because it's
    // not desired to be an explicitly selectable shell as it's uncertain, which shell it actually points to. But have
    // it supported when it comes from the "Use system default (sh)" option.
    if (!isWindows()) {
        // The platform is either Linux or macOS.
        // Add 'sh' support.
        supported_shells.push("sh");
    }
    for (const supported_shell_path of supported_shells) {
        // Check that the shell file names match. It doesn't matter in which directory the shell is located in.
        if (extractFileName(supported_shell_path).toLowerCase() === shell_file_name.toLowerCase()) {
            // The shell can be considered to be supported.
            return true;
        }
    }
    return false;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function getDefaultSettings(is_new_installation) {
    return {
        // Common:
        settings_version: is_new_installation
            ? SC_Plugin.SettingsVersion // For new installations, a specific settings version number can be used, as migrations do not need to be taken into account.
            : "prior-to-0.7.0" // This will be substituted by ShellCommandsPlugin.saveSettings() when the settings are saved.
        ,
        // Hidden settings (no UI controls in the settings panel)
        debug: false,
        obsidian_command_palette_prefix: "Execute: ",
        // Variables:
        preview_variables_in_command_palette: true,
        show_autocomplete_menu: true,
        // Environments:
        working_directory: "",
        default_shells: {},
        environment_variable_path_augmentations: {},
        // Output:
        error_message_duration: 20,
        notification_message_duration: 10,
        execution_notification_mode: "disabled",
        output_channel_clipboard_also_outputs_to_notification: true,
        // Events:
        enable_events: true,
        // Modals:
        approve_modals_by_pressing_enter_key: true,
        // Shell commands:
        max_visible_lines_in_shell_command_fields: false,
        shell_commands: [],
        // Prompts:
        prompts: [],
        // Custom variables
        custom_variables: [],
        // Output wrappers
        output_wrappers: [],
    };
}
const PlatformNames = {
    darwin: "Macintosh",
    linux: "Linux",
    win32: "Windows",
};
const CommandPaletteOptions = {
    enabled: "Command palette & hotkeys",
    unlisted: "Hotkeys only",
    disabled: "Excluded",
};

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class ShellCommandExecutor {
    constructor(plugin, t_shell_command, 
    /** Needed for Preactions to be able to access all variables, in case any variables are used by a Preaction. Use null, if the shell command execution happens outside of any event context. */
    sc_event) {
        this.plugin = plugin;
        this.t_shell_command = t_shell_command;
        this.sc_event = sc_event;
    }
    /**
     * Performs preactions, and if they all give resolved Promises, executes the shell command.
     */
    async doPreactionsAndExecuteShellCommand(parsing_process, overriding_output_channel) {
        const preactions = this.t_shell_command.getPreactions();
        // Does an already started ParsingProcess exist?
        if (!parsing_process) {
            // No ParsingProcess yet.
            // Create one and parse all variables that are safe to parse before preactions.
            debugLog("Going to prepare possible Preactions, but will first start a variable parsing process. Depending on possible Preactions, this might not yet parse all variables.");
            parsing_process = this.t_shell_command.createParsingProcess(this.sc_event);
            // Parse the first set of variables, not all sets.
            if (!await parsing_process.process()) {
                // Some errors happened.
                debugLog("Will not prepare possible Preactions, because the parsing process failed. Will cancel shell command execution.");
                parsing_process.displayErrorMessages();
                return;
            }
        }
        else {
            debugLog("Going to prepare possible Preactions with an already started variable parsing process.");
        }
        // Create a pipeline for preactions.
        let preaction_pipeline = Promise.resolve(true); // Will contain a series of preaction performs.
        // Confirm execution from a user, if needed.
        // I haven't decided yet if I want to move this to be its own Preaction subclass. Might make sense, but requires configuration migration.
        if (this.t_shell_command.getConfiguration().confirm_execution) {
            preaction_pipeline = preaction_pipeline.then(() => {
                debugLog("Asking a confirmation from a user to execute shell command #" + this.t_shell_command.getId());
                return new Promise((resolve, reject) => {
                    const confirmation_modal = new ConfirmationModal(this.plugin, this.t_shell_command.getAliasOrShellCommand(), "Execute this shell command?", "Yes, execute");
                    confirmation_modal.open();
                    confirmation_modal.promise.then((execution_confirmed) => {
                        if (execution_confirmed) {
                            // The PromptModal has been closed.
                            // Check if user wanted to execute the shell command or cancel.
                            if (execution_confirmed) {
                                // User wants to execute.
                                debugLog("User confirmed to execute shell command #" + this.t_shell_command.getId());
                                resolve(true);
                            }
                            else {
                                // User wants to cancel.
                                debugLog("User cancelled execution of shell command #" + this.t_shell_command.getId());
                                resolve(false);
                            }
                        }
                    });
                });
            });
        }
        // Perform preactions
        preactions.forEach((preaction) => {
            debugLog(`Adding Preaction of type '${preaction.configuration.type}' to pipeline.`);
            preaction_pipeline = preaction_pipeline.then(() => {
                debugLog(`Calling Preaction of type '${preaction.configuration.type}'.`);
                return preaction.perform(parsing_process, this.sc_event);
            });
        });
        if (0 === preactions.length) {
            debugLog("No Preactions to perform. This is ok.");
        }
        preaction_pipeline.then(async (can_execute) => {
            if (can_execute) {
                // Parse either all variables, or if some variables are already parsed, then just the rest. Might also be that
                // all variables are already parsed.
                debugLog("Parsing all the rest of the variables (if there are any left).");
                if (await parsing_process.processRest()) {
                    // Parsing the rest of the variables succeeded
                    // Execute the shell command.
                    const parsing_results = parsing_process.getParsingResults();
                    const shell_command_parsing_result = {
                        shell_command: parsing_results["shell_command"].parsed_content,
                        alias: parsing_results["alias"].parsed_content,
                        environment_variable_path_augmentation: parsing_results.environment_variable_path_augmentation.parsed_content,
                        output_wrapper_stdout: parsing_results.output_wrapper_stdout.parsed_content,
                        output_wrapper_stderr: parsing_results.output_wrapper_stderr.parsed_content,
                        succeeded: true,
                        error_messages: [],
                    };
                    debugLog("Will call ShellCommandExecutor.executeShellCommand().");
                    this.executeShellCommand(shell_command_parsing_result, overriding_output_channel);
                }
                else {
                    // Parsing has failed.
                    debugLog("Parsing the rest of the variables failed.");
                    parsing_process.displayErrorMessages();
                }
            }
            else {
                // Cancel execution
                debugLog("Shell command execution cancelled.");
            }
        });
    }
    /**
     * Does not ask for confirmation before execution. This should only be called if: a) a confirmation is already asked from a user, or b) this command is defined not to need a confirmation.
     * Use confirmAndExecuteShellCommand() instead to have a confirmation asked before the execution.
     *
     * @param shell_command_parsing_result The actual shell command that will be executed is taken from this object's '.shell_command' property.
     * @param overriding_output_channel Optional. If specified, all output streams will be directed to this output channel. Otherwise, output channels are determined from this.t_shell_command.
     */
    executeShellCommand(shell_command_parsing_result, overriding_output_channel) {
        const working_directory = this.getWorkingDirectory();
        // Define output channels
        let outputChannels = this.t_shell_command.getOutputChannels();
        if (overriding_output_channel) {
            // Ignore the shell command's normal channels and use temporarily something else.
            outputChannels = {
                'stdout': overriding_output_channel,
                'stderr': overriding_output_channel,
            };
        }
        // Check that the shell command is not empty
        const shell_command = shell_command_parsing_result.shell_command.trim();
        if (!shell_command.length) {
            // It is empty
            const error_message = this.getErrorMessageForEmptyShellCommand();
            debugLog(error_message);
            this.plugin.newError(error_message);
            return;
        }
        // Check that the currently defined shell is supported by this plugin. If using system default shell, it's possible
        // that the shell is something that is not supported. Also, the settings file can be edited manually, and incorrect
        // shell can be written there.
        const shell = this.t_shell_command.getShell();
        if (!isShellSupported(shell)) {
            debugLog("Shell is not supported: " + shell);
            this.plugin.newError("This plugin does not support the following shell: " + shell);
            return;
        }
        // Define an object for environment variables.
        const environment_variables = cloneObject(process.env); // Need to clone process.env, otherwise the modifications below will be stored permanently until Obsidian is hard-restarted (= closed and launched again).
        // Augment the PATH environment variable (if wanted)
        const augmented_path = this.augmentPATHEnvironmentVariable(shell_command_parsing_result.environment_variable_path_augmentation);
        if (augmented_path.length > 0) {
            environment_variables[getPATHEnvironmentVariableName()] = augmented_path;
        }
        // Check that the working directory exists and is a folder
        if (!fs__namespace.existsSync(working_directory)) {
            // Working directory does not exist
            // Prevent execution
            debugLog("Working directory does not exist: " + working_directory);
            this.plugin.newError("Working directory does not exist: " + working_directory);
        }
        else if (!fs__namespace.lstatSync(working_directory).isDirectory()) {
            // Working directory is not a directory.
            // Prevent execution
            debugLog("Working directory exists but is not a folder: " + working_directory);
            this.plugin.newError("Working directory exists but is not a folder: " + working_directory);
        }
        else {
            // Working directory is OK
            // Prepare execution options
            const options = {
                "cwd": working_directory,
                "shell": shell,
                "env": environment_variables,
            };
            // Execute the shell command
            debugLog("Executing command " + shell_command + " in " + working_directory + "...");
            try {
                const child_process$1 = child_process.spawn(shell_command, options);
                // Common error handling regardless of output handling mode
                child_process$1.on("error", (error) => {
                    // Probably most errors will NOT end up here, I guess this event occurs for some rare errors.
                    //
                    // A quote from https://nodejs.org/api/child_process.html#event-error (read 2022-10-29):
                    // > The 'error' event is emitted whenever:
                    // > - The process could not be spawned, or
                    // > - The process could not be killed, or
                    // > - Sending a message to the child process failed.
                    debugLog("Shell command failed to execute: Received a non-stderr error message: " + error.message);
                    this.plugin.newError("Shell command failed to execute. Error: " + error.message);
                });
                // Define output encoding
                child_process$1.stdout.setEncoding("utf8"); // Receive stdout and ...
                child_process$1.stderr.setEncoding("utf8"); // ... stderr as strings, not as Buffer objects.
                // Define a terminator
                const processTerminator = () => {
                    child_process$1.kill("SIGTERM");
                };
                // Hook into child_process for output handling
                switch (this.t_shell_command.getOutputHandlingMode()) {
                    case "buffered": {
                        // Output will be buffered and handled as a single batch.
                        this.handleBufferedOutput(child_process$1, shell_command_parsing_result, outputChannels);
                        break;
                    }
                    case "realtime": {
                        // Output will be handled on-the-go.
                        this.handleRealtimeOutput(child_process$1, shell_command_parsing_result, outputChannels, processTerminator);
                    }
                }
                // Display a notification of the execution (if wanted).
                if ("disabled" !== this.plugin.settings.execution_notification_mode) {
                    this.showExecutionNotification(child_process$1, shell_command, this.plugin.settings.execution_notification_mode, processTerminator);
                }
            }
            catch (exception) {
                // An exception has happened.
                // Check if the shell command was too long.
                if (exception.message.match(/spawn\s+ENAMETOOLONG/i)) {
                    // It was too long. Show an error message.
                    this.plugin.newError("Shell command execution failed because it's too long: " + shell_command.length + " characters. (Unfortunately the max limit is unknown).");
                }
                else {
                    // The shell command was not too long, this exception is about something else.
                    // Rethrow the exception.
                    throw exception;
                }
            }
        }
    }
    handleBufferedOutput(child_process, shell_command_parsing_result, outputChannels) {
        child_process.on("exit", (exitCode) => {
            // Get outputs
            const stdout = child_process.stdout.read() ?? "";
            let stderr = child_process.stderr.read() ?? ""; // let instead of const: stderr can be emptied later due to ignoring.
            // Did the shell command execute successfully?
            if (exitCode > 0) {
                // Some error occurred
                debugLog("Command executed and failed. Error number: " + exitCode + ". Stderr: " + stderr);
                // Check if this error should be displayed to the user or not
                if (this.t_shell_command.getIgnoreErrorCodes().contains(exitCode)) {
                    // The user has ignored this error.
                    debugLog("User has ignored this error, so won't display it.");
                    // Handle only stdout output stream
                    stderr = "";
                    exitCode = null; // TODO: consider if exitCode should just be left untouched. It could be informative to 'Ask after execution' output channel that shows exit code to user.
                }
                else {
                    // The error can be shown.
                    debugLog("Will display the error to user.");
                }
                // Handle at least stdout (and maybe stderr) output stream
                handleBufferedOutput(this.plugin, this.t_shell_command, shell_command_parsing_result, stdout, stderr, exitCode, outputChannels);
            }
            else {
                // Probably no errors, but do one more check.
                // Even when 'error' is null and everything should be ok, there may still be error messages outputted in stderr.
                if (stderr.length > 0) {
                    // Check a special case: should error code 0 be ignored?
                    if (this.t_shell_command.getIgnoreErrorCodes().contains(0)) {
                        // Exit code 0 is on the ignore list, so suppress stderr output.
                        stderr = "";
                        debugLog("Shell command executed: Encountered error code 0, but stderr is ignored.");
                    }
                    else {
                        debugLog("Shell command executed: Encountered error code 0, and stderr will be relayed to an output handler.");
                    }
                }
                else {
                    debugLog("Shell command executed: No errors.");
                }
                // Handle output
                handleBufferedOutput(this.plugin, this.t_shell_command, shell_command_parsing_result, stdout, stderr, 0, outputChannels); // Use zero as an error code instead of null (0 means no error). If stderr happens to contain something, exit code 0 gets displayed in an error balloon (if that is selected as a channel for stderr).
            }
        });
    }
    handleRealtimeOutput(childProcess, shell_command_parsing_result, outputChannelCodes, processTerminator) {
        // Prepare output channels
        const outputChannels = startRealtimeOutputHandling(this.plugin, this.t_shell_command, shell_command_parsing_result, outputChannelCodes, processTerminator);
        // Define an output handler
        const handleNewOutputContent = async (outputStreamName, readableStream) => {
            // Don't emit new events while the current handling is in progress. (I think) it might cause a race condition where a simultaneous handling could overwrite another handling's data. Pause both streams, not just the current one, to maintain correct handling order also between the two streams.
            childProcess.stdout.pause();
            childProcess.stderr.pause();
            const outputContent = readableStream.read() ?? "";
            await outputChannels[outputStreamName].handleRealtime(outputStreamName, outputContent);
            // Can emit new events again.
            childProcess.stdout.resume();
            childProcess.stderr.resume();
        };
        // Hook into output streams' (such as stdout and stderr) output retrieving events.
        // Note that there might be just one stream, e.g. only stderr, if stdout is ignored. In the future, there might also be more than two streams, when custom streams are implemented.
        for (const outputStreamName of Object.getOwnPropertyNames(outputChannels)) {
            const readableStream = childProcess[outputStreamName];
            readableStream.on("readable", () => handleNewOutputContent(outputStreamName, readableStream));
        }
        // Hook into exit events
        childProcess.on("exit", (exitCode, signal /* TODO: Pass signal to channels so it can be shown to users in the future */) => {
            // Call all OutputChannels' endRealtime().
            const alreadyCalledChannelCodes = [];
            for (const outputStreamName of Object.getOwnPropertyNames(outputChannels)) {
                const outputChannel = outputChannels[outputStreamName];
                const outputChannelCode = outputChannelCodes[outputStreamName];
                // Ensure this OutputChannel has not yet been called.
                if (!alreadyCalledChannelCodes.includes(outputChannelCode)) {
                    // Not yet called, so do the call.
                    outputChannel.endRealtime(exitCode);
                    // Mark that this channel's endRealtime() has already been called. Solves a situation where stderr and stdout uses the same channel, in which case endRealtime() should not be accidentally called twice.
                    alreadyCalledChannelCodes.push(outputChannelCode);
                }
            }
        });
    }
    getWorkingDirectory() {
        // Returns either a user defined working directory, or an automatically detected one.
        const working_directory = this.plugin.settings.working_directory;
        if (working_directory.length == 0) {
            // No working directory specified, so use the vault directory.
            return getVaultAbsolutePath(this.plugin.app);
        }
        else if (!path__namespace.isAbsolute(working_directory)) {
            // The working directory is relative.
            // Help to make it refer to the vault's directory. Without this, the relative path would refer to Obsidian's installation directory (at least on Windows).
            return path__namespace.join(getVaultAbsolutePath(this.plugin.app), working_directory);
        }
        return working_directory;
    }
    augmentPATHEnvironmentVariable(path_augmentation) {
        path_augmentation = convertNewlinesToPATHSeparators(path_augmentation, getOperatingSystem());
        // Check if there's anything to augment.
        if (path_augmentation.length > 0) {
            // Augment.
            const original_path = process.env[getPATHEnvironmentVariableName()];
            let augmented_path;
            if (path_augmentation.contains(original_path)) {
                // The augmentation contains the original PATH.
                // Simply replace the whole original PATH with the augmented one, as there's no need to care about including
                // the original content.
                debugLog("Augmenting environment variable PATH so it will become " + path_augmentation);
                augmented_path = path_augmentation;
            }
            else {
                // The augmentation does not contain the original PATH.
                // Instead of simply replacing the original PATH, append the augmentation after it.
                const separator = getPATHSeparator(getOperatingSystem());
                debugLog("Augmenting environment variable PATH by adding " + separator + path_augmentation + " after it.");
                augmented_path = original_path + separator + path_augmentation;
            }
            debugLog("PATH augmentation result: " + augmented_path);
            return augmented_path;
        }
        else {
            // No augmenting is needed.
            debugLog("No augmentation is defined for environment variable PATH. This is completely ok.");
            return "";
        }
    }
    /**
     * This method should only be called if it's first checked that neither shell command version for the current platform nor a 'default' version exists.
     *
     * @private
     */
    getErrorMessageForEmptyShellCommand() {
        if (this.t_shell_command.getNonEmptyPlatformIds().length > 0) {
            // The shell command contains versions for other platforms, but not for the current one.
            const current_platform_name = PlatformNames[getOperatingSystem()];
            const version_word = this.t_shell_command.getNonEmptyPlatformIds().length > 1 ? "versions" : "a version";
            const other_platform_names = this.t_shell_command.getNonEmptyPlatformIds().map(platform_id => PlatformNames[platform_id]).join(" and ");
            return `The shell command does not have a version for ${current_platform_name}, it only has ${version_word} for ${other_platform_names}.`;
        }
        else {
            // The shell command doesn't contain a version for any platforms, it's completely empty.
            return "The shell command is empty. :(";
        }
    }
    /**
     * Displays a notification balloon indicating a user that a shell command is being executed.
     *
     * @param child_process
     * @param shell_command
     * @param execution_notification_mode
     * @param processTerminator Will be called if user clicks 'Request to terminate the process' icon.
     * @private
     */
    showExecutionNotification(child_process, shell_command, execution_notification_mode, processTerminator) {
        const createRequestTerminatingButton = (notice) => {
            // @ts-ignore Notice.noticeEl belongs to Obsidian's PRIVATE API, and it may change without a prior notice. Only
            // create the button if noticeEl exists and is an HTMLElement.
            const noticeEl = notice.noticeEl;
            if (undefined !== noticeEl && noticeEl instanceof HTMLElement) {
                this.plugin.createRequestTerminatingButton(noticeEl, processTerminator);
            }
        };
        const execution_notification_message = "Executing: " + (this.t_shell_command.getAlias() || shell_command);
        switch (execution_notification_mode) {
            case "quick": {
                // Retrieve the timeout from settings defined by a user.
                const processNotification = this.plugin.newNotification(execution_notification_message, undefined);
                createRequestTerminatingButton(processNotification);
                break;
            }
            case "permanent": {
                // Show the notification until the process ends.
                const processNotification = this.plugin.newNotification(execution_notification_message, 0);
                createRequestTerminatingButton(processNotification);
                // Hide the notification when the process finishes.
                child_process.on("exit", () => processNotification.hide());
                break;
            }
            case "if-long": {
                // Only show the notification if the process runs for an extended period of time (defined below).
                window.setTimeout(() => {
                    // Check if the process is still running.
                    if (null === child_process.exitCode && !child_process.killed) {
                        // The process is still running.
                        // Display notification.
                        const processNotification = this.plugin.newNotification(execution_notification_message, 0);
                        createRequestTerminatingButton(processNotification);
                        // Hide the notification when the process finishes.
                        child_process.on("exit", () => processNotification.hide());
                    }
                }, 2000); // If you change the timeout, change documentation, too!
                break;
            }
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Instance {
    constructor(model, configuration, parent_instance_or_configuration) {
        this.model = model;
        this.configuration = configuration;
        debugLog(this.constructor.name + ": Creating a new instance.");
        // Determine parent type
        if (parent_instance_or_configuration instanceof Instance) {
            // It's an instance object
            this.parent_instance = parent_instance_or_configuration;
            this.parent_configuration = this.parent_instance.configuration;
        }
        else {
            // It's a configuration object.
            // No parent instance is available, so probably this is about SC_MainSettings object, as it does not have Model/Instance classes (at least yet).
            this.parent_instance = null; // It's null already, but do this just to make a statement.
            this.parent_configuration = parent_instance_or_configuration;
        }
    }
    setIfValid(field, value) {
        return this.model.validateValue(this, field, value).then(() => {
            this.configuration[field] = value;
        });
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Model {
    constructor(plugin) {
        this.plugin = plugin;
    }
    createSettingFields(instance, parent_element, with_deletion = true) {
        debugLog(this.constructor.name + ": Creating setting fields.");
        // Create a container
        const setting_fields_container = parent_element.createDiv(); // Create a nested container that can be easily deleted if the instance is deleted.
        const main_setting_field = this._createSettingFields(instance, setting_fields_container);
        if (with_deletion) {
            main_setting_field.addExtraButton(button => button
                .setIcon("trash")
                .setTooltip("Delete this " + this.getSingularName().toLocaleLowerCase())
                .onClick(() => {
                // The trash icon has been clicked
                // Open up a modal asking for confirmation if the instance can be deleted from this.parent_configuration.
                const confirmation_modal = new ConfirmationModal(this.plugin, "Delete " + this.getSingularName().toLocaleLowerCase() + ": " + instance.getTitle(), "Are you sure you want to delete this " + this.getSingularName().toLocaleLowerCase() + "?", "Yes, delete");
                confirmation_modal.open();
                confirmation_modal.promise.then(async (deletion_confirmed) => {
                    if (deletion_confirmed) {
                        // User has confirmed the deletion.
                        // Delete the configuration and remove the instance from custom collections.
                        this.deleteInstance(instance);
                        // Delete setting fields.
                        setting_fields_container.remove();
                        // Save settings
                        await this.plugin.saveSettings();
                    }
                });
            }));
        }
        return main_setting_field;
    }
    /**
     * Deletes the instance from configuration, and calls _deleteChild() which will delete the instance from custom collections.
     *
     * Can be made public if needed.
     */
    deleteInstance(instance) {
        debugLog(this.constructor.name + ": Deleting an instance.");
        this._deleteInstance(instance);
        const relation = this.defineParentConfigurationRelation(instance);
        switch (relation.type) {
            // case "one-to-one": // TODO: Uncomment when first model that needs this is implemented.
            // This is a relation where 'key' points directly to the instance's configuration.
            // delete this.parent_configuration[this.relation.key];
            // break;
            case "one-to-many-index": {
                // This is a relation where 'key' points to an indexed array of instance configurations. Use 'index' to pick the correct instance configuration.
                instance.parent_configuration[relation.key].splice(relation.index, 1); // Do not use delete, as it would place null in the list.
                break;
            }
            case "one-to-many-id": {
                // This is a relation where 'key' points to an indexed array of instance configurations. Use 'id' to determine the correct index.
                const index = this.idToIndex(instance.parent_configuration[relation.key], relation.id);
                if (null === index) {
                    // Something went wrong
                    throw new Error(`${this.constructor.name}.deleteInstance(): Could not find an index for id ${relation.id}.`);
                }
                instance.parent_configuration[relation.key].splice(index, 1); // Do not use delete, as it would place null in the list.
                break;
            }
        }
    }
    idToIndex(configurations, id) {
        let result_index = null;
        configurations.forEach((instance_configuration, index) => {
            if (instance_configuration.id === id) {
                // This is the correct configuration.
                result_index = index;
            }
        });
        return result_index;
    }
    /**
     * This should delete the instance from custom collections. It should be overridden by all Instance classes that have deletable children.
     */
    _deleteInstance(instance) {
        throw new Error(this.constructor.name + ".deleteInstance(): This class does not override _deleteInstance() method. Maybe the class is not supposed to have children?");
    }
}
// Model class collection
const model_classes = new Map();
function introduceModelClass(model_class) {
    model_classes.set(model_class.constructor.name, model_class);
}
function getModel(model_class_name) {
    return model_classes.get(model_class_name);
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputWrapper extends Instance {
    constructor(model, plugin, configuration, parent_configuration) {
        super(model, configuration, parent_configuration);
        this.model = model;
        this.plugin = plugin;
        this.configuration = configuration;
        this.parent_configuration = parent_configuration;
        // Introduce the ID to an ID generator so that it won't accidentally generate the same ID again when creating new OutputWrappers.
        getIDGenerator().addReservedID(configuration.id);
    }
    getID() {
        return this.configuration.id;
    }
    getTitle() {
        return this.configuration.title;
    }
    getContent() {
        return this.configuration.content;
    }
    getConfiguration() {
        return this.configuration;
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var autocomplete = createCommonjsModule(function (module, exports) {
(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, (function () {
  /*
   * https://github.com/kraaden/autocomplete
   * Copyright (c) 2016 Denys Krasnoshchok
   * MIT License
   */
  function autocomplete(settings) {
      // just an alias to minimize JS file size
      var doc = document;
      var container = settings.container || doc.createElement("div");
      var containerStyle = container.style;
      var userAgent = navigator.userAgent;
      var mobileFirefox = ~userAgent.indexOf("Firefox") && ~userAgent.indexOf("Mobile");
      var debounceWaitMs = settings.debounceWaitMs || 0;
      var preventSubmit = settings.preventSubmit || false;
      var disableAutoSelect = settings.disableAutoSelect || false;
      // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead
      var keyUpEventName = mobileFirefox ? "input" : "keyup";
      var items = [];
      var inputValue = "";
      var minLen = 2;
      var showOnFocus = settings.showOnFocus;
      var selected;
      var keypressCounter = 0;
      var debounceTimer;
      if (settings.minLength !== undefined) {
          minLen = settings.minLength;
      }
      if (!settings.input) {
          throw new Error("input undefined");
      }
      var input = settings.input;
      container.className = "autocomplete " + (settings.className || "");
      // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning
      containerStyle.position = "absolute";
      /**
       * Detach the container from DOM
       */
      function detach() {
          var parent = container.parentNode;
          if (parent) {
              parent.removeChild(container);
          }
      }
      /**
       * Clear debouncing timer if assigned
       */
      function clearDebounceTimer() {
          if (debounceTimer) {
              window.clearTimeout(debounceTimer);
          }
      }
      /**
       * Attach the container to DOM
       */
      function attach() {
          if (!container.parentNode) {
              doc.body.appendChild(container);
          }
      }
      /**
       * Check if container for autocomplete is displayed
       */
      function containerDisplayed() {
          return !!container.parentNode;
      }
      /**
       * Clear autocomplete state and hide container
       */
      function clear() {
          // prevent the update call if there are pending AJAX requests
          keypressCounter++;
          items = [];
          inputValue = "";
          selected = undefined;
          detach();
      }
      /**
       * Update autocomplete position
       */
      function updatePosition() {
          if (!containerDisplayed()) {
              return;
          }
          containerStyle.height = "auto";
          containerStyle.width = input.offsetWidth + "px";
          var maxHeight = 0;
          var inputRect;
          function calc() {
              var docEl = doc.documentElement;
              var clientTop = docEl.clientTop || doc.body.clientTop || 0;
              var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
              var scrollTop = window.pageYOffset || docEl.scrollTop;
              var scrollLeft = window.pageXOffset || docEl.scrollLeft;
              inputRect = input.getBoundingClientRect();
              var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
              var left = inputRect.left + scrollLeft - clientLeft;
              containerStyle.top = top + "px";
              containerStyle.left = left + "px";
              maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
              if (maxHeight < 0) {
                  maxHeight = 0;
              }
              containerStyle.top = top + "px";
              containerStyle.bottom = "";
              containerStyle.left = left + "px";
              containerStyle.maxHeight = maxHeight + "px";
          }
          // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)
          calc();
          calc();
          if (settings.customize && inputRect) {
              settings.customize(input, inputRect, container, maxHeight);
          }
      }
      /**
       * Redraw the autocomplete div element with suggestions
       */
      function update() {
          // delete all children from autocomplete DOM container
          while (container.firstChild) {
              container.removeChild(container.firstChild);
          }
          // function for rendering autocomplete suggestions
          var render = function (item, currentValue) {
              var itemElement = doc.createElement("div");
              itemElement.textContent = item.label || "";
              return itemElement;
          };
          if (settings.render) {
              render = settings.render;
          }
          // function to render autocomplete groups
          var renderGroup = function (groupName, currentValue) {
              var groupDiv = doc.createElement("div");
              groupDiv.textContent = groupName;
              return groupDiv;
          };
          if (settings.renderGroup) {
              renderGroup = settings.renderGroup;
          }
          var fragment = doc.createDocumentFragment();
          var prevGroup = "#9?$";
          items.forEach(function (item) {
              if (item.group && item.group !== prevGroup) {
                  prevGroup = item.group;
                  var groupDiv = renderGroup(item.group, inputValue);
                  if (groupDiv) {
                      groupDiv.className += " group";
                      fragment.appendChild(groupDiv);
                  }
              }
              var div = render(item, inputValue);
              if (div) {
                  div.addEventListener("click", function (ev) {
                      settings.onSelect(item, input);
                      clear();
                      ev.preventDefault();
                      ev.stopPropagation();
                  });
                  if (item === selected) {
                      div.className += " selected";
                  }
                  fragment.appendChild(div);
              }
          });
          container.appendChild(fragment);
          if (items.length < 1) {
              if (settings.emptyMsg) {
                  var empty = doc.createElement("div");
                  empty.className = "empty";
                  empty.textContent = settings.emptyMsg;
                  container.appendChild(empty);
              }
              else {
                  clear();
                  return;
              }
          }
          attach();
          updatePosition();
          updateScroll();
      }
      function updateIfDisplayed() {
          if (containerDisplayed()) {
              update();
          }
      }
      function resizeEventHandler() {
          updateIfDisplayed();
      }
      function scrollEventHandler(e) {
          if (e.target !== container) {
              updateIfDisplayed();
          }
          else {
              e.preventDefault();
          }
      }
      function keyupEventHandler(ev) {
          var keyCode = ev.which || ev.keyCode || 0;
          var ignore = settings.keysToIgnore || [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];
          for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {
              var key = ignore_1[_i];
              if (keyCode === key) {
                  return;
              }
          }
          if (keyCode >= 112 /* F1 */ && keyCode <= 123 /* F12 */ && !settings.keysToIgnore) {
              return;
          }
          // the down key is used to open autocomplete
          if (keyCode === 40 /* Down */ && containerDisplayed()) {
              return;
          }
          startFetch(0 /* Keyboard */);
      }
      /**
       * Automatically move scroll bar if selected item is not visible
       */
      function updateScroll() {
          var elements = container.getElementsByClassName("selected");
          if (elements.length > 0) {
              var element = elements[0];
              // make group visible
              var previous = element.previousElementSibling;
              if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
                  element = previous;
              }
              if (element.offsetTop < container.scrollTop) {
                  container.scrollTop = element.offsetTop;
              }
              else {
                  var selectBottom = element.offsetTop + element.offsetHeight;
                  var containerBottom = container.scrollTop + container.offsetHeight;
                  if (selectBottom > containerBottom) {
                      container.scrollTop += selectBottom - containerBottom;
                  }
              }
          }
      }
      /**
       * Select the previous item in suggestions
       */
      function selectPrev() {
          if (items.length < 1) {
              selected = undefined;
          }
          else {
              if (selected === items[0]) {
                  selected = items[items.length - 1];
              }
              else {
                  for (var i = items.length - 1; i > 0; i--) {
                      if (selected === items[i] || i === 1) {
                          selected = items[i - 1];
                          break;
                      }
                  }
              }
          }
      }
      /**
       * Select the next item in suggestions
       */
      function selectNext() {
          if (items.length < 1) {
              selected = undefined;
          }
          if (!selected || selected === items[items.length - 1]) {
              selected = items[0];
              return;
          }
          for (var i = 0; i < (items.length - 1); i++) {
              if (selected === items[i]) {
                  selected = items[i + 1];
                  break;
              }
          }
      }
      function keydownEventHandler(ev) {
          var keyCode = ev.which || ev.keyCode || 0;
          if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {
              var containerIsDisplayed = containerDisplayed();
              if (keyCode === 27 /* Esc */) {
                  clear();
              }
              else {
                  if (!containerIsDisplayed || items.length < 1) {
                      return;
                  }
                  keyCode === 38 /* Up */
                      ? selectPrev()
                      : selectNext();
                  update();
              }
              ev.preventDefault();
              if (containerIsDisplayed) {
                  ev.stopPropagation();
              }
              return;
          }
          if (keyCode === 13 /* Enter */) {
              if (selected) {
                  if (preventSubmit) {
                      ev.preventDefault();
                  }
                  settings.onSelect(selected, input);
                  clear();
              }
          }
      }
      function focusEventHandler() {
          if (showOnFocus) {
              startFetch(1 /* Focus */);
          }
      }
      function startFetch(trigger) {
          // If multiple keys were pressed, before we get an update from server,
          // this may cause redrawing autocomplete multiple times after the last key was pressed.
          // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.
          var savedKeypressCounter = ++keypressCounter;
          var inputText = input.value;
          var cursorPos = input.selectionStart || 0;
          if (inputText.length >= minLen || trigger === 1 /* Focus */) {
              clearDebounceTimer();
              debounceTimer = window.setTimeout(function () {
                  settings.fetch(inputText, function (elements) {
                      if (keypressCounter === savedKeypressCounter && elements) {
                          items = elements;
                          inputValue = inputText;
                          selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];
                          update();
                      }
                  }, trigger, cursorPos);
              }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);
          }
          else {
              clear();
          }
      }
      function blurEventHandler() {
          // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM
          setTimeout(function () {
              if (doc.activeElement !== input) {
                  clear();
              }
          }, 200);
      }
      /**
       * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
       */
      container.addEventListener("mousedown", function (evt) {
          evt.stopPropagation();
          evt.preventDefault();
      });
      /**
       * Fixes #30: autocomplete closes when scrollbar is clicked in IE
       * See: https://stackoverflow.com/a/9210267/13172349
       */
      container.addEventListener("focus", function () { return input.focus(); });
      /**
       * This function will remove DOM elements and clear event handlers
       */
      function destroy() {
          input.removeEventListener("focus", focusEventHandler);
          input.removeEventListener("keydown", keydownEventHandler);
          input.removeEventListener(keyUpEventName, keyupEventHandler);
          input.removeEventListener("blur", blurEventHandler);
          window.removeEventListener("resize", resizeEventHandler);
          doc.removeEventListener("scroll", scrollEventHandler, true);
          clearDebounceTimer();
          clear();
      }
      // setup event handlers
      input.addEventListener("keydown", keydownEventHandler);
      input.addEventListener(keyUpEventName, keyupEventHandler);
      input.addEventListener("blur", blurEventHandler);
      input.addEventListener("focus", focusEventHandler);
      window.addEventListener("resize", resizeEventHandler);
      doc.addEventListener("scroll", scrollEventHandler, true);
      return {
          destroy: destroy
      };
  }

  return autocomplete;

})));

});

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function getVariableAutocompleteItems(plugin) {
    if (0 === autocomplete_items.length) {
        plugin.getVariables().forEach((variable) => {
            autocomplete_items.push(...variable.getAutocompleteItems());
        });
    }
    return autocomplete_items;
}
function resetVariableAutocompleteItems() {
    while (autocomplete_items.length) {
        autocomplete_items.pop();
    }
}
const autocomplete_items = [];

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 *
 * @param plugin Used for getting a list of Variable autocomplete items.
 * @param input_element
 * @param call_on_completion A function that will be called when a user has selected a suggestion and performed the autocomplete action. onChange event will not be called, because it would trigger opening the autocomplete menu again, so that's why a separate callback is used.
 * @param extra_autocomplete_items
 */
function createAutocomplete(plugin, input_element, call_on_completion, extra_autocomplete_items = []) {
    autocomplete({
        input: input_element,
        fetch: (input_value_but_not_used, update) => {
            const autocomplete_items = merge_and_sort_autocomplete_items(getVariableAutocompleteItems(plugin), CustomAutocompleteItems, extra_autocomplete_items);
            const max_suggestions = 30;
            // Get the so far typed text - exclude everything that is on the right side of the caret.
            const caret_position = input_element.selectionStart;
            const typed_text = input_element.value.slice(0, caret_position);
            const search_query = get_search_query(typed_text);
            if ("" === search_query.search_text) {
                // No suggestions for empty word.
                update([]);
            }
            else {
                // The word is not empty, so can suggest something.
                let matched_items = autocomplete_items.filter(item => item_match(item, search_query));
                sort_autocomplete_items(matched_items, search_query);
                matched_items = matched_items.slice(0, max_suggestions); // Limit to a reasonable amount of suggestions.
                update(matched_items);
            }
        },
        onSelect: (item) => {
            // A user has selected an item to be autocompleted
            // Get the item text and already typed text
            let supplement = item.value;
            let caret_position = input_element.selectionStart;
            const typed_text = input_element.value.slice(0, caret_position);
            const search_query = get_search_query(typed_text);
            const search_text = search_query.search_text;
            // Special case: Check if }} happens to appear after the caret
            const after_caret = input_element.value.slice(caret_position, caret_position + 2);
            if ("}}" === after_caret) {
                // The replacing will happen in a {{variable}}.
                // Do not accidentally insert another }} pair.
                supplement = supplement.replace(/\}\}$/u, ""); // Only removes a trailing }} if there is one.
            }
            // Try to save part of the beginning, in case it seems like not being part of the search query.
            let replace_start = find_starting_position(search_text, supplement); // The length difference of typed_text and search_text will be added here below.
            if (false === replace_start) {
                // This should never happen, but if it does, do not replace anything, just insert.
                replace_start = caret_position;
            }
            else {
                // Adjust the position
                replace_start += typed_text.length - search_text.length;
            }
            // Choose a method for doing the inserting
            if (undefined !== document.execCommand) {
                // execCommand() is deprecated, but available.
                // Use it to do the insertion, because this way an undo history can be preserved.
                input_element.setSelectionRange(replace_start, caret_position); // First select the part that will be replaced, because execCommand() does not support defining positions. This adds a cumbersome selection step to the undo history, but at least undoing works.
                document.execCommand("insertText", false, supplement);
            }
            else {
                // execCommand() is not available anymore.
                // Use setRangeText() to do the insertion. It will clear undo history, but at least the insertion works.
                input_element.setRangeText(supplement, replace_start, caret_position);
            }
            // Move the caret to a logical continuation point
            caret_position = replace_start + supplement.length;
            if (supplement.match(/:\}\}$/u)) {
                // Place the caret after the colon, instead of after }}.
                caret_position -= 2;
            }
            input_element.setSelectionRange(caret_position, caret_position);
            // Call a hook
            call_on_completion(input_element.value);
        },
        render: (item) => {
            const div_element = document.createElement("div");
            div_element.createSpan({ text: item.value, attr: { class: "SC-autocomplete-value" } });
            if (item.help_text) {
                div_element.createSpan({ text: ": ", attr: { class: "SC-autocomplete-separator" } });
                div_element.createSpan({ attr: { class: "SC-autocomplete-help-text" } }).insertAdjacentHTML("beforeend", item.help_text);
            }
            return div_element;
        },
        minLength: 2,
        className: "SC-autocomplete",
        keysToIgnore: [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */],
        preventSubmit: true, // Prevents creating newlines in textareas when enter is pressed in the autocomplete menu.
    });
}
function item_match(item, search_query) {
    const item_value = item.value.toLocaleLowerCase();
    const search_text = search_query.search_text.toLocaleLowerCase();
    // Match query type
    if (item.type !== search_query.search_type) {
        // If the query type is different, do not include this item.
        // This can happen e.g. if {{ is typed, and the item is not a variable, or {{! is typed, and the item is not an unescaped variable.
        return false;
    }
    // Match text
    let search_character;
    let search_position = 0;
    for (let search_character_index = 0; search_character_index < search_text.length; search_character_index++) {
        search_character = search_text[search_character_index];
        if (item_value.includes(search_character, search_position)) {
            // This character was found in item_value.
            search_position = item_value.indexOf(search_character, search_position) + 1;
        }
        else {
            // This character was not found.
            return false;
        }
    }
    return true;
}
function find_starting_position(typed_text, supplement) {
    typed_text = typed_text.toLocaleLowerCase();
    supplement = supplement.toLocaleLowerCase();
    for (let supplement_index = supplement.length; supplement_index >= 0; supplement_index--) {
        const partial_supplement = supplement.slice(0, supplement_index);
        if (typed_text.contains(partial_supplement)) {
            return typed_text.indexOf(partial_supplement);
        }
    }
    return false;
}
/**
 * Sorts in place, does not make a copy.
 * @param autocomplete_items
 * @param search_query
 */
function sort_autocomplete_items(autocomplete_items, search_query) {
    const search_text_excluding_curly_brackets = search_query.search_text.replace(/^{{!?/, "");
    function get_common_beginning_length(autocomplete_item, search_query) {
        const search_text = search_query.search_text.toLocaleLowerCase();
        const item_value = autocomplete_item.value.toLocaleLowerCase();
        const shortest_length = Math.min(search_text.length, item_value.length);
        for (let character_index = 0; character_index < shortest_length; character_index++) {
            const search_character = search_text[character_index];
            const item_character = item_value[character_index];
            if (search_character !== item_character) {
                // The common beginning has ended.
                return character_index;
            }
        }
        return shortest_length;
    }
    autocomplete_items.sort((a, b) => {
        const boost_a = Math.max(get_common_beginning_length(a, search_query), 1); // Boosts are used as multipliers,
        const boost_b = Math.max(get_common_beginning_length(b, search_query), 1); // so they cannot be zero.
        const a_length = a.value.length * boost_b; // boost_b worsens A (= makes it artificially "longer")
        const b_length = b.value.length * boost_a; // boost_a worsens B
        // Determine sorting method. If the search query is just a couple of characters, the matches would be quite vague, sorting by the matched items' length would not tell much, and the list would just look strangely ordered.
        if (search_text_excluding_curly_brackets.length < 2 || a_length === b_length) {
            // Sort alphabetically.
            return a.value > b.value ? 1 : -1;
        }
        else {
            // Sort by lengths. The shortest item is preferred. If an item has a long common beginning with the search query, boost the item up.
            return a_length - b_length;
        }
    });
}
const CustomAutocompleteItems = [];
function addCustomAutocompleteItems(custom_autocomplete_yaml) {
    // Ensure the content is not empty
    if (0 === custom_autocomplete_yaml.trim().length) {
        return "The content is empty.";
    }
    // Try to parse YAML syntax
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let yaml; // 'any' is defined in obsidian.d.ts for the return type of parseYaml(), so I made ESLint ignore it.
    try {
        yaml = obsidian.parseYaml(custom_autocomplete_yaml);
    }
    catch (error) {
        // A syntax error has appeared.
        return error.message;
    }
    if (null === yaml || typeof yaml !== "object") {
        return "Unable to parse the content due to unknown reason.";
    }
    // Iterate autocomplete item groups
    const group_names = Object.getOwnPropertyNames(yaml);
    const error_messages = [];
    group_names.forEach((group_name) => {
        const group_items = yaml[group_name];
        const group_item_values = Object.getOwnPropertyNames(group_items);
        // Iterate all autocomplete items in the group
        group_item_values.forEach((autocomplete_item_value) => {
            const autocomplete_item_label = group_items[autocomplete_item_value];
            if (typeof autocomplete_item_label !== "string") {
                error_messages.push("Autocomplete item '" + autocomplete_item_value + "' has an incorrect help text type: " + autocomplete_item_label + " is a " + typeof autocomplete_item_label + ", but it should be a string.");
                return;
            }
            // Determine a correct type for the item
            let type = "other";
            if (autocomplete_item_value.startsWith("{{")) {
                // This is a variable
                type = "normal-variable";
            }
            // The item is ok, add it to the list
            CustomAutocompleteItems.push({
                value: autocomplete_item_value,
                help_text: autocomplete_item_label,
                group: group_name,
                type: type,
            });
            if (type === "normal-variable") {
                // Add an unescaped version of the variable, too
                CustomAutocompleteItems.push({
                    value: autocomplete_item_value.replace(/^\{\{/u, "{{!"),
                    help_text: autocomplete_item_label,
                    group: group_name,
                    type: "unescaped-variable",
                });
            }
        });
    });
    if (error_messages.length > 0) {
        // Something failed
        return error_messages.join("; ");
    }
    // All ok
    return true;
}
/**
 * TODO: Can the sorting be removed from here? Now autocomplete items are sorted again every time when filtering, based on the keyword (https://github.com/Taitava/obsidian-shellcommands/issues/249).
 * @param autocomplete_item_sets
 */
function merge_and_sort_autocomplete_items(...autocomplete_item_sets) {
    const merged_autocomplete_items = [].concat(...autocomplete_item_sets);
    return merged_autocomplete_items.sort((a, b) => {
        // First compare groups
        if (a.group < b.group) {
            // a's group should come before b's group.
            return -1;
        }
        else if (a.group > b.group) {
            // a's group should come after b's group.
            return 1;
        }
        else {
            // The groups are the same.
            // Compare values.
            if (a.value < b.value) {
                // a should come before b.
                return -1;
            }
            else if (a.value > b.value) {
                // a should come after b.
                return 1;
            }
            else {
                // The values are the same.
                // The order does not matter.
                return 0;
            }
        }
    });
}
/**
 * Reduces an input string to the nearest logical word.
 * @param typed_text
 */
function get_search_query(typed_text) {
    let search_text = typed_text.match(/\S*?$/u)[0]; // Reduce the text - limit to a single word (= exclude spaces and everything before them).
    let search_type = "other"; // May be overwritten.
    if (search_text.contains("}}")) {
        // The query happens right after a {{variable}}.
        // Make the query string to start after the }} pair, i.e. remove }} and everything before it. This improves the search.
        search_text = search_text.replace(/.+\}\}/u, "");
    }
    if (search_text.contains("{{")) {
        // A {{variable}} is being queried.
        // Make the query string to start from the {{ pair, i.e. remove everything before {{ . This improves the search.
        search_text = search_text.replace(/.+\{\{/u, "{{");
        if (search_text.contains("{{!")) {
            // An _unescaped_ variable is searched for.
            search_type = "unescaped-variable";
        }
        else {
            // A normal variable is searched for.
            search_type = "normal-variable";
        }
    }
    return {
        search_text: search_text,
        search_type: search_type,
    };
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputWrapperSettingsModal extends SC_Modal {
    constructor(plugin, output_wrapper, 
    /** Can be undefined if the output wrapper is created from a place where there is no name element. */
    output_wrapper_name_setting, 
    /** If defined, a button will be added and on_after_approval() / on_after_cancelling() will be called depending on whether the button was clicked or not. */
    ok_button_text, on_after_approval, on_after_cancelling) {
        super(plugin);
        this.output_wrapper = output_wrapper;
        this.output_wrapper_name_setting = output_wrapper_name_setting;
        this.ok_button_text = ok_button_text;
        this.on_after_approval = on_after_approval;
        this.on_after_cancelling = on_after_cancelling;
        this.approved = false;
    }
    onOpen() {
        super.onOpen();
        const container_element = this.modalEl.createDiv();
        container_element.addClass("SC-setting-group"); // Make setting fields wider in this container.
        // Title
        const title_setting = new obsidian.Setting(container_element)
            .setName("Output wrapper title")
            .setDesc("Only used in settings, will not appear in output.")
            .addText(text => text
            .setValue(this.output_wrapper.getTitle())
            .onChange(async (new_title) => {
            this.output_wrapper.getConfiguration().title = new_title;
            await this.plugin.saveSettings();
            // Update the title in a name setting. (Only if the modal was created from a place where an OutputWrapper name element exists).
            this.output_wrapper_name_setting?.setName(new_title);
        }));
        const title_input_element = title_setting.controlEl.find("input");
        // Content
        const output_variable = new Variable_Output(this.plugin, ""); // For getting an autocomplete item.
        new obsidian.Setting(container_element)
            .setName("Content")
            .setDesc("Use {{output}} as a placeholder for text that will be received from a shell command. Other variables are available, too.")
            .addTextArea(textarea_component => textarea_component
            .setValue(this.output_wrapper.configuration.content)
            .onChange(async (new_content) => {
            this.output_wrapper.configuration.content = new_content;
            await this.plugin.saveSettings();
        })
            .then((textarea_component) => {
            // Autocomplete for Content.
            if (this.plugin.settings.show_autocomplete_menu) {
                createAutocomplete(this.plugin, textarea_component.inputEl, () => textarea_component.onChanged(), output_variable.getAutocompleteItems());
            }
        }));
        // Focus on the title field.
        title_input_element.focus();
        // Ok button
        if (this.ok_button_text) {
            new obsidian.Setting(container_element)
                .addButton(button => button
                .setButtonText(this.ok_button_text)
                .onClick(() => this.approve()));
        }
    }
    approve() {
        if (this.on_after_approval) {
            this.approved = true;
            this.on_after_approval();
        }
        this.close();
    }
    onClose() {
        super.onClose();
        // Call a cancelling hook if one is defined (and if the closing happens due to cancelling, i.e. the ok button is NOT clicked).
        if (!this.approved && this.on_after_cancelling) {
            this.on_after_cancelling();
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class OutputWrapperModel extends Model {
    constructor() {
        super(...arguments);
        this.output_wrappers = new OutputWrapperMap();
    }
    _createSettingFields(output_wrapper, container_element) {
        debugLog("Creating setting fields for an OutputWrapper instance.");
        const output_wrapper_name_setting = new obsidian.Setting(container_element)
            // Configuration button
            .setName(output_wrapper.getTitle())
            .addExtraButton(button => button
            .setTooltip("Define output wrapper content")
            .setIcon("gear")
            .onClick(() => {
            this.openSettingsModal(output_wrapper, output_wrapper_name_setting);
        }));
        return output_wrapper_name_setting;
    }
    defineParentConfigurationRelation(output_wrapper) {
        return {
            type: "one-to-many-id",
            key: "output_wrappers",
            id: output_wrapper.getID(),
        };
    }
    getSingularName() {
        return "Output wrapper";
    }
    loadInstances(parent_configuration) {
        debugLog("Loading OutputWrapper instances.");
        this.output_wrappers = new OutputWrapperMap();
        parent_configuration.output_wrappers.forEach((output_wrapper_configuration) => {
            const output_wrapper = new OutputWrapper(this, this.plugin, output_wrapper_configuration, parent_configuration);
            this.output_wrappers.set(output_wrapper_configuration.id, output_wrapper);
        });
        return this.output_wrappers;
    }
    newInstance(parent_configuration) {
        debugLog("Creating a new OutputWrapper instance.");
        // TODO: Move this logic to the base Model class.
        // Setup a default configuration and generate an ID
        const output_wrapper_configuration = this._getDefaultConfiguration();
        // Instantiate an OutputWrapper
        const output_wrapper = new OutputWrapper(this, this.plugin, output_wrapper_configuration, this.plugin.settings);
        this.output_wrappers.set(output_wrapper.getID(), output_wrapper);
        // Store the configuration into plugin's settings
        parent_configuration.output_wrappers.push(output_wrapper_configuration);
        // Return the OutputWrapper
        return output_wrapper;
    }
    validateValue(output_wrapper, field, value) {
        // No validation is needed, I guess. 'Title' and 'content' can both be empty, although an empty title does not make sense.
        return Promise.resolve(undefined);
    }
    openSettingsModal(output_wrapper, output_wrapper_name_setting) {
        debugLog("Opening settings modal for an OutputWrapper instance.");
        const modal = new OutputWrapperSettingsModal(this.plugin, output_wrapper, output_wrapper_name_setting);
        modal.open();
    }
    _getDefaultConfiguration() {
        return {
            id: getIDGenerator().generateID(),
            title: "",
            content: "",
        };
    }
    _deleteInstance(deletable_output_wrapper) {
        debugLog("Deleting an OutputWrapper instance.");
        // Remove the OutputWrapper from all TShellCommands that use it.
        const shell_commands = this.plugin.getTShellCommands();
        for (const shell_command_id in shell_commands) {
            const t_shell_command = shell_commands[shell_command_id];
            const output_wrappers = t_shell_command.getConfiguration().output_wrappers;
            Object.each(output_wrappers, (output_wrapper_id, output_stream) => {
                if (output_wrapper_id === deletable_output_wrapper.getID()) {
                    // A shell command uses the output wrapper that is about to be deleted.
                    // Configure the shell command not to use any output wrapper.
                    output_wrappers[output_stream] = null;
                }
            });
        }
        // Remove the OutputWrapper from this class's internal list.
        this.output_wrappers.delete(deletable_output_wrapper.getID());
    }
}
class OutputWrapperMap extends Map {
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function introduceModels(plugin) {
    debugLog("Introducing models.");
    // Keep in alphabetical order, if possible.
    introduceModelClass(new CustomVariableModel(plugin));
    introduceModelClass(new PromptFieldModel(plugin));
    introduceModelClass(new PromptModel(plugin));
    introduceModelClass(new OutputWrapperModel(plugin));
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * This class serves as the actual operational variable class for custom variables. It's paired with the CustomVariableInstance class, which acts
 * as a configuration class to handle settings together with CustomVariableModel class.
 */
class CustomVariable extends Variable {
    constructor(plugin, custom_variable_instance) {
        super(plugin);
        this.custom_variable_instance = custom_variable_instance;
        this.value = null; // TODO: When implementing variable types, make this class abstract and let subclasses define the type of this property.
        this.always_available = false;
        this.on_change_callbacks = new Set();
        this.updateProperties();
        debugLog(`Loaded CustomVariable ${this.variable_name}.`);
    }
    generateValue() {
        return new Promise((resolve) => {
            if (null === this.value) {
                debugLog(`Custom variable ${this.variable_name} does not have a value yet, and no default value is defined.`);
                this.newErrorMessage("This custom variable does not have a value yet, and no default value is defined.");
                return resolve(null);
            }
            return resolve(this.value);
        });
    }
    /**
     * TODO: Make it possible to prevent calling onChange callbacks:
     *  - Make it possible to call the callbacks later outside this class.
     *  - This makes it possible to prevent unnecessary CustomVariableView updates when multiple CustomVariables are assigned values in one go (via Shell command URI).
     *  - Store the old value into some kind of history list.
     *  - When calling the callbacks, the current CustomVariable should be passed as a parameter instead of the 'value' and 'old_value' parameters (which can be accessed via the CustomVariable object).
     *
     * @param value
     */
    async setValue(value) {
        const old_value = this.value;
        debugLog(`CustomVariable ${this.variable_name}: Setting value to: ${value} (old was: ${old_value}).`);
        this.value = value;
        // Call the onChange hook.
        await this.callOnChangeCallbacks(value, old_value ?? ""); // Use "" if old_value is null.
    }
    /**
     * Retrieves variable_name and help_text properties from the associated CustomVariableInstance.
     * Called when loading the CustomVariable and when the associated CustomVariableInstance's settings are changed.
     */
    updateProperties() {
        debugLog(`CustomVariable ${this.variable_name}: Updating variable name and help text.`);
        this.variable_name = this.custom_variable_instance.getPrefixedName();
        this.help_text = this.custom_variable_instance.configuration.description;
        resetVariableAutocompleteItems(); // Make autocomplete lists reload their content in order to get the new variable name/help text.
    }
    getIdentifier() {
        return this.custom_variable_instance.getID();
    }
    /**
     * Adds the given callback function to a stack of functions that will be called whenever this CustomVariable's value changes.
     * @param on_change_callback
     */
    onChange(on_change_callback) {
        this.on_change_callbacks.add(on_change_callback);
    }
    async callOnChangeCallbacks(new_value, old_value) {
        debugLog(`CustomVariable ${this.variable_name}: Calling onChange callbacks.`);
        for (const on_change_callback of this.on_change_callbacks) {
            await on_change_callback(this, new_value, old_value);
        }
    }
    /**
     * Returns true if the CustomVariable has an assigned value.
     */
    isAvailable() {
        return null !== this.value;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * This class serves as an accessor to CustomVariable configurations. It's paired with the CustomVariable class, which acts
 * as an operational class to implement the variable functionality.
 *
 * TODO: Decide a better name for this class. It's too easy to confuse with the CustomVariable class name.
 */
class CustomVariableInstance extends Instance {
    constructor(model, configuration, parent_configuration) {
        super(model, configuration, parent_configuration);
        this.model = model;
        this.custom_variable = null;
        // Introduce the ID to an ID generator so that it won't accidentally generate the same ID again when creating new CustomVariableInstances.
        getIDGenerator().addReservedID(configuration.id);
        debugLog(`Loaded CustomVariableInstance ${this.getID()}.`);
    }
    getID() {
        return this.configuration.id;
    }
    getFullName() {
        return `{{${this.getPrefixedName()}}}`;
    }
    /**
     * Adds an underscore in front of the name.
     */
    getPrefixedName() {
        return "_" + this.configuration.name;
    }
    getTitle() {
        return this.getFullName();
    }
    getCustomVariable() {
        if (!this.custom_variable) {
            debugLog(`CustomVariableInstance ${this.getID()}: Cannot find a CustomVariable. Maybe it's not loaded?`);
            throw new Error(this.constructor.name + ".getVariable(): Cannot find a CustomVariable. Maybe it's not loaded?");
        }
        return this.custom_variable;
    }
    createCustomVariable() {
        debugLog(`CustomVariableInstance ${this.getID()}: Creating an operational CustomVariable.`);
        this.custom_variable = new CustomVariable(this.model.plugin, this);
        this.custom_variable.onChange(async () => await this.model.plugin.updateCustomVariableViews());
        return this.custom_variable;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class CustomVariableModel extends Model {
    getSingularName() {
        return "Custom variable";
    }
    defineParentConfigurationRelation(custom_variable_instance) {
        debugLog(`CustomVariableModel: Defining parent configuration relation for CustomVariableInstance ${custom_variable_instance.getID()}.`);
        return {
            type: "one-to-many-id",
            key: "custom_variables",
            id: custom_variable_instance.getID(),
        };
    }
    loadInstances(parent_configuration) {
        debugLog(`CustomVariableModel: Loading CustomVariableInstances.`);
        this.custom_variable_instances = new CustomVariableInstanceMap;
        parent_configuration.custom_variables.forEach((custom_variable_configuration) => {
            this.custom_variable_instances.set(custom_variable_configuration.id, new CustomVariableInstance(this, custom_variable_configuration, parent_configuration));
        });
        return this.custom_variable_instances;
    }
    newInstance(parent_configuration) {
        debugLog(`CustomVariableModel: Creating a new CustomVariableInstance.`);
        // Create a default configuration object
        const custom_variable_configuration = this._getDefaultConfiguration();
        parent_configuration.custom_variables.push(custom_variable_configuration);
        // Create a CustomVariableInstance for handling the configuration
        const custom_variable_instance = new CustomVariableInstance(this, custom_variable_configuration, parent_configuration);
        this.custom_variable_instances.set(custom_variable_configuration.id, custom_variable_instance);
        // Create an operational variable.
        this.plugin.getVariables().add(custom_variable_instance.createCustomVariable());
        return custom_variable_instance;
        // TODO: Move this logic to the base Model class.
    }
    _createSettingFields(instance, container_element) {
        debugLog(`CustomVariableModel: Creating setting fields for CustomVariableInstance ${instance.getID()}.`);
        // Make the fields appear closer together.
        container_element.addClass("SC-setting-group");
        // Heading setting
        const heading_setting = new obsidian.Setting(container_element)
            .setName(instance.getFullName())
            .setHeading();
        // Name setting
        new obsidian.Setting(container_element)
            .setName("Variable name")
            .setDesc("Must contain at least one character. Allowed characters are letters a-z, numbers 0-9 and an underscore _")
            .setClass("SC-custom-variable-name-setting")
            .addText(text => text
            .setValue(instance.configuration.name)
            .onChange((new_name) => {
            // TODO: Find a way to create this kind of trivial onChange() functions in the Model base class.
            instance.setIfValid("name", new_name).then(async () => {
                // Valid
                heading_setting.setName(instance.getFullName()); // Also removes a possible warning message.
                instance.getCustomVariable().updateProperties(); // Update the name also to the operational variable, not only in configuration.
                await this.plugin.saveSettings();
                await this.plugin.updateCustomVariableViews();
            }, (reason) => {
                // Not valid
                if (typeof reason === "string") {
                    // This is a validation error message.
                    // Display a warning message.
                    heading_setting.setName(reason + " The name was not saved.");
                }
                else {
                    // Some other runtime error has occurred.
                    throw reason;
                }
            });
        }));
        // Description setting
        new obsidian.Setting(container_element)
            .setName("Description")
            .setDesc("Appears in autocomplete lists along with the variable name, and also in the 'Custom variables' pane, if you use it.")
            .addText(text => text
            .setValue(instance.configuration.description)
            .onChange(async (new_description) => {
            // TODO: Find a way to create this kind of trivial onChange() functions in the Model base class.
            instance.configuration.description = new_description;
            instance.getCustomVariable().updateProperties(); // Update the description also to the operational variable, not only in configuration.
            await this.plugin.saveSettings();
            await this.plugin.updateCustomVariableViews();
        }));
        return heading_setting;
    }
    validateValue(custom_variable_instance, field, custom_variable_name) {
        debugLog(`CustomVariableModel: Validating ${field} value ${custom_variable_name} for CustomVariableInstance ${custom_variable_instance.getID()}.`);
        return new Promise((resolve, reject) => {
            switch (field) {
                case "name":
                    // Check that the name contains only characters a-z, 0-9 and/or underline _
                    if (!custom_variable_name.match(/^[\w\d]+$/u)) {
                        // Incorrect format.
                        reject(`The name {{_${custom_variable_name}}} does not meet the naming requirements.`);
                        return;
                    }
                    // Check if the name is a duplicate.
                    if (this.isCustomVariableNameDuplicate(custom_variable_name, custom_variable_instance)) {
                        // It's a duplicate.
                        reject(`The name {{_${custom_variable_name}}} is already reserved.`);
                    }
                    else {
                        // It's unique.
                        resolve();
                    }
                    return;
                default:
                    // Other fields do not need validation.
                    resolve();
                    return;
            }
        });
    }
    _getDefaultConfiguration() {
        // Generate a unique name for the variable by using a sequential number.
        let sequential_number = 1;
        while (this.isCustomVariableNameDuplicate(String(sequential_number))) {
            sequential_number++;
        }
        // Create a configuration object.
        return {
            id: getIDGenerator().generateID(),
            name: String(sequential_number),
            description: "",
        };
    }
    async _deleteInstance(custom_variable_instance) {
        debugLog(`CustomVariableModel: Deleting CustomVariableInstance ${custom_variable_instance.getID()}.`);
        // Remove the CustomVariableInstance from all PromptFields that use it.
        for (const prompt of this.plugin.getPrompts().values()) {
            for (const prompt_field of prompt.prompt_fields) {
                if (custom_variable_instance.getID() === prompt_field.configuration.target_variable_id) {
                    // This prompt field uses this CustomVariableInstance.
                    // Remove the variable from use.
                    prompt_field.configuration.target_variable_id = "";
                    // Saving is done later, after the _deleteInstance() call.
                }
            }
        }
        // Delete CustomVariable
        try {
            this.plugin.getVariables().delete(custom_variable_instance.getCustomVariable());
        }
        catch (error) {
            // If custom_variable_instance.getCustomVariable() failed, no need to do anything. It just means there is no CustomVariable, so there's nothing to delete.
        }
        // Delete CustomVariableInstance
        this.custom_variable_instances.delete(custom_variable_instance.getID());
        // remove the variable from custom variable side panes.
        await this.plugin.updateCustomVariableViews();
    }
    /**
     * Can be changed to public if needed.
     */
    isCustomVariableNameDuplicate(custom_variable_name, ignore_custom_variable_instance) {
        let is_duplicate = false;
        this.custom_variable_instances.forEach((custom_variable2_instance, custom_variable_id) => {
            // First check can the current custom variable attend to the duplicate test.
            if (ignore_custom_variable_instance && custom_variable_id === ignore_custom_variable_instance.getID()) {
                // Don't check this instance. This skipping is used for the current owner of the name.
                return;
            }
            // Now do the actual duplicate test.
            if (custom_variable_name.toLocaleLowerCase() === custom_variable2_instance.configuration.name.toLocaleLowerCase()) {
                is_duplicate = true;
            }
        });
        return is_duplicate;
    }
}
class CustomVariableInstanceMap extends Map {
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class CustomVariableSettingsModal extends SC_Modal {
    constructor(plugin, custom_variable_instance, on_after_creation, on_after_cancelling) {
        super(plugin);
        this.custom_variable_instance = custom_variable_instance;
        this.on_after_creation = on_after_creation;
        this.on_after_cancelling = on_after_cancelling;
        this.created = false;
    }
    onOpen() {
        super.onOpen();
        const model = getModel(CustomVariableModel.name);
        model.createSettingFields(this.custom_variable_instance, this.modalEl, false);
        new obsidian.Setting(this.modalEl)
            .addButton(button => button
            .setButtonText("Create")
            .onClick(() => this.approve()));
    }
    approve() {
        this.created = true;
        this.on_after_creation();
        this.close();
    }
    onClose() {
        super.onClose();
        if (!this.created) {
            this.on_after_cancelling();
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class CustomVariableView extends obsidian.ItemView {
    constructor(plugin, leaf) {
        super(leaf);
        this.plugin = plugin;
    }
    getDisplayText() {
        return "Custom variables";
    }
    getViewType() {
        return CustomVariableView.ViewType;
    }
    getIcon() {
        return "code-glyph";
    }
    async onOpen() {
        this.container_element = this.containerEl.children[1].createDiv(); // I don't know why I cannot create elements directly under this.containerEl (they wouldn't show up). I did the same thing as was done here: https://marcus.se.net/obsidian-plugin-docs/guides/custom-views (referenced 2022-03-23).
        this.container_element.addClass("container");
        await this.updateContent();
    }
    async updateContent() {
        this.container_element.empty();
        this.container_element.createEl("h3", { text: "Custom variables" });
        for (const custom_variable_instance of this.plugin.getCustomVariableInstances().values()) {
            let custom_variable_value = (await custom_variable_instance.getCustomVariable().getValue()).value;
            let emphasize = false;
            if (null === custom_variable_value) {
                custom_variable_value = "No value yet.";
                emphasize = true;
            }
            else if ("" === custom_variable_value) {
                custom_variable_value = "An empty text.";
                emphasize = true;
            }
            const variable_list_element = this.container_element.createEl("ul");
            const variable_list_item_element = variable_list_element.createEl("li", {
                text: custom_variable_instance.getFullName(),
                attr: {
                    "aria-label": custom_variable_instance.configuration.description,
                },
            });
            variable_list_item_element.createEl("br");
            let variable_list_item_element_child;
            if (emphasize) {
                variable_list_item_element_child = variable_list_item_element.createEl("em");
            }
            else {
                // Bold normal values to make them more prominent in contrast to variable names and "No value yet."/"An empty text." texts.
                variable_list_item_element_child = variable_list_item_element.createEl("strong");
            }
            variable_list_item_element_child.insertAdjacentText("beforeend", custom_variable_value);
        }
    }
}
CustomVariableView.ViewType = "SC-custom-variables-view";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Preaction {
    constructor(plugin, configuration, t_shell_command) {
        this.plugin = plugin;
        this.configuration = configuration;
        this.t_shell_command = t_shell_command;
    }
    /**
     * Maybe this wrapper method is unneeded, but have it for a while at least.
     */
    perform(parsing_process, sc_event) {
        return this.doPreaction(parsing_process, sc_event);
    }
    /**
     * Returns variables that are dependent of this Preaction, i.e. variables whose value is set by this Preaction.
     * If a variable is READ by a Preaction, it is NOT considered to be _dependent_ of the Preaction, as long as the variable's
     * value is not changed by the Preaction.
     *
     * By default, it returns an empty VariableSet, because not all Preactions will use variables at all.
     */
    getDependentVariables() {
        return new VariableSet();
    }
}
function createPreaction(plugin, preaction_configuration, t_shell_command) {
    switch (preaction_configuration.type) {
        case "prompt":
            return new Preaction_Prompt(plugin, preaction_configuration, t_shell_command);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Preaction_Prompt extends Preaction {
    constructor(plugin, configuration, t_shell_command) {
        super(plugin, configuration, t_shell_command);
        this.configuration = configuration;
    }
    doPreaction(parsing_process, sc_event) {
        // TODO: Now that doPreaction() returns a similar Promise as is received from openPrompt(), consider just returning the same Promise instead of creating a new one.
        return new Promise((resolve) => {
            this.getPrompt().openPrompt(this.t_shell_command, parsing_process, sc_event).then((execution_confirmed) => {
                // The PromptModal has been closed.
                // Check if user wanted to execute the shell command or cancel.
                if (execution_confirmed) {
                    // User wants to execute.
                    resolve(true);
                }
                else {
                    // User wants to cancel.
                    resolve(false);
                }
            });
        });
    }
    /**
     * Returns all the CustomVariables whose values this Preaction's Prompt sets.
     */
    getDependentVariables() {
        const variables = new VariableSet();
        for (const prompt_field of this.getPrompt().prompt_fields) {
            // Check that the PromptField has a target variable defined. Otherwise getTargetVariable() would cause a crash.
            if ("" !== prompt_field.configuration.target_variable_id) {
                variables.add(prompt_field.getTargetVariable());
            }
        }
        return variables;
    }
    /**
     * TODO: Remove.
     */
    getDefaultConfiguration() {
        return {
            type: "prompt",
            enabled: false,
            prompt_id: "",
        };
    }
    getPrompt() {
        return this.plugin.getPrompts().get(this.configuration.prompt_id);
    }
}
function getDefaultPreaction_Prompt_Configuration() {
    return {
        type: "prompt",
        enabled: false,
        prompt_id: "",
    };
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PromptField extends Instance {
    constructor(model, prompt, configuration, prompt_field_index) {
        super(model, configuration, prompt.configuration);
        this.model = model;
        this.prompt = prompt;
        this.configuration = configuration;
        this.prompt_field_index = prompt_field_index;
        this.parsing_errors = [];
    }
    /**
     *
     * @param container_element
     * @param t_shell_command
     * @param sc_event Used when parsing variables for default_value and the inputted value. Needed so that also {{event_*}} variables can be used in prompts.
     */
    async createField(container_element, t_shell_command, sc_event) {
        await this._createField(container_element, t_shell_command, sc_event);
        // Create a preview setting element. It will not contain any actual setting elements, just text.
        this.preview_setting = new obsidian.Setting(container_element);
        // Parse variables in the default value and insert it to the field.
        // Note that this is a different "default value" than what TShellCommand considers as variables' default values! This is about a _field's_ default value, not a variable's default value. t_shell_command is passed in order to allow any possible variables in the field's default value to access the variables' default values (which come from TShellCommand).
        await this.applyDefaultValue(t_shell_command, sc_event);
    }
    getTitle() {
        return this.configuration.label === "" ? "Unlabelled field" : this.configuration.label;
    }
    /**
     * Parses the default value and sets it to the form element.
     * @param t_shell_command
     * @param sc_event
     * @private
     */
    async applyDefaultValue(t_shell_command, sc_event) {
        const default_value = this.configuration.default_value;
        const parsing_result = await parseVariables(this.prompt.model.plugin, default_value, null, t_shell_command, sc_event);
        if (!parsing_result.succeeded) {
            // Parsing failed.
            this.setValue(default_value); // Use the unparsed value. If default value contains a variable that cannot be parsed, a user can see the variable in the prompt modal and either fix it or change it to something else.
        }
        else {
            // Parsing succeeded.
            this.setValue(parsing_result.parsed_content);
        }
        await this.valueHasChanged(t_shell_command, sc_event);
    }
    getParsedValue() {
        return this.parsed_value;
    }
    getParsingErrors() {
        return this.parsing_errors;
    }
    /**
     * Updates this.parsed_value, this.parsing_errors and this.preview_setting .
     *
     * @param t_shell_command
     * @param sc_event
     * @protected
     */
    async valueHasChanged(t_shell_command, sc_event) {
        let preview;
        // Parse variables in the value.
        const parsing_result = await parseVariables(this.prompt.model.plugin, this.getValue(), null, t_shell_command, sc_event);
        if (!parsing_result.succeeded) {
            // Parsing failed.
            this.parsed_value = null;
            if (parsing_result.error_messages.length > 0) {
                // Display the first error message. If there are more, others can be omitted.
                preview = parsing_result.error_messages[0];
            }
            else {
                // If there are no error messages, then errors are silently ignored by user's variable configuration, in which case just show the original content.
                preview = parsing_result.original_content;
            }
            this.parsing_errors = parsing_result.error_messages;
        }
        else {
            // Parsing succeeded
            this.parsed_value = parsing_result.parsed_content;
            preview = parsing_result.parsed_content;
            this.parsing_errors = []; // No errors.
        }
        // Update the preview element.
        if (0 === parsing_result.count_parsed_variables) {
            // If no variables were used, hide the description as it's not needed to repeat the value that already shows up in the form field.
            preview = "";
        }
        this.preview_setting.setDesc(preview);
        // Call a possible external callback
        if (this.on_change_callback) {
            this.on_change_callback();
        }
    }
    /**
     * @param on_change_callback A callback that will be called whenever the field's value is changed.
     */
    onChange(on_change_callback) {
        this.on_change_callback = on_change_callback;
    }
    /**
     * @param on_focus_callback A callback that will be called whenever the field is focused.
     */
    onFocus(on_focus_callback) {
        this.on_focus_callback = on_focus_callback;
    }
    /**
     * Should be called by the subclass when the field has gotten focus.
     */
    hasGottenFocus() {
        if (this.on_focus_callback) {
            this.on_focus_callback(this);
        }
    }
    /**
     * Ensures that the field is filled, if it's mandatory. If the field is not mandatory, it's always valid.
     *
     * @return True when valid, false when not valid.
     */
    validate() {
        if (!this.configuration.required) {
            // No need to validate, because the field is not mandatory.
            return true;
        }
        // Ensure the field is filled
        return this.isFilled();
    }
    getTargetVariableInstance() {
        const target_variable_id = this.configuration.target_variable_id;
        const custom_variable_instance = this.prompt.model.plugin.getCustomVariableInstances().get(target_variable_id);
        if (!custom_variable_instance) {
            throw new Error(this.constructor.name + ".getTargetVariableInstance(): CustomVariableInstance with ID '" + target_variable_id + "' was not found");
        }
        return custom_variable_instance;
    }
    getTargetVariable() {
        const custom_variable_instance = this.getTargetVariableInstance();
        return custom_variable_instance.getCustomVariable();
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PromptFieldModel extends Model {
    getSingularName() {
        return "Field";
    }
    defineParentConfigurationRelation(prompt_field) {
        return {
            type: "one-to-many-index",
            key: "fields",
            index: prompt_field.prompt_field_index,
        };
    }
    loadInstances(prompt) {
        const prompt_fields = new PromptFieldSet;
        prompt.configuration.fields.forEach((field_configuration, index) => {
            prompt_fields.add(this.createInstance(prompt, field_configuration, index));
        });
        return prompt_fields;
    }
    newInstance(prompt) {
        // TODO: Move this logic to the base Model class.
        // Setup a default configuration
        const prompt_field_configuration = this._getDefaultConfiguration();
        // Instantiate a PromptField
        const prompt_field = this.createInstance(prompt, prompt_field_configuration, prompt.configuration.fields.length);
        // Store the configuration into the prompt's configuration
        prompt.configuration.fields.push(prompt_field_configuration);
        // Store the PromptField instance into its parent Prompt's list of fields.
        prompt.prompt_fields.add(prompt_field);
        // Return the PromptField
        return prompt_field;
    }
    createInstance(prompt, prompt_field_configuration, prompt_field_index) {
        // TODO: When the 'type' field gets implemented on PromptFieldConfiguration, implement some kind of switch structure here to create different types of PromptFields.
        return new PromptField_Text(this, prompt, prompt_field_configuration, prompt_field_index);
    }
    _createSettingFields(prompt_field, container_element) {
        const label_placeholders = [
            "What is your name?",
            "How big is the universe?",
            "How long is eternity?",
            "What is your lucky number?",
            "What is your favorite song?",
            "What is your favorite color?",
            "How many books have you read?",
            "What is the purpose of life?",
        ];
        const default_value_placeholders = [
            ["Bond, James Bond", "John Doe", "Jane Doe", "Mr. Bean"],
            ["Very big, and still expanding", "93 billion light-years"],
            ["Infinite", "Too long to wait for"],
            [String(randomInteger(0, 9)), "I don't have one"],
            ["We are the world (USA for Africa)", "Heal the world (Michael Jackson)", "Imagine (John Lennon)", "Circle of life (Elton John)"],
            ["Blue as deep as an ocean", "Red as love", "Grass-green", "Snow-white"],
            ["Thousands", "Many", "Countless", "None"],
            ["Thinking", "Being a being", "42"],
        ];
        const label_placeholder_index = randomInteger(0, label_placeholders.length - 1);
        const default_value_placeholders_subset = default_value_placeholders[label_placeholder_index];
        // Create a list of custom variables
        const custom_variable_options = {};
        this.plugin.getCustomVariableInstances().forEach((custom_variable_instance, custom_variable_id) => {
            custom_variable_options[custom_variable_id] = custom_variable_instance.getFullName();
        });
        const on_default_value_setting_change = async (new_default_value) => {
            prompt_field.configuration.default_value = new_default_value;
            await this.plugin.saveSettings();
        };
        // Create the setting fields
        const setting_group_element = container_element.createDiv({ attr: { class: "SC-setting-group" } });
        let label_setting_component;
        let description_setting_component;
        const setting_group = {
            heading_setting: new obsidian.Setting(setting_group_element)
                .setName("") // This will be set down below.
                .setHeading(),
            label_setting: new obsidian.Setting(setting_group_element)
                .setName("Field label")
                .addText(text => label_setting_component = text
                .setValue(prompt_field.configuration.label)
                .setPlaceholder(label_placeholders[label_placeholder_index])
                .onChange(async (new_label) => {
                prompt_field.configuration.label = new_label;
                _update_heading();
                await this.plugin.saveSettings();
            })),
            default_value_setting: new obsidian.Setting(setting_group_element)
                .setName("Default value")
                .addText(text => text
                .setValue(prompt_field.configuration.default_value)
                .setPlaceholder(prompt_field.configuration.label ? "" // If the label is defined, do not add a placeholder here, as the label's placeholder is not visible, so this placeholder would not make sense.
                : default_value_placeholders_subset[randomInteger(0, default_value_placeholders_subset.length - 1)])
                .onChange(on_default_value_setting_change)),
            description_setting: new obsidian.Setting(setting_group_element)
                .setName("Description")
                .addText(text => description_setting_component = text
                .setValue(prompt_field.configuration.description)
                .onChange(async (new_description) => {
                prompt_field.configuration.description = new_description;
                await this.plugin.saveSettings();
            })),
            target_variable_setting: new obsidian.Setting(setting_group_element)
                .setName("Target variable")
                .setDesc("Where the inputted value will be stored in. You can use the variable in a shell command.")
                .addDropdown(dropdown => dropdown
                .addOption("", "") // An option for a situation when nothing is selected.
                .addOptions(custom_variable_options)
                .addOption("new", "Create a new custom variable")
                .setValue(prompt_field.configuration.target_variable_id)
                .onChange((new_target_variable_id) => {
                if ("new" === new_target_variable_id) {
                    // Create a new custom variable.
                    const model = getModel(CustomVariableModel.name);
                    const custom_variable_instance = model.newInstance(this.plugin.settings);
                    this.plugin.saveSettings().then(() => {
                        const modal = new CustomVariableSettingsModal(this.plugin, custom_variable_instance, async () => {
                            // Variable is created.
                            dropdown.addOption(custom_variable_instance.getID(), custom_variable_instance.getTitle());
                            dropdown.setValue(custom_variable_instance.getID());
                            prompt_field.configuration.target_variable_id = custom_variable_instance.getID();
                            await this.plugin.saveSettings();
                        }, async () => {
                            dropdown.setValue(prompt_field.configuration.target_variable_id); // Reset the dropdown selection.
                            // Variable creation was cancelled.
                            model.deleteInstance(custom_variable_instance);
                            await this.plugin.saveSettings();
                        });
                        modal.open();
                    });
                }
                else {
                    // Use an existing target variable (or an empty id "").
                    // Check that this target variable is not reserved.
                    prompt_field.setIfValid("target_variable_id", new_target_variable_id).then(async () => {
                        // It can be used.
                        await this.plugin.saveSettings();
                    }, (error_message) => {
                        if (typeof error_message === "string") {
                            // This is a validation error message.
                            // The target variable is reserved.
                            dropdown.setValue(prompt_field.configuration.target_variable_id); // Reset the dropdown selection.
                            this.plugin.newNotification(error_message);
                        }
                        else {
                            // Some other runtime error has occurred.
                            throw error_message;
                        }
                    });
                }
            })),
            required_setting: new obsidian.Setting(setting_group_element)
                .setName("Is required")
                .setDesc("If on, the field needs to be filled before the prompt can be submitted.")
                .addToggle(toggle => toggle
                .setValue(prompt_field.configuration.required)
                .onChange(async (new_required) => {
                prompt_field.configuration.required = new_required;
                await this.plugin.saveSettings();
            })),
        };
        _update_heading();
        function _update_heading() {
            setting_group.heading_setting.setName(prompt_field.getTitle());
        }
        // Autocomplete menu
        if (this.plugin.settings.show_autocomplete_menu) {
            // Show autocomplete menu (= a list of available variables).
            const label_input_element = setting_group.label_setting.controlEl.find("input");
            createAutocomplete(this.plugin, label_input_element, () => label_setting_component.onChanged());
            const default_value_input_element = setting_group.default_value_setting.controlEl.find("input");
            createAutocomplete(this.plugin, default_value_input_element, on_default_value_setting_change);
            const description_input_element = setting_group.description_setting.controlEl.find("input");
            createAutocomplete(this.plugin, description_input_element, () => description_setting_component.onChanged());
        }
        return setting_group.heading_setting;
    }
    validateValue(prompt_field, field, value) {
        switch (field) {
            case "target_variable_id": {
                const new_target_variable_id = value; // A more descriptive name for 'value'.
                // Always allow an empty target_variable_id. A Prompt cannot be opened if a field lacks a target_variable_id, but it's allowed to be stored in the configuration, because new Prompts cannot have a default selected target variable.
                if ("" === new_target_variable_id) {
                    return Promise.resolve();
                }
                // Check that the target variable is not used by other fields of the same Prompt.
                for (const other_prompt_field of prompt_field.prompt.prompt_fields) {
                    if (prompt_field !== other_prompt_field) { // Do not check the same field. Only check other fields.
                        // Check if this other field has the same target variable.
                        if (new_target_variable_id === other_prompt_field.configuration.target_variable_id) {
                            // They have the same target_variable_id.
                            // Return an error message.
                            const target_variable_name = this.plugin.getCustomVariableInstances().get(new_target_variable_id).getFullName();
                            return Promise.reject(`Target variable ${target_variable_name} is already used by another field in the same prompt. Select another variable.`);
                        }
                    }
                }
                // All fields have been checked and no collisions were found.
                return Promise.resolve();
            }
            default: {
                // No validation for other fields.
                throw new Error(this.constructor.name + ".validateValue(): No validation is implemented for other fields.");
            }
        }
    }
    _getDefaultConfiguration() {
        return {
            // type: "text",
            label: "",
            description: "",
            default_value: "",
            //  TODO: Add 'placeholder'.
            target_variable_id: "",
            required: true,
        };
    }
    _deleteInstance(prompt_field) {
        prompt_field.prompt.prompt_fields.delete(prompt_field);
    }
}
class PromptFieldSet extends Set {
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PromptField_Text extends PromptField {
    async _createField(container_element, t_shell_command, sc_event) {
        const plugin = this.prompt.model.plugin;
        // Create the field
        const on_change = () => this.valueHasChanged(t_shell_command, sc_event);
        const label_parsing_result = await parseVariables(this.prompt.model.plugin, this.configuration.label, null, t_shell_command, sc_event);
        const description_parsing_result = await parseVariables(this.prompt.model.plugin, this.configuration.description, null, t_shell_command, sc_event);
        const setting = new obsidian.Setting(container_element)
            .setName(label_parsing_result.succeeded ? label_parsing_result.parsed_content : label_parsing_result.original_content)
            .setDesc(description_parsing_result.succeeded ? description_parsing_result.parsed_content : description_parsing_result.original_content)
            .addText((text_component) => {
            this.text_component = text_component;
            text_component.onChange(on_change);
        });
        // Set up onFocus hook.
        this.text_component.inputEl.onfocus = () => {
            this.hasGottenFocus();
        };
        // Show autocomplete menu (if enabled)
        if (plugin.settings.show_autocomplete_menu) {
            const input_element = setting.controlEl.find("input");
            createAutocomplete(plugin, input_element, on_change);
        }
    }
    setValue(value) {
        this.text_component.setValue(value);
    }
    getValue() {
        return this.text_component.getValue();
    }
    setFocus() {
        this.text_component.inputEl.focus();
    }
    isFilled() {
        return this.getValue().length > 0;
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class Prompt extends Instance {
    constructor(model, plugin, configuration, parent_configuration) {
        super(model, configuration, parent_configuration);
        this.model = model;
        this.plugin = plugin;
        this.configuration = configuration;
        this.parent_configuration = parent_configuration;
        this.prompt_fields = new PromptFieldSet();
        // Introduce the ID to an ID generator so that it won't accidentally generate the same ID again when creating new Prompts.
        getIDGenerator().addReservedID(configuration.id);
        this.createFields();
    }
    getID() {
        return this.configuration.id;
    }
    getTitle() {
        return this.configuration.title;
    }
    getConfiguration() {
        return this.configuration;
    }
    getCSSClass() {
        return Prompt.getCSSBaseClass() + "-" + this.getID();
    }
    static getCSSBaseClass() {
        return "SC-prompt-modal";
    }
    getCSSClasses() {
        return [
            Prompt.getCSSBaseClass(),
            this.getCSSClass(),
        ];
    }
    /**
     * @param t_shell_command Can be null, if wanted to just preview the Prompt modal without really executing a shell command. Inputted values will still be assigned to target variables.
     * @param parsing_process
     * @param sc_event
     * @return Promise The boolean value tells whether the user wants to execute a shell command (true) or cancel (false).
     */
    openPrompt(t_shell_command, parsing_process, sc_event) {
        const can_open_prompt_result = this.canOpenPrompt();
        if (true !== can_open_prompt_result) {
            // Some error is preventing opening the prompt.
            // A human-readable error message is contained in can_open_prompt_result.
            debugLog("Could not open Prompt " + this.getID() + " because of error: " + can_open_prompt_result);
            this.plugin.newError(can_open_prompt_result);
            return Promise.resolve(false); // false: Cancel execution (pretends that a user cancelled it, but it's ok).
        }
        debugLog("Opening Prompt " + this.getID());
        const modal = new PromptModal(this.plugin, this.prompt_fields, t_shell_command, parsing_process, this, sc_event, () => { return this.validateFields(); });
        modal.open();
        return modal.promise;
    }
    canOpenPrompt() {
        // Check that all PromptFields have a target variable defined.
        for (const prompt_field of this.prompt_fields) {
            if (!prompt_field.configuration.target_variable_id) {
                return `Cannot open prompt '${this.getTitle()}': Field '${prompt_field.getTitle()}' does not have a target variable.`;
            }
            else {
                try {
                    prompt_field.getTargetVariableInstance(); // Just try to get a CustomVariableInstance. No need to use it here, but if this fails, we know the variable is removed.
                }
                catch (error) {
                    return `Cannot open prompt '${this.getTitle()}': Field '${prompt_field.getTitle()}' uses a target variable which does not exist anymore.`;
                }
            }
        }
        // All ok.
        return true;
    }
    /**
     * Creates PromptField instances, NOT setting fields!
     */
    createFields() {
        debugLog("Creating fields for Prompt " + this.getID());
        const prompt_field_model = getModel(PromptFieldModel.name);
        this.prompt_fields = prompt_field_model.loadInstances(this);
    }
    /**
     * Validates values in PromptField instances, NOT setting fields!
     */
    validateFields() {
        debugLog("Validating fields for Prompt " + this.getID());
        // Iterate all fields and check their validity.
        const error_messages = [];
        this.prompt_fields.forEach((prompt_field) => {
            // Check if the field has parsing errors.
            const parsing_errors = prompt_field.getParsingErrors();
            for (const parsing_error of parsing_errors) {
                // This field has parsing error(s).
                error_messages.push(`'${prompt_field.getTitle()}': ` + parsing_error);
            }
            // Check other validity.
            if (!prompt_field.validate()) {
                // This field failed to validate.
                // TODO: Change this so that the message will come from prompt_field.validate().
                error_messages.push(`'${prompt_field.getTitle()}' needs to be filled.`);
            }
        });
        // Return the result.
        if (0 === error_messages.length) {
            return Promise.resolve();
        }
        else {
            return Promise.reject(error_messages);
        }
    }
    /**
     * When previewing a PromptModal, there is no real shell command available (because no shell command has triggered the
     * PromptModal). This method creates just a dummy shell command string that imitates a command that would echo variable values.
     */
    getExampleShellCommand() {
        const variable_names = [];
        for (const prompt_field of this.prompt_fields) {
            variable_names.push(prompt_field.getTargetVariableInstance().getFullName());
        }
        return "echo " + variable_names.join(" ");
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PromptModal extends SC_Modal {
    constructor(plugin, prompt_fields, 
    /** Can be null, if wanted to just preview the Prompt modal without really executing a shell command. Inputted values will still be assigned to target variables. */
    t_shell_command, parsing_process, prompt, sc_event, 
    /** A function that is called when a user clicks the execution button. This function should check the form elements' validity and return false if there are unfilled fields. */
    validator) {
        super(plugin);
        this.prompt_fields = prompt_fields;
        this.t_shell_command = t_shell_command;
        this.parsing_process = parsing_process;
        this.prompt = prompt;
        this.sc_event = sc_event;
        this.validator = validator;
        this.user_confirmed_ok = false;
        this.promise = new Promise((resolve) => {
            this.resolve_promise = resolve;
        });
    }
    async onOpen() {
        super.onOpen();
        // Parse and display title
        const title_parsing_result = await parseVariables(this.plugin, this.prompt.getTitle(), null, this.t_shell_command, this.sc_event);
        this.setTitle(title_parsing_result.succeeded
            ? title_parsing_result.parsed_content
            : title_parsing_result.original_content);
        // Parse and display description
        if (this.prompt.configuration.description) {
            const description_parsing_result = await parseVariables(this.plugin, this.prompt.configuration.description, null, this.t_shell_command, this.sc_event);
            const description = description_parsing_result.succeeded
                ? description_parsing_result.parsed_content
                : description_parsing_result.original_content;
            const description_element = createMultilineTextElement("p", description, this.modalEl);
            description_element.addClass("setting-item-description"); // A CSS class defined by Obsidian.
        }
        // Preview the shell command (if wanted)
        // TODO: Extract to a separate method, as this is a big block of code.
        let update_shell_command_preview = null; // Stays null if .preview_shell_command is false.
        let focused_prompt_field;
        if (this.prompt.getConfiguration().preview_shell_command) {
            let shell_command_preview_text;
            if (this.t_shell_command?.getAlias()) {
                this.modalEl.createEl("p", { text: this.t_shell_command.getAlias(), attr: { class: "SC-no-margin" } });
            }
            // Create "Show variable values" toggle
            let preview_variable_values = true;
            const variable_names_visible_icon = "code-glyph";
            const variable_values_visible_glyph = "price-tag-glyph";
            const preview_variable_values_setting = new obsidian.Setting(this.modalEl)
                .addExtraButton(button => button
                .setIcon(variable_values_visible_glyph)
                .setTooltip("Toggle showing variable names or values.")
                .onClick(() => {
                preview_variable_values = !preview_variable_values;
                button.setIcon(preview_variable_values
                    ? variable_values_visible_glyph
                    : variable_names_visible_icon);
                update_shell_command_preview();
            }));
            // Decide what text to use in the preview
            if (this.parsing_process) {
                // Show a real shell command. Use preparsed content (= content that might have some variables already parsed).
                shell_command_preview_text = this.parsing_process.getParsingResults().shell_command.parsed_content;
            }
            else if (this.t_shell_command) {
                // Show a real shell command. No preparsed content is available. This content does not have any variables parsed yet.
                shell_command_preview_text = this.t_shell_command.getShellCommand();
            }
            else {
                // Make up a fake "shell command" for previewing.
                shell_command_preview_text = this.prompt.getExampleShellCommand();
                this.modalEl.createEl("p", { text: "(This is not a real shell command, it's just an example for this preview when no real shell command is available.)", attr: { class: "SC-no-margin SC-small-font" } });
            }
            this.modalEl.createEl("hr");
            // A function for handling preview text updates.
            update_shell_command_preview = async () => {
                let shell_command_preview_text_final = shell_command_preview_text;
                if (preview_variable_values) {
                    // The preview should show the VALUES.
                    // Ensure the form fields do not contain any parsing errors. (If there are errors, an unparsed preview text will be shown).
                    if (this.getPromptFieldsParsingErrors().length === 0) {
                        // All fields are parsed ok (= individual parsing).
                        // Insert the field values into the shell command preview by parsing the preview text.
                        // Get current values from the prompt fields.
                        const fresh_values = this.getPromptFieldsValues(); // These PromptField values are fresh, so not yet stored in the actual variables.
                        // Parse variables in the shell command preview text.
                        const parsing_result = await parseVariables(this.plugin, shell_command_preview_text, this.getShell(), this.t_shell_command, this.sc_event, undefined, // Use all variables.
                        (variable, raw_value) => {
                            if (fresh_values.has(variable.variable_name)) {
                                // Change the value to the one in the prompt field.
                                raw_value.error_messages = []; // Remove any possible error messages.
                                raw_value.succeeded = true; // This needs to reflect that there are no error messages.
                                raw_value.value = fresh_values.get(variable.variable_name);
                            }
                            // No modifications.
                        }, (variable, escaped_value) => {
                            // Emphasize the value that came from the currently focused field.
                            if (focused_prompt_field) {
                                if (variable.variable_name.toLocaleLowerCase() === focused_prompt_field.getTargetVariableInstance().getPrefixedName().toLocaleLowerCase()) {
                                    // Make the value bold.
                                    return `<strong>${escaped_value}</strong>`;
                                }
                            }
                            // No modifications.
                            return escaped_value;
                        });
                        if (parsing_result.succeeded) {
                            shell_command_preview_text_final = parsing_result.parsed_content;
                        }
                    }
                }
                else {
                    // The preview should show the VARIABLE NAMES.
                    if (focused_prompt_field) {
                        const pattern = new RegExp(focused_prompt_field.getTargetVariable().getPattern(), "igu"); // i: case-insensitive; g: match all occurrences instead of just the first one. u: support 4-byte unicode characters too.
                        shell_command_preview_text_final = shell_command_preview_text_final.replace(pattern, (replaceable_variable_name) => {
                            return "<strong>" + replaceable_variable_name + "</strong>";
                        });
                    }
                }
                preview_variable_values_setting.descEl.innerHTML = shell_command_preview_text_final;
            };
        }
        // Create fields
        let is_first_field = true;
        for (const prompt_field of this.prompt_fields) {
            await prompt_field.createField(this.modalEl.createDiv({ attr: { class: "SC-setting-group" } }), this.t_shell_command, this.sc_event);
            if (update_shell_command_preview) {
                prompt_field.onChange(update_shell_command_preview);
            }
            prompt_field.onFocus((prompt_field) => {
                focused_prompt_field = prompt_field;
                if (update_shell_command_preview) {
                    update_shell_command_preview();
                }
            });
            if (is_first_field) {
                // Focus on the first field.
                is_first_field = false;
                prompt_field.setFocus();
            }
        }
        if (update_shell_command_preview) {
            // Set a preview text. Must be done after fields are created, because their values are accessed.
            update_shell_command_preview();
        }
        // Tip about variables
        let tip = "";
        if (this.prompt_fields.size > 0) {
            // TODO: When implementing different field types, add a check that the tip is only shown when there are text/numeric fields present.
            // Only show the tip if this modal actually contains fields. Prompts can also be used as custom 'confirmation prompts' without any fields.
            tip = "Tip! You can use {{variables}} in text fields.";
        }
        // Execute button
        const execute_button_text_parsing_result = await parseVariables(this.plugin, this.prompt.configuration.execute_button_text, null, this.t_shell_command, this.sc_event);
        const execute_button_text = execute_button_text_parsing_result.succeeded
            ? execute_button_text_parsing_result.parsed_content
            : execute_button_text_parsing_result.original_content;
        new obsidian.Setting(this.modalEl)
            .setDesc(tip)
            .addButton(button => button
            .setButtonText(execute_button_text)
            .onClick(() => this.approve()));
        if (!this.t_shell_command) {
            // Notice that this is a preview only Prompt.
            this.modalEl.createEl("p", { text: `This is a preview prompt. No shell command will be executed, but clicking the '${this.prompt.configuration.execute_button_text}' button will still store the inputted value(s) to variable(s).` }).addClass("SC-prompt-dry-run-notice");
        }
        // Add CSS classes so that custom styling can be done on a per-prompt modal basis (or for all prompt modals via a common class).
        this.modalEl.addClasses(this.prompt.getCSSClasses());
    }
    approve() {
        this.validator().then(async () => {
            // The form fields are filled ok
            await this.assignValuesToVariables();
            this.resolve_promise(true);
            this.user_confirmed_ok = true;
            this.close();
        }, (error_messages) => {
            if (Array.isArray(error_messages)) {
                // There were some problems with the fields.
                this.plugin.newErrors(error_messages);
            }
            else {
                // Some other runtime error has occurred.
                throw error_messages;
            }
        });
    }
    onClose() {
        super.onClose();
        if (!this.user_confirmed_ok) { // TODO: Find out if there is a way to not use this kind of flag property. Can the status be checked from the promise itself?
            this.resolve_promise(false);
        }
    }
    async assignValuesToVariables() {
        for (const prompt_field of this.prompt_fields) {
            await prompt_field.getTargetVariable().setValue(prompt_field.getParsedValue());
        }
    }
    /**
     * Gathers a Map of variable values typed in the form, but does not store the values into the variables. Called when
     * generating a preview text, so the result of this method will not persist in any way.
     * @private
     */
    getPromptFieldsValues() {
        const values = new Map();
        for (const prompt_field of this.prompt_fields) {
            values.set(prompt_field.getTargetVariable().variable_name, prompt_field.getParsedValue() ?? "");
        }
        return values;
    }
    getPromptFieldsParsingErrors() {
        const parsing_errors = [];
        for (const prompt_field of this.prompt_fields) {
            parsing_errors.push(...prompt_field.getParsingErrors());
        }
        return parsing_errors;
    }
    getShell() {
        if (this.t_shell_command) {
            // This is a real usage of the PromptModal, so a TShellCommand is available. Look up the shell from that.
            return this.t_shell_command.getShell();
        }
        else {
            // Just trying the PromptModal. Just use some shell for variable escaping in an example preview.
            return this.plugin.getDefaultShell();
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PromptModel extends Model {
    constructor() {
        super(...arguments);
        this.prompts = new PromptMap();
    }
    getSingularName() {
        return "Prompt";
    }
    defineParentConfigurationRelation(prompt) {
        return {
            type: "one-to-many-id",
            key: "prompts",
            id: prompt.getID(),
        };
    }
    loadInstances(parent_configuration) {
        debugLog("Loading Prompt instances.");
        this.prompts = new PromptMap();
        parent_configuration.prompts.forEach((prompt_configuration) => {
            const prompt = new Prompt(this, this.plugin, prompt_configuration, parent_configuration);
            this.prompts.set(prompt_configuration.id, prompt);
        });
        return this.prompts;
    }
    newInstance(parent_configuration) {
        debugLog("Creating a new Prompt instance.");
        // TODO: Move this logic to the base Model class.
        // Setup a default configuration and generate an ID
        const prompt_configuration = this._getDefaultConfiguration();
        // Instantiate a Prompt
        const prompt = new Prompt(this, this.plugin, prompt_configuration, this.plugin.settings);
        this.prompts.set(prompt.getID(), prompt);
        // Store the configuration into plugin's settings
        this.plugin.settings.prompts.push(prompt_configuration);
        // Return the Prompt
        return prompt;
    }
    _createSettingFields(prompt, container_element) {
        debugLog("Creating setting fields for a Prompt instance.");
        const prompt_name_setting = new obsidian.Setting(container_element)
            // Configuration button
            .setName(prompt.getTitle())
            .addExtraButton(button => button
            .setTooltip("Define prompt fields")
            .setIcon("gear")
            .onClick(() => {
            this.openSettingsModal(prompt, prompt_name_setting);
        }));
        return prompt_name_setting;
    }
    validateValue(prompt, field, value) {
        // This method is not used, so it can just resolve all the time.
        return Promise.resolve(undefined);
    }
    openSettingsModal(prompt, prompt_name_setting) {
        debugLog("Opening settings modal for a Prompt instance.");
        const modal = new PromptSettingsModal(this.plugin, prompt, prompt_name_setting);
        modal.open();
    }
    _getDefaultConfiguration() {
        return {
            id: getIDGenerator().generateID(),
            title: "",
            description: "",
            preview_shell_command: false,
            fields: [],
            execute_button_text: "Execute",
        };
    }
    _deleteInstance(prompt) {
        debugLog("Deleting a Prompt instance.");
        // Remove the Prompt from all TShellCommands that use it.
        const shell_commands = this.plugin.getTShellCommands();
        for (const shell_command_id in shell_commands) {
            const t_shell_command = shell_commands[shell_command_id];
            for (const preaction_configuration of t_shell_command.getConfiguration().preactions) {
                if ("prompt" === preaction_configuration.type) {
                    const preaction_prompt_configuration = preaction_configuration;
                    if (prompt.getID() === preaction_prompt_configuration.prompt_id) {
                        // This TShellCommand uses this Prompt.
                        // Remove the Prompt from use.
                        preaction_prompt_configuration.enabled = false;
                        preaction_prompt_configuration.prompt_id = undefined;
                        t_shell_command.resetPreactions();
                        // Saving is done later, after the _deleteInstance() call.
                    }
                }
            }
        }
        this.prompts.delete(prompt.getID());
    }
}
class PromptMap extends Map {
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * @return Promise<InstanceClass> A promise that gets resolved if a user clicks the button. The promise is supplied with the newly created instance.
 */
function createNewModelInstanceButton(plugin, model_class_name, button_container_element, instance_container_element, parent_instance_or_configuration) {
    debugLog("Creating a button for creating a new instance for model " + model_class_name + ".");
    return new Promise((resolve_promise) => {
        const model = getModel(model_class_name);
        new obsidian.Setting(button_container_element)
            .addButton(button => button
            .setButtonText("New " + model.getSingularName().toLocaleLowerCase())
            .onClick(async () => {
            const instance = model.newInstance(parent_instance_or_configuration);
            const main_setting = model.createSettingFields(instance, instance_container_element);
            resolve_promise({
                "instance": instance,
                "main_setting": main_setting,
            });
            await plugin.saveSettings();
        }));
    });
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class PromptSettingsModal extends SC_Modal {
    constructor(plugin, prompt, 
    /** Can be undefined if the modal is created from a place where there is no name element. */
    prompt_name_setting, 
    /** If defined, a button will be added and on_after_approval() / on_after_cancelling() will be called depending on whether the button was clicked or not. */
    ok_button_text, on_after_approval, on_after_cancelling) {
        super(plugin);
        this.prompt = prompt;
        this.prompt_name_setting = prompt_name_setting;
        this.ok_button_text = ok_button_text;
        this.on_after_approval = on_after_approval;
        this.on_after_cancelling = on_after_cancelling;
        this.approved = false;
    }
    onOpen() {
        super.onOpen();
        const container_element = this.modalEl;
        const title_and_description_group_element = container_element.createDiv({ attr: { class: "SC-setting-group" } });
        // Title
        const title_setting = new obsidian.Setting(title_and_description_group_element)
            .setName("Prompt title")
            .addExtraButton(icon => icon
            .setTooltip("Try the prompt without executing any shell command.")
            .setIcon("run-command")
            .onClick(() => {
            // "Dry run" the Prompt
            this.prompt.openPrompt(null, null, null).then();
        }))
            .addText(text => text
            .setValue(this.prompt.getTitle())
            .onChange(async (new_title) => {
            this.prompt.getConfiguration().title = new_title;
            await this.plugin.saveSettings();
            // Update the title in a name setting. (Only if the modal was created from a place where a Prompt name element exists).
            this.prompt_name_setting?.setName(new_title);
        })
            .then((title_setting_component) => {
            // Autocomplete for Title.
            if (this.plugin.settings.show_autocomplete_menu) {
                createAutocomplete(this.plugin, title_setting_component.inputEl, () => title_setting_component.onChanged());
            }
        }));
        const title_input_element = title_setting.controlEl.find("input");
        // Focus on the title field.
        title_input_element.focus();
        // Description
        new obsidian.Setting(title_and_description_group_element)
            .setName("Description")
            .setDesc("Displayed between the prompt title and fields. Both Description and Title support {{variables}}.")
            .addTextArea(textarea => textarea
            .setValue(this.prompt.configuration.description)
            .onChange(async (new_description) => {
            this.prompt.getConfiguration().description = new_description;
            await this.plugin.saveSettings();
        })
            .then((description_component) => {
            // Autocomplete for Description.
            if (this.plugin.settings.show_autocomplete_menu) {
                createAutocomplete(this.plugin, description_component.inputEl, () => description_component.onChanged());
            }
        }));
        // Preview shell command
        new obsidian.Setting(container_element)
            .setName("Preview shell command in prompt")
            .setDesc("If this is on, the prompt will display the executable shell command with variable names in it, and highlight the variable(s) that will be affected by the values inputted in the prompt.")
            .addToggle(toggle => toggle
            .setValue(this.prompt.getConfiguration().preview_shell_command)
            .onChange(async (new_value) => {
            this.prompt.getConfiguration().preview_shell_command = new_value;
            await this.plugin.saveSettings();
        }));
        // Fields
        new obsidian.Setting(container_element)
            .setName("Fields")
            .setDesc("Tip! You can use {{variables}} in 'Field label', 'Default value' and 'Description'.");
        const prompt_field_model = getModel(PromptFieldModel.name);
        const fields_container = container_element.createDiv();
        this.prompt.prompt_fields.forEach((prompt_field) => {
            prompt_field_model.createSettingFields(prompt_field, fields_container);
        });
        // New field button
        createNewModelInstanceButton(this.plugin, PromptFieldModel.name, container_element, fields_container, this.prompt).then();
        // Execute button text
        new obsidian.Setting(container_element.createDiv({ attr: { class: "SC-setting-group" } }))
            .setName("Execute button text")
            .addText(text => text
            .setValue(this.prompt.configuration.execute_button_text)
            .onChange(async (new_execute_button_text) => {
            this.prompt.configuration.execute_button_text = new_execute_button_text;
            await this.plugin.saveSettings();
        })
            .then((execute_button_text_component) => {
            // Autocomplete for the Execute button text.
            if (this.plugin.settings.show_autocomplete_menu) {
                createAutocomplete(this.plugin, execute_button_text_component.inputEl, () => execute_button_text_component.onChanged());
            }
        }));
        // Ok button
        if (this.ok_button_text) {
            new obsidian.Setting(container_element)
                .addButton(button => button
                .setButtonText(this.ok_button_text)
                .onClick(() => this.approve()));
        }
        // A tip about CSS styling.
        new obsidian.Setting(container_element)
            .setDesc("Tip! You can customise the style of the prompt modal with CSS by using the class ." + this.prompt.getCSSClass() + " or ." + Prompt.getCSSBaseClass() + " (for all prompt modals).");
    }
    approve() {
        if (this.on_after_approval) {
            this.approved = true;
            this.on_after_approval();
        }
        this.close();
    }
    onClose() {
        super.onClose();
        // Call a cancelling hook if one is defined (and if the closing happens due to cancelling, i.e. the ok button is NOT clicked).
        if (!this.approved && this.on_after_cancelling) {
            this.on_after_cancelling();
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function createPATHAugmentationFields(plugin, container_element, path_augmentations) {
    const path_variable_name = getPATHEnvironmentVariableName();
    new obsidian.Setting(container_element)
        .setName(`Add directories to the ${path_variable_name} environment variable`)
        .setHeading()
        .setDesc(`This is sometimes needed in order to be able to call some user installed applications. The directories will be appended AFTER the default directories in ${path_variable_name}, unless {{!environment:${path_variable_name}}} is included. Other {{variables}} can be used, too, but they don't affect the appending order.`)
        // An icon for showing the current PATH content.
        .addExtraButton(button => button
        .setIcon("bullet-list")
        .setTooltip(`Show the current ${path_variable_name} content (without any additions).`)
        .onClick(() => {
        const modal = new ConfirmationModal(plugin, `Current ${path_variable_name} content`, process.env.PATH, "Close");
        modal.open();
    }))
        // Help link
        .addExtraButton(button => button
        .setIcon("help")
        .setTooltip(`Documentation: Additions to the ${path_variable_name} environment variable`)
        .onClick(() => gotoURL(DocumentationPATHAugmentationsLink)));
    // Create a field for each operating system.
    const sub_container_element = container_element.createDiv();
    sub_container_element.addClass("SC-setting-group");
    Object.getOwnPropertyNames(PlatformNames).forEach((platform_id) => {
        const platform_name = PlatformNames[platform_id];
        new obsidian.Setting(sub_container_element).setName(platform_name + " " + getPATHEnvironmentVariableName(platform_id) + " additions")
            .setDesc("Define each directory on a separate line, or multiple directories on one line, separated by " + getPATHSeparator(platform_id, true))
            .addTextArea(textarea => textarea
            .setValue(path_augmentations[platform_id] ?? "")
            .onChange(async (new_path_augmentation) => {
            // PATH augmentation has been changed.
            // Update the configuration.
            if (new_path_augmentation.length > 0) {
                // The augmentation has content.
                path_augmentations[platform_id] = new_path_augmentation;
            }
            else {
                // The augmentation has been removed.
                delete path_augmentations[platform_id];
            }
            await plugin.saveSettings();
        })
            .then((textarea_component) => {
            // Add an autocomplete menu.
            createAutocomplete(plugin, textarea_component.inputEl, () => textarea_component.onChanged());
        }));
    });
}
function getPATHSeparator(platform_id, verbose = false) {
    switch (platform_id) {
        case "linux":
        case "darwin": // This is macOS.
            return verbose ? "a colon :" : ":";
        case "win32":
            return verbose ? "a semicolon ;" : ";";
    }
}
function convertNewlinesToPATHSeparators(path, platform_id) {
    const separator = getPATHSeparator(platform_id);
    return path.replace(/(\r\n|\r|\n)+/gu, // + means that multiple adjacent newlines can be combined into a single separator character.
    () => separator);
}
/**
 * Retrieves a PATH environment variable augmentation string (specific to the current operating system) from the plugin's
 * configuration. Returns it WITHOUT parsing possible variables in the string. If the current operating system does not
 * have a dedicated PATH augmentation string in the configuration, returns null.
 *
 * @param plugin
 */
function getPATHAugmentation(plugin) {
    return plugin.settings.environment_variable_path_augmentations[getOperatingSystem()] ?? null;
}
/**
 * Returns OS specific name for the PATH environment variable. For Windows its Path, but for macOS and Linux its PATH, so
 * the only difference is casing.
 */
function getPATHEnvironmentVariableName(platform_id = getOperatingSystem()) {
    switch (platform_id) {
        case "darwin":
        case "linux":
            return "PATH";
        case "win32":
            return "Path";
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * ParsingProcess instances can be used in situations where it's uncertain can all variables be parsed at the time being,
 * i.e. when parsing shell commands (and aliases), as they can have preactions which require parsing to be done in two phases.
 *
 * Also, shell commands are often parsed in advance for command palette and context menus. Then it's good to store the parsing
 * result by using instances of this class.
 *
 * Then again, if the parsing use-case is simpler, e.g. Prompt description or prompt field values, it's more straightforward
 * to just call parseVariables() without utilising this class. After all, this class is a wrapper for parseVariables().
 *
 * <ParsingMap> is a generalization for defining keys for an object that will be used for submitting the original parseable
 * content. The same keys will then be used to form another object containing the parsing results.
 */
class ParsingProcess {
    constructor(plugin, original_contents, 
    /** Used to get a shell (getShell()) and default values for variables. */
    t_shell_command, sc_event, 
    /**
     * When .process() is called, it will shift and process the first VariableSet present in this array. So, the next call
     * will shift and process the next set.
     */
    variable_sets, 
    /**
     * This can be used to mark certain contents to always avoid escaping special characters in their variable values.
     * This should only be used for content that is never submitted to a shell, i.e. output wrappers at the moment.
     *
     * This is a list of 'content keys'.
     */
    avoid_escaping = []) {
        this.plugin = plugin;
        this.original_contents = original_contents;
        this.t_shell_command = t_shell_command;
        this.sc_event = sc_event;
        this.variable_sets = variable_sets;
        this.avoid_escaping = avoid_escaping;
        this.parsing_results = {};
        this.is_first_call = true;
        debugLog("Parsing process: Count variable sets: " + this.variable_sets.length);
    }
    /**
     * Performs the next step in the parsing process. The step can be the first one, or a subsequent step.
     *
     * @return True if parsing succeeded, false otherwise. Read the results by calling .getParsingResult().
     */
    async process() {
        const current_variables = this.variable_sets.shift();
        let success = true;
        debugLog("Parsing process: Count variables in current set: " + current_variables.size);
        // Multiple contents can be parsed in the same call. TShellCommand instances have 'shell_command' and 'alias'
        // contents which are parsed at the same time. This multi-content support can be used for even more situations if
        // needed in the future.
        for (const content_key of this.getContentKeys()) {
            let parse_content;
            if (this.is_first_call) {
                // Use original content.
                parse_content = this.original_contents[content_key];
                debugLog("Starting to parse '" + content_key + "': " + parse_content);
            }
            else {
                // Continue parsing content from previous parsing result. This time parse variables that were not parse back then.
                // FIXME: Problem: variable values that came from an earlier phase are exposed to repetitive parsing. Find a way to limit the parsing to only original parts of the shell command.
                parse_content = this.parsing_results[content_key].parsed_content;
                debugLog("Continuing parsing '" + content_key + "': " + parse_content);
            }
            // Parse the variables
            const parsing_result = await parseVariables(this.plugin, parse_content, this.avoidEscaping(content_key) ? null : this.t_shell_command.getShell(), // If no escaping is needed, pass null.
            this.t_shell_command, this.sc_event, current_variables);
            // Check if the parsing succeeded or failed.
            success = success && parsing_result.succeeded; // Flag as failed also if a previous phase has failed.
            // Store the parsing result
            this.mergeToParsingResults(content_key, parsing_result);
        }
        // Finish
        this.is_first_call = false;
        return success;
    }
    /**
     * A wrapper for .process() that processes all the VariableSets that are still left unprocessed.
     *
     * @return True if parsing all sets succeeded, false otherwise.
     */
    async processRest() {
        // 1. Check a previous parsing result (if exists).
        for (const content_key of this.getContentKeys()) {
            if (this.parsing_results[content_key]) {
                // A previous parsing result exists.
                // Ensure it has not failed.
                debugLog("Previous parsing succeeded? " + this.parsing_results[content_key].succeeded);
                if (!this.parsing_results[content_key].succeeded) {
                    // The previous parsing result has failed.
                    return false;
                }
            }
        }
        // 2. Process the rest of the VariableSets.
        for (let i = 0; i < this.variable_sets.length; i++) {
            if (!await this.process()) {
                return false;
            }
        }
        return true;
    }
    getParsingResults() {
        return this.parsing_results;
    }
    /**
     * Calls SC_Plugin.newErrors() to create visible error balloons for all the issues encountered during parsing.
     */
    displayErrorMessages() {
        this.plugin.newErrors(this.getErrorMessages());
    }
    /**
     * @private Can be made public if needed.
     */
    getErrorMessages() {
        let error_messages = [];
        for (const content_key of this.getContentKeys()) {
            error_messages.push(...this.parsing_results[content_key].error_messages);
        }
        // Remove duplicate error messages. When parsing 'shell_command' and 'alias', they can contain same variables and
        // therefore generate same error messages.
        error_messages = uniqueArray(error_messages);
        return error_messages;
    }
    getContentKeys() {
        return Object.getOwnPropertyNames(this.original_contents);
    }
    /**
     * Merges consecutive parsing results together so that information from both the old and new parsing results can be preserved.
     */
    mergeToParsingResults(content_key, parsing_result) {
        if (!this.parsing_results[content_key]) {
            // No need to merge. But clone the object so that possible future merges will not mess up the original object in case it's used somewhere else.
            this.parsing_results[content_key] = cloneObject(parsing_result);
        }
        else {
            // Merge
            // NOTE: this.parsing_results[content_key].original_content IS KEPT UNCHANGED! The newer "original" content is not actually original, because it's partly parsed. That's why the old one is preserved.
            this.parsing_results[content_key].parsed_content = parsing_result.parsed_content; // New parsed content overrides the old one.
            this.parsing_results[content_key].succeeded &&= parsing_result.succeeded; // Both the old and new parsing must have succeeded in order to consider the whole process succeeded.
            this.parsing_results[content_key].error_messages.push(...parsing_result.error_messages); // Include both old and new error messages.
            this.parsing_results[content_key].count_parsed_variables += parsing_result.count_parsed_variables; // Sum up the variable usage counts. At the time of writing, the sum is only used for determining if there were any variables parsed or not, so an accurate sum is not used atm.
        }
    }
    /**
     * Tells whether the given content_key has a mark that special characters in the content's variable values should not be escaped.
     *
     * @param content_key
     * @private
     */
    avoidEscaping(content_key) {
        return this.avoid_escaping.contains(content_key);
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function newShellCommandConfiguration(shell_command_id, shell_command = "") {
    return {
        id: shell_command_id,
        platform_specific_commands: {
            default: shell_command,
        },
        shells: {},
        alias: "",
        icon: null,
        confirm_execution: false,
        ignore_error_codes: [],
        output_channels: {
            stdout: "ignore",
            stderr: "notification",
        },
        output_wrappers: {
            stdout: null,
            stderr: null,
        },
        output_channel_order: "stdout-first",
        output_handling_mode: "buffered",
        events: {},
        command_palette_availability: "enabled",
        preactions: [],
        variable_default_values: {},
    };
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
async function RunMigrations(plugin) {
    const should_save = [
        EnsureMainFieldsExist(plugin),
        MigrateCommandsToShellCommands(plugin),
        MigrateShellCommandsObjectToArray(plugin),
        MigrateShellCommandToPlatforms(plugin),
        EnsureShellCommandsHaveAllFields(plugin),
        DeleteEmptyCommandsField(plugin),
    ];
    if (should_save.includes(true)) {
        // Only save if there were changes to configuration.
        debugLog("Saving migrations...");
        backupSettingsFile(plugin); // Make a backup copy of the old file BEFORE writing the new, migrated settings file.
        await plugin.saveSettings();
        debugLog("Migrations saved...");
    }
}
/**
 * Can be removed in the future, but I haven't yet decided will it be done in 1.0 or later.
 */
function MigrateShellCommandsObjectToArray(plugin) {
    // Check if the shell commands' container is an object.
    if (!Array.isArray(plugin.settings.shell_commands)) {
        // It is an object. It needs to be changed to an array in order to allow custom ordering.
        const shell_commands_array = [];
        for (const shell_command_id of Object.getOwnPropertyNames(plugin.settings.shell_commands)) { // Remember that plugin.settings.shell_commands is an object here! Not an array (yet).
            // @ts-ignore I don't know why TypeScript thinks the index is incorrect.
            const shell_command_configuration = plugin.settings.shell_commands[shell_command_id];
            // Assign 'id' to ShellCommandConfiguration because it did not contain it before this migration.
            shell_command_configuration.id = shell_command_id;
            // Add the ShellCommandConfiguration to the new array container.
            shell_commands_array.push(shell_command_configuration);
        }
        // Replace the old object container with the new array container.
        plugin.settings.shell_commands = shell_commands_array; // Now plugin.settings.shell_commands changes to be an array instead of an object.
        return true; // Save the changes.
    }
    else {
        // The container is already migrated.
        return false; // No need to save anything.
    }
}
/**
 * Can be removed in 1.0.0.
 *
 * @param plugin
 * @constructor
 */
function MigrateCommandsToShellCommands(plugin) {
    if (undefined === plugin.settings.commands) {
        return false;
    }
    const count_shell_commands = plugin.settings.commands.length;
    let save = false;
    if (0 < count_shell_commands) {
        let count_empty_commands = 0; // A counter for empty or null commands
        debugLog("settings.commands is not empty, will migrate " + count_shell_commands + " commands to settings.shell_commands.");
        for (const shell_command_id in plugin.settings.commands) {
            const shell_command = plugin.settings.commands[shell_command_id];
            // Ensure that the command is not empty. Just in case.
            if (null === shell_command || 0 === shell_command.length) {
                // The command is empty
                debugLog("Migration failure for shell command #" + shell_command_id + ": The original shell command string is empty, so it cannot be migrated.");
                count_empty_commands++;
            }
            else if (undefined !== plugin.getShellCommandConfigurationIndex(shell_command_id)) {
                // A command with the same id already exists
                debugLog("Migration failure for shell command #" + shell_command_id + ": A shell command with same ID already exists in settings.shell_commands.");
            }
            else {
                // All OK, migrate.
                plugin.settings.shell_commands.push(newShellCommandConfiguration(shell_command_id, shell_command)); // Creates a shell command with default values and defines the command for it.
                delete plugin.settings.commands[shell_command_id]; // Leaves a null in place, but we can deal with it by deleting the whole array if it gets empty.
                count_empty_commands++; // Account the null generated on the previous line.
                save = true;
                debugLog("Migrated shell command #" + shell_command_id + ": " + shell_command);
            }
        }
        if (count_empty_commands === count_shell_commands) {
            // The whole commands array now contains only empty/null commands.
            // Delete it.
            delete plugin.settings.commands;
        }
    }
    else {
        debugLog("settings.commands is empty, so no need to migrate commands. Good thing! :)");
    }
    return save;
}
/**
 * This is a general migrator that adds new, missing properties to ShellCommandConfiguration objects. This is not tied to any specific version update, unlike MigrateCommandsToShellCommands().
 *
 * @param plugin
 * @constructor
 */
function EnsureShellCommandsHaveAllFields(plugin) {
    let save = false;
    const shell_command_default_configuration = newShellCommandConfiguration("no-id"); // Use a dummy id here, because something needs to be used. This id should never end up being used in practice.
    const shell_command_configurations = plugin.settings.shell_commands;
    for (const shell_command_configuration of shell_command_configurations) {
        for (const property_name in shell_command_default_configuration) {
            // @ts-ignore property_default_value can have (almost) whatever datatype
            const property_default_value = shell_command_default_configuration[property_name];
            // @ts-ignore
            if (undefined === shell_command_configuration[property_name] && property_name !== "id") { // The "id" check is just in case that MigrateShellCommandsObjectToArray() would not have added the "id" property, in which case the dummy "no-id" id should not be accidentally assigned to the shell command.
                // This shell command does not have this property.
                // Add the property to the shell command and use a default value.
                debugLog("EnsureShellCommandsHaveAllFields(): Shell command #" + shell_command_configuration.id + " does not have a property '" + property_name + "'. Will create the property and assign a default value '" + property_default_value + "'.");
                // @ts-ignore
                shell_command_configuration[property_name] = property_default_value;
                save = true;
            }
        }
    }
    return save;
}
/**
 * This is a general migrator that adds new, missing properties to the main settings object. This is not tied to any specific version update, unlike MigrateCommandsToShellCommands().
 *
 * @param plugin
 * @constructor
 */
function EnsureMainFieldsExist(plugin) {
    let has_missing_fields = false;
    const settings = plugin.settings;
    const default_settings = getDefaultSettings(false);
    for (const property_name in default_settings) {
        // @ts-ignore
        if (undefined === settings[property_name]) {
            // The settings object does not have this property.
            // @ts-ignore property_default_value can have (almost) whatever datatype
            const property_default_value = default_settings[property_name];
            debugLog("EnsureMainFieldsExist(): Main settings does not have property '" + property_name + "'. Will later create the property and assign a default value '" + property_default_value + "'.");
            has_missing_fields = true;
        }
    }
    if (has_missing_fields) {
        debugLog("EnsureMainFieldsExist(): Doing the above-mentioned new field creations...");
        plugin.settings = combineObjects(default_settings, plugin.settings);
        debugLog("EnsureMainFieldsExist(): Done.");
        return true; // Save the changes
    }
    debugLog("EnsureMainFieldsExist(): No new fields to create, all ok.");
    return false; // Nothing to save.
}
/**
 * Can be removed in 1.0.0.
 *
 * @param plugin
 * @constructor
 */
function MigrateShellCommandToPlatforms(plugin) {
    let save = false;
    for (const shell_command_configuration of plugin.settings.shell_commands) {
        if (undefined !== shell_command_configuration.shell_command) {
            // The shell command should be migrated.
            if (undefined === shell_command_configuration.platform_specific_commands || shell_command_configuration.platform_specific_commands.default === "") {
                debugLog("Migrating shell command #" + shell_command_configuration.id + ": shell_command string will be moved to platforms.default: " + shell_command_configuration.shell_command);
                shell_command_configuration.platform_specific_commands = {
                    default: shell_command_configuration.shell_command,
                };
                delete shell_command_configuration.shell_command;
                save = true;
            }
            else {
                debugLog("Migration failure for shell command #" + shell_command_configuration.id + ": platforms exists already.");
            }
        }
    }
    return save;
}
/**
 * Can be removed in 1.0.0.
 *
 * @param plugin
 * @constructor
 */
function DeleteEmptyCommandsField(plugin) {
    let save = false;
    if (undefined !== plugin.settings.commands) {
        if (plugin.settings.commands.length === 0) {
            delete plugin.settings.commands;
            save = true;
        }
    }
    return save;
}
/**
 * Permanent, do not remove.
 *
 * @param plugin
 */
function backupSettingsFile(plugin) {
    // plugin.app.fileManager.
    // @ts-ignore
    const current_settings_version = (plugin.settings.settings_version === "prior-to-0.7.0") ? "0.x" : plugin.settings.settings_version;
    const plugin_path = getPluginAbsolutePath(plugin);
    const settings_file_path = path__namespace.join(plugin_path, "data.json");
    const backup_file_path_without_extension = path__namespace.join(plugin_path, "data-backup-version-" + current_settings_version + "-before-upgrading-to-" + SC_Plugin.SettingsVersion);
    // Check that the current settings file can be found.
    if (!fs__namespace.existsSync(settings_file_path)) {
        // Not found. Probably the vault uses a different config folder than .obsidian.
        debugLog("backupSettingsFile(): Cannot find data.json");
        plugin.newError("Shell commands: Cannot create a backup of current settings file, because data.json is not found.");
        return;
    }
    let backup_file_path = backup_file_path_without_extension + ".json";
    let running_number = 1;
    while (fs__namespace.existsSync(backup_file_path)) {
        running_number++; // The first number will be 2.
        backup_file_path = backup_file_path_without_extension + "-" + running_number + ".json";
        if (running_number >= 1000) {
            // There is some problem with detecting existing/inexisting files.
            // Prevent hanging the program in an eternal loop.
            throw new Error("backupSettingsFile(): Eternal loop detected.");
        }
    }
    fs__namespace.copyFileSync(settings_file_path, backup_file_path);
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function createShellSelectionField(plugin, container_element, shells, is_global_settings) {
    let platform_id;
    for (platform_id in PlatformNames) {
        const platform_name = PlatformNames[platform_id];
        let options;
        if (is_global_settings) {
            const current_system_default = (getOperatingSystem() === platform_id) ? " (" + extractFileName(getUsersDefaultShell()) + ")" : "";
            options = { "default": "Use system default" + current_system_default };
        }
        else {
            options = { "default": "Use default" };
        }
        for (const shell_path in PlatformShells[platform_id]) {
            // @ts-ignore // TODO: Get rid of these two ts-ignores.
            const shell_name = PlatformShells[platform_id][shell_path];
            // @ts-ignore
            options[shell_path] = shell_name;
        }
        new obsidian.Setting(container_element)
            .setName(platform_name + (is_global_settings ? " default shell" : " shell"))
            .setDesc((is_global_settings ? "Can be overridden by each shell command. " : "") + ("win32" === platform_id ? "Powershell is recommended over cmd.exe, because this plugin does not support escaping variables in CMD." : ""))
            .addDropdown(dropdown => dropdown
            .addOptions(options)
            .setValue(shells[platform_id] ?? "default")
            .onChange(((_platform_id) => {
            return async (value) => {
                if ("default" === value) {
                    // When using default shell, the value should be unset.
                    delete shells[_platform_id];
                }
                else {
                    // Normal case: assign the shell value.
                    shells[_platform_id] = value;
                }
                await plugin.saveSettings();
            };
        })(platform_id)));
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function CreateShellCommandFieldCore(plugin, container_element, setting_icon_and_name, shell_command, shell, t_shell_command, show_autocomplete_menu, extra_on_change, shell_command_placeholder = "Enter your command") {
    async function on_change(shell_command) {
        // Update preview
        setting_group.preview_setting.descEl.innerHTML = ""; // Remove previous content.
        createMultilineTextElement("span", // TODO: Maybe cleaner would be not to create a <span>, but to insert the content directly into descEl.
        await getShellCommandPreview(plugin, shell_command, shell, t_shell_command, null /* No event is available during preview. */), setting_group.preview_setting.descEl);
        // Let the caller extend this onChange, to preform saving the settings:
        extra_on_change(shell_command);
        // Resize the shell command textarea to match the amount of lines in it.
        update_textarea_height(shell_command, shell_command_placeholder);
    }
    function update_textarea_height(shell_command, shell_command_placeholder) {
        const newlines_pattern = /\r\n|\r|\n/;
        const count_lines_in_shell_command = shell_command.split(newlines_pattern).length;
        const count_lines_in_shell_command_placeholder = shell_command_placeholder.split(newlines_pattern).length;
        let count_lines_final = Math.max(count_lines_in_shell_command, count_lines_in_shell_command_placeholder);
        if (plugin.settings.max_visible_lines_in_shell_command_fields) {
            // Limit the height so that the field will not take up too much space.
            count_lines_final = Math.min(plugin.settings.max_visible_lines_in_shell_command_fields, count_lines_final);
        }
        setting_group.shell_command_setting.settingEl.find("textarea").rows = count_lines_final;
    }
    const setting_group = {
        name_setting: new obsidian.Setting(container_element)
            .setClass("SC-name-setting")
            .then((name_setting) => {
            name_setting.nameEl.innerHTML = setting_icon_and_name;
        }),
        shell_command_setting: new obsidian.Setting(container_element)
            .addTextArea(text => text
            .setPlaceholder(shell_command_placeholder)
            .setValue(shell_command)
            .onChange(on_change))
            .setClass("SC-shell-command-setting"),
        preview_setting: new obsidian.Setting(container_element)
            .setClass("SC-preview-setting")
            .then(async (setting) => {
            setting.descEl.innerHTML = ""; // Remove previous content. Not actually needed here because it's empty already, but do it just in case.
            createMultilineTextElement("span", // TODO: Maybe cleaner would be not to create a <span>, but to insert the content directly into descEl.
            await getShellCommandPreview(plugin, shell_command, shell, t_shell_command, null /* No event is available during preview. */), setting.descEl);
        }),
    };
    update_textarea_height(shell_command, shell_command_placeholder);
    // Autocomplete menu
    if (show_autocomplete_menu) {
        createAutocomplete(plugin, setting_group.shell_command_setting.settingEl.find("textarea"), on_change);
    }
    return setting_group;
}
/**
 *
 * @param plugin
 * @param shell_command
 * @param shell
 * @param t_shell_command
 * @param sc_event
 * @public Exported because createShellCommandField uses this.
 */
async function getShellCommandPreview(plugin, shell_command, shell, t_shell_command, sc_event) {
    const parsing_result = await parseVariables(plugin, shell_command, shell, t_shell_command, sc_event);
    if (!parsing_result.succeeded) {
        // Variable parsing failed.
        if (parsing_result.error_messages.length > 0) {
            // Return all error messages, each in its own line. (Usually there's just one message).
            return parsing_result.error_messages.join(os.EOL); // Newlines are converted to <br>'s by the consumers of this function.
        }
        else {
            // If there are no error messages, then errors are silently ignored by user's variable configuration.
            // The preview can then show the original, unparsed shell command.
            return shell_command;
        }
    }
    // Variable parsing succeeded
    return parsing_result.parsed_content;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function createPlatformSpecificShellCommandField(plugin, container_element, t_shell_command, platform_id, show_autocomplete_menu) {
    const platform_name = PlatformNames[platform_id];
    const setting_group = CreateShellCommandFieldCore(plugin, container_element, "Shell command on " + platform_name, t_shell_command.getPlatformSpecificShellCommands()[platform_id] ?? "", t_shell_command.getShell(), t_shell_command, show_autocomplete_menu, async (shell_command) => {
        if (shell_command.length) {
            // shell_command is not empty, so it's a normal command.
            t_shell_command.getPlatformSpecificShellCommands()[platform_id] = shell_command;
        }
        else {
            // shell_command is empty, so the default command should be used.
            delete t_shell_command.getPlatformSpecificShellCommands()[platform_id];
        }
        await plugin.saveSettings();
    }, t_shell_command.getDefaultShellCommand());
    setting_group.name_setting.setDesc("If empty, the default shell command will be used on " + platform_name + ".");
    return setting_group;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function createTabs(container_element, tabs) {
    const tab_header = container_element.createEl("div", { attr: { class: "SC-tab-header" } });
    const tab_content_containers = {};
    const tab_buttons = {};
    const tab_structure = {
        header: tab_header,
        active_tab_id: Object.keys(tabs)[0],
        buttons: tab_buttons,
        contentContainers: tab_content_containers,
    };
    let first_button;
    for (const tab_id in tabs) {
        const tab = tabs[tab_id];
        // Create button
        const button = tab_header.createEl("button", {
            attr: {
                class: "SC-tab-header-button",
                activateTab: "SC-tab-" + tab_id,
            },
        });
        button.onclick = function (event) {
            const tab_button = this; // Use 'this' instead of event.target because this way we'll always get a button element, not an element inside the  button (i.e. an icon).
            // Hide all tab contents and get the max dimensions
            let max_width = 0;
            let max_height = 0;
            const tab_header = tab_button.parentElement;
            const container_element = tab_header.parentElement;
            const tab_contents = container_element.findAll("div.SC-tab-content"); // Do not get all tab contents that exist, because there might be multiple tab systems open at the same time.
            const is_main_settings_modal = container_element.hasClass("vertical-tab-content");
            for (const index in tab_contents) {
                const tab_content = tab_contents[index];
                // Get the maximum tab dimensions so that all tabs can have the same dimensions.
                // But don't do it if this is the main settings modal
                if (!is_main_settings_modal) {
                    tab_content.addClass("SC-tab-active"); // Need to make the tab visible temporarily in order to get the dimensions.
                    if (tab_content.offsetHeight > max_height) {
                        max_height = tab_content.offsetHeight;
                    }
                    if (tab_content.offsetWidth > max_width) {
                        max_width = tab_content.offsetWidth;
                    }
                }
                // Finally hide the tab
                tab_content.removeClass("SC-tab-active");
            }
            // Remove active status from all buttons
            const adjacent_tab_buttons = tab_header.findAll(".SC-tab-header-button"); // Do not get all tab buttons that exist, because there might be multiple tab systems open at the same time.
            for (const index in adjacent_tab_buttons) {
                const tab_button = adjacent_tab_buttons[index];
                tab_button.removeClass("SC-tab-active");
            }
            // Activate the clicked tab
            tab_button.addClass("SC-tab-active");
            const activate_tab_id = tab_button.attributes.getNamedItem("activateTab").value;
            const tab_content = document.getElementById(activate_tab_id);
            tab_content.addClass("SC-tab-active");
            // Mark the clicked tab as active in TabStructure (just to report which tab is currently active)
            tab_structure.active_tab_id = activate_tab_id.replace(/^SC-tab-/, ""); // Remove "SC-tab" prefix.
            // Focus an element (if a focusable element is present)
            tab_content.find(".SC-focus-element-on-tab-opening")?.focus(); // ? = If not found, do nothing.
            // Apply the max dimensions to this tab
            // But don't do it if this is the main settings modal
            if (!is_main_settings_modal) {
                tab_content.style.width = max_width + "px";
                tab_content.style.height = max_height + "px";
            }
            // Do nothing else (I don't know if this is needed or not)
            event.preventDefault();
        };
        obsidian.setIcon(button, tab.icon);
        button.insertAdjacentText("beforeend", " " + tab.title);
        tab_buttons[tab_id] = button;
        // Create content container
        tab_content_containers[tab_id] = container_element.createEl("div", { attr: { class: "SC-tab-content", id: "SC-tab-" + tab_id } });
        // Generate content
        tab.content_generator(tab_content_containers[tab_id]);
        // Memorize the first tab's button
        if (!first_button) {
            first_button = button;
        }
    }
    // Activate the first tab
    if (first_button) {
        first_button.click();
    }
    // Return the TabStructure
    return tab_structure;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_onLayoutReady extends SC_Event {
    constructor() {
        super(...arguments);
        this.register_after_changing_settings = false;
    }
    _register(t_shell_command) {
        this.app.workspace.onLayoutReady(async () => await this.trigger(t_shell_command));
        return false; // The base class does not need to register anything.
    }
    _unregister(t_shell_command) {
        // No need to unregister, because this event happens only once when Obsidian starts. If the event is not enabled for a shell command, next time Obsidian starts, this event won't get registered.
    }
}
SC_Event_onLayoutReady.event_code = "on-layout-ready";
SC_Event_onLayoutReady.event_title = "Obsidian starts";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_onQuit extends SC_WorkspaceEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "quit";
    }
}
SC_Event_onQuit.event_code = "on-quit";
SC_Event_onQuit.event_title = "Obsidian quits";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_onActiveLeafChanged extends SC_WorkspaceEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "active-leaf-change";
    }
}
SC_Event_onActiveLeafChanged.event_code = "on-active-leaf-changed";
SC_Event_onActiveLeafChanged.event_title = "Switching the active pane";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_EveryNSeconds extends SC_Event {
    constructor() {
        super(...arguments);
        this.default_configuration = {
            enabled: false,
            seconds: 60,
        };
        this.intervals_ids = {};
    }
    _register(t_shell_command) {
        const milliseconds = this.getConfiguration(t_shell_command).seconds * 1000;
        const interval_id = window.setInterval(async () => await this.trigger(t_shell_command), milliseconds);
        this.plugin.registerInterval(interval_id);
        this.intervals_ids[t_shell_command.getId()] = interval_id;
        return false; // The base class does not need to register anything.
    }
    _unregister(t_shell_command) {
        window.clearInterval(this.intervals_ids[t_shell_command.getId()]);
    }
    /**
     * Overridden only to change the return type.
     * @param t_shell_command
     * @protected
     */
    getConfiguration(t_shell_command) {
        return super.getConfiguration(t_shell_command);
    }
    createExtraSettingsFields(extra_settings_container, t_shell_command) {
        const configuration = this.getConfiguration(t_shell_command);
        let apply_seconds;
        new obsidian.Setting(extra_settings_container)
            .setName("Seconds")
            .setDesc("Needs to be at least 1. Currently supports only integers.")
            .addText(text => text
            .setValue(configuration.seconds.toString())
            .onChange((raw_value) => {
            apply_seconds = parseInt(raw_value);
            // Don't save here, because the user might still be editing the number.
        }))
            .addButton(button => button
            .setButtonText("Apply")
            .onClick(async () => {
            if (undefined == apply_seconds || apply_seconds === this.getConfiguration(t_shell_command).seconds) {
                new obsidian.Notice("You didn't change the seconds!");
            }
            else if (isNaN(apply_seconds)) {
                new obsidian.Notice("The seconds need to be an integer!");
            }
            else if (apply_seconds <= 0) {
                new obsidian.Notice("The seconds need to be at least 1!");
            }
            else {
                // All ok, save.
                this.getConfiguration(t_shell_command).seconds = apply_seconds;
                await this.plugin.saveSettings();
                // Re-register to apply the change
                this.unregister(t_shell_command);
                this.register(t_shell_command);
                // Done
                this.noticeAboutEnabling(t_shell_command);
            }
        }));
    }
    onAfterEnabling(t_shell_command) {
        this.noticeAboutEnabling(t_shell_command);
    }
    noticeAboutEnabling(t_shell_command) {
        new obsidian.Notice("The shell command will run every " + this.getConfiguration(t_shell_command).seconds + " seconds");
    }
}
SC_Event_EveryNSeconds.event_code = "every-n-seconds";
SC_Event_EveryNSeconds.event_title = "Every n seconds";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Event_EditorMenu extends SC_MenuEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "editor-menu";
    }
    getTrigger(t_shell_command) {
        return async (menu, editor, view) => {
            await this.addTShellCommandToMenu(t_shell_command, menu);
        };
    }
}
SC_Event_EditorMenu.event_code = "editor-menu";
SC_Event_EditorMenu.event_title = "Editor menu";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
function getSC_Events(plugin) {
    if (undefined === getSC_Events.events) {
        // Cache the list of SC_Event objects
        getSC_Events.events = [
            new SC_Event_onLayoutReady(plugin),
            new SC_Event_onQuit(plugin),
            new SC_Event_onActiveLeafChanged(plugin),
            new SC_Event_EveryNSeconds(plugin),
            new SC_Event_FileMenu(plugin),
            new SC_Event_FolderMenu(plugin),
            new SC_Event_EditorMenu(plugin),
            new SC_Event_FileContentModified(plugin),
            new SC_Event_FileCreated(plugin),
            new SC_Event_FileDeleted(plugin),
            new SC_Event_FileMoved(plugin),
            new SC_Event_FileRenamed(plugin),
            new SC_Event_FolderCreated(plugin),
            new SC_Event_FolderDeleted(plugin),
            new SC_Event_FolderMoved(plugin),
            new SC_Event_FolderRenamed(plugin),
        ];
    }
    return getSC_Events.events;
}
getSC_Events.events = undefined;

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.0 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * A wrapper for Obsidian's setIcon(), but with the difference that this one does not need a container as a parameter.
 */
function getIconHTML(icon_id) {
    if (!icon_id) {
        return "";
    }
    const icon_container = document.body.createEl("div"); // A temporary element, will be deleted soon. Not nice to create a temporary element in the body, but I don't know any better way.
    debugLog(icon_id); // TODO: Do not commit.
    obsidian.setIcon(icon_container, icon_id);
    const icon_html = icon_container.innerHTML;
    icon_container.remove();
    return icon_html;
}
/**
 * @author The list is provided by phibr0.
 * @link https://discord.com/channels/686053708261228577/840286264964022302/968248588641665075
 * @description phibr0: "Updated Icon List for Obsidian v0.14.7+ (lucide icons v0.30.0 + obsidians own)"
 * @copyright The copyright statement at the top of this file does not affect this list of icons.
 * TODO: The list seems to miss some icons, at least 'gear'.
 */
const ICON_LIST = ["activity", "airplay", "alarm-check", "alarm-clock-off", "alarm-clock", "alarm-minus", "alarm-plus", "album", "alert-circle", "alert-octagon", "alert-triangle", "align-center-horizontal", "align-center-vertical", "align-center", "align-end-horizontal", "align-end-vertical", "align-horizontal-distribute-center", "align-horizontal-distribute-end", "align-horizontal-distribute-start", "align-horizontal-justify-center", "align-horizontal-justify-end", "align-horizontal-justify-start", "align-horizontal-space-around", "align-horizontal-space-between", "align-justify", "align-left", "align-right", "align-start-horizontal", "align-start-vertical", "align-vertical-distribute-center", "align-vertical-distribute-end", "align-vertical-distribute-start", "align-vertical-justify-center", "align-vertical-justify-end", "align-vertical-justify-start", "align-vertical-space-around", "align-vertical-space-between", "anchor", "aperture", "archive", "arrow-big-down", "arrow-big-left", "arrow-big-right", "arrow-big-up", "arrow-down-circle", "arrow-down-left", "arrow-down-right", "arrow-down", "arrow-left-circle", "arrow-left-right", "arrow-left", "arrow-right-circle", "arrow-right", "arrow-up-circle", "arrow-up-left", "arrow-up-right", "arrow-up", "asterisk", "at-sign", "award", "axe", "banknote", "bar-chart-2", "bar-chart", "baseline", "battery-charging", "battery-full", "battery-low", "battery-medium", "battery", "beaker", "bell-minus", "bell-off", "bell-plus", "bell-ring", "bell", "bike", "binary", "bitcoin", "bluetooth-connected", "bluetooth-off", "bluetooth-searching", "bluetooth", "bold", "book-open", "book", "bookmark-minus", "bookmark-plus", "bookmark", "bot", "box-select", "box", "briefcase", "brush", "bug", "building-2", "building", "bus", "calculator", "calendar", "camera-off", "camera", "car", "carrot", "cast", "check-circle-2", "check-circle", "check-square", "check", "chevron-down", "chevron-first", "chevron-last", "chevron-left", "chevron-right", "chevron-up", "chevrons-down-up", "chevrons-down", "chevrons-left", "chevrons-right", "chevrons-up-down", "chevrons-up", "chrome", "circle-slashed", "circle", "clipboard-check", "clipboard-copy", "clipboard-list", "clipboard-x", "clipboard", "clock-1", "clock-10", "clock-11", "clock-12", "clock-2", "clock-3", "clock-4", "clock-5", "clock-6", "clock-7", "clock-8", "clock-9", "clock", "cloud-drizzle", "cloud-fog", "cloud-hail", "cloud-lightning", "cloud-moon", "cloud-off", "cloud-rain-wind", "cloud-rain", "cloud-snow", "cloud-sun", "cloud", "cloudy", "clover", "code-2", "code", "codepen", "codesandbox", "coffee", "coins", "columns", "command", "compass", "contact", "contrast", "cookie", "copy", "copyleft", "copyright", "corner-down-left", "corner-down-right", "corner-left-down", "corner-left-up", "corner-right-down", "corner-right-up", "corner-up-left", "corner-up-right", "cpu", "credit-card", "crop", "cross", "crosshair", "crown", "currency", "database", "delete", "dice-1", "dice-2", "dice-3", "dice-4", "dice-5", "dice-6", "disc", "divide-circle", "divide-square", "divide", "dollar-sign", "download-cloud", "download", "dribbble", "droplet", "droplets", "drumstick", "edit-2", "edit-3", "edit", "egg", "equal-not", "equal", "eraser", "euro", "expand", "external-link", "eye-off", "eye", "facebook", "fast-forward", "feather", "figma", "file-check-2", "file-check", "file-code", "file-digit", "file-input", "file-minus-2", "file-minus", "file-output", "file-plus-2", "file-plus", "file-search", "file-text", "file-x-2", "file-x", "file", "files", "film", "filter", "flag-off", "flag-triangle-left", "flag-triangle-right", "flag", "flame", "flashlight-off", "flashlight", "flask-conical", "flask-round", "folder-minus", "folder-open", "folder-plus", "folder", "form-input", "forward", "frame", "framer", "frown", "function-square", "gamepad-2", "gamepad", "gauge", "gavel", "gem", "ghost", "gift", "git-branch-plus", "git-branch", "git-commit", "git-fork", "git-merge", "git-pull-request", "github", "gitlab", "glasses", "globe-2", "globe", "grab", "graduation-cap", "grid", "grip-horizontal", "grip-vertical", "hammer", "hand-metal", "hand", "hard-drive", "hard-hat", "hash", "haze", "headphones", "heart", "help-circle", "hexagon", "highlighter", "history", "home", "image-minus", "image-off", "image-plus", "image", "import", "inbox", "indent", "indian-rupee", "infinity", "info", "inspect", "instagram", "italic", "japanese-yen", "key", "keyboard", "landmark", "languages", "laptop-2", "laptop", "lasso-select", "lasso", "layers", "layout-dashboard", "layout-grid", "layout-list", "layout-template", "layout", "library", "life-buoy", "lightbulb-off", "lightbulb", "link-2-off", "link-2", "link", "linkedin", "list-checks", "list-minus", "list-ordered", "list-plus", "list-x", "list", "loader-2", "loader", "locate-fixed", "locate-off", "locate", "lock", "log-in", "log-out", "mail", "map-pin", "map", "maximize-2", "maximize", "megaphone", "meh", "menu", "message-circle", "message-square", "mic-off", "mic", "minimize-2", "minimize", "minus-circle", "minus-square", "minus", "monitor-off", "monitor-speaker", "monitor", "moon", "more-horizontal", "more-vertical", "mountain-snow", "mountain", "mouse-pointer-2", "mouse-pointer-click", "mouse-pointer", "mouse", "move-diagonal-2", "move-diagonal", "move-horizontal", "move-vertical", "move", "music", "navigation-2", "navigation", "network", "octagon", "option", "outdent", "package-check", "package-minus", "package-plus", "package-search", "package-x", "package", "palette", "palmtree", "paperclip", "pause-circle", "pause-octagon", "pause", "pen-tool", "pencil", "percent", "person-standing", "phone-call", "phone-forwarded", "phone-incoming", "phone-missed", "phone-off", "phone-outgoing", "phone", "pie-chart", "piggy-bank", "pin", "pipette", "plane", "play-circle", "play", "plug-zap", "plus-circle", "plus-square", "plus", "pocket", "podcast", "pointer", "pound-sterling", "power-off", "power", "printer", "qr-code", "quote", "radio-receiver", "radio", "redo", "refresh-ccw", "refresh-cw", "regex", "repeat-1", "repeat", "reply-all", "reply", "rewind", "rocket", "rocking-chair", "rotate-ccw", "rotate-cw", "rss", "ruler", "russian-ruble", "save", "scale", "scan-line", "scan", "scissors", "screen-share-off", "screen-share", "search", "send", "separator-horizontal", "separator-vertical", "server-crash", "server-off", "server", "settings-2", "settings", "share-2", "share", "sheet", "shield-alert", "shield-check", "shield-close", "shield-off", "shield", "shirt", "shopping-bag", "shopping-cart", "shovel", "shrink", "shuffle", "sidebar-close", "sidebar-open", "sidebar", "sigma", "signal-high", "signal-low", "signal-medium", "signal-zero", "signal", "skip-back", "skip-forward", "skull", "slack", "slash", "sliders", "smartphone-charging", "smartphone", "smile", "snowflake", "sort-asc", "sort-desc", "speaker", "sprout", "square", "star-half", "star", "stop-circle", "stretch-horizontal", "stretch-vertical", "strikethrough", "subscript", "sun", "sunrise", "sunset", "superscript", "swiss-franc", "switch-camera", "table", "tablet", "tag", "target", "tent", "terminal-square", "terminal", "text-cursor-input", "text-cursor", "thermometer-snowflake", "thermometer-sun", "thermometer", "thumbs-down", "thumbs-up", "ticket", "timer-off", "timer-reset", "timer", "toggle-left", "toggle-right", "tornado", "trash-2", "trash", "trello", "trending-down", "trending-up", "triangle", "truck", "tv-2", "tv", "twitch", "twitter", "type", "umbrella", "underline", "undo", "unlink-2", "unlink", "unlock", "upload-cloud", "upload", "user-check", "user-minus", "user-plus", "user-x", "user", "users", "verified", "vibrate", "video-off", "video", "view", "voicemail", "volume-1", "volume-2", "volume-x", "volume", "wallet", "wand", "watch", "waves", "webcam", "wifi-off", "wifi", "wind", "wrap-text", "wrench", "x-circle", "x-octagon", "x-square", "x", "youtube", "zap-off", "zap", "zoom-in", "zoom-out", "search-large", "search", "activity", "airplay", "alarm-check", "alarm-clock-off", "alarm-clock", "alarm-minus", "alarm-plus", "album", "alert-circle", "alert-octagon", "alert-triangle", "align-center-horizontal", "align-center-vertical", "align-center", "align-end-horizontal", "align-end-vertical", "align-horizontal-distribute-center", "align-horizontal-distribute-end", "align-horizontal-distribute-start", "align-horizontal-justify-center", "align-horizontal-justify-end", "align-horizontal-justify-start", "align-horizontal-space-around", "align-horizontal-space-between", "align-justify", "align-left", "align-right", "align-start-horizontal", "align-start-vertical", "align-vertical-distribute-center", "align-vertical-distribute-end", "align-vertical-distribute-start", "align-vertical-justify-center", "align-vertical-justify-end", "align-vertical-justify-start", "align-vertical-space-around", "align-vertical-space-between", "anchor", "aperture", "archive", "arrow-big-down", "arrow-big-left", "arrow-big-right", "arrow-big-up", "arrow-down-circle", "arrow-down-left", "arrow-down-right", "arrow-down", "arrow-left-circle", "arrow-left-right", "arrow-left", "arrow-right-circle", "arrow-right", "arrow-up-circle", "arrow-up-left", "arrow-up-right", "arrow-up", "asterisk", "at-sign", "award", "axe", "banknote", "bar-chart-2", "bar-chart", "baseline", "battery-charging", "battery-full", "battery-low", "battery-medium", "battery", "beaker", "bell-minus", "bell-off", "bell-plus", "bell-ring", "bell", "bike", "binary", "bitcoin", "bluetooth-connected", "bluetooth-off", "bluetooth-searching", "bluetooth", "bold", "book-open", "book", "bookmark-minus", "bookmark-plus", "bookmark", "bot", "box-select", "box", "briefcase", "brush", "bug", "building-2", "building", "bus", "calculator", "calendar", "camera-off", "camera", "car", "carrot", "cast", "check-circle-2", "check-circle", "check-square", "check", "chevron-down", "chevron-first", "chevron-last", "chevron-left", "chevron-right", "chevron-up", "chevrons-down-up", "chevrons-down", "chevrons-left", "chevrons-right", "chevrons-up-down", "chevrons-up", "chrome", "circle-slashed", "circle", "clipboard-check", "clipboard-copy", "clipboard-list", "clipboard-x", "clipboard", "clock-1", "clock-10", "clock-11", "clock-12", "clock-2", "clock-3", "clock-4", "clock-5", "clock-6", "clock-7", "clock-8", "clock-9", "lucide-clock", "cloud-drizzle", "cloud-fog", "cloud-hail", "cloud-lightning", "cloud-moon", "cloud-off", "cloud-rain-wind", "cloud-rain", "cloud-snow", "cloud-sun", "lucide-cloud", "cloudy", "clover", "code-2", "code", "codepen", "codesandbox", "coffee", "coins", "columns", "command", "compass", "contact", "contrast", "cookie", "copy", "copyleft", "copyright", "corner-down-left", "corner-down-right", "corner-left-down", "corner-left-up", "corner-right-down", "corner-right-up", "corner-up-left", "corner-up-right", "cpu", "credit-card", "crop", "lucide-cross", "crosshair", "crown", "currency", "database", "delete", "dice-1", "dice-2", "dice-3", "dice-4", "dice-5", "dice-6", "disc", "divide-circle", "divide-square", "divide", "dollar-sign", "download-cloud", "download", "dribbble", "droplet", "droplets", "drumstick", "edit-2", "edit-3", "edit", "egg", "equal-not", "equal", "eraser", "euro", "expand", "external-link", "eye-off", "eye", "facebook", "fast-forward", "feather", "figma", "file-check-2", "file-check", "file-code", "file-digit", "file-input", "file-minus-2", "file-minus", "file-output", "file-plus-2", "file-plus", "file-search", "file-text", "file-x-2", "file-x", "file", "files", "film", "filter", "flag-off", "flag-triangle-left", "flag-triangle-right", "flag", "flame", "flashlight-off", "flashlight", "flask-conical", "flask-round", "folder-minus", "folder-open", "folder-plus", "lucide-folder", "form-input", "forward", "frame", "framer", "frown", "function-square", "gamepad-2", "gamepad", "gauge", "gavel", "gem", "ghost", "gift", "git-branch-plus", "git-branch", "git-commit", "git-fork", "git-merge", "git-pull-request", "github", "gitlab", "glasses", "globe-2", "globe", "grab", "graduation-cap", "grid", "grip-horizontal", "grip-vertical", "hammer", "hand-metal", "hand", "hard-drive", "hard-hat", "hash", "haze", "headphones", "heart", "help-circle", "hexagon", "highlighter", "history", "home", "image-minus", "image-off", "image-plus", "image", "import", "inbox", "indent", "indian-rupee", "infinity", "lucide-info", "inspect", "instagram", "italic", "japanese-yen", "key", "keyboard", "landmark", "lucide-languages", "laptop-2", "laptop", "lasso-select", "lasso", "layers", "layout-dashboard", "layout-grid", "layout-list", "layout-template", "layout", "library", "life-buoy", "lightbulb-off", "lightbulb", "link-2-off", "link-2", "lucide-link", "linkedin", "list-checks", "list-minus", "list-ordered", "list-plus", "list-x", "list", "loader-2", "loader", "locate-fixed", "locate-off", "locate", "lock", "log-in", "log-out", "mail", "map-pin", "map", "maximize-2", "maximize", "megaphone", "meh", "menu", "message-circle", "message-square", "mic-off", "mic", "minimize-2", "minimize", "minus-circle", "minus-square", "minus", "monitor-off", "monitor-speaker", "monitor", "moon", "more-horizontal", "more-vertical", "mountain-snow", "mountain", "mouse-pointer-2", "mouse-pointer-click", "mouse-pointer", "mouse", "move-diagonal-2", "move-diagonal", "move-horizontal", "move-vertical", "move", "music", "navigation-2", "navigation", "network", "octagon", "option", "outdent", "package-check", "package-minus", "package-plus", "package-search", "package-x", "package", "palette", "palmtree", "paperclip", "pause-circle", "pause-octagon", "pause", "pen-tool", "lucide-pencil", "percent", "person-standing", "phone-call", "phone-forwarded", "phone-incoming", "phone-missed", "phone-off", "phone-outgoing", "phone", "pie-chart", "piggy-bank", "lucide-pin", "pipette", "plane", "play-circle", "play", "plug-zap", "plus-circle", "plus-square", "plus", "pocket", "podcast", "pointer", "pound-sterling", "power-off", "power", "printer", "qr-code", "quote", "radio-receiver", "radio", "redo", "refresh-ccw", "refresh-cw", "regex", "repeat-1", "repeat", "reply-all", "reply", "rewind", "rocket", "rocking-chair", "rotate-ccw", "rotate-cw", "rss", "ruler", "russian-ruble", "save", "scale", "scan-line", "scan", "scissors", "screen-share-off", "screen-share", "lucide-search", "send", "separator-horizontal", "separator-vertical", "server-crash", "server-off", "server", "settings-2", "settings", "share-2", "share", "sheet", "shield-alert", "shield-check", "shield-close", "shield-off", "shield", "shirt", "shopping-bag", "shopping-cart", "shovel", "shrink", "shuffle", "sidebar-close", "sidebar-open", "sidebar", "sigma", "signal-high", "signal-low", "signal-medium", "signal-zero", "signal", "skip-back", "skip-forward", "skull", "slack", "slash", "sliders", "smartphone-charging", "smartphone", "smile", "snowflake", "sort-asc", "sort-desc", "speaker", "sprout", "square", "star-half", "lucide-star", "stop-circle", "stretch-horizontal", "stretch-vertical", "strikethrough", "subscript", "sun", "sunrise", "sunset", "superscript", "swiss-franc", "switch-camera", "table", "tablet", "tag", "target", "tent", "terminal-square", "terminal", "text-cursor-input", "text-cursor", "thermometer-snowflake", "thermometer-sun", "thermometer", "thumbs-down", "thumbs-up", "ticket", "timer-off", "timer-reset", "timer", "toggle-left", "toggle-right", "tornado", "trash-2", "lucide-trash", "trello", "trending-down", "trending-up", "triangle", "truck", "tv-2", "tv", "twitch", "twitter", "type", "umbrella", "underline", "undo", "unlink-2", "unlink", "unlock", "upload-cloud", "upload", "user-check", "user-minus", "user-plus", "user-x", "user", "users", "verified", "vibrate", "video-off", "video", "view", "voicemail", "volume-1", "volume-2", "volume-x", "volume", "wallet", "wand", "watch", "waves", "webcam", "wifi-off", "wifi", "wind", "wrap-text", "wrench", "x-circle", "x-octagon", "x-square", "x", "youtube", "zap-off", "zap", "zoom-in", "zoom-out", "search-large", "lucide-search"];
/**
 * The original ICON_LIST contains duplicate entries (e.g. two "activity" items) and is not in alphabetical order. This list improves it.
 */
const ICON_LIST_SORTED_UNIQUE = uniqueArray(ICON_LIST).sort();

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * TODO: Rename to ShellCommandSettingsModal
 */
class ExtraOptionsModal extends SC_Modal {
    constructor(plugin, shell_command_id, setting_tab) {
        super(plugin);
        this.shell_command_id = shell_command_id;
        this.t_shell_command = plugin.getTShellCommands()[shell_command_id];
        this.name_setting = setting_tab.setting_groups[shell_command_id].name_setting;
        this.setting_tab = setting_tab;
    }
    onOpen() {
        super.onOpen();
        this.modalEl.createEl("h2", { text: this.t_shell_command.getDefaultShellCommand() }); // TODO: Use this.setTitle() instead.
        // Tabs
        this.tab_structure = createTabs(this.modalEl, {
            "extra-options-general": {
                title: "General",
                icon: "gear",
                content_generator: (container_element) => {
                    this.tabGeneral(container_element);
                },
            },
            "extra-options-preactions": {
                title: "Preactions",
                icon: "note-glyph",
                content_generator: (container_element) => {
                    this.tabPreactions(container_element);
                },
            },
            "extra-options-output": {
                title: "Output",
                icon: "lines-of-text",
                content_generator: (container_element) => {
                    this.tabOutput(container_element);
                },
            },
            "extra-options-environments": {
                title: "Environments",
                icon: "stacked-levels",
                content_generator: (container_element) => {
                    this.tabEnvironments(container_element);
                },
            },
            "extra-options-events": {
                title: "Events",
                icon: "dice",
                content_generator: (container_element) => {
                    this.tabEvents(container_element);
                },
            },
            "extra-options-variables": {
                title: "Variables",
                icon: "code-glyph",
                content_generator: (container_element) => {
                    this.tabVariables(container_element);
                },
            },
        });
        // Hotkeys for moving to next/previous shell command
        const switch_to_t_shell_command = (t_shell_command) => {
            const new_modal = new ExtraOptionsModal(this.plugin, t_shell_command.getId(), this.setting_tab);
            this.close(); // Needs to be closed before the new one is opened, otherwise the new one's tab content won't be shown.
            new_modal.open();
            new_modal.activateTab(this.tab_structure.active_tab_id);
        };
        this.scope.register(["Mod"], "ArrowUp", () => {
            if (this.t_shell_command.previousTShellCommand()) {
                switch_to_t_shell_command(this.t_shell_command.previousTShellCommand());
            }
        });
        this.scope.register(["Mod"], "ArrowDown", () => {
            if (this.t_shell_command.nextTShellCommand()) {
                switch_to_t_shell_command(this.t_shell_command.nextTShellCommand());
            }
        });
        new obsidian.Setting(this.modalEl)
            .setDesc("Tip! Hit " + CmdOrCtrl() + " + up/down to switch to previous/next shell command.");
    }
    tabGeneral(container_element) {
        // Alias field
        const alias_container = container_element.createDiv({ attr: { class: "SC-setting-group" } });
        new obsidian.Setting(alias_container)
            .setName("Alias");
        const on_alias_change = async (value) => {
            // Change the actual alias value
            this.t_shell_command.getConfiguration().alias = value;
            // Update Obsidian command palette
            this.t_shell_command.renameObsidianCommand(this.t_shell_command.getShellCommand(), this.t_shell_command.getAlias());
            // UpdateShell commands settings panel
            this.name_setting.nameEl.innerHTML = generateShellCommandFieldIconAndName(this.t_shell_command);
            // Save
            await this.plugin.saveSettings();
        };
        const alias_setting = new obsidian.Setting(alias_container)
            .addText(text => text
            .setValue(this.t_shell_command.getAlias())
            .onChange(on_alias_change))
            .setClass("SC-no-description");
        const alias_input_element = alias_setting.controlEl.find("input");
        alias_input_element.addClass("SC-focus-element-on-tab-opening"); // Focus without a need to click the field.
        if (this.plugin.settings.show_autocomplete_menu) {
            // Show autocomplete menu (= a list of available variables).
            createAutocomplete(this.plugin, alias_input_element, on_alias_change);
        }
        alias_container.createEl("p", { text: "If not empty, the alias will be displayed in the command palette instead of the actual command. An alias is never executed as a command." });
        alias_container.createEl("p", { text: "You can also use the same {{}} style variables in aliases that are used in shell commands. When variables are used in aliases, they do not affect the command execution in any way, but it's a nice way to reveal what values your command will use, even when an alias hides most of the other technical details. Starting a variable with {{! will prevent escaping special characters in command palette." });
        // Icon field
        const current_icon = this.t_shell_command.getConfiguration().icon;
        const icon_setting = new obsidian.Setting(container_element)
            .setDesc("If defined, the icon will be shown in file menu, folder menu, and editor menu in front of the alias text. It's also shown in the settings. It makes it easier to distinguish different shell commands visually from each other.")
            .addDropdown(dropdown => dropdown
            .addOption("no-icon", "No icon") // Need to use a non-empty string like "no-icon", because if 'value' would be "" then it becomes the same as 'display' from some reason, i.e. "No icon".
            .then((dropdown) => {
            // Iterate all available icons.
            for (const icon_id of ICON_LIST_SORTED_UNIQUE) {
                // Create an option for the icon.
                dropdown.addOption(icon_id, icon_id);
            }
            dropdown.setValue(current_icon ?? ""); // "" == the 'No icon' option.
        })
            .onChange(async (new_icon) => {
            if ("no-icon" === new_icon) {
                // Disable icon
                this.t_shell_command.getConfiguration().icon = null;
                // Remove the icon from the modal
                icon_setting.nameEl.innerHTML = "Icon";
            }
            else {
                // Set or change the icon
                this.t_shell_command.getConfiguration().icon = new_icon;
                // Update the icon in the modal
                icon_setting.nameEl.innerHTML = "Icon " + getIconHTML(new_icon);
            }
            // Update (or remove) the icon in the main settings panel
            this.name_setting.nameEl.innerHTML = generateShellCommandFieldIconAndName(this.t_shell_command);
            // Save settings
            await this.plugin.saveSettings();
        }));
        icon_setting.nameEl.innerHTML = "Icon " + getIconHTML(current_icon);
        // Confirm execution field
        new obsidian.Setting(container_element)
            .setName("Ask confirmation before execution")
            .addToggle(toggle => toggle
            .setValue(this.t_shell_command.getConfirmExecution())
            .onChange(async (value) => {
            this.t_shell_command.getConfiguration().confirm_execution = value;
            const icon_container = this.name_setting.nameEl.find("span.shell-commands-confirm-execution-icon-container");
            if (this.t_shell_command.getConfirmExecution()) {
                // Show icon
                icon_container.removeClass("SC-hide");
            }
            else {
                // Hide icon
                icon_container.addClass("SC-hide");
            }
            await this.plugin.saveSettings();
        }));
        // Shell command id
        new obsidian.Setting(container_element)
            .setDesc(`Shell command id: ${this.shell_command_id}`)
            .addExtraButton(button => button
            .setIcon("documents")
            .setTooltip(`Copy ${this.shell_command_id} to the clipboard.`)
            .onClick(() => {
            copyToClipboard(this.shell_command_id);
            this.plugin.newNotification(`${this.shell_command_id} was copied to the clipboard.`);
        }));
        if (this.t_shell_command.canAddToCommandPalette()) {
            // Only show Obsidian command palette id if the shell command is available in the command palette.
            const obsidian_command_id = this.t_shell_command.getObsidianCommand().id;
            new obsidian.Setting(container_element)
                .setDesc(`Obsidian command palette id: ${obsidian_command_id}`)
                .addExtraButton(button => button
                .setIcon("documents")
                .setTooltip(`Copy ${obsidian_command_id} to the clipboard.`)
                .onClick(() => {
                copyToClipboard(obsidian_command_id);
                this.plugin.newNotification(`${obsidian_command_id} was copied to the clipboard.`);
            }))
                .settingEl.addClass("SC-no-top-border") // No horizontal ruler between the two id elements.
            ;
        }
    }
    tabPreactions(container_element) {
        container_element.createEl("p", { text: "Preactions are performed before the actual shell command gets executed, to do certain preparations for the shell command." });
        const preactions_configuration = this.t_shell_command.getConfiguration().preactions;
        // Load config values
        let preaction_prompt_configuration = null;
        preactions_configuration.forEach((preaction_configuration) => {
            switch (preaction_configuration.type) {
                case "prompt":
                    preaction_prompt_configuration = preaction_configuration;
            }
        });
        // Preaction: Prompt
        const prompt_options = {};
        this.plugin.getPrompts().forEach((prompt) => {
            prompt_options[prompt.getID()] = prompt.getTitle();
        });
        let old_selected_prompt_option = (preaction_prompt_configuration?.enabled) ? preaction_prompt_configuration.prompt_id : "no-prompt";
        new obsidian.Setting(container_element)
            .setName("Prompt")
            .setDesc("Prompts are used to ask values from the user right before shell command execution. The values can be accessed in the shell command via custom variables. You can manage all prompts in the plugin's main settings view, under the 'Preactions' tab.")
            .addDropdown(dropdown => dropdown
            .addOption("no-prompt", "No prompt")
            .addOptions(prompt_options)
            .addOption("new", "Create a new prompt")
            .setValue(old_selected_prompt_option)
            .onChange(async (new_prompt_id) => {
            // Create a PreactionPromptConfiguration if it does not exist.
            if (!preaction_prompt_configuration) {
                preaction_prompt_configuration = getDefaultPreaction_Prompt_Configuration();
                preactions_configuration.push(preaction_prompt_configuration);
                this.t_shell_command.resetPreactions();
            }
            // Interpret the selection
            switch (new_prompt_id) {
                case "new": {
                    // Create a new Prompt.
                    const model = getModel(PromptModel.name);
                    const new_prompt = model.newInstance(this.plugin.settings);
                    this.plugin.saveSettings().then(() => {
                        const modal = new PromptSettingsModal(this.plugin, new_prompt, null, "Create prompt", async () => {
                            // Prompt is created.
                            dropdown.addOption(new_prompt.getID(), new_prompt.getTitle());
                            dropdown.setValue(new_prompt.getID());
                            preaction_prompt_configuration.enabled = true;
                            preaction_prompt_configuration.prompt_id = new_prompt.getID();
                            await this.plugin.saveSettings();
                            old_selected_prompt_option = dropdown.getValue();
                        }, async () => {
                            // Prompt creation was cancelled.
                            dropdown.setValue(old_selected_prompt_option); // Reset the dropdown selection.
                            model.deleteInstance(new_prompt);
                            await this.plugin.saveSettings();
                        });
                        modal.open();
                    });
                    break;
                }
                case "no-prompt": {
                    // Disable the prompt.
                    preaction_prompt_configuration.enabled = false;
                    this.t_shell_command.resetPreactions();
                    await this.plugin.saveSettings();
                    old_selected_prompt_option = dropdown.getValue();
                    break;
                }
                default: {
                    // Use an existing prompt.
                    preaction_prompt_configuration.enabled = true;
                    preaction_prompt_configuration.prompt_id = new_prompt_id;
                    await this.plugin.saveSettings();
                    old_selected_prompt_option = dropdown.getValue();
                    break;
                }
            }
        }));
    }
    tabOutput(container_element) {
        // Output channeling
        const stdout_channel_setting = this.newOutputChannelSetting(container_element, "Output channel for stdout", "stdout");
        this.newOutputChannelSetting(container_element, "Output channel for stderr", "stderr", "If both stdout and stderr use the same channel, stderr will be combined to same message with stdout.");
        // Output wrappers
        this.newOutputWrapperSetting(container_element, "Output wrapper for stdout", "stdout", "Output wrappers can be used to surround output with predefined text, e.g. to put output into a code block. Note: If 'Output mode' is 'Realtime', wrappers will probably appear multiple times in output!");
        this.newOutputWrapperSetting(container_element, "Output wrapper for stderr", "stderr");
        // Output handling mode
        new obsidian.Setting(container_element)
            .setName("Output handling mode")
            .setDesc("Set to 'Realtime' if your shell command runs for a long time AND you want output handling to start as soon as any outputted content is available. Output channels might be used multiple times during a single process. 'Wait until finished' postpones output handling until all output is received, and handles it as a single bunch. If uncertain, use the traditional 'Wait until finished'.")
            .addDropdown(dropdown => dropdown
            .addOptions({
            "buffered": "Wait until finished",
            "realtime": "Realtime (experimental)",
        })
            .setValue(this.t_shell_command.getConfiguration().output_handling_mode)
            .onChange(async (newMode) => {
            this.t_shell_command.getConfiguration().output_handling_mode = newMode;
            await this.plugin.saveSettings();
        }))
            // Documentation link
            .addExtraButton(icon => icon
            .setIcon("help")
            .onClick(() => gotoURL(DocumentationOutputHandlingModeLink))
            .setTooltip("Documentation: Output handling mode"));
        // Order of output channels
        new obsidian.Setting(container_element)
            .setName("Order of stdout/stderr output")
            .setDesc("When output contains both errors and normal output, which one should be presented first? (Only matters if 'Output handling' is 'Wait until finished').")
            .addDropdown(dropdown => dropdown
            .addOptions({
            "stdout-first": "Stdout first, then stderr.",
            "stderr-first": "Stderr first, then stdout.",
        })
            .setValue(this.t_shell_command.getOutputChannelOrder())
            .onChange(async (value) => {
            this.t_shell_command.getConfiguration().output_channel_order = value;
            await this.plugin.saveSettings();
        }));
        // Focus on the stdout channel dropdown field
        stdout_channel_setting.controlEl.find("select").addClass("SC-focus-element-on-tab-opening");
        // Ignore errors field
        new obsidian.Setting(container_element)
            .setName("Ignore error codes")
            .setDesc("A comma separated list of numbers. If executing a shell command fails with one of these exit codes, no error message will be displayed, and the above stderr channel will be ignored. Stdout channel will still be used for stdout. Error codes must be integers and greater than or equal to 0. Anything else will be removed. Note: If 'Output handling' is 'Realtime', no exit code based ignoring can be done, as an error code is only received when a shell command process finishes.")
            .addText(text => text
            .setValue(this.t_shell_command.getIgnoreErrorCodes().join(","))
            .onChange(async (value) => {
            // Parse the string of comma separated numbers
            const ignore_error_codes = [];
            const raw_error_codes = value.split(",");
            for (const i in raw_error_codes) {
                const raw_error_code = raw_error_codes[i];
                const error_code_candidate = parseInt(raw_error_code.trim()); // E.g. an empty string converts to NaN (= Not a Number).
                // Ensure that the error code is not NaN, 0 or a negative number.
                if (!isNaN(error_code_candidate) && error_code_candidate >= 0) {
                    // The candidate is legit.
                    ignore_error_codes.push(error_code_candidate);
                }
            }
            // Save the validated error numbers
            this.t_shell_command.getConfiguration().ignore_error_codes = ignore_error_codes;
            await this.plugin.saveSettings();
            // Update icon
            const icon_container = this.name_setting.nameEl.find("span.shell-commands-ignored-error-codes-icon-container");
            if (this.t_shell_command.getIgnoreErrorCodes().length) {
                // Show icon
                icon_container.setAttr("aria-label", generateIgnoredErrorCodesIconTitle(this.t_shell_command.getIgnoreErrorCodes()));
                icon_container.removeClass("SC-hide");
            }
            else {
                // Hide icon
                icon_container.addClass("SC-hide");
            }
        }));
    }
    tabEnvironments(container_element) {
        // Platform specific shell commands
        let platform_id;
        let is_first = true;
        for (platform_id in PlatformNames) {
            const setting_group = createPlatformSpecificShellCommandField(this.plugin, container_element, this.t_shell_command, platform_id, this.plugin.settings.show_autocomplete_menu);
            if (is_first) {
                // Focus on the first OS specific shell command field
                setting_group.shell_command_setting.controlEl.find("textarea").addClass("SC-focus-element-on-tab-opening");
                is_first = false;
            }
        }
        // Platform specific shell selection
        createShellSelectionField(this.plugin, container_element, this.t_shell_command.getShells(), false);
    }
    tabEvents(container_element) {
        // Command palette
        const command_palette_availability_setting = new obsidian.Setting(container_element)
            .setName("Availability in Obsidian's command palette")
            .addDropdown(dropdown => dropdown
            .addOptions(CommandPaletteOptions)
            .setValue(this.t_shell_command.getConfiguration().command_palette_availability)
            .onChange(async (value) => {
            // Store value
            this.t_shell_command.getConfiguration().command_palette_availability = value;
            // Update command palette
            if (this.t_shell_command.canAddToCommandPalette()) {
                // Register to command palette
                this.t_shell_command.registerToCommandPalette();
            }
            else {
                // Unregister from command palette
                this.t_shell_command.unregisterFromCommandPalette();
            }
            // Save
            await this.plugin.saveSettings();
        }));
        // Focus on the command palette availability field
        command_palette_availability_setting.controlEl.find("select").addClass("SC-focus-element-on-tab-opening");
        // Events
        new obsidian.Setting(container_element)
            .setName("Execute this shell command automatically when:")
            .setHeading() // Make the name bold
        ;
        getSC_Events(this.plugin).forEach((sc_event) => {
            const is_event_enabled = this.t_shell_command.isSC_EventEnabled(sc_event.static().getCode());
            const summary_of_extra_variables = sc_event.getSummaryOfEventVariables();
            new obsidian.Setting(container_element)
                .setName(sc_event.static().getTitle())
                .setDesc(summary_of_extra_variables ? "Additional variables: " + summary_of_extra_variables : "")
                .addToggle(toggle => toggle
                .setValue(is_event_enabled)
                .onChange(async (enable) => {
                if (enable) {
                    // Enable the event
                    this.t_shell_command.enableSC_Event(sc_event);
                    extra_settings_container.style.display = "block"; // Show extra settings
                }
                else {
                    // Disable the event
                    this.t_shell_command.disableSC_Event(sc_event);
                    extra_settings_container.style.display = "none"; // Hide extra settings
                }
                // Save
                await this.plugin.saveSettings();
            }))
                // Documentation icon
                .addExtraButton(icon => icon
                .setIcon("help")
                .onClick(() => gotoURL(sc_event.static().getDocumentationLink()))
                .setTooltip("Documentation: " + sc_event.static().getTitle() + " event"));
            // Extra settings
            const extra_settings_container = container_element.createDiv();
            extra_settings_container.style.display = is_event_enabled ? "block" : "none";
            sc_event.createExtraSettingsFields(extra_settings_container, this.t_shell_command);
        });
    }
    tabVariables(container_element) {
        // Default values for variables
        new obsidian.Setting(container_element)
            .setName("Default values for variables")
            .setDesc("Certain variables can be inaccessible during certain situations, e.g. {{file_name}} is not available when no file pane is focused. You can define default values that will be used when a variable is otherwise unavailable.")
            .setHeading();
        // Add default value fields for each variable that can have a default value.
        for (const variable of this.plugin.getVariables()) {
            // Only add fields for variables that are not always accessible.
            if (!variable.isAlwaysAvailable()) {
                // Get an identifier for a variable (an id, if it's a CustomVariable, otherwise the variable's name).
                const variable_identifier = variable.getIdentifier();
                // If a default value has defined for this variable (and this TShellCommand), retrieve the configuration.
                let default_value_configuration = this.t_shell_command.getDefaultValueConfigurationForVariable(variable); // NOTE that this can be UNDEFINED!
                // A function for creating configuration in onChange() callbacks if the variable does not yet have one for this TShellCommand.
                const create_default_value_configuration = () => {
                    const configuration = {
                        type: "show-errors",
                        value: "",
                    };
                    this.t_shell_command.getConfiguration().variable_default_values[variable_identifier] = configuration;
                    return configuration;
                };
                let textarea_component;
                // A function for updating textarea_component visibility.
                const update_textarea_component_visibility = (type) => {
                    if ("value" === type) {
                        textarea_component.inputEl.removeClass("SC-hide");
                    }
                    else {
                        textarea_component.inputEl.addClass("SC-hide");
                    }
                };
                // Create the default value setting
                new obsidian.Setting(container_element)
                    .setName(variable.getFullName())
                    .setDesc("If not available, then:")
                    .setTooltip(variable.getAvailabilityTextPlain())
                    .addDropdown(dropdown => dropdown
                    .addOptions({
                    "show-errors": "Cancel execution and show errors",
                    "cancel-silently": "Cancel execution silently",
                    "value": "Execute with value:",
                })
                    .setValue(default_value_configuration ? default_value_configuration.type : "show-errors")
                    .onChange(async (new_type) => {
                    if (!default_value_configuration) {
                        default_value_configuration = create_default_value_configuration();
                    }
                    // Set the new type
                    default_value_configuration.type = new_type;
                    if ("show-errors" === new_type && default_value_configuration.value === "") {
                        // If "show-errors" is selected and no text value is typed, the configuration file can be cleaned up by removing this configuration object completely.
                        // Prevent deleting, if a text value is present, because the user might want to keep it if they will later change 'type' to 'value'.
                        delete this.t_shell_command.getConfiguration().variable_default_values[variable_identifier];
                    }
                    // Show/hide the textarea
                    update_textarea_component_visibility(new_type);
                    // Save the settings
                    await this.plugin.saveSettings();
                }))
                    .addTextArea(textarea => textarea_component = textarea
                    .setValue(default_value_configuration ? default_value_configuration.value : "")
                    .onChange(async (new_value) => {
                    if (!default_value_configuration) {
                        default_value_configuration = create_default_value_configuration();
                    }
                    // Set the new text value
                    default_value_configuration.value = new_value;
                    // Save the settings
                    await this.plugin.saveSettings();
                }).then((textarea_component) => {
                    // Autocomplete for the textarea.
                    if (this.plugin.settings.show_autocomplete_menu) {
                        createAutocomplete(this.plugin, textarea_component.inputEl, () => textarea_component.onChanged());
                    }
                }));
                update_textarea_component_visibility(default_value_configuration ? default_value_configuration.type : "show-errors");
            }
        }
    }
    activateTab(tab_id) {
        if (undefined === this.tab_structure.buttons[tab_id]) {
            throw Error("Invalid tab id: " + tab_id);
        }
        this.tab_structure.buttons[tab_id].click();
    }
    newOutputChannelSetting(container_element, title, output_stream_name, description = "") {
        const output_channel_options = getOutputChannelsOptionList(output_stream_name);
        return new obsidian.Setting(container_element)
            .setName(title)
            .setDesc(description)
            .addDropdown(dropdown => dropdown
            .addOptions(output_channel_options)
            .setValue(this.t_shell_command.getOutputChannels()[output_stream_name])
            .onChange(async (value) => {
            this.t_shell_command.getConfiguration().output_channels[output_stream_name] = value;
            await this.plugin.saveSettings();
        }));
    }
    newOutputWrapperSetting(container_element, title, output_stream_name, description = "") {
        const output_wrapper_options = {};
        this.plugin.getOutputWrappers().forEach((output_wrapper) => {
            output_wrapper_options[output_wrapper.getID()] = output_wrapper.getTitle();
        });
        const output_wrappers = this.t_shell_command.getConfiguration().output_wrappers;
        let old_selected_output_wrapper_option = (output_wrappers[output_stream_name]) ? output_wrappers[output_stream_name] : "no-output-wrapper";
        return new obsidian.Setting(container_element)
            .setName(title)
            .setDesc(description)
            .addDropdown(dropdown_component => dropdown_component
            .addOption("no-output-wrapper", "No " + output_stream_name + " wrapper")
            .addOptions(output_wrapper_options)
            .addOption("new", "Create a new output wrapper")
            .setValue(old_selected_output_wrapper_option)
            .onChange(async (output_wrapper_id) => {
            switch (output_wrapper_id) {
                case "new": {
                    // Create a new OutputWrapper.
                    const output_wrapper_model = getModel(OutputWrapperModel.name);
                    const new_output_wrapper = output_wrapper_model.newInstance(this.plugin.settings);
                    this.plugin.saveSettings().then(() => {
                        const modal = new OutputWrapperSettingsModal(this.plugin, new_output_wrapper, null, "Create output wrapper", async () => {
                            // Output wrapper is created.
                            dropdown_component.addOption(new_output_wrapper.getID(), new_output_wrapper.getTitle());
                            dropdown_component.setValue(new_output_wrapper.getID());
                            output_wrappers[output_stream_name] = new_output_wrapper.getID();
                            await this.plugin.saveSettings();
                            old_selected_output_wrapper_option = dropdown_component.getValue();
                        }, async () => {
                            // Prompt creation was cancelled.
                            dropdown_component.setValue(old_selected_output_wrapper_option); // Reset the dropdown selection.
                            output_wrapper_model.deleteInstance(new_output_wrapper);
                            await this.plugin.saveSettings();
                        });
                        modal.open();
                    });
                    break;
                }
                case "no-output-wrapper": {
                    // Disable output wrapper.
                    output_wrappers[output_stream_name] = null;
                    await this.plugin.saveSettings();
                    break;
                }
                default: {
                    // Use an existing output wrapper.
                    output_wrappers[output_stream_name] = output_wrapper_id;
                    await this.plugin.saveSettings();
                    break;
                }
            }
        }));
    }
    approve() {
        // No need to perform any action, just close the modal.
        this.close();
    }
}
ExtraOptionsModal.GENERAL_OPTIONS_SUMMARY = "Alias, Icon, Confirmation";
ExtraOptionsModal.PREACTIONS_OPTIONS_SUMMARY = "Preactions: Prompt for asking values from user";
ExtraOptionsModal.OUTPUT_OPTIONS_SUMMARY = "Stdout/stderr handling, Ignore errors";
ExtraOptionsModal.ENVIRONMENTS_OPTIONS_SUMMARY = "Shell selection, Operating system specific shell commands";
ExtraOptionsModal.EVENTS_SUMMARY = "Events";
ExtraOptionsModal.VARIABLES_SUMMARY = "Default values for variables";

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * TODO: Rename to DeleteShellCommandModal
 */
class DeleteModal extends SC_Modal {
    constructor(plugin, shell_command_id, setting_group, shell_command_element) {
        super(plugin);
        this.shell_command_id = shell_command_id;
        this.t_shell_command = plugin.getTShellCommands()[shell_command_id];
        this.setting_group = setting_group;
        this.shell_command_element = shell_command_element;
    }
    onOpen() {
        super.onOpen();
        this.modalEl.createEl("h2", { text: "Delete: " + this.t_shell_command.getShellCommand() }); // TODO: Use this.setTitle() instead.
        if (this.t_shell_command.getAlias()) {
            this.modalEl.createEl("p", { text: "Alias: " + this.t_shell_command.getAlias() });
        }
        this.modalEl.createEl("p", { text: "Are you sure you want to delete this shell command?" });
        const delete_button = this.modalEl.createEl("button", { text: "Yes, delete" });
        delete_button.onclick = async () => this.approve();
    }
    async approve() {
        // Unregister possible events in order to prevent them becoming ghosts that just keep executing even after removing the configuration.
        this.t_shell_command.unregisterSC_Events();
        // Remove the command
        debugLog("Command " + this.shell_command_id + " gonna be removed.");
        this.t_shell_command.unregisterFromCommandPalette(); // Remove from the command palette.
        delete this.plugin.getTShellCommands()[this.shell_command_id]; // Remove the TShellCommand object.
        const shell_command_index = this.plugin.getShellCommandConfigurationIndex(this.shell_command_id);
        this.plugin.settings.shell_commands.splice(shell_command_index, 1); // Remove from the plugin's settings.
        // Remove the setting fields
        this.shell_command_element.remove();
        await this.plugin.saveSettings();
        debugLog("Command removed.");
        this.close();
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 *
 * @param plugin
 * @param container_element
 * @param setting_tab
 * @param shell_command_id Either a string formatted integer ("0", "1" etc) or "new" if it's a field for a command that does not exist yet.
 * @param show_autocomplete_menu
 */
function createShellCommandField(plugin, container_element, setting_tab, shell_command_id, show_autocomplete_menu) {
    const is_new = "new" === shell_command_id;
    let t_shell_command;
    if (is_new) {
        // Create an empty command
        t_shell_command = plugin.newTShellCommand();
        shell_command_id = t_shell_command.getId(); // Replace "new" with a real id.
    }
    else {
        // Use an old shell command
        t_shell_command = plugin.getTShellCommands()[shell_command_id];
    }
    debugLog("Create command field for command #" + shell_command_id + (is_new ? " (NEW)" : ""));
    let shell_command;
    if (is_new) {
        shell_command = "";
    }
    else {
        shell_command = t_shell_command.getDefaultShellCommand();
    }
    // Wrap all shell command setting elements in a single div.
    const shell_command_element = container_element.createDiv();
    shell_command_element.addClass("SC-id-" + shell_command_id);
    const setting_group = CreateShellCommandFieldCore(plugin, shell_command_element, generateShellCommandFieldIconAndName(t_shell_command), shell_command, t_shell_command.getShell(), t_shell_command, show_autocomplete_menu, async (shell_command) => {
        if (is_new) {
            debugLog("Creating new command " + shell_command_id + ": " + shell_command);
        }
        else {
            debugLog("Command " + shell_command_id + " gonna change to: " + shell_command);
        }
        // Do this in both cases, when creating a new command and when changing an old one:
        t_shell_command.getConfiguration().platform_specific_commands.default = shell_command;
        if (is_new) {
            // Create a new command
            // plugin.registerShellCommand(t_shell_command); // I don't think this is needed to be done anymore
            debugLog("Command created.");
        }
        else {
            // Change an old command
            t_shell_command.renameObsidianCommand(t_shell_command.getShellCommand(), t_shell_command.getAlias()); // Change the command's name in Obsidian's command palette and in hotkey settings.
            debugLog("Command changed.");
        }
        await plugin.saveSettings();
    });
    setting_tab.setting_groups[shell_command_id] = setting_group;
    // Primary icon buttons
    setting_group.name_setting
        .addExtraButton(button => button
        .setTooltip("Normal click: Execute now. " + CmdOrCtrl() + " + click: Execute and ask what to do with output.")
        .setIcon("run-command")
        .extraSettingsEl.addEventListener("click", async (event) => {
        const ctrl_clicked = event.ctrlKey;
        // Execute the shell command now (for trying it out in the settings)
        const parsing_process = t_shell_command.createParsingProcess(null); // No SC_Event is available when executing shell commands manually.
        if (await parsing_process.process()) {
            const executor = new ShellCommandExecutor(plugin, t_shell_command, null); // No SC_Event is available when manually executing the shell command.
            await executor.doPreactionsAndExecuteShellCommand(parsing_process, ctrl_clicked ? "modal" : undefined // If ctrl/cmd is pressed, override output channels with 'Ask after execution' modal. Otherwise, use undefined to indicate that the shell command's normal output channels should be used.
            );
        }
        else {
            parsing_process.displayErrorMessages();
        }
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.GENERAL_OPTIONS_SUMMARY)
        .onClick(async () => {
        // Open an extra options modal: General tab
        const modal = new ExtraOptionsModal(plugin, shell_command_id, setting_tab);
        modal.open();
        modal.activateTab("extra-options-general");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.PREACTIONS_OPTIONS_SUMMARY)
        .setIcon("note-glyph")
        .onClick(async () => {
        // Open an extra options modal: Preactions tab
        const modal = new ExtraOptionsModal(plugin, shell_command_id, setting_tab);
        modal.open();
        modal.activateTab("extra-options-preactions");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.OUTPUT_OPTIONS_SUMMARY)
        .setIcon("lines-of-text")
        .onClick(async () => {
        // Open an extra options modal: Output tab
        const modal = new ExtraOptionsModal(plugin, shell_command_id, setting_tab);
        modal.open();
        modal.activateTab("extra-options-output");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.ENVIRONMENTS_OPTIONS_SUMMARY)
        .setIcon("stacked-levels")
        .onClick(async () => {
        // Open an extra options modal: Environments tab
        const modal = new ExtraOptionsModal(plugin, shell_command_id, setting_tab);
        modal.open();
        modal.activateTab("extra-options-environments");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.EVENTS_SUMMARY)
        .setIcon("dice")
        .onClick(async () => {
        // Open an extra options modal: Events tab
        const modal = new ExtraOptionsModal(plugin, shell_command_id, setting_tab);
        modal.open();
        modal.activateTab("extra-options-events");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.VARIABLES_SUMMARY)
        .setIcon("code-glyph")
        .onClick(async () => {
        // Open an extra options modal: Variables tab
        const modal = new ExtraOptionsModal(plugin, shell_command_id, setting_tab);
        modal.open();
        modal.activateTab("extra-options-variables");
    }))
        .addExtraButton(button => button
        .setTooltip("Delete this shell command")
        .setIcon("trash")
        .onClick(async () => {
        // Open a delete modal
        const modal = new DeleteModal(plugin, shell_command_id, setting_group, shell_command_element);
        modal.open();
    }));
    // Informational icons (= non-clickable)
    const icon_container = setting_group.name_setting.nameEl.createEl("span", { attr: { class: "SC-main-icon-container" } });
    // "Ask confirmation" icon.
    const confirm_execution_icon_container = icon_container.createEl("span", { attr: { "aria-label": "Asks confirmation before execution.", class: "shell-commands-confirm-execution-icon-container" } });
    obsidian.setIcon(confirm_execution_icon_container, "languages");
    if (!t_shell_command.getConfirmExecution()) {
        // Do not display the icon for commands that do not use confirmation.
        confirm_execution_icon_container.addClass("SC-hide");
    }
    // "Ignored error codes" icon
    const ignored_error_codes_icon_container = icon_container.createEl("span", { attr: { "aria-label": generateIgnoredErrorCodesIconTitle(t_shell_command.getIgnoreErrorCodes()), class: "shell-commands-ignored-error-codes-icon-container" } });
    obsidian.setIcon(ignored_error_codes_icon_container, "strikethrough-glyph");
    if (!t_shell_command.getIgnoreErrorCodes().length) {
        // Do not display the icon for commands that do not ignore any errors.
        ignored_error_codes_icon_container.addClass("SC-hide");
    }
    // Secondary icon buttons
    setting_group.preview_setting.addExtraButton(button => button
        .setIcon("link")
        .setTooltip("Copy this shell command's Obsidian URI to the clipboard. Visiting the URI executes the shell command. " + CmdOrCtrl() + " + click: Copy a markdown link.")
        // onClick() handler - use a custom one instead of ExtraButtonComponent.onClick(), because Obsidian API (at least v. 0.14.8) does not support detecting CTRL press. https://forum.obsidian.md/t/fr-settings-pass-mouseevent-to-extrabuttoncomponent-onclick/37177
        .extraSettingsEl.addEventListener("click", (event) => {
        const ctrl_clicked = event.ctrlKey;
        const execution_uri = t_shell_command.getExecutionURI();
        let result;
        if (ctrl_clicked) {
            // A full link is wanted.
            result = `[${escapeMarkdownLinkCharacters(t_shell_command.getAlias())}](${escapeMarkdownLinkCharacters(execution_uri)})`;
        }
        else {
            // Only the URI is wanted.
            result = execution_uri;
        }
        copyToClipboard(result);
        plugin.newNotification("Copied to clipboard: " + os.EOL + result);
    }));
    if (t_shell_command.canHaveHotkeys()) {
        setting_group.preview_setting.addExtraButton(button => button
            .setIcon("any-key")
            .setTooltip("Go to hotkey settings.")
            .onClick(() => {
            // The most important parts of this closure function are copied 2022-04-27 from https://github.com/pjeby/hotkey-helper/blob/c8a032e4c52bd9ce08cb909cec15d1ed9d0a3439/src/plugin.js#L436-L442 (also from other lines of the same file).
            // @ts-ignore This is private API access. Not good, but then again the feature is not crucial - if it breaks, it won't interrupt anything important.
            plugin.app.setting?.openTabById("hotkeys");
            // @ts-ignore
            const hotkeys_settings_tab = plugin.app.setting.settingTabs.filter(tab => tab.id === "hotkeys").shift();
            if (hotkeys_settings_tab && hotkeys_settings_tab.searchInputEl && hotkeys_settings_tab.updateHotkeyVisibility) {
                debugLog("Hotkeys: Filtering by shell command " + t_shell_command.getObsidianCommand().name);
                hotkeys_settings_tab.searchInputEl.value = t_shell_command.getObsidianCommand().name;
                hotkeys_settings_tab.updateHotkeyVisibility();
            }
            else {
                debugLog("Hotkeys: Cannot do filtering due to API changes.");
            }
        }));
    }
    // Add hotkey information
    if (!is_new && t_shell_command.canHaveHotkeys()) {
        const hotkeys = getHotkeysForShellCommand(plugin, shell_command_id);
        if (hotkeys) {
            let hotkeys_joined = "";
            hotkeys.forEach((hotkey) => {
                if (hotkeys_joined) {
                    hotkeys_joined += "<br>";
                }
                hotkeys_joined += HotkeyToString(hotkey);
            });
            const hotkey_div = setting_group.preview_setting.controlEl.createEl("div", { attr: { class: "setting-item-description SC-hotkey-info" } });
            // Comment out the icon because it would look like a clickable button (as there are other clickable icons in the settings).
            // setIcon(hotkey_div, "any-key", 22); // Hotkey icon
            hotkey_div.insertAdjacentHTML("beforeend", " " + hotkeys_joined);
        }
    }
    debugLog("Created.");
}
/**
 * @param t_shell_command
 * @public Exported because ShellCommandExtraOptionsModal uses this too.
 */
function generateShellCommandFieldIconAndName(t_shell_command) {
    const icon_html = t_shell_command.getIconHTML() + " ";
    if (t_shell_command.getAlias()) {
        return icon_html + t_shell_command.getAlias();
    }
    return icon_html + "Shell command without alias";
}
/**
 * @param ignored_error_codes
 * @public Exported because ShellCommandExtraOptionsModal uses this too.
 */
function generateIgnoredErrorCodesIconTitle(ignored_error_codes) {
    const plural = ignored_error_codes.length !== 1 ? "s" : "";
    return "Ignored error" + plural + ": " + ignored_error_codes.join(",");
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_MainSettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.setting_groups = {};
        this.last_position = {
            scroll_position: 0,
            tab_name: "main-shell-commands",
        };
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        this.tab_structure = createTabs(containerEl, {
            "main-shell-commands": {
                title: "Shell commands",
                icon: "run-command",
                content_generator: (container_element) => {
                    this.tabShellCommands(container_element);
                },
            },
            "main-environments": {
                title: "Environments",
                icon: "stacked-levels",
                content_generator: (container_element) => {
                    this.tabEnvironments(container_element);
                },
            },
            "main-preactions": {
                title: "Preactions",
                icon: "note-glyph",
                content_generator: (container_element) => {
                    this.tabPreactions(container_element);
                },
            },
            "main-output": {
                title: "Output",
                icon: "lines-of-text",
                content_generator: (container_element) => {
                    this.tabOutput(container_element);
                },
            },
            "main-events": {
                title: "Events",
                icon: "dice",
                content_generator: (container_element) => {
                    this.tabEvents(container_element);
                },
            },
            "main-variables": {
                title: "Variables",
                icon: "code-glyph",
                content_generator: (container_element) => {
                    this.tabVariables(container_element);
                },
            },
        });
        // Documentation link & GitHub links
        containerEl.createEl("p").insertAdjacentHTML("beforeend", "<a href=\"" + DocumentationMainLink + "\">Documentation</a> - " +
            "<a href=\"" + GitHubLink + "\">SC on GitHub</a> - " +
            "<a href=\"" + ChangelogLink + "\">SC version: " + this.plugin.getPluginVersion() + "</a>");
        // Copyright notice
        const copyright_paragraph = containerEl.createEl("p");
        copyright_paragraph.addClass("SC-small-font");
        copyright_paragraph.insertAdjacentHTML("beforeend", `
            <em>Shell commands</em> plugin Copyright &copy; 2021 - 2022 Jarkko Linnanvirta. This program comes with ABSOLUTELY NO WARRANTY. This is free software, and you are welcome to redistribute it under certain conditions. See more information in the license: <a href="${LicenseLink}">GNU GPL-3.0</a>.
        `);
        // KEEP THIS AFTER CREATING ALL ELEMENTS:
        this.rememberLastPosition(containerEl);
    }
    tabShellCommands(container_element) {
        // Show a search field
        this.createSearchField(container_element);
        // A <div> element for all command input fields. New command fields can be created at the bottom of this element.
        const command_fields_container = container_element.createEl("div");
        // Fields for modifying existing commands
        let shell_commands_exist = false;
        for (const command_id in this.plugin.getTShellCommands()) {
            createShellCommandField(this.plugin, command_fields_container, this, command_id, this.plugin.settings.show_autocomplete_menu);
            shell_commands_exist = true;
        }
        // 'No shell commands yet' paragraph.
        const no_shell_commands_paragraph = container_element.createEl("p", { text: "No shell commands yet, click the 'New shell command' button below." });
        if (shell_commands_exist) {
            // Shell commands exist, so do not show the "No shell commands yet" text.
            no_shell_commands_paragraph.hide();
        }
        // "New command" button
        new obsidian.Setting(container_element)
            .addButton(button => button
            .setButtonText("New shell command")
            .onClick(async () => {
            createShellCommandField(this.plugin, command_fields_container, this, "new", this.plugin.settings.show_autocomplete_menu);
            no_shell_commands_paragraph.hide();
            debugLog("New empty command created.");
        }));
    }
    createSearchField(container_element) {
        const search_container = container_element.createDiv();
        const search_title = "Search shell commands";
        const search_setting = new obsidian.Setting(search_container)
            .setName(search_title)
            .setDesc("Looks up shell commands' aliases, commands, ids and icons.")
            .addSearch(search_component => search_component
            .onChange((search_term) => {
            let count_matches = 0;
            for (const shell_command_id in this.plugin.getTShellCommands()) {
                let matched = false;
                // Check if a search term was defined.
                if ("" == search_term) {
                    // Show all shell commands.
                    matched = true;
                }
                else {
                    // A search term is defined.
                    // Define fields where to look for the search term
                    const t_shell_command = this.plugin.getTShellCommands()[shell_command_id];
                    const search_targets = [
                        t_shell_command.getId(),
                        t_shell_command.getConfiguration().alias,
                    ];
                    search_targets.push(...Object.values(t_shell_command.getPlatformSpecificShellCommands()));
                    // Only include icon in the search if it's defined.
                    if (t_shell_command.getConfiguration().icon) {
                        search_targets.push(t_shell_command.getConfiguration().icon);
                    }
                    // Check if it's a match
                    search_targets.forEach((search_target) => {
                        if (search_target.toLocaleLowerCase().contains(search_term.toLocaleLowerCase())) {
                            matched = true;
                            debugLog("Search " + search_term + " MATCHED " + search_target);
                        }
                    });
                }
                // Show or hide the shell command.
                const shell_command_element = document.querySelector("div.SC-id-" + shell_command_id);
                if (!shell_command_element) {
                    throw new Error("Shell command setting element does not exist with selector div.SC-id-" + shell_command_id);
                }
                if (matched) {
                    shell_command_element.removeClass("SC-hide");
                    count_matches++;
                }
                else {
                    shell_command_element.addClass("SC-hide");
                }
            }
            // Display match count
            if ("" == search_term) {
                // Don't show match count.
                search_setting.setName(search_title);
            }
            else {
                // Show match count.
                switch (count_matches) {
                    case 0: {
                        search_setting.setName("No matches");
                        break;
                    }
                    case 1: {
                        search_setting.setName("1 match");
                        break;
                    }
                    default: {
                        search_setting.setName(count_matches + " matches");
                        break;
                    }
                }
            }
        }).then((search_component) => {
            // Focus on the search field.
            search_component.inputEl.addClass("SC-focus-element-on-tab-opening");
        }));
    }
    tabEvents(container_element) {
        // A general description about events
        container_element.createEl("p", { text: "Events introduce a way to execute shell commands automatically in certain situations, e.g. when Obsidian starts. They are set up for each shell command separately, but this tab contains general options for them." });
        // Enable/disable all events
        new obsidian.Setting(container_element)
            .setName("Enable events")
            .setDesc("This is a quick way to immediately turn off all events, if you want.")
            .addToggle(toggle => toggle
            .setValue(this.plugin.settings.enable_events)
            .onChange(async (enable_events) => {
            // The toggle was clicked.
            this.plugin.settings.enable_events = enable_events;
            if (enable_events) {
                // Register events.
                this.plugin.registerSC_Events(true);
            }
            else {
                // Unregister events.
                this.plugin.unregisterSC_Events();
            }
            await this.plugin.saveSettings();
        }));
        // A list of current enable events
        container_element.createEl("p", { text: "The following gives just a quick glance over which events are enabled on which shell commands. To enable/disable events for a shell command, go to the particular shell command's settings via the 'Shell commands' tab. The list is only updated when you reopen the whole settings panel." });
        let found_enabled_event = false;
        getSC_Events(this.plugin).forEach((sc_event) => {
            const event_enabled_t_shell_commands = sc_event.getTShellCommands();
            // Has the event been enabled for any shell commands?
            if (event_enabled_t_shell_commands.length) {
                // Yes, it's enabled.
                // Show a list of shell commands
                const paragraph_element = container_element.createEl("p", { text: sc_event.static().getTitle() });
                const list_element = paragraph_element.createEl("ul");
                event_enabled_t_shell_commands.forEach((t_shell_command) => {
                    list_element.createEl("li", { text: t_shell_command.getAliasOrShellCommand() });
                });
                found_enabled_event = true;
            }
        });
        if (!found_enabled_event) {
            container_element.createEl("p", { text: "No events are enabled for any shell commands." });
        }
    }
    tabVariables(container_element) {
        // "Preview variables in command palette" field
        new obsidian.Setting(container_element)
            .setName("Preview variables in command palette and menus")
            .setDesc("If on, variable names are substituted with their realtime values when you view your commands in the command palette and right click context menus (if used). A nice way to ensure your commands will use correct values.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.preview_variables_in_command_palette)
            .onChange(async (value) => {
            debugLog("Changing preview_variables_in_command_palette to " + value);
            this.plugin.settings.preview_variables_in_command_palette = value;
            await this.plugin.saveSettings();
        }));
        // "Show autocomplete menu" field
        new obsidian.Setting(container_element)
            .setName("Show autocomplete menu")
            .setDesc("If on, a dropdown menu shows up when you begin writing {{variable}} names, showing matching variables and their instructions. Also allows defining custom suggestions in autocomplete.yaml file - see the documentation.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.show_autocomplete_menu)
            .onChange(async (value) => {
            debugLog("Changing show_autocomplete_menu to " + value);
            this.plugin.settings.show_autocomplete_menu = value;
            this.display(); // Re-render the whole settings view to apply the change.
            await this.plugin.saveSettings();
        }))
            .addExtraButton(extra_button => extra_button
            .setIcon("help")
            .setTooltip("Documentation: Autocomplete")
            .onClick(() => {
            gotoURL(DocumentationAutocompleteLink);
        }));
        // Custom variables
        new obsidian.Setting(container_element)
            .setName("Custom variables")
            .setHeading() // Make the "Variables" text bold.
            .addExtraButton(extra_button => extra_button
            .setIcon("pane-layout")
            .setTooltip("Open a pane that displays all custom variables and their values.")
            .onClick(() => {
            this.plugin.createCustomVariableView();
        }))
            .addExtraButton(extra_button => extra_button
            .setIcon("help")
            .setTooltip("Documentation: Custom variables")
            .onClick(() => {
            gotoURL(DocumentationCustomVariablesLink);
        }));
        // Settings for each CustomVariable
        const custom_variable_model = getModel(CustomVariableModel.name);
        const custom_variable_container = container_element.createDiv();
        this.plugin.getCustomVariableInstances().forEach((custom_variable_instance) => {
            custom_variable_model.createSettingFields(custom_variable_instance, custom_variable_container);
        });
        createNewModelInstanceButton(this.plugin, CustomVariableModel.name, container_element, custom_variable_container, this.plugin.settings).then();
        // Built-in variable instructions
        new obsidian.Setting(container_element)
            .setName("Built-in variables")
            .setHeading() // Make the "Variables" text bold.
            .addExtraButton(extra_button => extra_button
            .setIcon("help")
            .setTooltip("Documentation: Built-in variables")
            .onClick(() => {
            gotoURL(DocumentationBuiltInVariablesLink);
        }));
        const variables = this.plugin.getVariables();
        variables.forEach((variable) => {
            if (!(variable instanceof CustomVariable)) {
                const paragraph = container_element.createEl("p");
                paragraph.insertAdjacentHTML("afterbegin", variable.getHelpName() +
                    "<br>" +
                    variable.help_text);
                const availability_text = variable.getAvailabilityText();
                if (availability_text) {
                    paragraph.insertAdjacentHTML("beforeend", "<br>" + availability_text);
                }
            }
        });
        container_element.createEl("p", { text: "When you type variables into commands, a preview text appears under the command field to show how the command will look like when it gets executed with variables substituted with their real values." });
        container_element.createEl("p", { text: "Special characters in variable values are tried to be escaped (except if you use CMD as the shell in Windows). This is to improve security so that a variable won't accidentally cause bad things to happen. If you want to use a raw, unescaped value, add an exclamation mark before the variable's name, e.g. {{!title}}, but be careful, it's dangerous!" });
        container_element.createEl("p", { text: "There is no way to prevent variable parsing. If you need {{ }} characters in your command, they won't be parsed as variables as long as they do not contain any of the variable names listed below. If you would need to pass e.g. {{title}} literally to your command, there is no way to do it atm, please create a discussion in GitHub." });
        container_element.createEl("p", { text: "All variables that access the current file, may cause the command preview to fail if you had no file panel active when you opened the settings window - e.g. you had focus on graph view instead of a note = no file is currently active. But this does not break anything else than the preview." });
    }
    tabEnvironments(container_element) {
        // "Working directory" field
        new obsidian.Setting(container_element)
            .setName("Working directory")
            .setDesc("A directory where your commands will be run. If empty, defaults to your vault's location. Can be relative (= a folder in the vault) or absolute (= complete from filesystem root).")
            .addText(text => text
            .setPlaceholder(getVaultAbsolutePath(this.app))
            .setValue(this.plugin.settings.working_directory)
            .onChange(async (value) => {
            debugLog("Changing working_directory to " + value);
            this.plugin.settings.working_directory = value;
            await this.plugin.saveSettings();
        }));
        // Platforms' default shells
        createShellSelectionField(this.plugin, container_element, this.plugin.settings.default_shells, true);
        // PATH environment variable fields
        createPATHAugmentationFields(this.plugin, container_element, this.plugin.settings.environment_variable_path_augmentations);
    }
    tabPreactions(container_element) {
        // Prompts
        const prompt_model = getModel(PromptModel.name);
        new obsidian.Setting(container_element)
            .setName("Prompts")
            .setHeading() // Make the "Prompts" text to appear as a heading.
        ;
        const prompts_container_element = container_element.createDiv();
        this.plugin.getPrompts().forEach((prompt) => {
            prompt_model.createSettingFields(prompt, prompts_container_element);
        });
        // 'New prompt' button
        const new_prompt_button_promise = createNewModelInstanceButton(this.plugin, PromptModel.name, container_element, prompts_container_element, this.plugin.settings);
        new_prompt_button_promise.then((result) => {
            prompt_model.openSettingsModal(result.instance, result.main_setting); // Open the prompt settings modal, as the user will probably want to configure it now anyway.
        });
    }
    tabOutput(container_element) {
        // Output wrappers
        const output_wrapper_model = getModel(OutputWrapperModel.name);
        new obsidian.Setting(container_element)
            .setName("Output wrappers")
            .setHeading() // Make the "Output wrappers" text to appear as a heading.
            .addExtraButton(extra_button => extra_button
            .setIcon("help")
            .setTooltip("Documentation: Output wrappers")
            .onClick(() => gotoURL(DocumentationOutputWrappersLink)));
        const output_wrappers_container_element = container_element.createDiv();
        this.plugin.getOutputWrappers().forEach((output_wrapper) => {
            output_wrapper_model.createSettingFields(output_wrapper, output_wrappers_container_element);
        });
        // 'New output wrapper' button
        const new_output_wrapper_button_promise = createNewModelInstanceButton(this.plugin, OutputWrapperModel.name, container_element, output_wrappers_container_element, this.plugin.settings);
        new_output_wrapper_button_promise.then((result) => {
            output_wrapper_model.openSettingsModal(result.instance, result.main_setting); // Open the output wrapper settings modal, as the user will probably want to configure it now anyway.
        });
        // "Error message duration" field
        this.createNotificationDurationField(container_element, "Error message duration", "Concerns messages about failed shell commands.", "error_message_duration");
        // "Notification message duration" field
        this.createNotificationDurationField(container_element, "Notification message duration", "Concerns informational, non-fatal messages, e.g. output directed to 'Notification balloon'.", "notification_message_duration");
        // "Show a notification when executing shell commands" field
        new obsidian.Setting(container_element)
            .setName("Show a notification when executing shell commands")
            .addDropdown(dropdown_component => dropdown_component
            .addOptions({
            "disabled": "Do not show",
            "quick": "Show for " + this.plugin.settings.notification_message_duration + " seconds",
            "permanent": "Show until the process is finished",
            "if-long": "Show only if executing takes long",
        })
            .setValue(this.plugin.settings.execution_notification_mode)
            .onChange(async (new_execution_notification_mode) => {
            // Save the change.
            this.plugin.settings.execution_notification_mode = new_execution_notification_mode;
            await this.plugin.saveSettings();
        }));
        // "Output channel 'Clipboard' displays a notification message, too" field
        new obsidian.Setting(container_element)
            .setName("Output channel 'Clipboard' displays a notification message, too")
            .setDesc("If a shell command's output is directed to the clipboard, also show the output in a popup box on the top right corner. This helps to notice what was inserted into clipboard.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.output_channel_clipboard_also_outputs_to_notification)
            .onChange(async (value) => {
            this.plugin.settings.output_channel_clipboard_also_outputs_to_notification = value;
            await this.plugin.saveSettings();
        }));
    }
    createNotificationDurationField(container_element, title, description, setting_name) {
        new obsidian.Setting(container_element)
            .setName(title)
            .setDesc(description + " In seconds, between 1 and 180.")
            .addText(field => field
            .setValue(String(this.plugin.settings[setting_name]))
            .onChange(async (duration_string) => {
            const duration = parseInt(duration_string);
            if (duration >= 1 && duration <= 180) {
                debugLog("Change " + setting_name + " from " + this.plugin.settings[setting_name] + " to " + duration);
                this.plugin.settings[setting_name] = duration;
                await this.plugin.saveSettings();
                debugLog("Changed.");
            }
            // Don't show a notice if duration is not between 1 and 180, because this function is called every time a user types in this field, so the value might not be final.
        }));
    }
    rememberLastPosition(container_element) {
        const last_position = this.last_position;
        // Go to last position now
        this.tab_structure.buttons[last_position.tab_name].click();
        window.setTimeout(() => {
            container_element.scrollTo({
                top: this.last_position.scroll_position,
                behavior: "auto",
            });
        }, 0); // 'timeout' can be 0 ms, no need to wait any longer.
        // Listen to changes
        container_element.addEventListener("scroll", (event) => {
            this.last_position.scroll_position = container_element.scrollTop;
        });
        for (const tab_name in this.tab_structure.buttons) {
            const button = this.tab_structure.buttons[tab_name];
            button.onClickEvent((event) => {
                last_position.tab_name = tab_name;
            });
        }
    }
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
/**
 * TODO: Rename this class. Replace the T prefix with something else. The T stands for Type (kind of like TFile from Obsidian), but this is not a type, this is a class. Maybe ShellCommandInstance? It's not the best name, but I can't come up with a better one now.
 */
class TShellCommand {
    constructor(plugin, configuration) {
        this.plugin = plugin;
        this.configuration = configuration;
        // Introduce the ID to an ID generator so that it won't accidentally generate the same ID again when creating new shell commands.
        getIDGenerator().addReservedID(configuration.id);
    }
    getPlugin() {
        return this.plugin;
    }
    /**
     * Use this when you need to alter the configuration values. if you only need to read configuration values, use get*()
     * methods instead.
     */
    getConfiguration() {
        return this.configuration;
    }
    getId() {
        return this.configuration.id;
    }
    getShell() {
        const operating_system = getOperatingSystem();
        // Check if the shell command has defined a specific shell.
        if (undefined === this.configuration.shells[operating_system]) {
            // The shell command does not define an explicit shell.
            // Use a default shell from the plugin's settings.
            return this.plugin.getDefaultShell();
        }
        else {
            // The shell command has an explicit shell defined.
            return this.configuration.shells[operating_system];
        }
    }
    getShells() {
        return this.configuration.shells;
    }
    /**
     * Returns a shell command string specific for the current operating system, or a generic shell command if this shell
     * command does not have an explicit version for the current OS.
     */
    getShellCommand() {
        const operating_system = getOperatingSystem();
        // Check if the shell command has defined a specific command for this operating system.
        if (undefined === this.configuration.platform_specific_commands[operating_system]) {
            // No command is defined specifically for this operating system.
            // Return an "OS agnostic" command.
            return this.configuration.platform_specific_commands.default;
        }
        else {
            // The shell command has defined a specific command for this operating system.
            return this.configuration.platform_specific_commands[operating_system];
        }
    }
    /**
     * Returns a version of the shell command that should be used if no platform specific command is defined for the
     * current platform. If you plan to use this for execution, consider using getShellCommand() instead, as it takes the
     * current platform into account.
     */
    getDefaultShellCommand() {
        return this.configuration.platform_specific_commands.default;
    }
    getPlatformSpecificShellCommands() {
        return this.configuration.platform_specific_commands;
    }
    /**
     * Returns a list of PlatformIds that have a shell command version defined. 'default' is never included in the list.
     *
     * TODO: Invent a better name for this method.
     */
    getNonEmptyPlatformIds() {
        const platform_specific_shell_commands = this.getPlatformSpecificShellCommands();
        const platform_ids_with_non_empty_shell_commands = [];
        let platform_id;
        for (platform_id in PlatformNames) { // Note that this loop does not iterate 'default' platform id (= the fallback platform id that is used when a shell command does not have a version for the current platform).
            const platform_specific_shell_command = platform_specific_shell_commands[platform_id];
            if (platform_specific_shell_command && "" !== platform_specific_shell_command.trim()) {
                platform_ids_with_non_empty_shell_commands.push(platform_id);
            }
        }
        return platform_ids_with_non_empty_shell_commands;
    }
    getIconId() {
        return this.configuration.icon;
    }
    getIconHTML() {
        if (this.configuration.icon) {
            // An icon is defined.
            return getIconHTML(this.configuration.icon);
        }
        else {
            // No icon is defined.
            return "";
        }
    }
    getAlias() {
        return this.configuration.alias;
    }
    /**
     * TODO: Use this method in all places where similar logic is needed.
     */
    getAliasOrShellCommand() {
        return this.configuration.alias || this.getShellCommand();
    }
    getConfirmExecution() {
        return this.configuration.confirm_execution;
    }
    getIgnoreErrorCodes() {
        return this.configuration.ignore_error_codes;
    }
    getOutputChannelOrder() {
        return this.configuration.output_channel_order;
    }
    getOutputChannels() {
        return this.configuration.output_channels;
    }
    getOutputHandlingMode() {
        return this.configuration.output_handling_mode;
    }
    /**
     * Finds an output wrapper that should be used for the given OutputStream. Returns null, if no OutputWrapper should
     * be used.
     *
     * @param output_stream
     */
    getOutputWrapper(output_stream) {
        const output_wrapper_id = this.configuration.output_wrappers[output_stream];
        if (!output_wrapper_id) {
            // No output wrapper is defined for this output stream in this shell command.
            return null;
        }
        for (const output_wrapper of this.plugin.getOutputWrappers().values()) {
            // Check if this is the output wrapper defined for this shell command.
            if (output_wrapper.getID() === output_wrapper_id) {
                // The correct output wrapper was found.
                return output_wrapper;
            }
        }
        throw new Error("OutputWrapper with ID " + output_wrapper_id + " was not found.");
    }
    /**
     * Checks if different output streams can be wrapped together. In addition to this, combining output streams also
     * requires the OutputChannels to be the same, but that's not checked in this method.
     */
    isOutputWrapperStdoutSameAsStderr() {
        return this.configuration.output_wrappers["stdout"] === this.configuration.output_wrappers["stderr"];
    }
    getEventsConfiguration() {
        return this.configuration.events;
    }
    getEventConfiguration(sc_event) {
        return this.getEventsConfiguration()[sc_event.static().getCode()] || sc_event.getDefaultConfiguration(false);
    }
    isSC_EventEnabled(event_code) {
        const events_configuration = this.getEventsConfiguration();
        if (undefined === events_configuration[event_code]) {
            // Not enabled
            return false;
        }
        else {
            // Maybe enabled
            return events_configuration[event_code].enabled;
        }
    }
    /**
     * Called when changing event settings in ShellCommandExtraOptionsModal.
     * plugin.saveSettings() needs to be called after this!
     *
     * @param sc_event
     */
    enableSC_Event(sc_event) {
        const event_code = sc_event.static().getCode();
        const events_configuration = this.getEventsConfiguration();
        if (undefined === events_configuration[event_code]) {
            // Not enabled
            // Enable
            events_configuration[event_code] = sc_event.getDefaultConfiguration(true);
        }
        else {
            // Maybe enabled
            if (!events_configuration[event_code].enabled) {
                events_configuration[event_code].enabled = true;
            }
        }
        if (sc_event.canRegisterAfterChangingSettings()) {
            this.registerSC_Event(sc_event);
        }
        sc_event.onAfterEnabling(this);
    }
    /**
     * Called when changing event settings in ShellCommandExtraOptionsModal.
     * plugin.saveSettings() needs to be called after this!
     *
     * @param sc_event
     */
    disableSC_Event(sc_event) {
        const event_code = sc_event.static().getCode();
        const events_configuration = this.getEventsConfiguration();
        if (undefined !== events_configuration[event_code]) {
            // Maybe enabled
            if (events_configuration[event_code].enabled) {
                // Is enabled.
                // Disable.
                const configuration_property_names = Object.getOwnPropertyNames(events_configuration[event_code]);
                if (configuration_property_names.length > 1) {
                    // There's more settings than just 'enable'.
                    // Disable by setting 'enable' to false, don't flush the settings, they can be useful if the event gets re-enabled.
                    events_configuration[event_code].enabled = false;
                }
                else {
                    // 'enabled' is the only setting.
                    // Disable by removing the configuration object completely to make the settings file cleaner.
                    delete events_configuration[event_code];
                }
            }
        }
        if (sc_event.canRegisterAfterChangingSettings()) {
            this.unregisterSC_Event(sc_event);
        }
    }
    /**
     * Returns all SC_Events that are enabled fro this shell command.
     *
     * Private as it's currently only used domestically, but can be changed to public if needed.
     */
    getSC_Events() {
        const enabled_sc_events = [];
        getSC_Events(this.plugin).forEach((sc_event) => {
            if (this.isSC_EventEnabled(sc_event.static().getCode())) {
                enabled_sc_events.push(sc_event);
            }
        });
        return enabled_sc_events;
    }
    /**
     * Private, if you need access from outside, use enableSC_Event().
     *
     * @param sc_event
     * @private
     */
    registerSC_Event(sc_event) {
        sc_event.register(this);
    }
    /**
     * Private, if you need access from outside, use disableSC_Event().
     *
     * @param sc_event
     * @private
     */
    unregisterSC_Event(sc_event) {
        sc_event.unregister(this);
    }
    /**
     * Set's up all events that are enabled for this shell command.
     *
     * @param called_after_changing_settings Set to: true, if this happens after changing configuration; false, if this happens during loading the plugin.
     */
    registerSC_Events(called_after_changing_settings) {
        this.getSC_Events().forEach((sc_event) => {
            const can_register = !called_after_changing_settings || sc_event.canRegisterAfterChangingSettings();
            if (can_register) {
                this.registerSC_Event(sc_event);
            }
        });
    }
    unregisterSC_Events() {
        this.getSC_Events().forEach((sc_event) => {
            this.unregisterSC_Event(sc_event);
        });
    }
    registerToCommandPalette() {
        // TODO: Move the logic from plugin.registerShellCommand() to here, but split to multiple methods.
        this.plugin.registerShellCommand(this);
    }
    unregisterFromCommandPalette() {
        // FIXME: I think the unregistering does not work.
        delete this.plugin.obsidian_commands[this.getId()];
    }
    /**
     * Checks the configuration for command_palette_availability and returns:
     *  - true, if the value is "enabled" or "unlisted"
     *  - false, if the value is "disabled"
     *
     * Adding to command palette also enables hotkeys, which is why adding can be permitted, but showing denied, if a shell command should only be available via hotkeys.
     */
    canAddToCommandPalette() {
        return this.getConfiguration().command_palette_availability !== "disabled";
    }
    /**
     * Another name for canAddToCommandPalette().
     */
    canHaveHotkeys() {
        return this.canAddToCommandPalette();
    }
    /**
     * Checks the configuration for command_palette_availability and returns:
     *  - true, if the value is "enabled"
     *  - false, if the value is "disabled" or "unlisted"
     */
    canShowInCommandPalette() {
        return this.getConfiguration().command_palette_availability === "enabled";
    }
    /**
     * Creates a new ParsingProcess instance and defines two sets of variables:
     *  - First set: All variables that are not tied to any preactions.
     *  - Second set: Variables that are tied to preactions. Can be an empty set.
     * You need to still call ParsingProcess.process() to parse the first set. ShellCommandExecutor takes care of calling
     * ParsingProcess.processRest() to process all non-processed sets.
     *
     * @See ParsingProcess class for a description of the process.
     * @param sc_event Needed to get {{event_*}} variables parsed. Can be left out if working outside any SC_Event context, in which case {{event_*}} variables are inaccessible.
     */
    createParsingProcess(sc_event) {
        const stdout_output_wrapper = this.getOutputWrapper("stdout"); // Can be null
        const stderr_output_wrapper = this.getOutputWrapper("stderr"); // Can be null
        return new ParsingProcess(this.plugin, {
            shell_command: this.getShellCommand(),
            alias: this.getAlias(),
            environment_variable_path_augmentation: getPATHAugmentation(this.plugin) ?? "",
            output_wrapper_stdout: stdout_output_wrapper ? stdout_output_wrapper.getContent() : undefined,
            output_wrapper_stderr: stderr_output_wrapper ? stderr_output_wrapper.getContent() : undefined,
        }, this, sc_event, [
            this.getNonPreactionsDependentVariables(),
            this.getPreactionsDependentVariables(), // Second set: Variables that are tied to preactions. Can be an empty set.
        ], [
            // Do not escape variables in output wrappers, because they are not going through a shell and escape characters would be visible in the end result.
            'output_wrapper_stdout',
            'output_wrapper_stderr',
        ]);
    }
    setObsidianCommand(obsidian_command) {
        this.obsidian_command = obsidian_command;
    }
    getObsidianCommand() {
        return this.obsidian_command;
    }
    /**
     * No renaming is done if the shell command is excluded from the command palette.
     */
    renameObsidianCommand(shell_command, alias) {
        // Rename the command in command palette
        const prefix = this.plugin.getPluginName() + ": "; // Normally Obsidian prefixes all commands with the plugin name automatically, but now that we are actually _editing_ a command in the palette (not creating a new one), Obsidian won't do the prefixing for us.
        // Check that the shell command is actually registered to Obsidian's command palette.
        if (undefined !== this.obsidian_command) {
            // Yes, the shell command is registered in Obsidian's command palette.
            // Update the command palette name.
            this.obsidian_command.name = prefix + generateObsidianCommandName(this.plugin, shell_command, alias);
        }
        // If the shell command's "command_palette_availability" settings is set to "disabled", then the shell command is not present in this.obsidian_command and so the command palette name does not need updating.
    }
    /**
     * Clears an internal cache used by .getPreactions().
     * Only needed to be called after creating new PreactionConfigurations or deleting old ones. Should not need to be called
     * when modifying properties in existing PreactionConfigurations.
     */
    resetPreactions() {
        debugLog(`TShellCommand ${this.getId()}: Resetting preactions.`);
        delete this.cached_preactions;
    }
    getPreactions() {
        debugLog(`TShellCommand ${this.getId()}: Getting preactions.`);
        if (!this.cached_preactions) {
            this.cached_preactions = [];
            this.getConfiguration().preactions.forEach((preaction_configuration) => {
                // Only create the preaction if it's enabled.
                if (preaction_configuration.enabled) {
                    // Yes, it's enabled.
                    // Instantiate the Preaction.
                    this.cached_preactions.push(createPreaction(this.plugin, preaction_configuration, this));
                }
            });
        }
        return this.cached_preactions;
    }
    /**
     * Returns Variables that are not dependent on any Preaction.
     * @private Can be made public if needed.
     */
    getNonPreactionsDependentVariables() {
        debugLog(`TShellCommand ${this.getId()}: Getting non preactions dependent variables.`);
        const all_variables = this.plugin.getVariables();
        return removeFromSet(all_variables, this.getPreactionsDependentVariables());
    }
    /**
     * @private Can be made public if needed.
     */
    getPreactionsDependentVariables() {
        debugLog(`TShellCommand ${this.getId()}: Getting preactions dependent variables.`);
        let dependent_variables = new VariableSet();
        for (const preaction of this.getPreactions()) {
            dependent_variables = mergeSets(dependent_variables, preaction.getDependentVariables());
        }
        return dependent_variables;
    }
    /**
     * @return Returns undefined, if no configuration is defined for this variable.
     */
    getDefaultValueConfigurationForVariable(variable) {
        return this.configuration.variable_default_values[variable.getIdentifier()];
    }
    /**
     * Returns an URI that can be used in links (in or outside of Obsidian) to execute this shell command. The URI also
     * contains stubs for any possible CustomVariables that might be used in the shell command (if any).
     */
    getExecutionURI() {
        const execution_uri = this.plugin.getObsidianURI(SC_Plugin.SHELL_COMMANDS_URI_ACTION, { execute: this.getId() });
        // Get a list CustomVariables that the shell command uses.
        const custom_variables = new VariableSet();
        for (const custom_variable of getUsedVariables(this.plugin, this.getShellCommand())) {
            // Check that the variable IS a CustomVariable.
            if (custom_variable instanceof CustomVariable) {
                custom_variables.add(custom_variable);
            }
        }
        // Exclude variables whose values will come from Preactions - they will not probably be needed in the URI.
        const custom_variables_suitable_for_uri = removeFromSet(custom_variables, this.getPreactionsDependentVariables());
        // Append the suitable custom variable names to the uri.
        let execution_uri_with_variables = execution_uri;
        for (const custom_variable of custom_variables_suitable_for_uri) {
            execution_uri_with_variables += "&" + custom_variable.variable_name + "=";
        }
        // Finished.
        return execution_uri_with_variables;
    }
    /**
     * Returns an adjacent TShellCommand that appears next in the configuration list. Returns undefined, if this is the
     * last TShellCommand. Used in settings to switch quickly from one TShellCommand to another.
     */
    nextTShellCommand() {
        const t_shell_commands = Object.values(this.plugin.getTShellCommands());
        const this_index = t_shell_commands.indexOf(this);
        if (this_index === t_shell_commands.length - 1) {
            return undefined;
        }
        return t_shell_commands[this_index + 1];
    }
    /**
     * Returns an adjacent TShellCommand that appears before in the configuration list. Returns undefined, if this is the
     * first TShellCommand. Used in settings to switch quickly from one TShellCommand to another.
     */
    previousTShellCommand() {
        const t_shell_commands = Object.values(this.plugin.getTShellCommands());
        const this_index = t_shell_commands.indexOf(this);
        if (this_index === 0) {
            return undefined;
        }
        return t_shell_commands[this_index - 1];
    }
}

/**
 * Copied 2021-10-29 from https://gist.github.com/TheDistantSea/8021359
 * Modifications:
 *  - Made compatible with TypeScript by adding type definitions.
 *  - Changed var to let.
 *
 * Compares two software version numbers (e.g. "1.7.1" or "1.2b").
 *
 * This function was born in http://stackoverflow.com/a/6832721.
 *
 * @param {string} v1 The first version to be compared.
 * @param {string} v2 The second version to be compared.
 * @param {object} [options] Optional flags that affect comparison behavior:
 * <ul>
 *     <li>
 *         <tt>lexicographical: true</tt> compares each part of the version strings lexicographically instead of
 *         naturally; this allows suffixes such as "b" or "dev" but will cause "1.10" to be considered smaller than
 *         "1.2".
 *     </li>
 *     <li>
 *         <tt>zeroExtend: true</tt> changes the result if one version string has less parts than the other. In
 *         this case the shorter string will be padded with "zero" parts instead of being considered smaller.
 *     </li>
 * </ul>
 * @returns {number|NaN}
 * <ul>
 *    <li>0 if the versions are equal</li>
 *    <li>a negative integer iff v1 < v2</li>
 *    <li>a positive integer iff v1 > v2</li>
 *    <li>NaN if either version string is in the wrong format</li>
 * </ul>
 *
 * @copyright by Jon Papaioannou (["john", "papaioannou"].join(".") + "@gmail.com")
 * @license This function is in the public domain. Do what you want with it, no strings attached.
 */
function versionCompare(v1, v2, options = {}) {
    let lexicographical = options && options.lexicographical, zeroExtend = options && options.zeroExtend, v1parts = v1.split('.'), v2parts = v2.split('.');
    function isValidPart(x) {
        return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
    }
    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
        return NaN;
    }
    if (zeroExtend) {
        while (v1parts.length < v2parts.length)
            v1parts.push("0");
        while (v2parts.length < v1parts.length)
            v2parts.push("0");
    }
    if (!lexicographical) {
        v1parts = v1parts.map(Number);
        v2parts = v2parts.map(Number);
    }
    for (let i = 0; i < v1parts.length; ++i) {
        if (v2parts.length == i) {
            return 1;
        }
        if (v1parts[i] == v2parts[i]) {
            continue;
        }
        else if (v1parts[i] > v2parts[i]) {
            return 1;
        }
        else {
            return -1;
        }
    }
    if (v1parts.length != v2parts.length) {
        return -1;
    }
    return 0;
}

/*
 * 'Shell commands' plugin for Obsidian.
 * Copyright (C) 2021 - 2022 Jarkko Linnanvirta
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * Contact the author (Jarkko Linnanvirta): https://github.com/Taitava/
 */
class SC_Plugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.obsidian_commands = {};
        this.t_shell_commands = {};
        /**
         * Holder for shell commands and aliases, whose variables are parsed before the actual execution during command
         * palette preview. This array gets emptied after every time a shell command is executed via the command palette.
         *
         * This is only used for command palette, not when executing a shell command from the settings panel, nor when
         * executing shell commands via SC_Events.
         *
         * @private
         */
        this.cached_parsing_processes = {};
    }
    async onload() {
        debugLog('loading plugin');
        // Load settings
        if (!await this.loadSettings()) {
            // Loading the settings has failed due to an unsupported settings file version.
            // The plugin should not be used, and it has actually disabled itself, but the code execution needs to be
            // stopped manually.
            return;
        }
        // Run possible configuration migrations
        await RunMigrations(this);
        // Define models
        introduceModels(this);
        // Generate TShellCommand objects from configuration (only after configuration migrations are done)
        this.loadTShellCommands();
        // Load Prompts
        const prompt_model = getModel(PromptModel.name);
        this.prompts = prompt_model.loadInstances(this.settings);
        // Load CustomVariables (configuration instances)
        const custom_variable_model = getModel(CustomVariableModel.name);
        this.custom_variable_instances = custom_variable_model.loadInstances(this.settings);
        // Load variables (both built-in and custom ones). Do this AFTER loading configs for custom variables!
        this.variables = loadVariables(this);
        // Load output wrappers
        const output_wrapper_model = getModel(OutputWrapperModel.name);
        this.output_wrappers = output_wrapper_model.loadInstances(this.settings);
        // Make all defined shell commands to appear in the Obsidian command palette.
        const shell_commands = this.getTShellCommands();
        for (const shell_command_id in shell_commands) {
            const t_shell_command = shell_commands[shell_command_id];
            if (t_shell_command.canAddToCommandPalette()) {
                this.registerShellCommand(t_shell_command);
            }
        }
        // Perform event registrations, if enabled.
        if (this.settings.enable_events) {
            this.registerSC_Events(false);
        }
        // Load a custom autocomplete list if it exists.
        this.loadCustomAutocompleteList();
        // Create a SettingsTab.
        this.addSettingTab(new SC_MainSettingsTab(this.app, this));
        // Make it possible to create CustomVariableViews.
        this.registerView(CustomVariableView.ViewType, (leaf) => new CustomVariableView(this, leaf));
        // Debug reserved IDs
        debugLog("IDGenerator's reserved IDs:");
        debugLog(getIDGenerator().getReservedIDs());
        // Register an URI handler.
        this.registerURIHandler();
    }
    loadTShellCommands() {
        this.t_shell_commands = {}; // TODO: Consider changing this to either an array or a Map.
        const shell_command_configurations = this.getShellCommandConfigurations();
        for (const shell_command_configuration of shell_command_configurations) {
            this.t_shell_commands[shell_command_configuration.id] = new TShellCommand(this, shell_command_configuration);
        }
    }
    getTShellCommands() {
        return this.t_shell_commands;
    }
    getVariables() {
        return this.variables;
    }
    getPrompts() {
        return this.prompts;
    }
    getCustomVariableInstances() {
        return this.custom_variable_instances;
    }
    getShellCommandConfigurations() {
        return this.settings.shell_commands;
    }
    getOutputWrappers() {
        return this.output_wrappers;
    }
    /**
     * Tries to find an index at which a ShellCommandConfiguration object is located in this.settings.shell_commands.
     * Returns undefined, if it's not found.
     *
     * DO NOT EXPOSE THE INDEX OUTSIDE THE PLUGIN! It's not a stable reference to a shell command, because shell commands
     * can be reordered (well, at least in some future version of the plugin). Always use the ID as a stable, externally
     * safe reference!
     *
     * @param shell_command_id
     */
    getShellCommandConfigurationIndex(shell_command_id) {
        return this.settings.shell_commands.findIndex((shell_command_configuration) => {
            return shell_command_configuration.id == shell_command_id;
        });
    }
    /**
     * Returns an Obsidian URI that complies with the format obsidian://action/?vault=XYZ and that may contain possible
     * custom arguments at the end.
     *
     * Note that if 'action' is 'open' and a 'file' argument is present in 'uri_arguments', the URI will use the shorthand syntax described here: https://help.obsidian.md/Advanced+topics/Using+obsidian+URI#Shorthand+formats
     *
     * @param action
     * @param uri_arguments
     */
    getObsidianURI(action, uri_arguments = {}) {
        const encoded_vault_name = encodeURIComponent(this.app.vault.getName());
        let base_uri;
        // Check which kind of uri type should be used: shorthand or normal
        if ("open" === action && uri_arguments.file !== undefined) {
            // Use shorthand uri type for opening a file.
            const encoded_file = encodeURIComponent(uri_arguments.file);
            base_uri = `obsidian://vault/${encoded_vault_name}/${encoded_file}`;
            delete uri_arguments.file; // Prevent adding an extra '&file=' argument to the end of the URI.
        }
        else {
            // Use normal uri type for everything else.
            base_uri = `obsidian://${action}/?vault=${encoded_vault_name}`;
        }
        let concatenated_uri_arguments = "";
        for (const uri_argument_name in uri_arguments) {
            const uri_argument_value = encodeURIComponent(uri_arguments[uri_argument_name]);
            concatenated_uri_arguments += `&${uri_argument_name}=${uri_argument_value}`;
        }
        return base_uri + concatenated_uri_arguments;
    }
    /**
     * Creates a new shell command object and registers it to Obsidian's command palette, but does not save the modified
     * configuration to disk. To save the addition, call saveSettings().
     */
    newTShellCommand() {
        const shell_command_id = getIDGenerator().generateID();
        const shell_command_configuration = newShellCommandConfiguration(shell_command_id);
        this.settings.shell_commands.push(shell_command_configuration);
        const t_shell_command = new TShellCommand(this, shell_command_configuration);
        this.t_shell_commands[shell_command_id] = t_shell_command;
        if (t_shell_command.canAddToCommandPalette()) { // This is probably always true, because the default configuration enables adding to the command palette, but check just in case.
            this.registerShellCommand(t_shell_command);
        }
        return t_shell_command;
    }
    /**
     * TODO: Move to TShellCommand.registerToCommandPalette(), but split to multiple methods.
     *
     * @param t_shell_command
     */
    registerShellCommand(t_shell_command) {
        const shell_command_id = t_shell_command.getId();
        debugLog("Registering shell command #" + shell_command_id + "...");
        // Define a function for executing the shell command.
        const executor = async (parsing_process) => {
            if (!parsing_process) {
                parsing_process = t_shell_command.createParsingProcess(null); // No SC_Event is available when executing shell commands via the command palette / hotkeys.
                // Try to process variables that can be processed before performing preactions.
                await parsing_process.process();
            }
            if (parsing_process.getParsingResults().shell_command.succeeded) {
                // The command was parsed correctly.
                const executor_instance = new ShellCommandExecutor(// Named 'executor_instance' because 'executor' is another constant.
                this, t_shell_command, null // No SC_Event is available when executing via command palette or hotkey.
                );
                await executor_instance.doPreactionsAndExecuteShellCommand(parsing_process);
            }
            else {
                // The command could not be parsed correctly.
                // Display error messages
                parsing_process.displayErrorMessages();
            }
        };
        // Register an Obsidian command
        const obsidian_command = {
            id: this.generateObsidianCommandId(shell_command_id),
            name: generateObsidianCommandName(this, t_shell_command.getShellCommand(), t_shell_command.getAlias()),
            // Use 'checkCallback' instead of normal 'callback' because we also want to get called when the command palette is opened.
            checkCallback: (is_opening_command_palette) => {
                if (is_opening_command_palette) {
                    // The user is currently opening the command palette.
                    // Check can the shell command be shown in command palette
                    if (!t_shell_command.canShowInCommandPalette()) {
                        // Cancel preview and deny showing in command palette.
                        debugLog("Shell command #" + t_shell_command.getId() + " won't be shown in command palette.");
                        return false;
                    }
                    // Do not execute the command yet, but parse variables for preview, if enabled in the settings.
                    debugLog("Getting command palette preview for shell command #" + t_shell_command.getId());
                    if (this.settings.preview_variables_in_command_palette) {
                        // Preparse variables
                        const parsing_process = t_shell_command.createParsingProcess(null); // No SC_Event is available when executing shell commands via the command palette / hotkeys.
                        parsing_process.process().then((parsing_succeeded) => {
                            if (parsing_succeeded) {
                                // Parsing succeeded
                                // Rename Obsidian command
                                const parsing_result = parsing_process.getParsingResults();
                                t_shell_command.renameObsidianCommand(parsing_result["shell_command"].parsed_content, parsing_result["alias"].parsed_content);
                                // Store the preparsed variables so that they will be used if this shell command gets executed.
                                this.cached_parsing_processes[t_shell_command.getId()] = parsing_process;
                            }
                        });
                    }
                    // If parsing failed (or was disabled), then use unparsed t_shell_command.getShellCommand() and t_shell_command.getAlias().
                    t_shell_command.renameObsidianCommand(t_shell_command.getShellCommand(), t_shell_command.getAlias());
                    this.cached_parsing_processes[t_shell_command.getId()] = undefined;
                    return true;
                }
                else {
                    // The user has instructed to execute the command.
                    executor(this.cached_parsing_processes[t_shell_command.getId()]).then(() => {
                        // Delete the whole array of preparsed commands. Even though we only used just one command from it, we need to notice that opening a command
                        // palette might generate multiple preparsed commands in the array, but as the user selects and executes only one command, all these temporary
                        // commands are now obsolete. Delete them just in case the user toggles the variable preview feature off in the settings, or executes commands via hotkeys. We do not want to
                        // execute obsolete commands accidentally.
                        // This deletion also needs to be done even if the executed command was not a preparsed command, because
                        // even when preparsing is turned on in the settings, some commands may fail to parse, and therefore they would not be in this array, but other
                        // commands might be.
                        this.cached_parsing_processes = {}; // Removes obsolete preparsed variables from all shell commands.
                        return; // When we are not in the command palette check phase, there's no need to return a value. Just have this 'return' statement because all other return points have a 'return' too.
                    });
                }
            }
        };
        this.addCommand(obsidian_command);
        this.obsidian_commands[shell_command_id] = obsidian_command; // Store the reference so that we can edit the command later in ShellCommandsSettingsTab if needed. TODO: Use tShellCommand instead.
        t_shell_command.setObsidianCommand(obsidian_command);
        debugLog("Registered.");
    }
    /**
     * Goes through all events and all shell commands, and for each shell command, registers all the events that the shell
     * command as enabled in its configuration. Does not modify the configurations.
     *
     * @param called_after_changing_settings Set to: true, if this happens after changing configuration; false, if this happens during loading the plugin.
     */
    registerSC_Events(called_after_changing_settings) {
        // Make sure that Obsidian is fully loaded before allowing any events to trigger.
        this.app.workspace.onLayoutReady(() => {
            // Even after Obsidian is fully loaded, wait a while in order to prevent SC_Event_onActiveLeafChanged triggering right after start-up.
            // At least on Obsidian 0.12.19 it's not enough to delay until onLayoutReady, need to wait a bit more in order to avoid the miss-triggering.
            window.setTimeout(() => {
                // Iterate all shell commands and register possible events.
                const shell_commands = this.getTShellCommands();
                for (const shell_command_id in shell_commands) {
                    const t_shell_command = shell_commands[shell_command_id];
                    t_shell_command.registerSC_Events(called_after_changing_settings);
                }
            }, 0); // 0 means to call the callback on "the next event cycle", according to window.setTimeout() documentation. It should be a long enough delay. But if SC_Event_onActiveLeafChanged still gets triggered during start-up, this value can be raised to for example 1000 (= one second).
        });
    }
    /**
     * Goes through all events and all shell commands, and makes sure all of them are unregistered, e.g. will not trigger
     * automatically. Does not modify the configurations.
     */
    unregisterSC_Events() {
        // Iterate all events
        getSC_Events(this).forEach((sc_event) => {
            // Iterate all shell commands
            const shell_commands = this.getTShellCommands();
            for (const shell_command_id in shell_commands) {
                const t_shell_command = shell_commands[shell_command_id];
                sc_event.unregister(t_shell_command);
            }
        });
    }
    /**
     * Defines an Obsidian protocol handler that allows receiving requests via obsidian://shell-commands URI.
     * @private
     */
    registerURIHandler() {
        this.registerObsidianProtocolHandler(SC_Plugin.SHELL_COMMANDS_URI_ACTION, async (parameters) => {
            const parameter_names = Object.getOwnPropertyNames(parameters);
            // Assign values to custom variables (also delete some unneeded entries from parameter_names)
            let custom_variable_assignments_failed = false;
            for (const parameter_index in parameter_names) {
                const parameter_name = parameter_names[parameter_index];
                // Check if the parameter name is a custom variable
                if (parameter_name.match(/^_/)) {
                    // This parameter defines a value for a custom variable
                    // Find the variable.
                    let found_custom_variable = false;
                    for (const variable of this.getVariables()) {
                        if (variable instanceof CustomVariable && variable.variable_name === parameter_name) {
                            // Found the correct variable.
                            found_custom_variable = true;
                            // Assign the given value to the custom variable.
                            await variable.setValue(parameters[parameter_name]);
                        }
                    }
                    if (!found_custom_variable) {
                        this.newError("Shell commands URI: A custom variable does not exist: " + parameter_name);
                        custom_variable_assignments_failed = true;
                    }
                }
            }
            if (!custom_variable_assignments_failed) {
                // Determine action
                if (undefined !== parameters.execute) {
                    // Execute a shell command.
                    const executable_shell_command_id = parameters.execute;
                    parameter_names.remove("execute"); // Mark the parameter as handled. Prevents showing an error message for an unrecognised parameter.
                    // Find the executable shell command
                    let found_t_shell_command = false;
                    const shell_commands = this.getTShellCommands();
                    for (const shell_command_id in shell_commands) {
                        const t_shell_command = shell_commands[shell_command_id];
                        if (t_shell_command.getId() === executable_shell_command_id) {
                            // This is the correct shell command.
                            found_t_shell_command = true;
                            // Execute it.
                            const executor = new ShellCommandExecutor(this, t_shell_command, null);
                            await executor.doPreactionsAndExecuteShellCommand();
                        }
                    }
                    if (!found_t_shell_command) {
                        this.newError("Shell commands URI: A shell command id does not exist: " + executable_shell_command_id);
                    }
                }
            }
            // Raise errors for any left-over parameters, if exists.
            for (const parameter_name of parameter_names) {
                switch (parameter_name) {
                    case "": // For some reason Obsidian 0.14.5 adds an empty-named parameter if there are no ?query=parameters present.
                    case "action": // Obsidian provides this always. Don't show an error message for this.
                    case "vault": // Obsidian handles this parameter automatically. Just make sure no error message is displayed when this is present.
                        // Do nothing
                        break;
                    default:
                        if (parameter_name.match(/^_/)) ;
                        else {
                            // Throw an error for everything else.
                            this.newError("Shell commands URI: Unrecognised parameter: " + parameter_name);
                        }
                }
            }
        });
    }
    generateObsidianCommandId(shell_command_id) {
        return "shell-command-" + shell_command_id;
    }
    onunload() {
        debugLog('Unloading Shell commands plugin.');
        // Close CustomVariableViews.
        this.app.workspace.detachLeavesOfType(CustomVariableView.ViewType);
    }
    /**
     *
     * @param current_settings_version
     * @private
     * @return True if the given settings version is supported by this plugin version, or an error message string if it's not supported.
     */
    isSettingsVersionSupported(current_settings_version) {
        if (current_settings_version === "prior-to-0.7.0") {
            // 0.x.y supports all old settings formats that do not define a version number. This support will be removed in 1.0.0.
            return true;
        }
        else {
            // Compare the version number
            /** Note that the plugin version may be different than what will be used in the version comparison. The plugin version will be displayed in possible error messages. */
            const plugin_version = this.getPluginVersion();
            const version_comparison = versionCompare(SC_Plugin.SettingsVersion, current_settings_version);
            if (version_comparison === 0) {
                // The versions are equal.
                // Supported.
                return true;
            }
            else if (version_comparison < 0) {
                // The compared version is newer than what the plugin can support.
                return "The settings file is saved by a newer version of this plugin, so this plugin does not support the structure of the settings file. Please upgrade this plugin to at least version " + current_settings_version + ". Now the plugin version is " + plugin_version;
            }
            else {
                // The compared version is older than the version that the plugin currently uses to write settings.
                // 0.x.y supports all old settings versions. In 1.0.0, some old settings formats might lose their support, but that's not yet certain.
                return true;
            }
        }
    }
    getPluginVersion() {
        return this.manifest.version;
    }
    async loadSettings() {
        // Try to read a settings file
        let all_settings;
        this.settings = await this.loadData(); // May have missing main settings fields, if the settings file is from an older version of SC. It will be migrated later.
        if (null === this.settings) {
            // The settings file does not exist.
            // Use default settings
            this.settings = getDefaultSettings(true);
            all_settings = this.settings;
        }
        else {
            // Succeeded to load a settings file.
            // In case the settings file does not have 'debug' or 'settings_version' fields, create them.
            all_settings = combineObjects(getDefaultSettings(false), this.settings); // This temporary settings object always has all fields defined (except sub fields, such as shell command specific fields, may still be missing, but they are not needed this early). This is used so that it's certain that the fields 'debug' and 'settings_version' exist.
        }
        // Update debug status - before this line debugging is always OFF!
        setDEBUG_ON(all_settings.debug);
        // Ensure that the loaded settings file is supported.
        const version_support = this.isSettingsVersionSupported(all_settings.settings_version);
        if (typeof version_support === "string") {
            // The settings version is not supported.
            new obsidian.Notice("SHELL COMMANDS PLUGIN HAS DISABLED ITSELF in order to prevent misinterpreting settings / corrupting the settings file!", 120 * 1000);
            new obsidian.Notice(version_support, 120 * 1000);
            await this.disablePlugin();
            return false; // The plugin should not be used.
        }
        return true; // Settings are loaded and the plugin can be used.
    }
    async saveSettings() {
        // Update settings version in case it's old.
        this.settings.settings_version = SC_Plugin.SettingsVersion;
        // Write settings
        await this.saveData(this.settings);
    }
    loadCustomAutocompleteList() {
        const custom_autocomplete_file_name = "autocomplete.yaml";
        const custom_autocomplete_file_path = path__namespace.join(getPluginAbsolutePath(this), custom_autocomplete_file_name);
        if (fs__namespace.existsSync(custom_autocomplete_file_path)) {
            debugLog("loadCustomAutocompleteList(): " + custom_autocomplete_file_name + " exists, will load it now.");
            const custom_autocomplete_content = fs__namespace.readFileSync(custom_autocomplete_file_path).toLocaleString();
            const result = addCustomAutocompleteItems(custom_autocomplete_content);
            if (true === result) {
                // OK
                debugLog("loadCustomAutocompleteList(): " + custom_autocomplete_file_name + " loaded.");
            }
            else {
                // An error has occurred.
                debugLog("loadCustomAutocompleteList(): " + result);
                this.newError("Shell commands: Unable to parse " + custom_autocomplete_file_name + ": " + result);
            }
        }
        else {
            debugLog("loadCustomAutocompleteList(): " + custom_autocomplete_file_name + " does not exists, so won't load it. This is perfectly ok.");
        }
    }
    async disablePlugin() {
        // This unfortunately accesses a private API.
        // @ts-ignore
        await this.app.plugins.disablePlugin(this.manifest.id);
    }
    getPluginId() {
        return this.manifest.id;
    }
    getPluginName() {
        return this.manifest.name;
    }
    newError(message, timeout = this.getErrorMessageDurationMs()) {
        return new obsidian.Notice(message, timeout);
    }
    newErrors(messages) {
        messages.forEach((message) => {
            this.newError(message);
        });
    }
    /**
     *
     * @param message
     * @param timeout Custom timeout in milliseconds. If not set, the timeout will be fetched from user configurable settings. Use 0 if you want to disable the timeout, i.e. show the notification until it's explicitly hidden by clinking it, or via code.
     */
    newNotification(message, timeout = this.getNotificationMessageDurationMs()) {
        return new obsidian.Notice(message, timeout);
    }
    getNotificationMessageDurationMs() {
        return this.settings.notification_message_duration * 1000; // * 1000 = convert seconds to milliseconds.
    }
    getErrorMessageDurationMs() {
        return this.settings.error_message_duration * 1000; // * 1000 = convert seconds to milliseconds.
    }
    getDefaultShell() {
        const operating_system = getOperatingSystem();
        let shell_name = this.settings.default_shells[operating_system]; // Can also be undefined.
        if (undefined === shell_name) {
            shell_name = getUsersDefaultShell();
        }
        return shell_name;
    }
    createCustomVariableView() {
        const leaf = this.app.workspace.getRightLeaf(false);
        leaf.setViewState({
            type: CustomVariableView.ViewType,
            active: true,
        }).then();
        this.app.workspace.revealLeaf(leaf);
    }
    /**
     * Called when CustomVariable values are changed.
     */
    async updateCustomVariableViews() {
        for (const leaf of this.app.workspace.getLeavesOfType(CustomVariableView.ViewType)) {
            await leaf.view.updateContent();
        }
    }
    /**
     * Used by OutputChannel_StatusBar.
     * TODO: Make it possible to have multiple status bar elements. It should be a shell command level setting, where a shell command opts for either to use their own status bar element, or a common one.
     */
    getOutputStatusBarElement() {
        if (!this.statusBarElement) {
            this.statusBarElement = this.addStatusBarItem();
        }
        return this.statusBarElement;
    }
    /**
     * Creates an icon button that when clicked, will send a request to terminate shell command execution intermittently.
     *
     * @param containerElement
     * @param processTerminator A callback that will actually terminate the shell command execution process.
     */
    createRequestTerminatingButton(containerElement, processTerminator) {
        const button = containerElement.createEl('a', {
            prepend: true,
            attr: {
                "aria-label": "Request to terminate the process",
                class: "SC-icon-terminate-process",
            },
        });
        obsidian.setIcon(button, "power");
        button.onclick = (event) => {
            processTerminator();
            event.preventDefault();
            event.stopPropagation();
        };
    }
}
/**
 * Defines the settings structure version. Change this when a new plugin version is released, but only if that plugin
 * version introduces changes to the settings structure. Do not change if the settings structure stays unchanged.
 */
SC_Plugin.SettingsVersion = "0.17.0";
SC_Plugin.SHELL_COMMANDS_URI_ACTION = "shell-commands";

module.exports = SC_Plugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsic3JjL1NDX01vZGFsLnRzIiwic3JjL0NvbmZpcm1hdGlvbk1vZGFsLnRzIiwic3JjL0RlYnVnLnRzIiwic3JjL0lER2VuZXJhdG9yLnRzIiwic3JjL0NvbW1vbi50cyIsInNyYy9saWIvZXNjYXBlUmVnRXhwLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfT3V0cHV0LnRzIiwic3JjL3ZhcmlhYmxlcy9lc2NhcGVycy9Fc2NhcGVyLnRzIiwic3JjL3ZhcmlhYmxlcy9lc2NhcGVycy9BbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXIudHMiLCJzcmMvdmFyaWFibGVzL2VzY2FwZXJzL1NoRXNjYXBlci50cyIsInNyYy92YXJpYWJsZXMvZXNjYXBlcnMvUG93ZXJTaGVsbEVzY2FwZXIudHMiLCJzcmMvdmFyaWFibGVzL2VzY2FwZXJzL0VzY2FwZVZhbHVlLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9DbGlwYm9hcmQudHMiLCJzcmMvdmFyaWFibGVzL0VkaXRvclZhcmlhYmxlLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9DYXJldFBvc2l0aW9uLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9EYXRlLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZUhlbHBlcnMudHMiLCJzcmMvdmFyaWFibGVzL0ZpbGVWYXJpYWJsZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfRmlsZUV4dGVuc2lvbi50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfRmlsZU5hbWUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0ZpbGVQYXRoLnRzIiwic3JjL3ZhcmlhYmxlcy9Gb2xkZXJWYXJpYWJsZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfRm9sZGVyTmFtZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfRm9sZGVyUGF0aC50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfU2VsZWN0aW9uLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9UYWdzLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9UaXRsZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfVmF1bHRQYXRoLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9Xb3Jrc3BhY2UudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX1Bhc3N0aHJvdWdoLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9ZQU1MVmFsdWUudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9FdmVudFZhcmlhYmxlLnRzIiwic3JjL0RvY3VtZW50YXRpb24udHMiLCJzcmMvZXZlbnRzL1NDX0V2ZW50LnRzIiwic3JjL2V2ZW50cy9TQ19Xb3Jrc3BhY2VFdmVudC50cyIsInNyYy9ldmVudHMvU0NfTWVudUV2ZW50LnRzIiwic3JjL2V2ZW50cy9TQ19BYnN0cmFjdEZpbGVNZW51RXZlbnQudHMiLCJzcmMvZXZlbnRzL1NDX0V2ZW50X0ZpbGVNZW51LnRzIiwic3JjL2V2ZW50cy9TQ19WYXVsdEV2ZW50LnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRmlsZURlbGV0ZWQudHMiLCJzcmMvZXZlbnRzL1NDX1ZhdWx0TW92ZU9yUmVuYW1lRXZlbnQudHMiLCJzcmMvZXZlbnRzL1NDX0V2ZW50X0ZpbGVSZW5hbWVkLnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWQudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVOYW1lLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGaWxlUGF0aC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRm9sZGVyTWVudS50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRm9sZGVyQ3JlYXRlZC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRm9sZGVyRGVsZXRlZC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRm9sZGVyUmVuYW1lZC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRm9sZGVyTW92ZWQudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZvbGRlck5hbWUudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZvbGRlclBhdGgudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudFRpdGxlLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGaWxlRXh0ZW5zaW9uLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRUYWdzLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRZQU1MVmFsdWUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0Vudmlyb25tZW50LnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRPbGRGaWxlTmFtZS50cyIsInNyYy92YXJpYWJsZXMvZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50T2xkRmlsZVBhdGgudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudE9sZEZvbGRlck5hbWUudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudE9sZEZvbGRlclBhdGgudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudE9sZFRpdGxlLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9OZXdOb3RlRm9sZGVyTmFtZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfTmV3Tm90ZUZvbGRlclBhdGgudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0ZpbGVVUkkudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVVUkkudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX05vdGVDb250ZW50LnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnROb3RlQ29udGVudC50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfRmlsZUNvbnRlbnQudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVDb250ZW50LnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9DYXJldFBhcmFncmFwaC50cyIsInNyYy92YXJpYWJsZXMvbG9hZFZhcmlhYmxlcy50cyIsInNyYy92YXJpYWJsZXMvcGFyc2VWYXJpYWJsZXMudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWwudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxfTm90aWZpY2F0aW9uLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlQ2FyZXQudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxfQ3VycmVudEZpbGVUb3AudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxfU3RhdHVzQmFyLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlQm90dG9tLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsX0NsaXBib2FyZC50cyIsInNyYy9Ib3RrZXlzLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsX01vZGFsLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsX09wZW5GaWxlcy50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbEZ1bmN0aW9ucy50cyIsInNyYy9TaGVsbC50cyIsInNyYy9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3MudHMiLCJzcmMvU2hlbGxDb21tYW5kRXhlY3V0b3IudHMiLCJzcmMvbW9kZWxzL0luc3RhbmNlLnRzIiwic3JjL21vZGVscy9Nb2RlbC50cyIsInNyYy9tb2RlbHMvb3V0cHV0X3dyYXBwZXIvT3V0cHV0V3JhcHBlci50cyIsIm5vZGVfbW9kdWxlcy9hdXRvY29tcGxldGVyL2F1dG9jb21wbGV0ZS5qcyIsInNyYy92YXJpYWJsZXMvZ2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtcy50cyIsInNyYy9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZS50cyIsInNyYy9tb2RlbHMvb3V0cHV0X3dyYXBwZXIvT3V0cHV0V3JhcHBlclNldHRpbmdzTW9kYWwudHMiLCJzcmMvbW9kZWxzL291dHB1dF93cmFwcGVyL091dHB1dFdyYXBwZXJNb2RlbC50cyIsInNyYy9tb2RlbHMvbW9kZWxzLnRzIiwic3JjL3ZhcmlhYmxlcy9DdXN0b21WYXJpYWJsZS50cyIsInNyYy9tb2RlbHMvY3VzdG9tX3ZhcmlhYmxlL0N1c3RvbVZhcmlhYmxlSW5zdGFuY2UudHMiLCJzcmMvbW9kZWxzL2N1c3RvbV92YXJpYWJsZS9DdXN0b21WYXJpYWJsZU1vZGVsLnRzIiwic3JjL21vZGVscy9jdXN0b21fdmFyaWFibGUvQ3VzdG9tVmFyaWFibGVTZXR0aW5nc01vZGFsLnRzIiwic3JjL21vZGVscy9jdXN0b21fdmFyaWFibGUvQ3VzdG9tVmFyaWFibGVWaWV3LnRzIiwic3JjL3ByZWFjdGlvbnMvUHJlYWN0aW9uLnRzIiwic3JjL3ByZWFjdGlvbnMvUHJlYWN0aW9uX1Byb21wdC50cyIsInNyYy9tb2RlbHMvcHJvbXB0L3Byb21wdF9maWVsZHMvUHJvbXB0RmllbGQudHMiLCJzcmMvbW9kZWxzL3Byb21wdC9wcm9tcHRfZmllbGRzL1Byb21wdEZpZWxkTW9kZWwudHMiLCJzcmMvbW9kZWxzL3Byb21wdC9wcm9tcHRfZmllbGRzL1Byb21wdEZpZWxkX1RleHQudHMiLCJzcmMvbW9kZWxzL3Byb21wdC9Qcm9tcHQudHMiLCJzcmMvbW9kZWxzL3Byb21wdC9Qcm9tcHRNb2RhbC50cyIsInNyYy9tb2RlbHMvcHJvbXB0L1Byb21wdE1vZGVsLnRzIiwic3JjL21vZGVscy9jcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9uLnRzIiwic3JjL21vZGVscy9wcm9tcHQvUHJvbXB0U2V0dGluZ3NNb2RhbC50cyIsInNyYy9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL1BhdGhFbnZpcm9ubWVudFZhcmlhYmxlRnVuY3Rpb25zLnRzIiwic3JjL3ZhcmlhYmxlcy9QYXJzaW5nUHJvY2Vzcy50cyIsInNyYy9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uLnRzIiwic3JjL01pZ3JhdGlvbnMudHMiLCJzcmMvc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9DcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkLnRzIiwic3JjL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRDb3JlLnRzIiwic3JjL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlUGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZEZpZWxkLnRzIiwic3JjL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvVGFicy50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfb25MYXlvdXRSZWFkeS50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfb25RdWl0LnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9vbkFjdGl2ZUxlYWZDaGFuZ2VkLnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9FdmVyeU5TZWNvbmRzLnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9FZGl0b3JNZW51LnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudExpc3QudHMiLCJzcmMvSWNvbnMudHMiLCJzcmMvc2V0dGluZ3MvRXh0cmFPcHRpb25zTW9kYWwudHMiLCJzcmMvc2V0dGluZ3MvRGVsZXRlTW9kYWwudHMiLCJzcmMvc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9DcmVhdGVTaGVsbENvbW1hbmRGaWVsZC50cyIsInNyYy9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NUYWIudHMiLCJzcmMvVFNoZWxsQ29tbWFuZC50cyIsInNyYy9saWIvdmVyc2lvbl9jb21wYXJlLnRzIiwic3JjL21haW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtNb2RhbH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNDX01vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cclxuICAgIHByaXZhdGUgX2lzT3BlbiA9IGZhbHNlO1xyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvciAoXHJcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IHBsdWdpbjogU0NfUGx1Z2luXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihwbHVnaW4uYXBwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgdGhlIG1vZGFsIHNjcm9sbGFibGUgaWYgaXQgaGFzIG1vcmUgY29udGVudCB0aGFuIHdoYXQgZml0cyBpbiB0aGUgc2NyZWVuLlxyXG4gICAgICAgIHRoaXMubW9kYWxFbC5hZGRDbGFzcyhcIlNDLW1vZGFsXCIsIFwiU0Mtc2Nyb2xsYWJsZVwiKTtcclxuXHJcbiAgICAgICAgLy8gQXBwcm92ZSB0aGUgbW9kYWwgYnkgcHJlc3NpbmcgdGhlIGVudGVyIGtleSAoaWYgZW5hYmxlZCkuXHJcbiAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmFwcHJvdmVfbW9kYWxzX2J5X3ByZXNzaW5nX2VudGVyX2tleSkge1xyXG4gICAgICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtdLCBcImVudGVyXCIsIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBubyB0ZXh0YXJlYSBpcyBmb2N1c2VkIGFuZCBubyBhdXRvY29tcGxldGUgbWVudSBpcyBvcGVuLlxyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0ZXh0YXJlYTpmb2N1c1wiKS5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICAwID09PSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiZGl2LlNDLWF1dG9jb21wbGV0ZVwiKS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHRleHRhcmVhcyB3aXRoIGZvY3VzIGFuZCBubyBvcGVuIGF1dG9jb21wbGV0ZSBtZW51cyB3ZXJlIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwcm92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNPcGVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc09wZW47XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHNldFRpdGxlKHRpdGxlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnRpdGxlRWwuaW5uZXJUZXh0ID0gdGl0bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgYSB1c2VyIHByZXNzZXMgdGhlIGVudGVyIGtleSAoaWYgYXBwcm92aW5nIG1vZGFscyBieSBlbnRlciBrZXkgcHJlc3MgaXMgZW5hYmxlZCBpbiBzZXR0aW5ncykuIFRoZSBwdXJwb3NlXHJcbiAgICAgKiBvZiB0aGUgbWV0aG9kIGlzIHRvIGFwcHJvdmUvcGVyZm9ybSB0aGUgYWN0aW9uIHRoZSBtb2RhbCBpcyBhc2tpbmcvcHJlcGFyaW5nLiBUaGUgbWV0aG9kIHNob3VsZCB0aGVuIGNsb3NlIHRoZSBtb2RhbFxyXG4gICAgICogYnkgY2FsbGluZyB0aGlzLmNsb3NlKCkgLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgYXBwcm92ZSgpOiB2b2lkO1xyXG5cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfTW9kYWx9IGZyb20gXCIuL1NDX01vZGFsXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5pbXBvcnQge1NldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvbk1vZGFsIGV4dGVuZHMgU0NfTW9kYWwge1xyXG5cclxuICAgIHB1YmxpYyBwcm9taXNlOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgcHJpdmF0ZSByZXNvbHZlX3Byb21pc2U6ICh2YWx1ZTogKGJvb2xlYW4gfCBQcm9taXNlTGlrZTxib29sZWFuPikpID0+IHZvaWQ7XHJcbiAgICBwcml2YXRlIGFwcHJvdmVkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcGx1Z2luOiBTQ19QbHVnaW4sXHJcbiAgICAgICAgdGl0bGU6IHN0cmluZyxcclxuICAgICAgICBwcml2YXRlIHF1ZXN0aW9uOiBzdHJpbmcsXHJcbiAgICAgICAgcHJpdmF0ZSB5ZXNfYnV0dG9uX3RleHQ6IHN0cmluZyxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5zZXRUaXRsZSh0aXRsZSk7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlX3Byb21pc2UgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKCk7XHJcblxyXG4gICAgICAgIC8vIERpc3BsYXkgdGhlIHF1ZXN0aW9uXHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogdGhpcy5xdWVzdGlvbn0pO1xyXG5cclxuICAgICAgICAvLyBEaXNwbGF5IHRoZSB5ZXMgYnV0dG9uXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KHRoaXMueWVzX2J1dHRvbl90ZXh0KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5hcHByb3ZlKCkpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhcHByb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdvdCBhIGNvbmZpcm1hdGlvbiBmcm9tIGEgdXNlclxyXG4gICAgICAgIHRoaXMucmVzb2x2ZV9wcm9taXNlKHRydWUpO1xyXG4gICAgICAgIHRoaXMuYXBwcm92ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5hcHByb3ZlZCkgeyAvLyBUT0RPOiBGaW5kIG91dCBpZiB0aGVyZSBpcyBhIHdheSB0byBub3QgdXNlIHRoaXMga2luZCBvZiBmbGFnIHByb3BlcnR5LiBDYW4gdGhlIHN0YXR1cyBiZSBjaGVja2VkIGZyb20gdGhlIHByb21pc2UgaXRzZWxmP1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVfcHJvbWlzZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiXHJcbi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBsb2dnaW5nIHN0dWZmIHRvIGNvbnNvbGUubG9nKCkgd2lsbCBiZSBlbmFibGVkLlxyXG4gKiBNaWdodCBhbHNvIGVuYWJsZSBzb21lIHRlc3Rpbmcge3t2YXJpYWJsZXN9fSBpbiB0aGUgZnV0dXJlLCBwZXJoYXBzLlxyXG4gKi9cclxuZXhwb3J0IGxldCBERUJVR19PTiA9IGZhbHNlO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldERFQlVHX09OKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICBERUJVR19PTiA9IHZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbHMgY29uc29sZS5sb2coKSwgYnV0IG9ubHkgaWYgZGVidWdnaW5nIGlzIGVuYWJsZWQuXHJcbiAqIEBwYXJhbSBtZXNzYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVidWdMb2cobWVzc2FnZTogdW5rbm93bikge1xyXG4gICAgaWYgKERFQlVHX09OKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIElER2VuZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgcmVzZXJ2ZWRfaWRzOiBzdHJpbmdbXSA9IFtdLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgbWluX2xlbmd0aCA9IDEwLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgY2hhcmFjdGVycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCIsXHJcbiAgICApIHt9XHJcblxyXG4gICAgcHVibGljIGFkZFJlc2VydmVkSUQoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIGRlYnVnTG9nKElER2VuZXJhdG9yLm5hbWUgKyBcIjogQWRkaW5nIGlkIFwiICsgaWQgKyBcIiB0byB0aGUgbGlzdCBvZiByZXNlcnZlZCBpZHMuXCIpO1xyXG4gICAgICAgIHRoaXMucmVzZXJ2ZWRfaWRzLnB1c2goaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZW5lcmF0ZUlEKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGdlbmVyYXRlZF9pZCA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUgKGdlbmVyYXRlZF9pZC5sZW5ndGggPCB0aGlzLm1pbl9sZW5ndGggfHwgdGhpcy5pc0lEUmVzZXJ2ZWQoZ2VuZXJhdGVkX2lkKSkge1xyXG4gICAgICAgICAgICBnZW5lcmF0ZWRfaWQgKz0gdGhpcy5nZW5lcmF0ZUNoYXJhY3RlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2VydmVkX2lkcy5wdXNoKGdlbmVyYXRlZF9pZCk7XHJcbiAgICAgICAgZGVidWdMb2coSURHZW5lcmF0b3IubmFtZSArIFwiOiBHZW5lcmF0ZWQgaWQgXCIgKyBnZW5lcmF0ZWRfaWQpO1xyXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZWRfaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlc2VydmVkSURzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc2VydmVkX2lkcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlQ2hhcmFjdGVyKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVycy5jaGFyQXQoXHJcbiAgICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuY2hhcmFjdGVycy5sZW5ndGgpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzSURSZXNlcnZlZChpZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzZXJ2ZWRfaWRzLmNvbnRhaW5zKGlkKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgaWRfZ2VuZXJhdG9yOiBJREdlbmVyYXRvciA9IG5ldyBJREdlbmVyYXRvcigpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldElER2VuZXJhdG9yKCkge1xyXG4gICAgcmV0dXJuIGlkX2dlbmVyYXRvcjtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgICBBcHAsXHJcbiAgICBFZGl0b3IsXHJcbiAgICBFZGl0b3JQb3NpdGlvbixcclxuICAgIEZpbGVTeXN0ZW1BZGFwdGVyLFxyXG4gICAgRnJvbnRNYXR0ZXJDYWNoZSxcclxuICAgIE1hcmtkb3duVmlldyxcclxuICAgIG5vcm1hbGl6ZVBhdGgsXHJcbiAgICBURmlsZSxcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtQbGF0Zm9ybUlkfSBmcm9tIFwiLi9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtwbGF0Zm9ybX0gZnJvbSBcIm9zXCI7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4vRGVidWdcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcbi8vIEB0cy1pZ25vcmVcclxuaW1wb3J0IHtzaGVsbH0gZnJvbSBcImVsZWN0cm9uXCI7XHJcbi8vIEB0cy1pZ25vcmUgRWxlY3Ryb24gaXMgaW5zdGFsbGVkLlxyXG5pbXBvcnQge2NsaXBib2FyZH0gZnJvbSBcImVsZWN0cm9uXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmF1bHRBYnNvbHV0ZVBhdGgoYXBwOiBBcHApIHtcclxuICAgIC8vIE9yaWdpbmFsIGNvZGUgd2FzIGNvcGllZCAyMDIxLTA4LTIyIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BoaWJyMC9vYnNpZGlhbi1vcGVuLXdpdGgvYmxvYi84NGYwZTI1YmE4ZTgzNTVmZjgzYjIyZjQwNTBhZGRlNGNjNjc2M2VhL21haW4udHMjTDY2LUw2N1xyXG4gICAgLy8gQnV0IHRoZSBjb2RlIGhhcyBiZWVuIHJld3JpdHRlbiAyMDIxLTA4LTI3IGFzIHBlciBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW5tZC9vYnNpZGlhbi1yZWxlYXNlcy9wdWxsLzQzMyNpc3N1ZWNvbW1lbnQtOTA2MDg3MDk1XHJcbiAgICBjb25zdCBhZGFwdGVyID0gYXBwLnZhdWx0LmFkYXB0ZXI7XHJcbiAgICBpZiAoYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGx1Z2luQWJzb2x1dGVQYXRoKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIocGF0aC5qb2luKFxyXG4gICAgICAgIGdldFZhdWx0QWJzb2x1dGVQYXRoKHBsdWdpbi5hcHApLFxyXG4gICAgICAgIHBsdWdpbi5hcHAudmF1bHQuY29uZmlnRGlyLFxyXG4gICAgICAgIFwicGx1Z2luc1wiLFxyXG4gICAgICAgIHBsdWdpbi5nZXRQbHVnaW5JZCgpKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3Igc29tZSByZWFzb24gdGhlcmUgaXMgbm8gUGxhdGZvcm0uaXNXaW5kb3dzIC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dpbmRvd3MoKSB7XHJcbiAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhcm91bmQgcGxhdGZvcm0oKSBpbiBvcmRlciB0byBjYXN0IHRoZSB0eXBlIHRvIFBsYXRmb3JtSWQuXHJcbiAqIFRPRE86IENvbnNpZGVyIHJlbmFtaW5nIHRoaXMgdG8gZ2V0UGxhdGZvcm1JZCgpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGluZ1N5c3RlbSgpOiBQbGF0Zm9ybUlkICB7XHJcbiAgICAvLyBAdHMtaWdub3JlIEluIHRoZW9yeSwgcGxhdGZvcm0oKSBjYW4gcmV0dXJuIGFuIE9TIG5hbWUgbm90IGluY2x1ZGVkIGluIE9wZXJhdGluZ1N5c3RlbU5hbWUuIEJ1dCBhcyBPYnNpZGlhblxyXG4gICAgLy8gY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgYW55dGhpbmcgZWxzZSB0aGFuIFdpbmRvd3MsIE1hYyBhbmQgTGludXggKGV4Y2VwdCBtb2JpbGUgcGxhdGZvcm1zLCBidXQgdGhleSBhcmVcclxuICAgIC8vIHJ1bGVkIG91dCBieSB0aGUgbWFuaWZlc3Qgb2YgdGhpcyBwbHVnaW4pLCBpdCBzaG91bGQgYmUgc2FmZSB0byBhc3N1bWUgdGhhdCB0aGUgY3VycmVudCBPUyBpcyBvbmUgb2YgdGhvc2VcclxuICAgIC8vIHRocmVlLlxyXG4gICAgcmV0dXJuIHBsYXRmb3JtKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3KGFwcDogQXBwKSB7XHJcbiAgICBjb25zdCB2aWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcImdldFZpZXcoKTogQ291bGQgbm90IGdldCBhIHZpZXcuIFdpbGwgcmV0dXJuIG51bGwuXCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFZGl0b3IoYXBwOiBBcHApOiBFZGl0b3Ige1xyXG5cclxuICAgIGNvbnN0IHZpZXcgPSBnZXRWaWV3KGFwcCk7XHJcbiAgICBpZiAobnVsbCA9PT0gdmlldykge1xyXG4gICAgICAgIC8vIENvdWxkIG5vdCBnZXQgYSB2aWV3LlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuc3VyZSB0aGF0IHZpZXcuZWRpdG9yIGV4aXN0cyEgSXQgZXhpc3RzIGF0IGxlYXN0IGlmIHRoaXMgaXMgYSBNYXJrRG93blZpZXcuXHJcbiAgICBpZiAoXCJlZGl0b3JcIiBpbiB2aWV3KSB7XHJcbiAgICAgICAgLy8gR29vZCwgaXQgZXhpc3RzLlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgV2UgYWxyZWFkeSBrbm93IHRoYXQgdmlldy5lZGl0b3IgZXhpc3RzLlxyXG4gICAgICAgIHJldHVybiB2aWV3LmVkaXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaWQgbm90IGZpbmQgYW4gZWRpdG9yLlxyXG4gICAgZGVidWdMb2coXCJnZXRFZGl0b3IoKTogJ3ZpZXcnIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCAnZWRpdG9yJy4gV2lsbCByZXR1cm4gbnVsbC5cIik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lT2JqZWN0PE9iamVjdFR5cGU+KG9iamVjdDogT2JqZWN0KTogT2JqZWN0VHlwZXtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpIGFzIE9iamVjdFR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlci4gSWYgdGhleSBoYXZlIHNhbWUgcHJvcGVydHkgbmFtZXMsIGZvcm1lciBvYmplY3RzJyBwcm9wZXJ0aWVzIGdldCBvdmVyd3JpdHRlbiBieSBsYXRlciBvYmplY3RzJyBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVPYmplY3RzKC4uLm9iamVjdHM6IE9iamVjdFtdKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgLi4ub2JqZWN0cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVNldHM8U2V0VHlwZT4oc2V0MTogU2V0PFNldFR5cGU+LCBzZXQyOiBTZXQ8U2V0VHlwZT4pOiBTZXQ8U2V0VHlwZT4ge1xyXG4gICAgcmV0dXJuIG5ldyBTZXQ8U2V0VHlwZT4oWy4uLnNldDEsIC4uLnNldDJdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgU2V0IGNsb25lZCBmcm9tICdmcm9tX3NldCcsIHdpdGggYWxsIGl0ZW1zIHByZXNlbnRlZCBpbiAncmVtb3ZlJyByZW1vdmVkIGZyb20gaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmcm9tX3NldFxyXG4gKiBAcGFyYW0gcmVtb3ZlIENhbiBiZSBlaXRoZXIgYSBTZXQgb2YgcmVtb3ZhYmxlIGl0ZW1zLCBvciBhIHNpbmdsZSBpdGVtLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUZyb21TZXQ8U2V0VHlwZT4oZnJvbV9zZXQ6IFNldDxTZXRUeXBlPiwgcmVtb3ZlOiBTZXQ8U2V0VHlwZT4gfCBTZXRUeXBlKTogU2V0PFNldFR5cGU+IHtcclxuICAgIGNvbnN0IHJlZHVjZWRfc2V0ID0gbmV3IFNldChmcm9tX3NldCk7XHJcbiAgICBpZiAocmVtb3ZlIGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZW1vdmFibGUgb2YgcmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHJlZHVjZWRfc2V0LmRlbGV0ZShyZW1vdmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVkdWNlZF9zZXQuZGVsZXRlKHJlbW92ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVkdWNlZF9zZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW1lIGFzIG5vcm1hbGl6ZVBhdGgoKSwgYnV0IGZpeGVzIHRoZXNlIGdsaXRjaGVzOlxyXG4gKiAtIExlYWRpbmcgZm9yd2FyZCBzbGFzaGVzIC8gYmFja3dhcmQgc2xhc2hlcyBzaG91bGQgbm90IGJlIHJlbW92ZWQuXHJcbiAqIC0gXFwgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gLyBpZiBwbGF0Zm9ybSBpcyBXaW5kb3dzLiBJbiBvdGhlciB3b3JkcywgLyBzaG91bGQgYmUgY29udmVydGVkIHRvIFxcIGlmIHBsYXRmb3JtIGlzIFdpbmRvd3MuXHJcbiAqXHJcbiAqIFRPRE86IEkndmUgb3BlbmVkIGEgZGlzY3Vzc2lvbiBhYm91dCB0aGlzIG9uIE9ic2lkaWFuJ3MgZm9ydW1zLiBJZiBhbnl0aGluZyBuZXcgY29tZXMgdXAgaW4gdGhlIGRpc2N1c3Npb24sIG1ha2UgY2hhbmdlcyBhY2NvcmRpbmdseS4gaHR0cHM6Ly9mb3J1bS5vYnNpZGlhbi5tZC90L25vcm1hbGl6ZXBhdGgtcmVtb3Zlcy1hLWxlYWRpbmcvMjQ3MTNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQYXRoMihwYXRoOiBzdHJpbmcpIHtcclxuICAgIC8vIDEuIFByZXBhcmF0aW9uc1xyXG4gICAgcGF0aCA9IHBhdGgudHJpbSgpO1xyXG4gICAgY29uc3QgbGVhZGluZ19zbGFzaGVzX3JlZ2V4cCA9IC9eWy9cXFxcXSovZ3U7IC8vIEdldCBhcyBtYW55IC8gb3IgXFwgc2xhc2hlcyBhcyB0aGVyZSBhcmUgaW4gdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHBhdGguIENhbiBhbHNvIGJlIFwiXCIgKGFuIGVtcHR5IHN0cmluZykuXHJcbiAgICBsZXQgbGVhZGluZ19zbGFzaGVzID0gbGVhZGluZ19zbGFzaGVzX3JlZ2V4cC5leGVjKHBhdGgpWzBdO1xyXG5cclxuICAgIC8vIDIuIFJ1biB0aGUgb3JpZ2luYWwgbm9ybWFsaXplUGF0aCgpXHJcbiAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcclxuXHJcbiAgICAvLyAzLiBGaXhlc1xyXG4gICAgLy8gQ2hlY2sgdGhhdCBjb3JyZWN0IHNsYXNoZXMgYXJlIHVzZWQuXHJcbiAgICBpZiAoaXNXaW5kb3dzKCkpIHtcclxuICAgICAgICAvLyBUaGUgcGxhdGZvcm0gaXMgV2luZG93cy5cclxuICAgICAgICAvLyBDb252ZXJ0IC8gdG8gXFxcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8vZ3UsIFwiXFxcXFwiKTsgLy8gTmVlZCB0byB1c2UgYSByZWdleHAgaW5zdGVhZCBvZiBhIG5vcm1hbCBcIi9cIiAtPiBcIlxcXFxcIiByZXBsYWNlIGJlY2F1c2UgdGhlIG5vcm1hbCByZXBsYWNlIHdvdWxkIG9ubHkgcmVwbGFjZSBmaXJzdCBvY2N1cnJlbmNlIG9mIC8uXHJcbiAgICAgICAgbGVhZGluZ19zbGFzaGVzID0gbGVhZGluZ19zbGFzaGVzLnJlcGxhY2UoL1xcLy9ndSwgXCJcXFxcXCIpOyAvLyBTYW1lIGhlcmUuXHJcbiAgICB9XHJcbiAgICAvLyBOb3cgZW5zdXJlIHRoYXQgcGF0aCBzdGlsbCBjb250YWlucyBsZWFkaW5nIHNsYXNoZXMgKGlmIHRoZXJlIHdlcmUgYW55IGJlZm9yZSBjYWxsaW5nIG5vcm1hbGl6ZVBhdGgoKSkuXHJcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBwYXRoIHNob3VsZCBoYXZlIGEgc2ltaWxhciBzZXQgb2YgbGVhZGluZyBzbGFzaGVzIGF0IHRoZSBiZWdpbm5pbmcuIEl0IGNhbiBiZSBhdCBsZWFzdCBcIi9cIiAob24gbGludXgvTWFjKSwgb3IgXCJcXFxcXCIgKG9uIFdpbmRvd3Mgd2hlbiBpdCdzIGEgbmV0d29yayBwYXRoKSwgaW4gdGhlb3J5IGV2ZW4gXCIvLy9cIiBvciBcIlxcXFxcXFxcXFxcIiB3aGF0ZXZlci5cclxuICAgIC8vIG5vcm1hbGl6ZVBhdGgoKSBzZWVtcyB0byByZW1vdmUgbGVhZGluZyBzbGFzaGVzIChhbmQgdGhleSBhcmUgbmVlZGVkIHRvIGJlIHJlLWFkZGVkKSwgYnV0IGl0J3MgbmVlZGVkIHRvIGNoZWNrIGZpcnN0LCBvdGhlcndpc2UgdGhlIHBhdGggd291bGQgaGF2ZSBkb3VibGUgbGVhZGluZyBzbGFzaGVzIGlmIG5vcm1hbGl6ZVBhdGgoKSBnZXRzIGZpeGVkIGluIHRoZSBmdXR1cmUuXHJcbiAgICBpZiAobGVhZGluZ19zbGFzaGVzLmxlbmd0aCAmJiBwYXRoLnNsaWNlKDAsIGxlYWRpbmdfc2xhc2hlcy5sZW5ndGgpICE9PSBsZWFkaW5nX3NsYXNoZXMpIHtcclxuICAgICAgICAvLyBUaGUgcGF0aCBkb2VzIG5vdCBjb250YWluIHRoZSByZXF1aXJlZCBzZXQgb2YgbGVhZGluZyBzbGFzaGVzLCBzbyBhZGQgdGhlbS5cclxuICAgICAgICBwYXRoID0gbGVhZGluZ19zbGFzaGVzICsgcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyA0LiBEb25lXHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGaWxlTmFtZShmaWxlX3BhdGg6IHN0cmluZywgd2l0aF9leHRlbnNpb24gPSB0cnVlKSB7XHJcbiAgICBpZiAod2l0aF9leHRlbnNpb24pIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5wYXJzZShmaWxlX3BhdGgpLmJhc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwYXRoLnBhcnNlKGZpbGVfcGF0aCkubmFtZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGaWxlUGFyZW50UGF0aChmaWxlX3BhdGg6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHBhdGgucGFyc2UoZmlsZV9wYXRoKS5kaXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBqb2luT2JqZWN0UHJvcGVydGllcyhvYmplY3Q6IHt9LCBnbHVlOiBzdHJpbmcpIHtcclxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eV9uYW1lIGluIG9iamVjdCkge1xyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBnbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgcmVzdWx0ICs9IG9iamVjdFtwcm9wZXJ0eV9uYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBkdXBsaWNhdGVzIGZyb20gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIElkZWEgaXMgY29waWVkIDIwMjEtMTAtMDYgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzMxMjE4ODAvMjc1NDAyNlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUFycmF5KGFycmF5OiBhbnlbXSkge1xyXG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcGVucyBhIHdlYiBicm93c2VyIGluIHRoZSBzcGVjaWZpZWQgVVJMLlxyXG4gKiBAcGFyYW0gdXJsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ290b1VSTCh1cmw6IHN0cmluZykge1xyXG4gICAgc2hlbGwub3BlbkV4dGVybmFsKHVybCk7IC8vIFRoaXMgcmV0dXJucyBhIHByb21pc2UsIGJ1dCBpdCBjYW4gYmUgaWdub3JlZCBhcyB0aGVyZSdzIG5vdGhpbmcgdG8gZG8gYWZ0ZXIgb3BlbmluZyB0aGUgYnJvd3Nlci5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZShwbHVnaW46IFNDX1BsdWdpbiwgc2hlbGxfY29tbWFuZDogc3RyaW5nLCBhbGlhczogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBwcmVmaXggPSBwbHVnaW4uc2V0dGluZ3Mub2JzaWRpYW5fY29tbWFuZF9wYWxldHRlX3ByZWZpeDtcclxuICAgIGlmIChhbGlhcykge1xyXG4gICAgICAgIC8vIElmIGFuIGFsaWFzIGlzIHNldCBmb3IgdGhlIGNvbW1hbmQsIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlIHNob3VsZCBkaXNwbGF5IHRoZSBhbGlhcyB0ZXh0IGluc3RlYWQgb2YgdGhlIGFjdHVhbCBjb21tYW5kLlxyXG4gICAgICAgIHJldHVybiBwcmVmaXggKyBhbGlhcztcclxuICAgIH1cclxuICAgIHJldHVybiBwcmVmaXggKyBzaGVsbF9jb21tYW5kO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlOiBzdHJpbmcsIGFsbG93X21pbnVzOiBib29sZWFuKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoYWxsb3dfbWludXMpIHtcclxuICAgICAgICByZXR1cm4gISF2YWx1ZS5tYXRjaCgvXi0/XFxkKyQvdSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhIXZhbHVlLm1hdGNoKC9eXFxkKyQvdSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2xhdGVzIDEtaW5kZXhlZCBjYXJldCBsaW5lIGFuZCBjb2x1bW4gdG8gYSAwLWluZGV4ZWQgRWRpdG9yUG9zaXRpb24gb2JqZWN0LiBBbHNvIHRyYW5zbGF0ZXMgYSBwb3NzaWJseSBuZWdhdGl2ZSBsaW5lXHJcbiAqIHRvIGEgcG9zaXRpdmUgbGluZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGZpbGUsIGFuZCBhIHBvc3NpYmx5IG5lZ2F0aXZlIGNvbHVtbiB0byBhIHBvc2l0aXZlIGNvbHVtbiBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpbmUuXHJcbiAqIEBwYXJhbSBlZGl0b3JcclxuICogQHBhcmFtIGNhcmV0X2xpbmVcclxuICogQHBhcmFtIGNhcmV0X2NvbHVtblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVFZGl0b3JQb3NpdGlvbihlZGl0b3I6IEVkaXRvciwgY2FyZXRfbGluZTogbnVtYmVyLCBjYXJldF9jb2x1bW46IG51bWJlcik6IEVkaXRvclBvc2l0aW9uIHtcclxuICAgIC8vIERldGVybWluZSBsaW5lXHJcbiAgICBpZiAoY2FyZXRfbGluZSA8IDApIHtcclxuICAgICAgICAvLyBOZWdhdGl2ZSBsaW5lIG1lYW5zIHRvIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBlbmQgb2YgdGhlIGZpbGUuXHJcbiAgICAgICAgY2FyZXRfbGluZSA9IE1hdGgubWF4KDAsIGVkaXRvci5sYXN0TGluZSgpICsgY2FyZXRfbGluZSArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBQb3NpdGl2ZSBsaW5lIG5lZWRzIGp1c3QgYSBzbWFsbCBhZGp1c3RtZW50LlxyXG4gICAgICAgIC8vIEVkaXRvciBsaW5lIGlzIHplcm8taW5kZXhlZCwgbGluZSBudW1iZXJzIGFyZSAxLWluZGV4ZWQuXHJcbiAgICAgICAgY2FyZXRfbGluZSAtPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBjb2x1bW5cclxuICAgIGlmIChjYXJldF9jb2x1bW4gPCAwKSB7XHJcbiAgICAgICAgLy8gTmVnYXRpdmUgY29sdW1uIG1lYW5zIHRvIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpbmUuXHJcbiAgICAgICAgY2FyZXRfY29sdW1uID0gTWF0aC5tYXgoMCwgZWRpdG9yLmdldExpbmUoY2FyZXRfbGluZSkubGVuZ3RoICsgY2FyZXRfY29sdW1uICsgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFBvc2l0aXZlIGNvbHVtbiBuZWVkcyBqdXN0IGEgc21hbGwgYWRqdXN0bWVudC5cclxuICAgICAgICAvLyBFZGl0b3IgY29sdW1uIGlzIHplcm8taW5kZXhlZCwgY29sdW1uIG51bWJlcnMgYXJlIDEtaW5kZXhlZC5cclxuICAgICAgICBjYXJldF9jb2x1bW4gLT0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpbmU6IGNhcmV0X2xpbmUsXHJcbiAgICAgICAgY2g6IGNhcmV0X2NvbHVtbixcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGlvbkZyb21UZXh0YXJlYSh0ZXh0YXJlYV9lbGVtZW50OiBIVE1MVGV4dEFyZWFFbGVtZW50LCByZXR1cm5fbnVsbF9pZl9lbXB0eTogdHJ1ZSk6IHN0cmluZyB8IG51bGw7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rpb25Gcm9tVGV4dGFyZWEodGV4dGFyZWFfZWxlbWVudDogSFRNTFRleHRBcmVhRWxlbWVudCwgcmV0dXJuX251bGxfaWZfZW1wdHk6IGZhbHNlKTogc3RyaW5nO1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRnJvbVRleHRhcmVhKHRleHRhcmVhX2VsZW1lbnQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQsIHJldHVybl9udWxsX2lmX2VtcHR5OiBib29sZWFuKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICBjb25zdCBzZWxlY3RlZF90ZXh0ID0gdGV4dGFyZWFfZWxlbWVudC52YWx1ZS5zdWJzdHJpbmcodGV4dGFyZWFfZWxlbWVudC5zZWxlY3Rpb25TdGFydCwgdGV4dGFyZWFfZWxlbWVudC5zZWxlY3Rpb25FbmQpO1xyXG4gICAgcmV0dXJuIFwiXCIgPT09IHNlbGVjdGVkX3RleHQgJiYgcmV0dXJuX251bGxfaWZfZW1wdHkgPyBudWxsIDogc2VsZWN0ZWRfdGV4dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gSFRNTEVsZW1lbnQgKHdpdGggZnJlZWx5IGRlY2lkYWJsZSB0YWcpIGFuZCBhZGRzIHRoZSBnaXZlbiBjb250ZW50IGludG8gaXQgYXMgbm9ybWFsIHRleHQuIE5vIEhUTUwgZm9ybWF0dGluZ1xyXG4gKiBpcyBzdXBwb3J0ZWQsIGkuZS4gcG9zc2libGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIHNob3duIGFzLWlzLiBOZXdsaW5lIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCB0byA8YnI+IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGFnXHJcbiAqIEBwYXJhbSBjb250ZW50XHJcbiAqIEBwYXJhbSBwYXJlbnRfZWxlbWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU11bHRpbGluZVRleHRFbGVtZW50KHRhZzoga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwLCBjb250ZW50OiBzdHJpbmcsIHBhcmVudF9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgY29uc3QgY29udGVudF9lbGVtZW50ID0gcGFyZW50X2VsZW1lbnQuY3JlYXRlRWwodGFnKTtcclxuXHJcbiAgICAvLyBJbnNlcnQgY29udGVudCBsaW5lLWJ5LWxpbmVcclxuICAgIGNvbnN0IGNvbnRlbnRfbGluZXMgPSBjb250ZW50LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKTsgLy8gRG9uJ3QgdXNlICggKSB3aXRoIHwgYmVjYXVzZSAuc3BsaXQoKSB3b3VsZCB0aGVuIGluY2x1ZGUgdGhlIG5ld2xpbmUgY2hhcmFjdGVycyBpbiB0aGUgcmVzdWx0aW5nIGFycmF5LlxyXG4gICAgY29udGVudF9saW5lcy5mb3JFYWNoKChjb250ZW50X2xpbmU6IHN0cmluZywgY29udGVudF9saW5lX2luZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAvLyBJbnNlcnQgdGhlIGxpbmUuXHJcbiAgICAgICAgY29udGVudF9lbGVtZW50Lmluc2VydEFkamFjZW50VGV4dChcImJlZm9yZWVuZFwiLCBjb250ZW50X2xpbmUpO1xyXG5cclxuICAgICAgICAvLyBJbnNlcnQgYSBsaW5lYnJlYWsgPGJyPiBpZiBuZWVkZWQuXHJcbiAgICAgICAgaWYgKGNvbnRlbnRfbGluZV9pbmRleCA8IGNvbnRlbnRfbGluZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBjb250ZW50X2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIFwiPGJyPlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb250ZW50X2VsZW1lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JbnRlZ2VyKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xyXG4gICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW4gKyAxO1xyXG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERvZXMgdGhlIGZvbGxvd2luZyBwcmVmaXhpbmdzOlxyXG4gKiAgIFxcIHdpbGwgYmVjb21lIFxcXFxcclxuICogICBbIHdpbGwgYmVjb21lIFxcW1xyXG4gKiAgIF0gd2lsbCBiZWNvbWUgXFxdXHJcbiAqICAgKCB3aWxsIGJlY29tZSBcXChcclxuICogICApIHdpbGwgYmVjb21lIFxcKVxyXG4gKlxyXG4gKiBAcGFyYW0gY29udGVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZU1hcmtkb3duTGlua0NoYXJhY3RlcnMoY29udGVudDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9bXFxcXCgpXFxbXFxdXS9ndSwgXCJcXFxcJCZcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGVDb250ZW50V2l0aG91dFlBTUwoYXBwOiBBcHAsIGZpbGU6IFRGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIC8vIFRoZSBsb2dpYyBpcyBib3Jyb3dlZCAyMDIyLTA5LTAxIGZyb20gaHR0cHM6Ly9mb3J1bS5vYnNpZGlhbi5tZC90L2hvdy10by1nZXQtY3VycmVudC1maWxlLWNvbnRlbnQtd2l0aG91dC15YW1sLWZyb250bWF0dGVyLzI2MTk3LzJcclxuICAgICAgICAvLyBUaGFuayB5b3UsIGVuZG9yYW1hISA8M1xyXG4gICAgICAgIGNvbnN0IGZpbGVfY29udGVudCA9IGFwcC52YXVsdC5yZWFkKGZpbGUpO1xyXG4gICAgICAgIGZpbGVfY29udGVudC50aGVuKChmaWxlX2NvbnRlbnQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlcl9jYWNoZTogRnJvbnRNYXR0ZXJDYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKS5mcm9udG1hdHRlcjtcclxuICAgICAgICAgICAgaWYgKGZyb250bWF0dGVyX2NhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBIFlBTUwgZnJvbnRtYXR0ZXIgaXMgcHJlc2VudCBpbiB0aGUgZmlsZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyX2VuZF9saW5lX251bWJlciA9IGZyb250bWF0dGVyX2NhY2hlLnBvc2l0aW9uLmVuZC5saW5lICsgMTsgLy8gKyAxOiBUYWtlIHRoZSBsYXN0IC0tLSBsaW5lIGludG8gYWNjb3VudCwgdG9vLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZV9jb250ZW50X3dpdGhvdXRfZnJvbnRtYXR0ZXI6IHN0cmluZyA9IGZpbGVfY29udGVudC5zcGxpdChcIlxcblwiKS5zbGljZShmcm9udG1hdHRlcl9lbmRfbGluZV9udW1iZXIpLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlX2NvbnRlbnRfd2l0aG91dF9mcm9udG1hdHRlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBZQU1MIGZyb250bWF0dGVyIGlzIHByZXNlbnQgaW4gdGhlIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHdob2xlIGZpbGUgY29udGVudCwgYmVjYXVzZSB0aGVyZSdzIG5vdGhpbmcgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZV9jb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0iLCJcclxuLyoqXHJcbiAqIEVzY2FwZXMgYSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYSBwYXR0ZXJuIGluIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBlc2NhcGUgbWludXM6IC0gLiBJdCdzIHByb2JhYmx5IG9rIGFzIGxvbmcgYXMgeW91IHdvbid0IHdyYXAgdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGluIHNxdWFyZSBicmFja2V0cyBbIF0gLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCBhIGNvbW1lbnQgYnkgY29vbGFqODYgb24gTm92IDI5LCAyMDE5IGF0IDI6NDQgaW4gdGhpcyBTdGFjayBPdmVyZmxvdyBhbnN3ZXI6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2LzI3NTQwMjZcclxuICpcclxuICogQ29waWVkIDIwMjItMDMtMTAgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMjZXNjYXBpbmdcclxuICogTW9kaWZpY2F0aW9uczpcclxuICogIC0gQWRkZWQgVHlwZVNjcmlwdCBkYXRhIHR5cGUgaGludHMgZm9yIHRoZSBwYXJhbWV0ZXIgYW5kIHJldHVybiB2YWx1ZS5cclxuICogIC0gQWRkZWQgJ2V4cG9ydCcga2V5d29yZC5cclxuICogIC0gQWRkZWQgdGhpcyBKU0RvYy5cclxuICogIC0gTm8gb3RoZXIgY2hhbmdlcy5cclxuICpcclxuICogQHBhcmFtIHN0cmluZ1xyXG4gKiBAcmV0dXJuIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xyXG59XHJcbiIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7QXBwfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge2VzY2FwZVJlZ0V4cH0gZnJvbSBcIi4uL2xpYi9lc2NhcGVSZWdFeHBcIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuaW1wb3J0IHtQYXJzaW5nUmVzdWx0fSBmcm9tIFwiLi9wYXJzZVZhcmlhYmxlc1wiO1xyXG5cclxuLyoqXHJcbiAqIFZhcmlhYmxlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGluamVjdCB2YWx1ZXMgdG8gc2hlbGwgY29tbWFuZHMgdXNpbmcge3t2YXJpYWJsZTphcmd1bWVudH19IHN5bnRheC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBWYXJpYWJsZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJfc2VwYXJhdG9yID0gXCI6XCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBwOiBBcHA7XHJcbiAgICBwcml2YXRlIGVycm9yX21lc3NhZ2VzOiBzdHJpbmdbXTsgLy8gRGVmYXVsdCB2YWx1ZSBpcyBzZXQgaW4gLnJlc2V0KClcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGlzIGlzIGZhbHNlLCB0aGUgdmFyaWFibGUgY2FuIGJlIGFzc2lnbmVkIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIGluIHNpdHVhdGlvbnMgd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuYXZhaWxhYmxlLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWx3YXlzX2F2YWlsYWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGRlZmluaXRpb24gZm9yIHdoYXQgcGFyYW1ldGVycyB0aGlzIHZhcmlhYmxlcyB0YWtlcy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjb250YWlucyBhY3R1YWwgdmFsdWVzIGZvciBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiBJQXJndW1lbnRzOyAvLyBEZWZhdWx0IHZhbHVlIGlzIHNldCBpbiAucmVzZXQoKVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuYXBwID0gcGx1Z2luLmFwcDtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7IC8vIFRoaXMgaXMgYWxzbyBjYWxsZWQgaW4gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXMoKSwgYnV0IGNhbGwgaXQgaGVyZSBqdXN0IGluIGNhc2UuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYXJpYWJsZSBpbnN0YW5jZXMgYXJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy4gVGhpcyBtZXRob2QgcmVzZXRzIGFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG1vZGlmaWVkIGR1cmluZyB1c2FnZTpcclxuICAgICAqICAtIGVycm9yX21lc3NhZ2VzXHJcbiAgICAgKiAgLSBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JfbWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRWYWx1ZShcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQgfCBudWxsID0gbnVsbCxcclxuICAgICAgICBzY19ldmVudDogU0NfRXZlbnQgfCBudWxsID0gbnVsbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2lsbCBwYXJzZSB2YXJpYWJsZXMgaW4gYSBkZWZhdWx0IHZhbHVlIChvbmx5IHVzZWQgaWYgdGhpcyB2YXJpYWJsZSBpcyBub3QgYXZhaWxhYmxlIHRoaXMgdGltZSkuIFRoZSBjYWxsYmFja1xyXG4gICAgICAgICAqIGlzIG9ubHkgdXNlZCwgaWYgdF9zaGVsbF9jb21tYW5kIGlzIGdpdmVuLiBTZXQgdG8gbnVsbCwgaWYgbm8gdmFyaWFibGUgcGFyc2luZyBpcyBuZWVkZWQgZm9yIGRlZmF1bHQgdmFsdWVzLlxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgZGVmYXVsdF92YWx1ZV9wYXJzZXI6ICgoY29udGVudDogc3RyaW5nKSA9PiBQcm9taXNlPFBhcnNpbmdSZXN1bHQ+KSB8IG51bGwgPSBudWxsLFxyXG4gICAgKTogUHJvbWlzZTxWYXJpYWJsZVZhbHVlUmVzdWx0PiB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxWYXJpYWJsZVZhbHVlUmVzdWx0PigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0F2YWlsYWJsZShzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSB2YXJpYWJsZSBjYW4gYmUgdXNlZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVWYWx1ZShzY19ldmVudCkudGhlbigodmFsdWU6IHN0cmluZyB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlczogdGhpcy5lcnJvcl9tZXNzYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VlZGVkOiB0aGlzLmVycm9yX21lc3NhZ2VzLmxlbmd0aCA9PT0gMCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBzaXR1YXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGF0IHNob3VsZCBiZSBkb25lLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uID0gdF9zaGVsbF9jb21tYW5kPy5nZXREZWZhdWx0VmFsdWVDb25maWd1cmF0aW9uRm9yVmFyaWFibGUodGhpcyk7IC8vIFRoZSBtZXRob2QgY2FuIHJldHVybiB1bmRlZmluZWQsIGFuZCB0X3NoZWxsX2NvbW1hbmQgY2FuIGJlIG51bGwuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0X3ZhbHVlX3R5cGUgPSBkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24gPyBkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24udHlwZSA6IFwic2hvdy1lcnJvcnNcIjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnX21lc3NhZ2VfYmFzZSA9IFwiVmFyaWFibGUgXCIgKyB0aGlzLmdldEZ1bGxOYW1lKCkgKyBcIiBpcyBub3QgYXZhaWxhYmxlLiBcIjtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGVmYXVsdF92YWx1ZV90eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNob3ctZXJyb3JzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGVycm9yIG1lc3NhZ2VzIGJ5IGNhbGxpbmcgZ2VuZXJhdGVWYWx1ZSgpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhkZWJ1Z19tZXNzYWdlX2Jhc2UgKyBcIldpbGwgcHJldmVudCBzaGVsbCBjb21tYW5kIGV4ZWN1dGlvbiBhbmQgc2hvdyB2aXNpYmxlIGVycm9yIG1lc3NhZ2VzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQXZhaWxhYmlsaXR5IGVycm9ycyBnZW5lcmF0aW9uIHNob3VsZCBiZSBtb3ZlZCB0byBoYXBwZW4gaW4gYSBkaWZmZXJlbnQgbWV0aG9kIHRoYW4gLmdlbmVyYXRlVmFsdWUoKSwgd2hpY2ggc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIHZhcmlhYmxlIGlzIGF2YWlsYWJsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVZhbHVlKHNjX2V2ZW50KS50aGVuKCgpID0+IHsgIC8vIE5vIG5lZWQgdG8gdXNlIHRoZSByZXR1cm4gdmFsdWUsIGl0J3MgbnVsbCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlczogdGhpcy5lcnJvcl9tZXNzYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FuY2VsLXNpbGVudGx5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZXhlY3V0aW9uLCBidXQgZG8gbm90IHNob3cgYW55IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhkZWJ1Z19tZXNzYWdlX2Jhc2UgKyBcIldpbGwgcHJldmVudCBzaGVsbCBjb21tYW5kIGV4ZWN1dGlvbiBzaWxlbnRseSB3aXRob3V0IHZpc2libGUgZXJyb3IgbWVzc2FnZXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYSBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhkZWJ1Z19tZXNzYWdlX2Jhc2UgKyBcIldpbGwgdXNlIGEgZGVmYXVsdCB2YWx1ZTogXCIgKyBkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdF92YWx1ZV9wYXJzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHBvc3NpYmxlIHZhcmlhYmxlcyBpbiB0aGUgZGVmYXVsdCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRfdmFsdWVfcGFyc2VyKGRlZmF1bHRfdmFsdWVfY29uZmlndXJhdGlvbi52YWx1ZSkudGhlbigoZGVmYXVsdF92YWx1ZV9wYXJzaW5nX3Jlc3VsdDogUGFyc2luZ1Jlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X3ZhbHVlX3BhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGVmYXVsdF92YWx1ZV9wYXJzaW5nX3Jlc3VsdC5wYXJzZWRfY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdF92YWx1ZV9wYXJzaW5nX3Jlc3VsdC5vcmlnaW5hbF9jb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZXM6IGRlZmF1bHRfdmFsdWVfcGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZDogZGVmYXVsdF92YWx1ZV9wYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB2YXJpYWJsZSBwYXJzaW5nIGlzIHdhbnRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPOiBDb25zaWRlciBjYW4gdGhlIHNjX2V2ZW50IHBhcmFtZXRlciBiZSBtb3ZlZCBzbyB0aGF0IGl0IHdvdWxkIG9ubHkgZXhpc3QgaW4gRXZlbnRWYXJpYWJsZSBhbmQgaXQncyBjaGlsZCBjbGFzc2VzPyBTYW1lIGZvciBnZXRWYWx1ZSgpIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50KTogUHJvbWlzZTxzdHJpbmd8bnVsbD47XHJcblxyXG4gICAgcHJvdGVjdGVkIGdldFBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRfY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBWYXJpYWJsZTtcclxuICAgICAgICByZXR1cm4gY2hpbGRfY2xhc3MucGFyYW1ldGVycztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFBhcmFtZXRlclNlcGFyYXRvcigpIHtcclxuICAgICAgICBjb25zdCBjaGlsZF9jbGFzcyA9IHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFZhcmlhYmxlO1xyXG4gICAgICAgIHJldHVybiBjaGlsZF9jbGFzcy5wYXJhbWV0ZXJfc2VwYXJhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQYXR0ZXJuKCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yX3ByZWZpeCA9IHRoaXMudmFyaWFibGVfbmFtZSArIFwiLmdldFBhdHRlcm4oKTogXCI7XHJcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAnXFxcXHtcXFxceyE/JyArIGVzY2FwZVJlZ0V4cCh0aGlzLnZhcmlhYmxlX25hbWUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyX25hbWUgaW4gdGhpcy5nZXRQYXJhbWV0ZXJzKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXJzKClbcGFyYW1ldGVyX25hbWVdO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyX3R5cGVfcGF0dGVybjogc3RyaW5nID0gdGhpcy5nZXRQYXJhbWV0ZXJTZXBhcmF0b3IoKTsgIC8vIEhlcmUgdGhpcy5wYXJhbWV0ZXJfc2VwYXJhdG9yICg9IDogKSBpcyBpbmNsdWRlZCBpbiB0aGUgcGFyYW1ldGVyIHZhbHVlIGp1c3Qgc28gdGhhdCBpdCdzIG5vdCBuZWVkZWQgdG8gZG8gbmVzdGVkIHBhcmVudGhlc2lzIHRvIGFjY29tcGxpc2ggcG9zc2libGUgb3B0aW9uYWxpdHk6ICg6KCkpPy4gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXMoKSB3aWxsIHJlbW92ZSB0aGUgbGVhZGluZyA6IC5cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHNob3VsZCB3ZSB1c2UgcGFyYW1ldGVyLm9wdGlvbnMgb3IgcGFyYW1ldGVyLnR5cGUuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gcGFyYW1ldGVyLm9wdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gcGFyYW1ldGVyLnR5cGVcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIGlzIGRlZmluZWQgOihcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGVycm9yX3ByZWZpeCArIFwiUGFyYW1ldGVyICdcIiArIHBhcmFtZXRlcl9uYW1lICsgXCInIHNob3VsZCBkZWZpbmUgZWl0aGVyICd0eXBlJyBvciAnb3B0aW9ucycsIG5laXRoZXIgaXMgZGVmaW5lZCFcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgIT09IHBhcmFtZXRlci5vcHRpb25zICYmXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgIT09IHBhcmFtZXRlci50eXBlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQm90aCBhcmUgZGVmaW5lZCA6KFxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyb3JfcHJlZml4ICsgXCJQYXJhbWV0ZXIgJ1wiICsgcGFyYW1ldGVyX25hbWUgKyBcIicgc2hvdWxkIGRlZmluZSBlaXRoZXIgJ3R5cGUnIG9yICdvcHRpb25zJywgbm90IGJvdGghXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuZGVmaW5lZCAhPT0gcGFyYW1ldGVyLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBwYXJhbWV0ZXIub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyX3R5cGVfcGF0dGVybiArPSBwYXJhbWV0ZXIub3B0aW9ucy5qb2luKFwifFwiICsgdGhpcy5nZXRQYXJhbWV0ZXJTZXBhcmF0b3IoKSk7IC8vIEUuZy4gXCJhYnNvbHV0ZXw6cmVsYXRpdmVcIiBmb3Ige3tmaWxlX3BhdGg6bW9kZX19IHZhcmlhYmxlJ3MgJ21vZGUnIHBhcmFtZXRlci5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBwYXJhbWV0ZXIudHlwZVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXIudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3R5cGVfcGF0dGVybiArPSBcIi4qP1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfdHlwZV9wYXR0ZXJuICs9IFwiXFxcXGQrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGVycm9yX3ByZWZpeCArIFwiUGFyYW1ldGVyICdcIiArIHBhcmFtZXRlcl9uYW1lICsgXCInIGhhcyBhbiB1bnJlY29nbmlzZWQgdHlwZTogXCIgKyBwYXJhbWV0ZXIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc3VicGF0dGVybiB0byAncGF0dGVybicuXHJcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gXCIoXCIgKyBwYXJhbWV0ZXJfdHlwZV9wYXR0ZXJuICsgXCIpXCI7XHJcbiAgICAgICAgICAgIGlmICghcGFyYW1ldGVyLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBwYXJhbWV0ZXIgb3B0aW9uYWwuXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IFwiP1wiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBwYXR0ZXJuICs9ICdcXFxcfVxcXFx9JztcclxuICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGFyYW1ldGVyTmFtZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuZ2V0UGFyYW1ldGVycygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJfbmFtZVxyXG4gICAgICogQHBhcmFtIGFyZ3VtZW50IEF0IHRoaXMgcG9pbnQgJ2FyZ3VtZW50JyBpcyBhbHdheXMgYSBzdHJpbmcsIGJ1dCB0aGlzIG1ldGhvZCBtYXkgY29udmVydCBpdCB0byBhbm90aGVyIGRhdGEgdHlwZSwgZGVwZW5kaW5nIG9uIHRoZSBwYXJhbWV0ZXIncyBkYXRhIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRBcmd1bWVudChwYXJhbWV0ZXJfbmFtZTogc3RyaW5nLCBhcmd1bWVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyX3R5cGUgPSB0aGlzLmdldFBhcmFtZXRlcnMoKVtwYXJhbWV0ZXJfbmFtZV0udHlwZSA/PyBcInN0cmluZ1wiOyAvLyBJZiB0aGUgdmFyaWFibGUgdXNlcyBcIm9wdGlvbnNcIiBpbnN0ZWFkIG9mIFwidHlwZVwiLCB0aGVuIHRoZSB0eXBlIGlzIGFsd2F5cyBcInN0cmluZ1wiLlxyXG4gICAgICAgIHN3aXRjaCAocGFyYW1ldGVyX3R5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHNbcGFyYW1ldGVyX25hbWVdID0gYXJndW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzW3BhcmFtZXRlcl9uYW1lXSA9IHBhcnNlSW50KGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgbmV3RXJyb3JNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwifX06IFwiO1xyXG4gICAgICAgIHRoaXMuZXJyb3JfbWVzc2FnZXMucHVzaChwcmVmaXggKyBtZXNzYWdlKTtcclxuICAgICAgICBkZWJ1Z0xvZyhwcmVmaXggKyBtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgbmV3RXJyb3JNZXNzYWdlcyhtZXNzYWdlczogc3RyaW5nW10pIHtcclxuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCk6IElBdXRvY29tcGxldGVJdGVtW10ge1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmFyaWFibGUgaGFzIGF0IGxlYXN0IG9uZSBfbWFuZGF0b3J5XyBwYXJhbWV0ZXIuXHJcbiAgICAgICAgbGV0IHBhcmFtZXRlcl9pbmRpY2F0b3IgPSBcIlwiO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcl9uYW1lcyA9XHJcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuZ2V0UGFyYW1ldGVycygpKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihwYXJhbWV0ZXJfbmFtZSA9PiB0aGlzLmdldFBhcmFtZXRlcnMoKVtwYXJhbWV0ZXJfbmFtZV0ucmVxdWlyZWQgPT09IHRydWUpIC8vIE9ubHkgaW5jbHVkZSBtYW5kYXRvcnkgcGFyYW1ldGVyc1xyXG4gICAgICAgIDtcclxuICAgICAgICBpZiAocGFyYW1ldGVyX25hbWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcGFyYW1ldGVyX2luZGljYXRvciA9IFZhcmlhYmxlLnBhcmFtZXRlcl9zZXBhcmF0b3I7IC8vIFdoZW4gdGhlIHZhcmlhYmxlIG5hbWUgZW5kcyB3aXRoIGEgcGFyYW1ldGVyIHNlcGFyYXRvciBjaGFyYWN0ZXIsIGl0IGluZGljYXRlcyB0byBhIHVzZXIgdGhhdCBhbiBhcmd1bWVudCBzaG91bGQgYmUgc3VwcGxpZWQuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBwYXJhbWV0ZXJfaW5kaWNhdG9yICsgXCJ9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiAodGhpcy5oZWxwX3RleHQgKyBcIiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpKS50cmltKCksIC8vIC50cmltKCkgcmVtb3ZlcyBcIiBcIiBpZiBoZWxwX3RleHQgb3IgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpIGlzIGVtcHR5LlxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVW5lc2NhcGVkIHZlcnNpb24gb2YgdGhlIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIHBhcmFtZXRlcl9pbmRpY2F0b3IgKyBcIn19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6ICh0aGlzLmhlbHBfdGV4dCArIFwiIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCkpLnRyaW0oKSwgLy8gLnRyaW0oKSByZW1vdmVzIFwiIFwiIGlmIGhlbHBfdGV4dCBvciBnZXRBdmFpbGFiaWxpdHlUZXh0KCkgaXMgZW1wdHkuXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SGVscE5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz5cIiArIHRoaXMuZ2V0RnVsbE5hbWUoKSArIFwiPC9zdHJvbmc+XCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBWYXJpYWJsZSdzIG5hbWUgd3JhcHBlZCBpbiB7eyBhbmQgfX0uXHJcbiAgICAgKlxyXG4gICAgICogVE9ETzogQ2hhbmdlIGhhcmRjb2RlZCB7eyB9fSBlbnRyaWVzIHRvIHVzZSB0aGlzIG1ldGhvZCBhbGwgYXJvdW5kIHRoZSBjb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCJ9fVwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHVuaXF1ZSBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCBpbiBkZWZhdWx0IHZhbHVlIGNvbmZpZ3VyYXRpb25zLlxyXG4gICAgICogQHJldHVybiBOb3JtYWwgdmFyaWFibGUgbmFtZSwgaWYgdGhpcyBpcyBhIGJ1aWx0LWluIHZhcmlhYmxlOyBvciBhbiBJRCBzdHJpbmcgaWYgdGhpcyBpcyBhIEN1c3RvbVZhcmlhYmxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SWRlbnRpZmllcigpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZ1bGxOYW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIHRoZSB2YXJpYWJsZSBjYW4gYmUgY3VycmVudGx5IGFjY2Vzc2VkLiBJZiB5b3Ugd2FudCB0byBrbm93IGlmIHRoZSB2YXJpYWJsZSBjYW4gc29tZXRpbWVzIGJlIGluYWNjZXNzaWJsZSxcclxuICAgICAqIHVzZSBpc0Fsd2F5c0F2YWlsYWJsZSgpIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0F2YWlsYWJsZShzY19ldmVudDogU0NfRXZlbnQgfCBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIElmIHRoZSB2YXJpYWJsZSBpcyBhbHdheXMgYXZhaWxhYmxlLCByZXR1cm4gdHJ1ZS4gSWYgbm90LCB0aGUgdmFyaWFibGUgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIHZhcmlhYmxlIGNhbiBzb21ldGltZXMgYmUgdW5hdmFpbGFibGUuIFVzZWQgaW4gc2V0dGluZ3MgdG8gYWxsb3cgYSB1c2VyIHRvIGRlZmluZVxyXG4gICAgICogZGVmYXVsdCB2YWx1ZXMgZm9yIHZhcmlhYmxlcyB0aGF0IGFyZSBub3QgYWx3YXlzIGF2YWlsYWJsZSwgZmlsdGVyaW5nIG91dCBhbHdheXMgYXZhaWxhYmxlIHZhcmlhYmxlcyBmb3Igd2hpY2ggZGVmYXVsdFxyXG4gICAgICogdmFsdWVzIHdvdWxkIG5vdCBtYWtlIHNlbnNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNBbHdheXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx3YXlzX2F2YWlsYWJsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciB2YXJpYWJsZXMgdGhhdCBhcmUgYWx3YXlzIGF2YWlsYWJsZSwgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBdmFpbGFiaWxpdHlUZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2FtZSBhcyBnZXRBdmFpbGFiaWxpdHlUZXh0KCksIGJ1dCByZW1vdmVzIEhUTUwgZnJvbSB0aGUgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXZhaWxhYmlsaXR5VGV4dFBsYWluKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLnJlcGxhY2UoLzxcXC8/c3Ryb25nPi9pZywgXCJcIik7IC8vIFJlbW92ZSA8c3Ryb25nPiBhbmQgPC9zdHJvbmc+IG1hcmtpbmdzIGZyb20gdGhlIGhlbHAgdGV4dFxyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgSUFyZ3VtZW50cyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG59XHJcblxyXG4vKipcclxuICoga2V5ID0gc3RyaW5nLCBwYXJhbWV0ZXIgbmFtZVxyXG4gKiB2YWx1ZSA9IGJvb2xlYW4sIGlzIHRoZSBwYXJhbWV0ZXIgbWFuZGF0b3J5IG9yIG5vdD9cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBhcmFtZXRlcnMge1xyXG4gICAgW2tleTogc3RyaW5nXToge1xyXG4gICAgICAgIC8qKiBXaGF0IGRhdGEgdHlwZSBpcyBhbGxvd2VkLiAoTmV3IHR5cGVzIGNhbiBiZSBhZGRlZCBsYXRlcikuIFNob3VsZCBiZSBvbWl0dGVkLCBpZiAnb3B0aW9ucycgaXMgdXNlZC4gKi9cclxuICAgICAgICB0eXBlPzogXCJzdHJpbmdcIiB8IFwiaW50ZWdlclwiO1xyXG4gICAgICAgIC8qKiBUaGlzIGNhbiBkZWZpbmUgc3RhdGljIHZhbHVlcyBmb3IgdGhpcyBwYXJhbWV0ZXIuIFNob3VsZCBiZSBvbWl0dGVkLCBpZiAndHlwZScgaXMgdXNlZC4gKi9cclxuICAgICAgICBvcHRpb25zPzogc3RyaW5nW107XHJcbiAgICAgICAgLyoqIElzIHRoaXMgcGFyYW1ldGVyIG1hbmRhdG9yeT8gKi9cclxuICAgICAgICByZXF1aXJlZDogYm9vbGVhbjtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGVWYWx1ZVJlc3VsdCB7XHJcbiAgICB2YWx1ZTogc3RyaW5nIHwgbnVsbCxcclxuICAgIGVycm9yX21lc3NhZ2VzOiBzdHJpbmdbXSxcclxuXHJcbiAgICAvKiogSW4gcHJhY3Rpc2UsIHRoaXMgaXMgdHJ1ZSBldmVyeSB0aW1lIGVycm9yX21lc3NhZ2VzIGlzIGVtcHR5LCBzbyB0aGlzIGlzIGp1c3QgYSBzaG9ydGhhbmQgc28gdGhhdCBlcnJvcl9tZXNzYWdlcy5sZW5ndGggZG9lcyBub3QgbmVlZCB0byBiZSBjaGVja2VkIGJ5IHRoZSBjb25zdW1lci4gKi9cclxuICAgIHN1Y2NlZWRlZDogYm9vbGVhbixcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYXJpYWJsZURlZmF1bHRWYWx1ZUNvbmZpZ3VyYXRpb24ge1xyXG4gICAgdHlwZTogXCJzaG93LWVycm9yc1wiIHwgXCJjYW5jZWwtc2lsZW50bHlcIiB8IFwidmFsdWVcIixcclxuICAgIHZhbHVlOiBzdHJpbmcsXHJcbn1cclxuIiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX091dHB1dCBleHRlbmRzIFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJvdXRwdXRcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRleHQgb3V0cHV0dGVkIGJ5IGEgc2hlbGwgY29tbWFuZCBhZnRlciBpdCdzIGV4ZWN1dGVkLlwiO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHByaXZhdGUgb3V0cHV0X2NvbnRlbnQ6IHN0cmluZyxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMub3V0cHV0X2NvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBdmFpbGFiaWxpdHlUZXh0KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz5Pbmx5IGF2YWlsYWJsZTwvc3Ryb25nPiBpbiA8ZW0+b3V0cHV0IHdyYXBwZXJzPC9lbT4sIGNhbm5vdCBiZSB1c2VkIGFzIGlucHV0IGZvciBzaGVsbCBjb21tYW5kcy5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFc2NhcGVyIHtcclxuICAgIHByb3RlY3RlZCByYXdfdmFsdWU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocmF3X3ZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnJhd192YWx1ZSA9IHJhd192YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZXNjYXBlKCk6IHN0cmluZztcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7RXNjYXBlcn0gZnJvbSBcIi4vRXNjYXBlclwiO1xyXG5cclxuLyoqXHJcbiAqIFByZWZpeGVzIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBsZXR0ZXJzLCBudW1iZXJzIG9yIHVuZGVyc2NvcmVzIHdpdGggYSBwcmVmaXggY2hhcmFjdGVyIHRoYXQgY2FuIGJlIGRlZmluZWQgYnkgY2hpbGQgY2xhc3Nlcy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXIgZXh0ZW5kcyBFc2NhcGVyIHtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwcmVmaXg6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgZXNjYXBlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3X3ZhbHVlLnJlcGxhY2UoL1teXFx3XFxkXS9ndSwgKHNwZWNpYWxfY2hhcmFjdGVyOiBzdHJpbmcpID0+IHsgIC8vIC9nIG1lYW5zIHRvIHJlcGxhY2UgYWxsIG9jY3VycmVuY2VzIGluc3RlYWQgb2YganVzdCB0aGUgZmlyc3Qgb25lLiAvdSBtZWFucyB0byBoYW5kbGUgZm91ci1ieXRlIHVuaWNvZGUgY2hhcmFjdGVycyBjb3JyZWN0bHkgYXMgb25lIGNoYXJhY3Rlciwgbm90IGFzIHR3byBzZXBhcmF0ZSBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAvLyBEbyB0aGUgcmVwbGFjaW5nIGluIGEgZnVuY3Rpb24gaW4gb3JkZXIgdG8gYXZvaWQgYSBwb3NzaWJsZSAkIGNoYXJhY3RlciB0byBiZSBpbnRlcnByZXRlZCBieSBKYXZhU2NyaXB0IHRvIGludGVyYWN0IHdpdGggdGhlIHJlZ2V4LlxyXG4gICAgICAgICAgICAvLyBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZSNzcGVjaWZ5aW5nX2Ffc3RyaW5nX2FzX2FfcGFyYW1ldGVyIChyZWZlcmVuY2VkIDIwMjEtMTEtMDIuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZpeCArIHNwZWNpYWxfY2hhcmFjdGVyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtBbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXJ9IGZyb20gXCIuL0FsbFNwZWNpYWxDaGFyYWN0ZXJzRXNjYXBlclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNoRXNjYXBlciBleHRlbmRzIEFsbFNwZWNpYWxDaGFyYWN0ZXJzRXNjYXBlciB7XHJcbiAgICBwcm90ZWN0ZWQgcHJlZml4ID0gXCJcXFxcXCI7IC8vIEluICpzaCwgZXNjYXBpbmcgc2hvdWxkIHVzZSBhIGJhY2tzbGFzaCwgZS5nLiBcIkhlbGxvLCB3b3JsZCFcIiBiZWNvbWVzIFxcXCJIZWxsb1xcLFxcIHdvcmxkXFwhXFxcIlxyXG5cclxuICAgIHB1YmxpYyBlc2NhcGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlX25ld2xpbmVzKHN1cGVyLmVzY2FwZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGVzY2FwZWQgbmV3bGluZSBjaGFyYWN0ZXJzIHRvIGEgZm9ybSB0aGF0IHRoZSBCb3VybmUgZmFtaWx5IHNoZWxscyB3aWxsIGludGVycHJldCBhcyBsaXRlcmFsIG5ld2xpbmVzLFxyXG4gICAgICogbm90IGFzIGlnbm9yYWJsZSBjaGFyYWN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlc2NhcGVkX3ZhbHVlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlcGxhY2VfbmV3bGluZXMoZXNjYXBlZF92YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gZXNjYXBlZF92YWx1ZVxyXG4gICAgICAgICAgICAucmVwbGFjZUFsbCh0aGlzLnByZWZpeCtcIlxcclwiLCB0aGlzLnByZWZpeCt0aGlzLnByZWZpeCtcInJcIikgLy8gUmVwbGFjZSBhIHJlYWwgbGluZWZlZWQgd2l0aCBhIGxpdGVyYWwgXCJcXFxcclwiLlxyXG4gICAgICAgICAgICAucmVwbGFjZUFsbCh0aGlzLnByZWZpeCtcIlxcblwiLCB0aGlzLnByZWZpeCt0aGlzLnByZWZpeCtcIm5cIikgLy8gUmVwbGFjZSBhIHJlYWwgbmV3bGluZSB3aXRoIGEgbGl0ZXJhbCBcIlxcXFxuXCIuXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtBbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXJ9IGZyb20gXCIuL0FsbFNwZWNpYWxDaGFyYWN0ZXJzRXNjYXBlclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFBvd2VyU2hlbGxFc2NhcGVyIGV4dGVuZHMgQWxsU3BlY2lhbENoYXJhY3RlcnNFc2NhcGVyIHtcclxuICAgIHByb3RlY3RlZCBwcmVmaXggPSBcImBcIjsgLy8gSW4gUG93ZXJTaGVsbCwgZXNjYXBpbmcgc2hvdWxkIHVzZSBhIGAgY2hhcmFjdGVyLCBlLmcuIFwiSGVsbG8sIHdvcmxkIVwiIGJlY29tZXMgYFwiSGVsbG9gLGAgd29ybGRgIWBcIlxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFc2NhcGVyfSBmcm9tIFwiLi9Fc2NhcGVyXCI7XHJcbmltcG9ydCB7U2hFc2NhcGVyfSBmcm9tIFwiLi9TaEVzY2FwZXJcIjtcclxuaW1wb3J0IHtQb3dlclNoZWxsRXNjYXBlcn0gZnJvbSBcIi4vUG93ZXJTaGVsbEVzY2FwZXJcIjtcclxuaW1wb3J0IHtOb3RpY2V9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge2V4dHJhY3RGaWxlTmFtZX0gZnJvbSBcIi4uLy4uL0NvbW1vblwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVZhbHVlKHNoZWxsOiBzdHJpbmcsIHJhd192YWx1ZTogc3RyaW5nKSB7XHJcbiAgICBzaGVsbCA9IGV4dHJhY3RGaWxlTmFtZShzaGVsbC50b0xvd2VyQ2FzZSgpKTtcclxuICAgIGxldCBlc2NhcGVyOiBFc2NhcGVyO1xyXG4gICAgc3dpdGNoIChzaGVsbCkge1xyXG4gICAgICAgIGNhc2UgXCJiYXNoXCI6XHJcbiAgICAgICAgY2FzZSBcImRhc2hcIjpcclxuICAgICAgICBjYXNlIFwienNoXCI6XHJcbiAgICAgICAgY2FzZSBcInNoXCI6IC8vIE1heSBzb21ldGltZXMgYXBwZWFyIHdoZW4gdXNpbmcgdGhlIFwiVXNlIHN5c3RlbSBkZWZhdWx0IChzaClcIiBvcHRpb24gYXMgYSBkZWZhdWx0IHNoZWxsLlxyXG4gICAgICAgICAgICBlc2NhcGVyID0gbmV3IFNoRXNjYXBlcihyYXdfdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicG93ZXJzaGVsbC5leGVcIjogIC8vIFBvd2VyU2hlbGwgNSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgV2luZG93cy5cclxuICAgICAgICBjYXNlIFwicHdzaC5leGVcIjogICAgICAgIC8vIEluIFdpbmRvd3MuXHJcbiAgICAgICAgY2FzZSBcInB3c2hcIjogICAgICAgICAgICAvLyBJbiBMaW51eCBhbmQgTWFjLiAoU0MgZG9lcyBub3QgYWN0dWFsbHkgc3VwcG9ydCB1c2luZyBQb3dlclNoZWxsIG9uIExpbnV4L01hYyBqdXN0IHlldCwgYnV0IHN1cHBvcnQgY2FuIGJlIGFkZGVkKS5cclxuICAgICAgICAgICAgZXNjYXBlciA9IG5ldyBQb3dlclNoZWxsRXNjYXBlcihyYXdfdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiY21kLmV4ZVwiOlxyXG4gICAgICAgICAgICAvLyBFeGNlcHRpb246IFRoZXJlIGlzIG5vIGVzY2FwaW5nIHN1cHBvcnQgZm9yIENNRCwgc28gYWxsIHZhbHVlcyB3aWxsIGJlIGxlZnQgdW5lc2NhcGVkIHdoZW4gQ01EIGlzIHVzZWQuIDooXHJcbiAgICAgICAgICAgIHJldHVybiByYXdfdmFsdWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gU2hlbGwgd2FzIG5vdCByZWNvZ25pc2VkLlxyXG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRXNjYXBlVmFsdWUoKTogVW5yZWNvZ25pc2VkIHNoZWxsOiBcIiArIHNoZWxsKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjYXBlVmFsdWUoKTogVW5yZWNvZ25pc2VkIHNoZWxsOiBcIiArIHNoZWxsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlc2NhcGVyLmVzY2FwZSgpO1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuLy8gQHRzLWlnbm9yZSBcImVsZWN0cm9uXCIgaXMgaW5zdGFsbGVkLlxyXG5pbXBvcnQge2NsaXBib2FyZH0gZnJvbSBcImVsZWN0cm9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfQ2xpcGJvYXJkIGV4dGVuZHMgVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImNsaXBib2FyZFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGNvbnRlbnQgeW91IGxhc3QgY29waWVkIHRvIHlvdXIgY2xpcGJvYXJkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsaXBib2FyZC5yZWFkVGV4dCgpKTtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldEVkaXRvcixcclxuICAgIGdldFZpZXcsXHJcbn0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge1xyXG4gICAgRWRpdG9yLFxyXG4gICAgTWFya2Rvd25WaWV3LFxyXG59IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFZGl0b3JWYXJpYWJsZSBleHRlbmRzIFZhcmlhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZWRpdG9yOiBFZGl0b3I7XHJcbiAgICBwcm90ZWN0ZWQgdmlldzogTWFya2Rvd25WaWV3O1xyXG5cclxuICAgIHByb3RlY3RlZCByZXF1aXJlRWRpdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gZ2V0RWRpdG9yKHRoaXMuYXBwKTtcclxuICAgICAgICBpZiAobnVsbCA9PT0gdGhpcy5lZGl0b3IpIHtcclxuICAgICAgICAgICAgLy8gTm8gZWRpdG9yLlxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIkNvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlISBQbGVhc2UgY3JlYXRlIGEgZGlzY3Vzc2lvbiBpbiBHaXRIdWIuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIG1hZGUgcHJvdGVjdGVkIGlmIG5lZWRlZCB0byBiZSBhY2Nlc3NlZCBieSBzdWJjbGFzc2VzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXF1aXJlVmlldygpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnZXRWaWV3KHRoaXMuYXBwKTtcclxuICAgICAgICBpZiAobnVsbCA9PT0gdGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHZpZXcuXHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiQ291bGQgbm90IGdldCBhIHZpZXcgaW5zdGFuY2UhIFBsZWFzZSBjcmVhdGUgYSBkaXNjdXNzaW9uIGluIEdpdEh1Yi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgaXNWaWV3TW9kZVNvdXJjZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVxdWlyZVZpZXcoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZpZXdfbW9kZSA9IHRoaXMudmlldy5nZXRNb2RlKCk7IC8vIFwicHJldmlld1wiIG9yIFwic291cmNlXCIgKGNhbiBhbHNvIGJlIFwibGl2ZVwiIGJ1dCBJIGRvbid0IGtub3cgd2hlbiB0aGF0IGhhcHBlbnMpXHJcbiAgICAgICAgc3dpdGNoICh2aWV3X21vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInByZXZpZXdcIjpcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBsZWFmIGlzIGluIHByZXZpZXcgbW9kZSwgd2hpY2ggbWFrZXMgdGhpbmdzIGRpZmZpY3VsdC5cclxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBNYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSB0aGlzIGZlYXR1cmUgYWxzbyBpbiBwcmV2aWV3IG1vZGUuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkVkaXRvclZhcmlhYmxlOiAndmlldycgaXMgaW4gcHJldmlldyBtb2RlLCBhbmQgdGhlIHBvb3IgZ3V5IHdobyB3cm90ZSB0aGlzIGNvZGUsIGRvZXMgbm90IGtub3cgaG93IHRvIHJldHVybiBhbiBlZGl0b3IgaW5zdGFuY2UgdGhhdCBjb3VsZCBiZSB1c2VkIGZvciBnZXR0aW5nIHRleHQgc2VsZWN0aW9uLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiWW91IG5lZWQgdG8gdHVybiBlZGl0aW5nIG1vZGUgb24sIHVuZm9ydHVuYXRlbHkgdGhpcyB2YXJpYWJsZSBkb2VzIG5vdCB3b3JrIGluIHByZXZpZXcgbW9kZS5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcclxuICAgICAgICAgICAgICAgIC8vIEdvb2QsIHRoZSBlZGl0b3IgaXMgaW4gXCJzb3VyY2VcIiBtb2RlLCBzbyBpdCdzIHBvc3NpYmxlIHRvIGdldCBhIHNlbGVjdGlvbi5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRpdG9yVmFyaWFibGU6IFVucmVjb2duaXNlZCB2aWV3IG1vZGU6IFwiICsgdmlld19tb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjI6XHJcbiAqICAtIFZpbmF5IFJhanVyIChjcmVhdGVkIG1vc3Qgb2YgdGhlIGNvbnRlbnQgb2YgdGhlIFZhcmlhYmxlX0NhcmV0UG9zaXRpb24gY2xhc3MpXHJcbiAqICAtIEphcmtrbyBMaW5uYW52aXJ0YSAoc29tZSBtaW5vci9zdHJ1Y3R1cmFsIGNoYW5nZXMpXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdDpcclxuICogIC0gVmluYXkgUmFqdXI6IGh0dHBzOi8vZ2l0aHViLmNvbS92cmFqdXJcclxuICogIC0gSmFya2tvIExpbm5hbnZpcnRhOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge2dldEVkaXRvcn0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtFZGl0b3JWYXJpYWJsZX0gZnJvbSBcIi4vRWRpdG9yVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9DYXJldFBvc2l0aW9uIGV4dGVuZHMgRWRpdG9yVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImNhcmV0X3Bvc2l0aW9uXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgbGluZSBudW1iZXIgYW5kIGNvbHVtbiBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBhcyAnbGluZTpjb2x1bW4nLiBHZXQgb25seSB0aGUgbGluZSBudW1iZXIgdXNpbmcge3tjYXJldF9wb3NpdGlvbjpsaW5lfX0sIGFuZCBvbmx5IHRoZSBjb2x1bW4gd2l0aCB7e2NhcmV0X3Bvc2l0aW9uOmNvbHVtbn19LiBMaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBhcmUgMS1pbmRleGVkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBhbHdheXNfYXZhaWxhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBtb2RlOiB7XHJcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcImxpbmVcIiwgXCJjb2x1bW5cIl0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgbW9kZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgYWJsZSB0byBnZXQgYW4gZWRpdG9yXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXF1aXJlRWRpdG9yKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcGUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoJ3RvJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBwb3NpdGlvbi5saW5lICsgMTsgLy8gZWRpdG9yIHBvc2l0aW9uIGlzIHplcm8taW5kZXhlZCwgbGluZSBudW1iZXJzIGFyZSAxLWluZGV4ZWRcclxuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gcG9zaXRpb24uY2ggKyAxOyAvLyBlZGl0b3IgcG9zaXRpb24gaXMgemVyby1pbmRleGVkLCBjb2x1bW4gcG9zaXRpb25zIGFyZSAxLWluZGV4ZWRcclxuXHJcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmFyZ3VtZW50cykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFyZ3VtZW50cy5tb2RlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGluZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShgJHtsaW5lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYCR7Y29sdW1ufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiVW5yZWNvZ25pc2VkIGFyZ3VtZW50OiBcIit0aGlzLmFyZ3VtZW50cy5tb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGNhc2Ugd2hlbiBubyBhcmdzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShgJHtsaW5lfToke2NvbHVtbn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBdXRvY29tcGxldGVJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCJ9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBsaW5lIG51bWJlciBhbmQgY29sdW1uIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIGFzICdsaW5lOmNvbHVtbicuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpsaW5lfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgbGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpjb2x1bW59fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBjb2x1bW4gbnVtYmVyIG9mIHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwifX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgbGluZSBudW1iZXIgYW5kIGNvbHVtbiBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBhcyAnbGluZTpjb2x1bW4nLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpsaW5lfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgbGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmNvbHVtbn19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGNvbHVtbiBudW1iZXIgb2YgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SGVscE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPnt7Y2FyZXRfcG9zaXRpb259fTwvc3Ryb25nPiwgPHN0cm9uZz57e2NhcmV0X3Bvc2l0aW9uOmxpbmV9fTwvc3Ryb25nPiBvciA8c3Ryb25nPnt7Y2FyZXRfcG9zaXRpb246Y29sdW1ufX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEhZ2V0RWRpdG9yKHRoaXMuYXBwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gd2hlbiBhIG5vdGUgcGFuZSBpcyBvcGVuLCBub3QgaW4gZ3JhcGggdmlldywgbm9yIHdoZW4gdmlld2luZyBub24tdGV4dCBmaWxlcy5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7bW9tZW50fSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVycywgVmFyaWFibGV9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRGF0ZSBleHRlbmRzIFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJkYXRlXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyBhIGRhdGUvdGltZSBzdGFtcCBhcyBwZXIgeW91ciBsaWtpbmcuIFRoZSBcXFwiZm9ybWF0XFxcIiBwYXJ0IGNhbiBiZSBjdXN0b21pemVkIGFuZCBpcyBtYW5kYXRvcnkuIEZvcm1hdHRpbmcgb3B0aW9uczogaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvZm9ybWF0L1wiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgZm9ybWF0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIGZvcm1hdDogc3RyaW5nLFxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vbWVudCgpLmZvcm1hdCh0aGlzLmFyZ3VtZW50cy5mb3JtYXQpKTtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7Z2V0VmF1bHRBYnNvbHV0ZVBhdGgsIG5vcm1hbGl6ZVBhdGgyLCB1bmlxdWVBcnJheX0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0FwcCwgZ2V0QWxsVGFncywgVEZpbGUsIFRGb2xkZXJ9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IENvbnNpZGVyIGNyZWF0aW5nIGEgZGVjb3JhdG9yIGNsYXNzIGZvciBURm9sZGVyIGFuZCBtb3ZpbmcgdGhpcyBmdW5jdGlvbiB0byBiZSBhIG1ldGhvZCBpbiBpdC5cclxuICpcclxuICogQHBhcmFtIGFwcFxyXG4gKiBAcGFyYW0gZm9sZGVyXHJcbiAqIEBwYXJhbSBtb2RlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9sZGVyUGF0aChhcHA6IEFwcCwgZm9sZGVyOiBURm9sZGVyLCBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCIpIHtcclxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpIGFzIFwiYWJzb2x1dGVcIiB8IFwicmVsYXRpdmVcIikge1xyXG4gICAgICAgIGNhc2UgXCJhYnNvbHV0ZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgoYXBwKSArIFwiL1wiICsgZm9sZGVyLnBhdGgpO1xyXG4gICAgICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxyXG4gICAgICAgICAgICBpZiAoZm9sZGVyLmlzUm9vdCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPYnNpZGlhbiBBUEkgZG9lcyBub3QgZ2l2ZSBhIGNvcnJlY3QgZm9sZGVyLnBhdGggdmFsdWUgZm9yIHRoZSB2YXVsdCdzIHJvb3QgZm9sZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU2VlIHRoaXMgZGlzY3Vzc2lvbiBhbmQgYXBwbHkgcG9zc2libGUgY2hhbmdlcyBpZiBzb21ldGhpbmcgd2lsbCBjb21lIHVwOiBodHRwczovL2ZvcnVtLm9ic2lkaWFuLm1kL3QvdmF1bHQtcm9vdC1mb2xkZXJzLXJlbGF0aXZlLXBhdGgtZ2l2ZXMvMjQ4NTdcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIi5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBub3JtYWwgc3ViZm9sZGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZm9sZGVyLnBhdGgpOyAvLyBOb3JtYWxpemUgdG8gZ2V0IGEgY29ycmVjdCBzbGFzaCBiZXR3ZWVuIGRpcmVjdG9yaWVzIGRlcGVuZGluZyBvbiBwbGF0Zm9ybS4gT24gV2luZG93cyBpdCBzaG91bGQgYmUgXFwgLlxyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBDb25zaWRlciBjcmVhdGluZyBhIGRlY29yYXRvciBjbGFzcyBmb3IgVEZpbGUgYW5kIG1vdmluZyB0aGlzIGZ1bmN0aW9uIHRvIGJlIGEgbWV0aG9kIGluIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwXHJcbiAqIEBwYXJhbSBmaWxlXHJcbiAqIEBwYXJhbSBtb2RlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVBhdGgoYXBwOiBBcHAsIGZpbGU6IFRGaWxlLCBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCIpIHtcclxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpIGFzIFwiYWJzb2x1dGVcIiB8IFwicmVsYXRpdmVcIikge1xyXG4gICAgICAgIGNhc2UgXCJhYnNvbHV0ZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgoYXBwKSArIFwiL1wiICsgZmlsZS5wYXRoKTtcclxuICAgICAgICBjYXNlIFwicmVsYXRpdmVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgyKGZpbGUucGF0aCk7IC8vIE5vcm1hbGl6ZSB0byBnZXQgYSBjb3JyZWN0IHNsYXNoIGRlcGVuZGluZyBvbiBwbGF0Zm9ybS4gT24gV2luZG93cyBpdCBzaG91bGQgYmUgXFwgLlxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFRPRE86IENvbnNpZGVyIGNyZWF0aW5nIGEgZGVjb3JhdG9yIGNsYXNzIGZvciBURmlsZSBhbmQgbW92aW5nIHRoaXMgZnVuY3Rpb24gdG8gYmUgYSBtZXRob2QgaW4gaXQuXHJcbiAqIEBwYXJhbSBmaWxlXHJcbiAqIEBwYXJhbSB3aXRoX2RvdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZTogVEZpbGUsIHdpdGhfZG90OiBib29sZWFuKSB7XHJcbiAgICBjb25zdCBmaWxlX2V4dGVuc2lvbiA9IGZpbGUuZXh0ZW5zaW9uO1xyXG5cclxuICAgIC8vIFNob3VsZCB0aGUgZXh0ZW5zaW9uIGJlIGdpdmVuIHdpdGggb3Igd2l0aG91dCBhIGRvdD9cclxuICAgIGlmICh3aXRoX2RvdCkge1xyXG4gICAgICAgIC8vIEEgcHJlY2VkaW5nIGRvdCBtdXN0IGJlIGluY2x1ZGVkLlxyXG4gICAgICAgIGlmIChmaWxlX2V4dGVuc2lvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEJ1dCBvbmx5IGlmIHRoZSBleHRlbnNpb24gaXMgbm90IGVtcHR5LlxyXG4gICAgICAgICAgICByZXR1cm4gXCIuXCIgKyBmaWxlX2V4dGVuc2lvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gZG90IHNob3VsZCBiZSBpbmNsdWRlZCwgb3IgdGhlIGV4dGVuc2lvbiBpcyBlbXB0eVxyXG4gICAgcmV0dXJuIGZpbGVfZXh0ZW5zaW9uO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVRhZ3MoYXBwOiBBcHAsIGZpbGU6IFRGaWxlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcclxuICAgIGNvbnN0IHRhZ3M6IHN0cmluZ1tdID0gdW5pcXVlQXJyYXkoZ2V0QWxsVGFncyhjYWNoZSkpOyAvLyBJZiBhIHRhZyBpcyBkZWZpbmVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIGZpbGUsIGdldFRhZ3MoKSByZXR1cm5zIGl0IG11bHRpcGxlIHRpbWVzLCBzbyB1c2UgdW5pcXVlQXJyYXkoKSB0byBpcm9uIG91dCBkdXBsaWNhdGVzLlxyXG5cclxuICAgIC8vIFJlbW92ZSBwcmVjZWRpbmcgaGFzaCBjaGFyYWN0ZXJzLiBFLmcuICN0YWcgYmVjb21lcyB0YWdcclxuICAgIHRhZ3MuZm9yRWFjaCgodGFnOiBzdHJpbmcsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgdGFnc1tpbmRleF0gPSB0YWcucmVwbGFjZShcIiNcIiwgXCJcIik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YWdzO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIGFwcFxyXG4gKiBAcGFyYW0gZmlsZVxyXG4gKiBAcGFyYW0gcHJvcGVydHlfcGF0aFxyXG4gKiBAcmV0dXJuIHN0cmluZ3xzdHJpbmdbXSBFaXRoZXIgYSByZXN1bHQgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBlcnJvciBtZXNzYWdlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlWUFNTFZhbHVlKGFwcDogQXBwLCBmaWxlOiBURmlsZSwgcHJvcGVydHlfcGF0aDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBlcnJvcl9tZXNzYWdlczogc3RyaW5nW10gPSBbXTtcclxuICAgIGNvbnN0IHByb3BlcnR5X3BhcnRzID0gcHJvcGVydHlfcGF0aC5zcGxpdChcIi5cIik7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgYWxsIHByb3BlcnR5IG5hbWVzIGFsb25nIHRoZSBwYXRoXHJcbiAgICBwcm9wZXJ0eV9wYXJ0cy5mb3JFYWNoKChwcm9wZXJ0eV9uYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAoMCA9PT0gcHJvcGVydHlfbmFtZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZXJyb3JfbWVzc2FnZXMucHVzaChcIllBTUwgcHJvcGVydHkgJ1wiICsgcHJvcGVydHlfcGF0aCArIFwiJyBoYXMgYW4gZW1wdHkgcHJvcGVydHkgbmFtZS4gUmVtb3ZlIHBvc3NpYmxlIGRvdWJsZSBkb3RzIG9yIGEgcHJlY2VkaW5nL3RyYWlsaW5nIGRvdC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoZXJyb3JfbWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIEZhaWx1cmUgaW4gcHJvcGVydHkgbmFtZShzKS5cclxuICAgICAgICByZXR1cm4gZXJyb3JfbWVzc2FnZXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xyXG4gICAgLy8gQ2hlY2sgdGhhdCBhIFlBTUwgc2VjdGlvbiBpcyBhdmFpbGFibGUgaW4gdGhlIGZpbGVcclxuICAgIGlmICh1bmRlZmluZWQgPT09IGZyb250bWF0dGVyKSB7XHJcbiAgICAgICAgLy8gTm8gaXQgYWluJ3QuXHJcbiAgICAgICAgZXJyb3JfbWVzc2FnZXMucHVzaChcIk5vIFlBTUwgZnJvbnRtYXR0ZXIgc2VjdGlvbiBpcyBkZWZpbmVkIGZvciB0aGUgY3VycmVudCBmaWxlLlwiKTtcclxuICAgICAgICByZXR1cm4gZXJyb3JfbWVzc2FnZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEEgWUFNTCBzZWN0aW9uIGlzIGF2YWlsYWJsZS5cclxuICAgICAgICAvLyBSZWFkIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLlxyXG4gICAgICAgIHJldHVybiBuZXN0ZWRfcmVhZChwcm9wZXJ0eV9wYXJ0cywgcHJvcGVydHlfcGF0aCwgZnJvbnRtYXR0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5X3BhcnRzIFByb3BlcnR5IHBhdGggc3BsaXQgaW50byBwYXJ0cyAoPSBwcm9wZXJ0eSBuYW1lcykuIFRoZSBkZWVwZXIgdGhlIG5lc3RpbmcgZ29lcywgdGhlIGZld2VyIHZhbHVlcyB3aWxsIGJlIGxlZnQgaW4gdGhpcyBhcnJheS5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eV9wYXRoIFRoZSBvcmlnaW5hbCwgd2hvbGUgcHJvcGVydHkgcGF0aCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0geWFtbF9vYmplY3RcclxuICAgICAqIEByZXR1cm4gc3RyaW5nfHN0cmluZ1tdIEVpdGhlciBhIHJlc3VsdCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBuZXN0ZWRfcmVhZChwcm9wZXJ0eV9wYXJ0czogc3RyaW5nW10sIHByb3BlcnR5X3BhdGg6IHN0cmluZywgeWFtbF9vYmplY3Q6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgb2JqZWN0IH0pOiBzdHJpbmcgfCBzdHJpbmdbXSB7XHJcbiAgICAgICAgbGV0IHByb3BlcnR5X25hbWU6IHN0cmluZyA9IHByb3BlcnR5X3BhcnRzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGEgbmVnYXRpdmUgbnVtZXJpYyBpbmRleC5cclxuICAgICAgICBpZiAocHJvcGVydHlfbmFtZS5tYXRjaCgvXi1cXGQrJC91KSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgcHJvcGVydHkgbmFtZSBpcyBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB5YW1sX29iamVjdCBjb250YWlucyBhdCBsZWFzdCBvbmUgZWxlbWVudC5cclxuICAgICAgICAgICAgY29uc3QgeWFtbF9vYmplY3Rfa2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHlhbWxfb2JqZWN0KS5maWx0ZXIoa2V5ID0+IGtleSAhPT0gXCJsZW5ndGhcIik7IC8vIEFsbCBfcmVhbGx5IGN1c3RvbV8geWFtbCBrZXlzLCBub3QgLmxlbmd0aFxyXG4gICAgICAgICAgICBpZiAoeWFtbF9vYmplY3Rfa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB5YW1sX29iamVjdCBoYXBwZW5zIHRvIGJlIGFuIGluZGV4ZWQgbGlzdC5cclxuICAgICAgICAgICAgICAgIGxldCBpc19pbmRleGVkX2xpc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgeWFtbF9vYmplY3Rfa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskL3UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IGxlYXN0IG9uZSBub24tbnVtZXJpYyBrZXkgd2FzIGZvdW5kLCBzbyBjb25zaWRlciB0aGUgb2JqZWN0IG5vdCB0byBiZSBhbiBpbmRleGVkIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX2luZGV4ZWRfbGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzX2luZGV4ZWRfbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgYW4gaW5kZXhlZCBsaXN0IGFuZCBwcm9wZXJ0eV9uYW1lIGlzIGEgbmVnYXRpdmUgaW5kZXggbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBwcm9wZXJ0eV9uYW1lIHRvIGEgcG9zaXRpdmUgaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5X25hbWUgPSBNYXRoLm1heCgwLCAvLyBJZiBhIGdyZWF0bHkgbmVnYXRpdmUgaW5kZXggaXMgdXNlZCAoZS5nLiAtOTk5KSwgZG9uJ3QgYWxsb3cgdGhlIG5ldyBpbmRleCB0byBiZSBuZWdhdGl2ZSBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeWFtbF9vYmplY3Rfa2V5cy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBwYXJzZUludChwcm9wZXJ0eV9uYW1lKSAvLyBBbHRob3VnaCArIGlzIHVzZWQsIHRoaXMgd2lsbCBiZSBhIHN1YnRyYWN0aW9uLCBiZWNhdXNlIHByb3BlcnR5X25hbWUgaXMgcHJlZml4ZWQgd2l0aCBhIG1pbnVzLlxyXG4gICAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGEgdmFsdWVcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eV92YWx1ZSA9IHlhbWxfb2JqZWN0W3Byb3BlcnR5X25hbWVdO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgZWl0aGVyOiBub3QgZm91bmQsIG9iamVjdCwgb3IgbGl0ZXJhbC5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eV92YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSB3YXMgbm90IGZvdW5kLlxyXG4gICAgICAgICAgICBlcnJvcl9tZXNzYWdlcy5wdXNoKFwiWUFNTCBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eV9uYW1lICsgXCInIGlzIG5vdCBmb3VuZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcl9tZXNzYWdlcztcclxuICAgICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wZXJ0eV92YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHN0aWxsIGRvdCBub3RhdGlvbiBwYXJ0cyBsZWZ0IGluIHRoZSBwcm9wZXJ0eSBwYXRoLlxyXG4gICAgICAgICAgICBpZiAoMCA9PT0gcHJvcGVydHlfcGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBkb3Qgbm90YXRpb24gcGFydHMgYXJlIGxlZnQuXHJcbiAgICAgICAgICAgICAgICAvLyBGcmVhayBvdXQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXN0ZWRfZWxlbWVudHNfa2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnR5X3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRfZWxlbWVudHNfa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZXMucHVzaChcIllBTUwgcHJvcGVydHkgJ1wiICsgcHJvcGVydHlfbmFtZSArIFwiJyBjb250YWlucyBhIG5lc3RlZCBlbGVtZW50IHdpdGgga2V5czogXCIgKyBuZXN0ZWRfZWxlbWVudHNfa2V5cy5qb2luKFwiLCBcIikgKyBcIi4gVXNlIGUuZy4gJ1wiICsgcHJvcGVydHlfcGF0aCArIFwiLlwiICsgbmVzdGVkX2VsZW1lbnRzX2tleXNbMF0gKyBcIicgdG8gZ2V0IGl0cyB2YWx1ZS5cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzLnB1c2goXCJZQU1MIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicgY29udGFpbnMgYSBuZXN0ZWQgZWxlbWVudC4gVXNlIGEgcHJvcGVydHkgbmFtZSB0aGF0IHBvaW50cyB0byBhIGxpdGVyYWwgdmFsdWUgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JfbWVzc2FnZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEb3Qgbm90YXRpb24gcGF0aCBzdGlsbCBoYXMgYW5vdGhlciBwcm9wZXJ0eSBuYW1lIGxlZnQsIHNvIGNvbnRpbnVlIHRoZSBodW50LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZF9yZWFkKHByb3BlcnR5X3BhcnRzLCBwcm9wZXJ0eV9wYXRoLCBwcm9wZXJ0eV92YWx1ZSBhcyB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IG9iamVjdCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBsaXRlcmFsLCBpLmUuIGEgc3RyaW5nIG9yIG51bWJlci5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5X3BhcnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzLnB1c2goXCJZQU1MIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicgZ2l2ZXMgYWxyZWFkeSBhIGxpdGVyYWwgdmFsdWUgJ1wiICsgcHJvcGVydHlfdmFsdWUudG9TdHJpbmcoKSArIFwiJywgYnV0IHRoZSBhcmd1bWVudCAnXCIgKyBwcm9wZXJ0eV9wYXRoICsgXCInIGFzc3VtZXMgdGhlIHByb3BlcnR5IHdvdWxkIGNvbnRhaW4gYSBuZXN0ZWQgZWxlbWVudCB3aXRoIHRoZSBrZXkgJ1wiICsgcHJvcGVydHlfcGFydHNbMF0gKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yX21lc3NhZ2VzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5X3ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGaWxlVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XHJcblxyXG4gICAgcHJvdGVjdGVkIGFsd2F5c19hdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0RmlsZSgpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50X2ZpbGUgPSB0aGlzLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICBpZiAoIWN1cnJlbnRfZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudF9maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0F2YWlsYWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50X2ZpbGUgPSB0aGlzLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICByZXR1cm4gISFjdXJyZW50X2ZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF2YWlsYWJpbGl0eVRleHQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPk9ubHkgYXZhaWxhYmxlPC9zdHJvbmc+IHdoZW4gdGhlIGFjdGl2ZSBwYW5lIGNvbnRhaW5zIGEgZmlsZSwgbm90IGluIGdyYXBoIHZpZXcgb3Igb3RoZXIgbm9uLWZpbGUgdmlldy5cIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEFjdGl2ZUZpbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtnZXRGaWxlRXh0ZW5zaW9ufSBmcm9tIFwiLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuaW1wb3J0IHtGaWxlVmFyaWFibGV9IGZyb20gXCIuL0ZpbGVWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0ZpbGVFeHRlbnNpb24gZXh0ZW5kcyBGaWxlVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImZpbGVfZXh0ZW5zaW9uXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlIG5hbWUncyBlbmRpbmcuIFVzZSB7e2ZpbGVfZXh0ZW5zaW9uOndpdGgtZG90fX0gdG8gaW5jbHVkZSBhIHByZWNlZGluZyBkb3QuIElmIHRoZSBleHRlbnNpb24gaXMgZW1wdHksIG5vIGRvdCBpcyBhZGRlZC4ge3tmaWxlX2V4dGVuc2lvbjpuby1kb3R9fSBuZXZlciBpbmNsdWRlcyBhIGRvdC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIFwiZG90XCI6IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW1wid2l0aC1kb3RcIiwgXCJuby1kb3RcIl0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBcImRvdFwiOiBcIndpdGgtZG90XCIgfCBcIm5vLWRvdFwiLFxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRGaWxlRXh0ZW5zaW9uKGZpbGUsIHRoaXMuYXJndW1lbnRzLmRvdCA9PT0gXCJ3aXRoLWRvdFwiKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpuby1kb3R9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBjdXJyZW50IGZpbGUgbmFtZSdzIGVuZGluZyB3aXRob3V0IGEgcHJlY2VkaW5nIGRvdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjp3aXRoLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGggYSBwcmVjZWRpbmcgZG90LiBJZiB0aGUgZXh0ZW5zaW9uIGlzIGVtcHR5LCBubyBkb3QgaXMgaW5jbHVkZWQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOm5vLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGhvdXQgYSBwcmVjZWRpbmcgZG90LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjp3aXRoLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGggYSBwcmVjZWRpbmcgZG90LiBJZiB0aGUgZXh0ZW5zaW9uIGlzIGVtcHR5LCBubyBkb3QgaXMgaW5jbHVkZWQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SGVscE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPnt7ZmlsZV9leHRlbnNpb246d2l0aC1kb3R9fTwvc3Ryb25nPiBvciA8c3Ryb25nPnt7ZmlsZV9leHRlbnNpb246bm8tZG90fX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9GaWxlTmFtZSBleHRlbmRzIEZpbGVWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZmlsZV9uYW1lXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlIG5hbWUgd2l0aCBhIGZpbGUgZXh0ZW5zaW9uLiBJZiB5b3UgbmVlZCBpdCB3aXRob3V0IHRoZSBleHRlbnNpb24sIHVzZSB7e3RpdGxlfX0gaW5zdGVhZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBQcm9taXNlPHN0cmluZ3xudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICAgICAgaWYgKCFmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtJUGFyYW1ldGVyc30gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcbmltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGaWxlUGF0aH0gZnJvbSBcIi4vVmFyaWFibGVIZWxwZXJzXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRmlsZVBhdGggZXh0ZW5kcyBGaWxlVmFyaWFibGV7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZmlsZV9wYXRoXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIGVpdGhlciBhcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbSwgb3IgYXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBtb2RlOiB7XHJcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcImFic29sdXRlXCIsIFwicmVsYXRpdmVcIl0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVfZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAoYWN0aXZlX2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEZpbGVQYXRoKHRoaXMuYXBwLCBhY3RpdmVfZmlsZSwgdGhpcy5hcmd1bWVudHMubW9kZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXV0b2NvbXBsZXRlSXRlbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVW5lc2NhcGVkIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlLCBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSwgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SGVscE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPnt7ZmlsZV9wYXRoOnJlbGF0aXZlfX08L3N0cm9uZz4gb3IgPHN0cm9uZz57e2ZpbGVfcGF0aDphYnNvbHV0ZX19PC9zdHJvbmc+XCI7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0ZpbGVWYXJpYWJsZX0gZnJvbSBcIi4vRmlsZVZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRm9sZGVyVmFyaWFibGUgZXh0ZW5kcyBGaWxlVmFyaWFibGUge1xyXG5cclxuICAgIHByb3RlY3RlZCBnZXRGb2xkZXIoKSB7XHJcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgZmlsZSdzIHBhcmVudCBmb2xkZXIuXHJcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3VycmVudF9mb2xkZXIgPSBmaWxlLnBhcmVudDtcclxuICAgICAgICBpZiAoIWN1cnJlbnRfZm9sZGVyKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHBhcmVudCBmb2xkZXIuXHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiVGhlIGN1cnJlbnQgZmlsZSBkb2VzIG5vdCBoYXZlIGEgcGFyZW50IGZvciBzb21lIHN0cmFuZ2UgcmVhc29uLlwiKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfZm9sZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0F2YWlsYWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBOb3JtYWwgY2hlY2s6IGVuc3VyZSBhIGZpbGUgcGFuZSBpcyBvcGVuIGFuZCBmb2N1c2VkLlxyXG4gICAgICAgIGlmICghc3VwZXIuaXNBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IGEgcGFyZW50IGZvbGRlciBpcyBhdmFpbGFibGUuIChJZiBub3QsIGl0J3Mgc3RyYW5nZS4pXHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRGaWxlKCkucGFyZW50O1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtGb2xkZXJWYXJpYWJsZX0gZnJvbSBcIi4vRm9sZGVyVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9Gb2xkZXJOYW1lIGV4dGVuZHMgRm9sZGVyVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImZvbGRlcl9uYW1lXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciBuYW1lLiBObyBhbmNlc3RvciBmb2xkZXJzIGFyZSBpbmNsdWRlZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBQcm9taXNlPHN0cmluZ3xudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyKCk7XHJcbiAgICAgICAgICAgIGlmICghZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmb2xkZXIubmFtZSk7IC8vIFRPRE86IENvbnNpZGVyIGNoYW5naW5nIHRvIGBmb2xkZXIuaXNSb290KCkgPyBcIi5cIiA6IGZvbGRlci5uYW1lO2AgYXMgaXMgZG9uZSBpbiBWYXJpYWJsZV9OZXdOb3RlRmlsZU5hbWUuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtGb2xkZXJWYXJpYWJsZX0gZnJvbSBcIi4vRm9sZGVyVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGb2xkZXJQYXRofSBmcm9tIFwiLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9Gb2xkZXJQYXRoIGV4dGVuZHMgRm9sZGVyVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImZvbGRlcl9wYXRoXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUncyBwYXJlbnQgZm9sZGVyLCBlaXRoZXIgYXMgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0sIG9yIGFzIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmdldEZvbGRlcigpO1xyXG4gICAgICAgICAgICBpZiAoZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRGb2xkZXJQYXRoKHRoaXMuYXBwLCBmb2xkZXIsIHRoaXMuYXJndW1lbnRzLm1vZGUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSdzIHBhcmVudCBmb2xkZXIsIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVW5lc2NhcGVkIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUncyBwYXJlbnQgZm9sZGVyLCByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tmb2xkZXJfcGF0aDpyZWxhdGl2ZX19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tmb2xkZXJfcGF0aDphYnNvbHV0ZX19PC9zdHJvbmc+XCI7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge2dldEVkaXRvciwgZ2V0Vmlld30gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0VkaXRvclZhcmlhYmxlfSBmcm9tIFwiLi9FZGl0b3JWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX1NlbGVjdGlvbiBleHRlbmRzIEVkaXRvclZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJzZWxlY3Rpb25cIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYWx3YXlzX2F2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIHByb3RlY3RlZCBhc3luYyBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgYWJsZSB0byBnZXQgYW4gZWRpdG9yXHJcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVpcmVFZGl0b3IoKSkge1xyXG4gICAgICAgICAgICAvLyBOb3BlLlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSB2aWV3IG1vZGVcclxuICAgICAgICBpZiAodGhpcy5pc1ZpZXdNb2RlU291cmNlKCkpIHtcclxuICAgICAgICAgICAgLy8gR29vZCwgdGhlIGVkaXRvciBpcyBpbiBcInNvdXJjZVwiIG1vZGUsIHNvIGl0J3MgcG9zc2libGUgdG8gZ2V0IGEgc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3Iuc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFZpZXcodGhpcy5hcHApO1xyXG4gICAgICAgIHJldHVybiB2aWV3ICYmIGdldEVkaXRvcih0aGlzLmFwcCkgJiYgdmlldy5nZXRNb2RlKCkgPT09IFwic291cmNlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF2YWlsYWJpbGl0eVRleHQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPk9ubHkgYXZhaWxhYmxlPC9zdHJvbmc+IGluIDxlbT5FZGl0aW5nPC9lbT4vPGVtPkxpdmUgcHJldmlldzwvZW0+IG1vZGUsIDxzdHJvbmc+bm90PC9zdHJvbmc+IGluIDxlbT5SZWFkaW5nPC9lbT4gbW9kZS5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGaWxlVGFnc30gZnJvbSBcIi4vVmFyaWFibGVIZWxwZXJzXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfVGFncyBleHRlbmRzIEZpbGVWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwidGFnc1wiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgYWxsIHRhZ3MgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBub3RlLiBSZXBsYWNlIHRoZSBcXFwic2VwYXJhdG9yXFxcIiBwYXJ0IHdpdGggYSBjb21tYSwgc3BhY2Ugb3Igd2hhdGV2ZXIgY2hhcmFjdGVycyB5b3Ugd2FudCB0byB1c2UgYXMgYSBzZXBhcmF0b3IgYmV0d2VlbiB0YWdzLiBBIHNlcGFyYXRvciBpcyBhbHdheXMgbmVlZGVkIHRvIGJlIGRlZmluZWQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBzZXBhcmF0b3I6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgc2VwYXJhdG9yOiBzdHJpbmcsXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlX2ZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGFuIGFjdGl2ZSBmaWxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRGaWxlVGFncyh0aGlzLmFwcCwgYWN0aXZlX2ZpbGUpLmpvaW4odGhpcy5hcmd1bWVudHMuc2VwYXJhdG9yKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBmaWxlIGlzIGFjdGl2ZSBhdCB0aGUgbW9tZW50XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtGaWxlVmFyaWFibGV9IGZyb20gXCIuL0ZpbGVWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX1RpdGxlIGV4dGVuZHMgRmlsZVZhcmlhYmxle1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcInRpdGxlXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlIG5hbWUgd2l0aG91dCBhIGZpbGUgZXh0ZW5zaW9uLiBJZiB5b3UgbmVlZCBpdCB3aXRoIHRoZSBleHRlbnNpb24sIHVzZSB7e2ZpbGVfbmFtZX19IGluc3RlYWQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVfZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAoYWN0aXZlX2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGFjdGl2ZV9maWxlLmJhc2VuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7Z2V0VmF1bHRBYnNvbHV0ZVBhdGh9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9WYXVsdFBhdGggZXh0ZW5kcyBWYXJpYWJsZXtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJ2YXVsdF9wYXRoXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgT2JzaWRpYW4gdmF1bHQncyBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGVzeXN0ZW0uIFRoaXMgaXMgdGhlIHNhbWUgdGhhdCBpcyB1c2VkIGFzIGEgZGVmYXVsdCB3b3JraW5nIGRpcmVjdG9yeSBpZiB5b3UgZG8gbm90IGRlZmluZSBvbmUgbWFudWFsbHkuIElmIHlvdSBkZWZpbmUgYSB3b3JraW5nIGRpcmVjdG9yeSBtYW51YWxseSwgdGhpcyB2YXJpYWJsZSB3b24ndCBnaXZlIHlvdSB5b3VyIG1hbnVhbGx5IGRlZmluZWQgZGlyZWN0b3J5LCBpdCBhbHdheXMgZ2l2ZXMgdGhlIHZhdWx0J3Mgcm9vdCBkaXJlY3RvcnkuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgodGhpcy5hcHApKTtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7VmFyaWFibGV9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfV29ya3NwYWNlIGV4dGVuZHMgVmFyaWFibGV7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwid29ya3NwYWNlXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCB3b3Jrc3BhY2UncyBuYW1lLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBhbHdheXNfYXZhaWxhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJZGVhIGhvdyB0byBhY2Nlc3MgdGhlIHdvcmtzcGFjZXMgcGx1Z2luIGlzIGNvcGllZCAyMDIxLTA5LTE1IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1ZpbnplbnQwMy9vYnNpZGlhbi1hZHZhbmNlZC11cmkvYmxvYi9mN2VmODBkNTI1MjQ4MTI0MmU2OTQ5NjIwOGU5MjU4NzQyMDlmNGFhL21haW4udHMjTDE2OC1MMTc5XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWxQbHVnaW5zIGV4aXN0cyBhbHRob3VnaCBpdCdzIG5vdCBpbiBvYnNpZGlhbi5kLnRzLlxyXG4gICAgICAgICAgICBjb25zdCB3b3Jrc3BhY2VzX3BsdWdpbiA9IHRoaXMuYXBwLmludGVybmFsUGx1Z2lucz8ucGx1Z2lucz8ud29ya3NwYWNlcztcclxuICAgICAgICAgICAgaWYgKCF3b3Jrc3BhY2VzX3BsdWdpbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJXb3Jrc3BhY2VzIGNvcmUgcGx1Z2luIGlzIG5vdCBmb3VuZCBmb3Igc29tZSByZWFzb24uIFBsZWFzZSBjcmVhdGUgYSBkaXNjdXNzaW9uIGluIEdpdEh1Yi5cIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3b3Jrc3BhY2VzX3BsdWdpbi5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIldvcmtzcGFjZXMgY29yZSBwbHVnaW4gaXMgbm90IGVuYWJsZWQuXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgd29ya3NwYWNlX25hbWUgPSB3b3Jrc3BhY2VzX3BsdWdpbi5pbnN0YW5jZT8uYWN0aXZlV29ya3NwYWNlO1xyXG4gICAgICAgICAgICBpZiAoIXdvcmtzcGFjZV9uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIkNvdWxkIG5vdCBmaWd1cmUgb3V0IHRoZSBjdXJyZW50IHdvcmtzcGFjZSdzIG5hbWUuIFByb2JhYmx5IHlvdSBoYXZlIG5vdCBsb2FkZWQgYSB3b3Jrc3BhY2UuIFlvdSBjYW4gZG8gaXQgZS5nLiB2aWEgXFxcIk1hbmFnZSB3b3Jrc3BhY2VzXFxcIiBmcm9tIHRoZSBsZWZ0IHNpZGUgcGFuZWwuXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWxsIG9rXHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHdvcmtzcGFjZV9uYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbFBsdWdpbnMgZXhpc3RzLCBhbHRob3VnaCBpdCdzIG5vdCBpbiBvYnNpZGlhbi5kLnRzLlxyXG4gICAgICAgIGNvbnN0IHdvcmtzcGFjZXNfcGx1Z2luID0gdGhpcy5hcHAuaW50ZXJuYWxQbHVnaW5zPy5wbHVnaW5zPy53b3Jrc3BhY2VzO1xyXG4gICAgICAgIHJldHVybiB3b3Jrc3BhY2VzX3BsdWdpbiAmJiB3b3Jrc3BhY2VzX3BsdWdpbi5lbmFibGVkICYmIHdvcmtzcGFjZXNfcGx1Z2luLmluc3RhbmNlPy5hY3RpdmVXb3Jrc3BhY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF2YWlsYWJpbGl0eVRleHQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPk9ubHkgYXZhaWxhYmxlPC9zdHJvbmc+IHdoZW4gdGhlIFdvcmtzcGFjZXMgY29yZSBwbHVnaW4gaXMgZW5hYmxlZC5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7SVBhcmFtZXRlcnMsIFZhcmlhYmxlfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX1Bhc3N0aHJvdWdoIGV4dGVuZHMgVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcInBhc3N0aHJvdWdoXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgc2FtZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC4gVXNlZCBmb3IgdGVzdGluZyBzcGVjaWFsIGNoYXJhY3RlcnMnIGVzY2FwaW5nLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgdmFsdWU6IHN0cmluZyxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIGFyZ3VtZW50IHRoYXQgd2FzIHJlY2VpdmVkLlxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hcmd1bWVudHMudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBdmFpbGFiaWxpdHlUZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gaW4gZGVidWcgbW9kZS5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGaWxlWUFNTFZhbHVlfSBmcm9tIFwiLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuaW1wb3J0IHtURmlsZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfWUFNTFZhbHVlIGV4dGVuZHMgRmlsZVZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJ5YW1sX3ZhbHVlXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJSZWFkcyBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZpbGUncyBmcm9udG1hdHRlci4gVGFrZXMgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LiBZb3UgY2FuIGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcyB3aXRoIGRvdCBub3RhdGlvbjogcHJvcGVydHkxLnByb3BlcnR5MlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcHJvcGVydHlfbmFtZToge1xyXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgcHJvcGVydHlfbmFtZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlX2ZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGFuIGFjdGl2ZSBmaWxlXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEZpbGVZQU1MVmFsdWUoYWN0aXZlX2ZpbGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgY29udGFpbnMgZXJyb3IgbWVzc2FnZShzKS5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZXMocmVzdWx0IGFzIHN0cmluZ1tdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvaywgaXQncyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQgYXMgc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnRcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB5YW1sX3ZhbHVlX2NhY2hlOiBzdHJpbmdbXSB8IHN0cmluZztcclxuICAgIHByaXZhdGUgZ2V0RmlsZVlBTUxWYWx1ZShhY3RpdmVfZmlsZTogVEZpbGUpOiBzdHJpbmdbXSB8IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnlhbWxfdmFsdWVfY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy55YW1sX3ZhbHVlX2NhY2hlID0gZ2V0RmlsZVlBTUxWYWx1ZSh0aGlzLmFwcCwgYWN0aXZlX2ZpbGUsIHRoaXMuYXJndW1lbnRzLnByb3BlcnR5X25hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy55YW1sX3ZhbHVlX2NhY2hlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMueWFtbF92YWx1ZV9jYWNoZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKCFzdXBlci5pc0F2YWlsYWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZV9maWxlID0gdGhpcy5nZXRGaWxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmdldEZpbGVZQU1MVmFsdWUoYWN0aXZlX2ZpbGUpID09PSBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG5cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7VmFyaWFibGV9IGZyb20gXCIuLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRXZlbnRWYXJpYWJsZSBleHRlbmRzIFZhcmlhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYWx3YXlzX2F2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQGFic3RyYWN0IFNob3VsZCBiZSBhYnN0cmFjdCwgYnV0IGNhbm5vdCBtYXJrIGlzIGFzIGFic3RyYWN0IGJlY2F1c2UgaXQncyBhbHNvIHN0YXRpYy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN1cHBvcnRlZF9zY19ldmVudHM6IHR5cGVvZiBTQ19FdmVudFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZlcnkgc3ViY2xhc3Mgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgaW4gdGhlaXIgZ2VuZXJhdGVWYWx1ZSgpIGJlZm9yZSByZXR1cm5pbmcgYSB2YWx1ZS4gSWYgdGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZSxcclxuICAgICAqIHRoZW4gYSB2YXJpYWJsZSBzaG91bGQgbm90IGdlbmVyYXRlIGEgdmFsdWUsIGFzIHRoZSBkZXBlbmRlbnQgU0NfRXZlbnQgaXMgdW5hdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETzogQ2hhbmdlIHRoZSBlcnJvciBzeXN0ZW0gdG8gdGhyb3cgZXhjZXB0aW9ucyBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gcmV0dXJuIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudDogU0NfRXZlbnQpOiBib29sZWFue1xyXG4gICAgICAgIC8vIDEuIENoZWNrIGdlbmVyYWxseSB0aGF0IGFuIGV2ZW50IGlzIGhhcHBlbmluZy5cclxuICAgICAgICAvLyAoTWF5YmUgdGhpcyBjaGVjayBpcyBub3Qgc28gaW1wb3J0YW50IGFueW1vcmUsIGFzIHNjX2V2ZW50IGlzIG5vdyByZWNlaXZlZCBhcyBhIHBhcmFtZXRlciBpbnN0ZWFkIG9mIGZyb20gYSBwcm9wZXJ0eSwgYnV0IGNoZWNrIGp1c3QgaW4gY2FzZS4pXHJcbiAgICAgICAgaWYgKCFzY19ldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIlRoaXMgdmFyaWFibGUgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXZlbnRzOiBcIiArIHRoaXMuZ2V0U3VtbWFyeU9mU3VwcG9ydGVkRXZlbnRzKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyLiBDaGVjayBwYXJ0aWN1bGFybHkgd2hpY2ggZXZlbnQgaXQgaXMuXHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzU0NfRXZlbnQoc2NfZXZlbnQuZ2V0Q2xhc3MoKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJUaGlzIHZhcmlhYmxlIGRvZXMgbm90IHN1cHBvcnQgZXZlbnQgJ1wiICsgc2NfZXZlbnQuc3RhdGljKCkuZ2V0VGl0bGUoKSArIFwiJy4gU3VwcG9ydGVkIGV2ZW50czogXCIgKyB0aGlzLmdldFN1bW1hcnlPZlN1cHBvcnRlZEV2ZW50cygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3VwcG9ydHNTQ19FdmVudChzY19ldmVudF9jbGFzczogdHlwZW9mIFNDX0V2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydGVkX3NjX2V2ZW50cy5jb250YWlucyhzY19ldmVudF9jbGFzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRTdW1tYXJ5T2ZTdXBwb3J0ZWRFdmVudHMoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBzY19ldmVudF90aXRsZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRfc2NfZXZlbnRzLmZvckVhY2goKHNjX2V2ZW50X2NsYXNzOiB0eXBlb2YgU0NfRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgc2NfZXZlbnRfdGl0bGVzLnB1c2goc2NfZXZlbnRfY2xhc3MuZ2V0VGl0bGUoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNjX2V2ZW50X3RpdGxlcy5qb2luKFwiLCBcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzQXZhaWxhYmxlKHNjX2V2ZW50OiBTQ19FdmVudCB8IG51bGwpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoIXNjX2V2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNTQ19FdmVudChzY19ldmVudC5nZXRDbGFzcygpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gaW4gZXZlbnRzOiBcIiArIHRoaXMuZ2V0U3VtbWFyeU9mU3VwcG9ydGVkRXZlbnRzKCkgKyBcIi5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uTWFpbkxpbmsgPSBcImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC9zaGVsbGNvbW1hbmRzXCI7XHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uQnVpbHRJblZhcmlhYmxlc0xpbmsgPSBcImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC9zaGVsbGNvbW1hbmRzL1ZhcmlhYmxlcy9WYXJpYWJsZXMrLStnZW5lcmFsK3ByaW5jaXBsZXMjQWxsK3ZhcmlhYmxlc1wiO1xyXG5leHBvcnQgY29uc3QgRG9jdW1lbnRhdGlvbkN1c3RvbVZhcmlhYmxlc0xpbmsgPSBcImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC9zaGVsbGNvbW1hbmRzL1ZhcmlhYmxlcy9DdXN0b20rdmFyaWFibGVzXCI7XHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uQXV0b2NvbXBsZXRlTGluayA9IFwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3NoZWxsY29tbWFuZHMvVmFyaWFibGVzL0F1dG9jb21wbGV0ZS9BdXRvY29tcGxldGVcIjtcclxuZXhwb3J0IGNvbnN0IERvY3VtZW50YXRpb25FdmVudHNGb2xkZXJMaW5rID0gXCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvc2hlbGxjb21tYW5kcy9FdmVudHMvXCI7XHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uUEFUSEF1Z21lbnRhdGlvbnNMaW5rID0gXCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvc2hlbGxjb21tYW5kcy9FbnZpcm9ubWVudHMvQWRkaXRpb25zK3RvK3RoZStQQVRIK2Vudmlyb25tZW50K3ZhcmlhYmxlXCI7XHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uT3V0cHV0V3JhcHBlcnNMaW5rID0gXCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvc2hlbGxjb21tYW5kcy9PdXRwdXQraGFuZGxpbmcvT3V0cHV0K3dyYXBwZXJzXCI7XHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uT3V0cHV0SGFuZGxpbmdNb2RlTGluayA9IFwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3NoZWxsY29tbWFuZHMvT3V0cHV0K2hhbmRsaW5nL1JlYWx0aW1lK291dHB1dCtoYW5kbGluZ1wiO1xyXG5leHBvcnQgY29uc3QgR2l0SHViTGluayA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvb2JzaWRpYW4tc2hlbGxjb21tYW5kc1wiO1xyXG5leHBvcnQgY29uc3QgQ2hhbmdlbG9nTGluayA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvb2JzaWRpYW4tc2hlbGxjb21tYW5kcy9ibG9iL21haW4vQ0hBTkdFTE9HLm1kXCI7XHJcbmV4cG9ydCBjb25zdCBMaWNlbnNlTGluayA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvb2JzaWRpYW4tc2hlbGxjb21tYW5kcy9ibG9iL21haW4vTElDRU5TRVwiOyIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtBcHAsIEV2ZW50UmVmfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtcclxuICAgIFNoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzLFxyXG4gICAgVFNoZWxsQ29tbWFuZCxcclxufSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vU0NfRXZlbnRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7Y2xvbmVPYmplY3R9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4uL3ZhcmlhYmxlcy9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuLi92YXJpYWJsZXMvZXZlbnRfdmFyaWFibGVzL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtEb2N1bWVudGF0aW9uRXZlbnRzRm9sZGVyTGlua30gZnJvbSBcIi4uL0RvY3VtZW50YXRpb25cIjtcclxuaW1wb3J0IHtcclxuICAgIFNoZWxsQ29tbWFuZEV4ZWN1dG9yXHJcbn0gZnJvbSBcIi4uL2ltcG9ydHNcIjtcclxuXHJcbi8qKlxyXG4gKiBOYW1lZCBTQ19FdmVudCBpbnN0ZWFkIG9mIGp1c3QgRXZlbnQsIGJlY2F1c2UgRXZlbnQgaXMgYSBjbGFzcyBpbiBKYXZhU2NyaXB0LlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNDX0V2ZW50IHtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSBwbHVnaW46IFNDX1BsdWdpbjtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSBhcHA6IEFwcDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBhYnN0cmFjdCBTaG91bGQgYmUgYWJzdHJhY3QsIGJ1dCBjYW5ub3QgbWFyayBpcyBhcyBhYnN0cmFjdCBiZWNhdXNlIGl0J3MgYWxzbyBzdGF0aWMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQGFic3RyYWN0IFNob3VsZCBiZSBhYnN0cmFjdCwgYnV0IGNhbm5vdCBtYXJrIGlzIGFzIGFic3RyYWN0IGJlY2F1c2UgaXQncyBhbHNvIHN0YXRpYy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdHJ1ZSwgY2hhbmdpbmcgdGhlIGVuYWJsZWQvZGlzYWJsZWQgc3RhdHVzIG9mIHRoZSBldmVudCBwZXJtaXRzIHJlZ2lzdGVyaW5nIHRoZSBldmVudCBpbW1lZGlhdGVseSwgc28gaXQgY2FuIGFjdGl2YXRlXHJcbiAgICAgKiBhbnl0aW1lLiBVc3VhbGx5IHRydWUsIGJ1dCBjYW4gYmUgc2V0IHRvIGZhbHNlIGlmIGltbWVkaWF0ZSByZWdpc3RlcmluZyB0ZW5kcyB0byB0cmlnZ2VyIHRoZSBldmVudCB1bm5lY2Vzc2FyaWx5LlxyXG4gICAgICpcclxuICAgICAqIEV2ZW50cyBhcmUgYWx3YXlzIHJlZ2lzdGVyZWQgd2hlbiBsb2FkaW5nIHRoZSBwbHVnaW4sIHJlZ2FyZGxlc3Mgb2YgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHJlZ2lzdGVyX2FmdGVyX2NoYW5naW5nX3NldHRpbmdzID0gdHJ1ZTtcclxuXHJcbiAgICBwcml2YXRlIGV2ZW50X3JlZ2lzdHJhdGlvbnM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBFdmVudFJlZiwgLy8ga2V5OiB0X3NoZWxsX2NvbW1hbmQgaWRcclxuICAgIH0gPSB7fTtcclxuICAgIHByb3RlY3RlZCBkZWZhdWx0X2NvbmZpZ3VyYXRpb246IFNDX0V2ZW50Q29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xyXG5cclxuICAgICAgICB0aGlzLnN1YmNsYXNzX2luc3RhbmNlID0gdGhpczsgLy8gU3RvcmVzIGEgc3ViY2xhc3MgcmVmZXJlbmNlLCBub3QgYSBiYXNlIGNsYXNzIHJlZmVyZW5jZS5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5zIGEgdmVyc2lvbiBvZiAndGhpcycgdmFyaWFibGUgdGhhdCByZWZlcnMgdG8gdGhlIGFjdHVhbCBzdWJjbGFzcywgbm90IHRoaXMgYmFzZSBjbGFzcy5cclxuICAgICAqIFRPRE86IFBlcmhhcHMgbW92ZSB0byBhIG5ldyBjbGFzcyB0aGF0IHdpbGwgYmVjb21lIGEgcGFyZW50IG9mIHRoaXMgY2xhc3M/XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN1YmNsYXNzX2luc3RhbmNlOiB0aGlzO1xyXG4gICAgcHVibGljIGdldENsYXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNsYXNzX2luc3RhbmNlLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTQ19FdmVudFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjYW5SZWdpc3RlckFmdGVyQ2hhbmdpbmdTZXR0aW5ncygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3Rlcl9hZnRlcl9jaGFuZ2luZ19zZXR0aW5ncztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRfcmVmZXJlbmNlID0gdGhpcy5fcmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICBpZiAoZXZlbnRfcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyRXZlbnQoZXZlbnRfcmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudF9yZWdpc3RyYXRpb25zW3Rfc2hlbGxfY29tbWFuZC5nZXRJZCgpXSA9IGV2ZW50X3JlZmVyZW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVucmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW4gRXZlbnRSZWYgaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRoaXMuZXZlbnRfcmVnaXN0cmF0aW9uc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0pIHtcclxuICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHdhcyByZWdpc3RlcmVkIHdpdGhvdXQgYW4gRXZlbnRSZWYgb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgVFNoZWxsQ29tbWFuZCB0byBfdW5yZWdpc3RlcigpIHNvIGl0IGNhbiBkbyBhIGN1c3RvbSB1bnJlZ2lzdGVyaW5nLlxyXG4gICAgICAgICAgICB0aGlzLl91bnJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHJlZ2lzdHJhdGlvbiBoYWQgY3JlYXRlZCBhbiBFdmVudFJlZiBvYmplY3QuXHJcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIEV2ZW50UmVmIHRvIF91bnJlZ2lzdGVyKCkgYW5kIGZvcmdldCBpdCBhZnRlcndhcmRzLlxyXG4gICAgICAgICAgICB0aGlzLl91bnJlZ2lzdGVyKHRoaXMuZXZlbnRfcmVnaXN0cmF0aW9uc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0pO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudF9yZWdpc3RyYXRpb25zW3Rfc2hlbGxfY29tbWFuZC5nZXRJZCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IF9yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiBmYWxzZSB8IEV2ZW50UmVmO1xyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBfdW5yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IF91bnJlZ2lzdGVyKGV2ZW50X3JlZmVyZW5jZTogRXZlbnRSZWYpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgYSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICogQHBhcmFtIHRfc2hlbGxfY29tbWFuZFxyXG4gICAgICogQHBhcmFtIHBhcnNpbmdfcHJvY2VzcyBTQ19NZW51RXZlbnQgY2FuIHVzZSB0aGlzIHRvIHBhc3MgYW4gYWxyZWFkeSBzdGFydGVkIFBhcnNpbmdQcm9jZXNzIGluc3RhbmNlLiBJZiBvbWl0dGVkLCBhIG5ldyBQYXJzaW5nUHJvY2VzcyB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhc3luYyB0cmlnZ2VyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCwgcGFyc2luZ19wcm9jZXNzPzogU2hlbGxDb21tYW5kUGFyc2luZ1Byb2Nlc3MpIHtcclxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICAgIGNvbnN0IGV4ZWN1dG9yID0gbmV3IFNoZWxsQ29tbWFuZEV4ZWN1dG9yKHRoaXMucGx1Z2luLCB0X3NoZWxsX2NvbW1hbmQsIHRoaXMpO1xyXG4gICAgICAgIGF3YWl0IGV4ZWN1dG9yLmRvUHJlYWN0aW9uc0FuZEV4ZWN1dGVTaGVsbENvbW1hbmQocGFyc2luZ19wcm9jZXNzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRfY29kZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFRpdGxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50X3RpdGxlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTdW1tYXJ5T2ZFdmVudFZhcmlhYmxlcygpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlX25hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRWYXJpYWJsZXMoKS5mb3JFYWNoKCh2YXJpYWJsZTogVmFyaWFibGUpID0+IHtcclxuICAgICAgICAgICAgdmFyaWFibGVfbmFtZXMucHVzaChcInt7XCIgKyB2YXJpYWJsZS52YXJpYWJsZV9uYW1lICsgXCJ9fVwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdmFyaWFibGVfbmFtZXMuam9pbihcIiwgXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RXZlbnRWYXJpYWJsZXMoKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRfdmFyaWFibGVzOiBFdmVudFZhcmlhYmxlW10gPSBbXTtcclxuICAgICAgICB0aGlzLnBsdWdpbi5nZXRWYXJpYWJsZXMoKS5mb3JFYWNoKCh2YXJpYWJsZTogVmFyaWFibGUpID0+IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhcmlhYmxlIGlzIGFuIEV2ZW50VmFyaWFibGVcclxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgRXZlbnRWYXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gWWVzIGl0IGlzLlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhcmlhYmxlIHN1cHBvcnRzIHRoaXMgcGFydGljdWxhciBldmVudC5cclxuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5zdXBwb3J0c1NDX0V2ZW50KHRoaXMuZ2V0Q2xhc3MoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBZZXMgaXQgc3VwcG9ydHMuXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRfdmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50X3ZhcmlhYmxlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSBvdmVycmlkZGVuIGluIGNoaWxkIGNsYXNzZXMgdGhhdCBuZWVkIGN1c3RvbSBzZXR0aW5ncyBmaWVsZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVuYWJsZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERlZmF1bHRDb25maWd1cmF0aW9uKGVuYWJsZWQ6IGJvb2xlYW4pOiBTQ19FdmVudENvbmZpZ3VyYXRpb24ge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjbG9uZU9iamVjdDxTQ19FdmVudENvbmZpZ3VyYXRpb24+KHRoaXMuZGVmYXVsdF9jb25maWd1cmF0aW9uKTtcclxuICAgICAgICBjb25maWd1cmF0aW9uLmVuYWJsZWQgPSBlbmFibGVkO1xyXG4gICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdldENvbmZpZ3VyYXRpb24odF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRfc2hlbGxfY29tbWFuZC5nZXRFdmVudENvbmZpZ3VyYXRpb24odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiBpbiBjaGlsZCBjbGFzc2VzIHRvIHByb3ZpZGUgY3VzdG9tIGNvbmZpZ3VyYXRpb24gZmllbGRzIGZvciBTaGVsbENvbW1hbmRzRXh0cmFPcHRpb25zTW9kYWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV4dHJhX3NldHRpbmdzX2NvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlRXh0cmFTZXR0aW5nc0ZpZWxkcyhleHRyYV9zZXR0aW5nc19jb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiB2b2lkIHtcclxuICAgICAgICAvLyBNb3N0IGNsYXNzZXMgZG8gbm90IGRlZmluZSBjdXN0b20gc2V0dGluZ3MsIHNvIGZvciB0aG9zZSBjbGFzc2VzIHRoaXMgbWV0aG9kIGRvZXMgbm90IG5lZWQgdG8gZG8gYW55dGhpbmcuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgVFNoZWxsQ29tbWFuZCBpbnN0YW5jZXMgdGhhdCBoYXZlIGVuYWJsZWQgdGhpcyBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRTaGVsbENvbW1hbmRzKCk6IFRTaGVsbENvbW1hbmRbXSB7XHJcbiAgICAgICAgY29uc3QgZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzOiBUU2hlbGxDb21tYW5kW10gPSBbXTtcclxuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2luLmdldFRTaGVsbENvbW1hbmRzKCkpLmZvckVhY2goKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGV2ZW50IGhhcyBiZWVuIGVuYWJsZWQgZm9yIHRoZSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICAgICAgICBpZiAodF9zaGVsbF9jb21tYW5kLmlzU0NfRXZlbnRFbmFibGVkKHRoaXMuc3RhdGljKCkuZXZlbnRfY29kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFllcywgaXQncyBlbmFibGVkLlxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzLnB1c2godF9zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbmFibGVkX3Rfc2hlbGxfY29tbWFuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU0NfRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGlsZCBjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGhvb2sgaW50byBhIHNpdHVhdGlvbiB3aGVyZSBhIHVzZXIgaGFzIGVuYWJsZWQgYW4gZXZlbnQgaW4gc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRfc2hlbGxfY29tbWFuZCBUaGUgVFNoZWxsQ29tbWFuZCBpbnN0YW5jZSBmb3Igd2hpY2ggdGhpcyBTQ19FdmVudCB3YXMgZW5hYmxlZCBmb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkFmdGVyRW5hYmxpbmcodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogdm9pZCB7XHJcbiAgICAgICAgLy8gSWYgYW4gU0NfRXZlbnQgZG9lcyBub3Qgb3ZlcnJpZGUgdGhpcyBob29rIG1ldGhvZCwgZG8gbm90aGluZy5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldERvY3VtZW50YXRpb25MaW5rKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIERvY3VtZW50YXRpb25FdmVudHNGb2xkZXJMaW5rICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZXZlbnRfdGl0bGUpO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4vU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge0V2ZW50UmVmfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTQ19Xb3Jrc3BhY2VFdmVudCBleHRlbmRzIFNDX0V2ZW50IHtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSB3b3Jrc3BhY2VfZXZlbnQ6XHJcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIHdheSB0byBtYWtlIHRoaXMgbGlzdCBkeW5hbWljLlxyXG4gICAgICAgIC8vIFRoaXMgbGlzdCByZWZsZWN0cyBPYnNpZGlhbiBBUEkgdmVyc2lvbiAwLjEyLjExLlxyXG4gICAgICAgIHwgJ3F1aWNrLXByZXZpZXcnXHJcbiAgICAgICAgfCAncmVzaXplJ1xyXG4gICAgICAgIHwgJ2NsaWNrJ1xyXG4gICAgICAgIHwgJ2FjdGl2ZS1sZWFmLWNoYW5nZSdcclxuICAgICAgICB8ICdmaWxlLW9wZW4nXHJcbiAgICAgICAgfCAnbGF5b3V0LWNoYW5nZSdcclxuICAgICAgICB8ICdjc3MtY2hhbmdlJ1xyXG4gICAgICAgIHwgJ2ZpbGUtbWVudSdcclxuICAgICAgICB8ICdlZGl0b3ItbWVudSdcclxuICAgICAgICB8ICdjb2RlbWlycm9yJ1xyXG4gICAgICAgIHwgJ3F1aXQnXHJcbiAgICA7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IEZpbmQgYSB3YXkgdG8gZ2V0IGEgZHluYW1pYyB0eXBlIGZvciB0aGlzLndvcmtzcGFjZV9ldmVudCAuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLndvcmtzcGFjZS5vbih0aGlzLndvcmtzcGFjZV9ldmVudCwgdGhpcy5nZXRUcmlnZ2VyKHRfc2hlbGxfY29tbWFuZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdW5yZWdpc3RlcihldmVudF9yZWZlcmVuY2U6IEV2ZW50UmVmKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9mZnJlZihldmVudF9yZWZlcmVuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZXRUcmlnZ2VyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIHJldHVybiBhc3luYyAoLi4ucGFyYW1ldGVyczogdW5rbm93bltdIC8qIE5lZWQgdG8gaGF2ZSB0aGlzIHVnbHkgcGFyYW1ldGVyIHRoaW5nIHNvIHRoYXQgc3ViY2xhc3NlcyBjYW4gZGVmaW5lIHRoZWlyIG93biBwYXJhbWV0ZXJzLiAqLykgPT4gYXdhaXQgdGhpcy50cmlnZ2VyKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX1dvcmtzcGFjZUV2ZW50fSBmcm9tIFwiLi9TQ19Xb3Jrc3BhY2VFdmVudFwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzLCBUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgTWVudSxcclxuICAgIE1lbnVJdGVtLFxyXG59IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNDX01lbnVFdmVudCBleHRlbmRzIFNDX1dvcmtzcGFjZUV2ZW50IHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgYWRkVFNoZWxsQ29tbWFuZFRvTWVudSh0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQsIG1lbnU6IE1lbnUpIHtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG1lbnUgaXRlbSBhcyBzb29uIGFzIHBvc3NpYmxlLiAoSWYgaXQncyBjcmVhdGVkIGFmdGVyICdhd2FpdCBwYXJzaW5nX3Byb2Nlc3MucHJvY2VzcygpJyBiZWxvdywgaXQgd29uJ3QgYmUgc2hvd24gaW4gdGhlIG1lbnUgZm9yIHNvbWUgcmVhc29uLCBhdCBsZWFzdCBpbiBPYnNpZGlhbiAwLjE2LjEpLlxyXG4gICAgICAgIC8vIE5vIHRpdGxlIGlzIHNldCBoZXJlLCBpdCB3aWxsIGJlIHNldCBsYXRlci5cclxuICAgICAgICBsZXQgbWVudV9pdGVtOiBNZW51SXRlbTtcclxuICAgICAgICBtZW51LmFkZEl0ZW0oaXRlbSA9PiBtZW51X2l0ZW0gPSBpdGVtXHJcbiAgICAgICAgICAgIC5zZXRJY29uKHRfc2hlbGxfY29tbWFuZC5nZXRJY29uSWQoKSkgLy8gSWNvbiBpZCBjYW4gYmUgbnVsbC5cclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmlnZ2VyKFxyXG4gICAgICAgICAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzaW5nX3Byb2Nlc3MsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBQYXJzZSBzaGVsbCBjb21tYW5kIHZhcmlhYmxlcyB0byBnZXQgYSB0aXRsZVxyXG4gICAgICAgIGxldCB0aXRsZSA9IHRfc2hlbGxfY29tbWFuZC5nZXRBbGlhc09yU2hlbGxDb21tYW5kKCk7IC8vIE1heSBjb250YWluIHVucGFyc2VkIHZhcmlhYmxlcy5cclxuICAgICAgICBsZXQgcGFyc2luZ19wcm9jZXNzOiBTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcztcclxuICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlKSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgcGFyc2luZyBwcm9jZXNzXHJcbiAgICAgICAgICAgIHBhcnNpbmdfcHJvY2VzcyA9IHRfc2hlbGxfY29tbWFuZC5jcmVhdGVQYXJzaW5nUHJvY2Vzcyh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGF3YWl0IHBhcnNpbmdfcHJvY2Vzcy5wcm9jZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcnNpbmcgc3VjY2VlZGVkLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2luZ19yZXN1bHRzID0gcGFyc2luZ19wcm9jZXNzLmdldFBhcnNpbmdSZXN1bHRzKCk7XHJcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHBhcnNpbmdfcmVzdWx0c1tcImFsaWFzXCJdLnBhcnNlZF9jb250ZW50IHx8IHBhcnNpbmdfcmVzdWx0c1tcInNoZWxsX2NvbW1hbmRcIl0ucGFyc2VkX2NvbnRlbnQ7IC8vIFRyeSB0byB1c2UgYSBwYXJzZWQgYWxpYXMsIGJ1dCBpZiBubyBhbGlhcyBpcyBhdmFpbGFibGUsIHVzZSBhIHBhcnNlZCBzaGVsbCBjb21tYW5kIGluc3RlYWQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgcGFyc2luZyBwcm9jZXNzIGZhaWxzLCB0aGUgZmFpbGVkIHByb2Nlc3MgY2FuIGJlIHBhc3NlZCB0byB0aGlzLnRyaWdnZXIoKS4gVGhlIGV4ZWN1dGlvbiB3aWxsIGV2ZW50dWFsbHkgYmUgY2FuY2VsbGVkIGFuZCBlcnJvciBtZXNzYWdlcyBkaXNwbGF5ZWQgKGlmIGRpc3BsYXlpbmcgaXMgYWxsb3dlZCkuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgbWVudSBpdGVtIHRpdGxlLlxyXG4gICAgICAgIG1lbnVfaXRlbS5zZXRUaXRsZSh0aXRsZSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7TWVudSwgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIFdvcmtzcGFjZUxlYWZ9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge1NDX01lbnVFdmVudH0gZnJvbSBcIi4vU0NfTWVudUV2ZW50XCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU0NfQWJzdHJhY3RGaWxlTWVudUV2ZW50IGV4dGVuZHMgU0NfTWVudUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBmaWxlX29yX2ZvbGRlcjogXCJmaWxlXCIgfCBcImZvbGRlclwiO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtzcGFjZV9ldmVudCA9IFwiZmlsZS1tZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZTogVEZpbGU7XHJcbiAgICBwcm90ZWN0ZWQgZm9sZGVyOiBURm9sZGVyO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZXRUcmlnZ2VyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIHJldHVybiBhc3luYyAobWVudTogTWVudSwgZmlsZTogVEFic3RyYWN0RmlsZSwgc291cmNlOiBzdHJpbmcsIGxlYWY/OiBXb3Jrc3BhY2VMZWFmKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgaXQncyB0aGUgY29ycmVjdCBtZW51OiBpZiB0aGUgU0NfRXZlbnQgcmVxdWlyZXMgYSBmaWxlIG1lbnUsICdmaWxlJyBuZWVkcyB0byBiZSBhIFRGaWxlLCBvdGhlcndpc2UgaXQgbmVlZHMgdG8gYmUgYSBURm9sZGVyLlxyXG4gICAgICAgICAgICBpZiAoKHRoaXMuZmlsZV9vcl9mb2xkZXIgPT09IFwiZm9sZGVyXCIgJiYgZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHx8ICh0aGlzLmZpbGVfb3JfZm9sZGVyID09PSBcImZpbGVcIiAmJiBmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWVudSBpcyBjb3JyZWN0LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbGUvZm9sZGVyIGZvciBkZWNsYXJlRXh0cmFWYXJpYWJsZXMoKVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmZpbGVfb3JfZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZSBhcyBURmlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvbGRlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGRlciA9IGZpbGUgYXMgVEZvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFRTaGVsbENvbW1hbmRUb01lbnUodF9zaGVsbF9jb21tYW5kLCBtZW51KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19BYnN0cmFjdEZpbGVNZW51RXZlbnR9IGZyb20gXCIuL1NDX0Fic3RyYWN0RmlsZU1lbnVFdmVudFwiO1xyXG5pbXBvcnQge1RGaWxlLCBURm9sZGVyfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9GaWxlTWVudSBleHRlbmRzIFNDX0Fic3RyYWN0RmlsZU1lbnVFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcImZpbGUtbWVudVwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiRmlsZSBtZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiID0gXCJmaWxlXCI7XHJcblxyXG4gICAgcHVibGljIGdldEZpbGUoKTogVEZpbGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZvbGRlcigpOiBURm9sZGVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlLnBhcmVudDtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4vU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtcclxuICAgIEV2ZW50UmVmLFxyXG4gICAgVEFic3RyYWN0RmlsZSxcclxuICAgIFRGaWxlLFxyXG4gICAgVEZvbGRlcixcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNDX1ZhdWx0RXZlbnQgZXh0ZW5kcyBTQ19FdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgdmF1bHRfZXZlbnQ6XHJcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIHdheSB0byBtYWtlIHRoaXMgbGlzdCBkeW5hbWljLlxyXG4gICAgICAgIC8vIFRoaXMgbGlzdCByZWZsZWN0cyBPYnNpZGlhbiBBUEkgdmVyc2lvbiAwLjEyLjExLlxyXG4gICAgICAgIHwgXCJjcmVhdGVcIlxyXG4gICAgICAgIHwgXCJtb2RpZnlcIlxyXG4gICAgICAgIHwgXCJkZWxldGVcIlxyXG4gICAgICAgIHwgXCJyZW5hbWVcIlxyXG4gICAgICAgIHwgXCJjbG9zZWRcIiAvLyBOb3QgaW1wbGVtZW50IGJ5IGFueSBTQ19FdmVudF8qIGNsYXNzLCBiZWNhdXNlIEknbSBub3Qgc3VyZSBpZiB0aGlzIGV2ZW50IGlzIG5lZWRlZC4gQnV0IGNhbiBiZSBpbXBsZW1lbnRlZCBpZiBuZWVkIGJlLlxyXG4gICAgO1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGZpbGVfb3JfZm9sZGVyOiBcImZpbGVcIiB8IFwiZm9sZGVyXCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZTogVEZpbGU7XHJcbiAgICBwcm90ZWN0ZWQgZm9sZGVyOiBURm9sZGVyO1xyXG5cclxuICAgIHByb3RlY3RlZCBfcmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogZmFsc2UgfCBFdmVudFJlZiB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUT0RPOiBGaW5kIGEgd2F5IHRvIGdldCBhIGR5bmFtaWMgdHlwZSBmb3IgdGhpcy52YXVsdF9ldmVudCAuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLnZhdWx0Lm9uKHRoaXMudmF1bHRfZXZlbnQsIHRoaXMuZ2V0VHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3VucmVnaXN0ZXIoZXZlbnRfcmVmZXJlbmNlOiBFdmVudFJlZik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9mZnJlZihldmVudF9yZWZlcmVuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZXRUcmlnZ2VyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIHJldHVybiBhc3luYyAoZmlsZTogVEFic3RyYWN0RmlsZSwgLi4uZXh0cmFfYXJndW1lbnRzOiB1bmtub3duW10gLyogTmVlZGVkIGZvciBTQ19FdmVudF9GaWxlUmVuYW1lZCBhbmQgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZCB0byBiZSBhYmxlIHRvIGRlZmluZSBhbiBhZGRpdGlvbmFsIHBhcmFtZXRlci4qLykgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBpdCdzIHRoZSBjb3JyZWN0IHR5cGUgb2YgZmlsZTogaWYgdGhlIFNDX0V2ZW50IHJlcXVpcmVzIGEgZmlsZSwgJ2ZpbGUnIG5lZWRzIHRvIGJlIGEgVEZpbGUsIG90aGVyd2lzZSBpdCBuZWVkcyB0byBiZSBhIFRGb2xkZXIuXHJcbiAgICAgICAgICAgIGlmICgodGhpcy5maWxlX29yX2ZvbGRlciA9PT0gXCJmb2xkZXJcIiAmJiBmaWxlIGluc3RhbmNlb2YgVEZvbGRlcikgfHwgKHRoaXMuZmlsZV9vcl9mb2xkZXIgPT09IFwiZmlsZVwiICYmIGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIHR5cGUgaXMgY29ycmVjdC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaWxlL2ZvbGRlciBmb3IgZGVjbGFyZUV4dHJhVmFyaWFibGVzKClcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5maWxlX29yX2ZvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGUgYXMgVEZpbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb2xkZXJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2xkZXIgPSBmaWxlIGFzIFRGb2xkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmlnZ2VyKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgZmlsZV9vcl9mb2xkZXIgaXMgXCJmaWxlXCIhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRGaWxlKCk6IFRGaWxlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjYW4gYmUgY2FsbGVkIHdoZXRoZXIgZmlsZV9vcl9mb2xkZXIgaXMgXCJmaWxlXCIgb3IgXCJmb2xkZXJcIi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEZvbGRlcigpOiBURm9sZGVyIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZmlsZV9vcl9mb2xkZXIpIHtcclxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUucGFyZW50O1xyXG4gICAgICAgICAgICBjYXNlIFwiZm9sZGVyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2xkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19WYXVsdEV2ZW50fSBmcm9tIFwiLi9TQ19WYXVsdEV2ZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU0NfRXZlbnRfRmlsZUNyZWF0ZWQgZXh0ZW5kcyBTQ19WYXVsdEV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZmlsZS1jcmVhdGVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJGaWxlIGNyZWF0ZWRcIjtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB2YXVsdF9ldmVudCA9IFwiY3JlYXRlXCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiID0gXCJmaWxlXCI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMy4wIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfVmF1bHRFdmVudH0gZnJvbSBcIi4vU0NfVmF1bHRFdmVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQgZXh0ZW5kcyBTQ19WYXVsdEV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZmlsZS1jb250ZW50LW1vZGlmaWVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJGaWxlIGNvbnRlbnQgbW9kaWZpZWRcIjtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB2YXVsdF9ldmVudCA9IFwibW9kaWZ5XCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiID0gXCJmaWxlXCI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMy4wIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfVmF1bHRFdmVudH0gZnJvbSBcIi4vU0NfVmF1bHRFdmVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X0ZpbGVEZWxldGVkIGV4dGVuZHMgU0NfVmF1bHRFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcImZpbGUtZGVsZXRlZFwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiRmlsZSBkZWxldGVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdmF1bHRfZXZlbnQgPSBcImRlbGV0ZVwiO1xyXG4gICAgcHJvdGVjdGVkIGZpbGVfb3JfZm9sZGVyOiBcImZpbGVcIiA9IFwiZmlsZVwiO1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMuMCBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX1ZhdWx0RXZlbnR9IGZyb20gXCIuL1NDX1ZhdWx0RXZlbnRcIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge1RBYnN0cmFjdEZpbGV9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge1xyXG4gICAgZXh0cmFjdEZpbGVOYW1lLFxyXG4gICAgZXh0cmFjdEZpbGVQYXJlbnRQYXRoLFxyXG59IGZyb20gXCIuLi9Db21tb25cIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTQ19WYXVsdE1vdmVPclJlbmFtZUV2ZW50IGV4dGVuZHMgU0NfVmF1bHRFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdmF1bHRfZXZlbnQgPSBcInJlbmFtZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciB0aGlzIGV2ZW50IHNob3VsZCB0cmlnZ2VyIHdoZW4gYSBmaWxlL2ZvbGRlciBpcyBtb3ZlZCBPUiByZW5hbWVkLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgbW92ZV9vcl9yZW5hbWU6IFwibW92ZVwiIHwgXCJyZW5hbWVcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWxlJ3Mgb2xkIHBhdGgsIGdvdHRlbiBmcm9tIE9ic2lkaWFuJ3MgVmF1bHQub24oXCJyZW5hbWVcIikuIE9ubHkgcHJlc2VudCBpZiB0aGlzLmZpbGVfb3JfZm9sZGVyIGlzIFwiZmlsZVwiLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaWxlX29sZF9yZWxhdGl2ZV9wYXRoOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGlzLmZpbGVfb3JfZm9sZGVyIGlzIFwiZmlsZVwiOiBUaGUgZmlsZSdzIHBhcmVudCBmb2xkZXIncyBvbGQgcGF0aC5cclxuICAgICAqIElmIHRoaXMuZmlsZV9vcl9mb2xkZXIgaXMgXCJmb2xkZXJcIjogVGhlIGZvbGRlcidzIG9sZCBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIFJlbGF0aXZlIGZyb20gdGhlIHZhdWx0J3Mgcm9vdCBmb2xkZXIuIEdvdHRlbiBmcm9tIE9ic2lkaWFuJ3MgVmF1bHQub24oXCJyZW5hbWVcIikuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZvbGRlcl9vbGRfcmVsYXRpdmVfcGF0aDogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZXRUcmlnZ2VyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG5cclxuICAgICAgICAvLyBHZXQgYSB0cmlnZ2VyIGZyb20gdGhlIHBhcmVudCBjbGFzcyAoU0NfVmF1bHRFdmVudCkuXHJcbiAgICAgICAgY29uc3QgdHJpZ2dlciA9IHN1cGVyLmdldFRyaWdnZXIodF9zaGVsbF9jb21tYW5kKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFzeW5jIChhYnN0cmFjdF9maWxlOiBUQWJzdHJhY3RGaWxlLCBvbGRfcmVsYXRpdmVfcGF0aDogc3RyaW5nKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIGZpbGUvZm9sZGVyIHdhcyBtb3ZlZCBvciByZW5hbWVkLlxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlsZS9mb2xkZXIgbmFtZSBoYXMgc3RheWVkIHRoZSBzYW1lLCBjb25jbHVkZSB0aGF0IHRoZSBmaWxlIGhhcyBiZWVuIE1PVkVELCBub3QgcmVuYW1lZC4gT3RoZXJ3aXNlLCBjb25jbHVkZSB0aGUgb3Bwb3NpdGUuXHJcbiAgICAgICAgICAgIGNvbnN0IG9sZF9maWxlX25hbWUgPSBleHRyYWN0RmlsZU5hbWUob2xkX3JlbGF0aXZlX3BhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdfZmlsZV9uYW1lID0gYWJzdHJhY3RfZmlsZS5uYW1lO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudF90eXBlID0gKG9sZF9maWxlX25hbWUgPT09IG5ld19maWxlX25hbWUpID8gXCJtb3ZlXCIgOiBcInJlbmFtZVwiOyAvLyBUZWxscyB3aGF0IHJlYWxseSBoYXBwZW5lZC4gdGhpcy5tb3ZlX29yX3JlbmFtZSB0ZWxscyB3aGF0IGlzIHRoZSBjb25kaXRpb24gZm9yIHRoZSBldmVudCB0byB0cmlnZ2VyLlxyXG5cclxuICAgICAgICAgICAgLy8gT25seSBwcm9jZWVkIHRoZSB0cmlnZ2VyaW5nLCBpZiB0aGUgZGV0ZXJtaW5lZCB0eXBlIGVxdWFscyB0aGUgb25lIGRlZmluZWQgYnkgdGhlIGV2ZW50IGNsYXNzLlxyXG4gICAgICAgICAgICBpZiAoZXZlbnRfdHlwZSA9PT0gdGhpcy5tb3ZlX29yX3JlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHR5cGUgaXMgY29ycmVjdC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaWxlIGFuZCBmb2xkZXIgZm9yIGRlY2xhcmVFeHRyYVZhcmlhYmxlcygpXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZmlsZV9vcl9mb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVfb2xkX3JlbGF0aXZlX3BhdGggPSBvbGRfcmVsYXRpdmVfcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2xkZXJfb2xkX3JlbGF0aXZlX3BhdGggPSBleHRyYWN0RmlsZVBhcmVudFBhdGgob2xkX3JlbGF0aXZlX3BhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZGVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyX29sZF9yZWxhdGl2ZV9wYXRoID0gb2xkX3JlbGF0aXZlX3BhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIG5vcm1hbCB0cmlnZ2VyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdHJpZ2dlcihhYnN0cmFjdF9maWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZvbGRlck9sZFJlbGF0aXZlUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkZXJfb2xkX3JlbGF0aXZlX3BhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZpbGVPbGRSZWxhdGl2ZVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZV9vbGRfcmVsYXRpdmVfcGF0aDtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19WYXVsdE1vdmVPclJlbmFtZUV2ZW50fSBmcm9tIFwiLi9TQ19WYXVsdE1vdmVPclJlbmFtZUV2ZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU0NfRXZlbnRfRmlsZVJlbmFtZWQgZXh0ZW5kcyBTQ19WYXVsdE1vdmVPclJlbmFtZUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZmlsZS1yZW5hbWVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJGaWxlIHJlbmFtZWRcIjtcclxuICAgIHByb3RlY3RlZCBtb3ZlX29yX3JlbmFtZTogXCJyZW5hbWVcIiA9IFwicmVuYW1lXCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiID0gXCJmaWxlXCI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMy4wIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfVmF1bHRNb3ZlT3JSZW5hbWVFdmVudH0gZnJvbSBcIi4vU0NfVmF1bHRNb3ZlT3JSZW5hbWVFdmVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X0ZpbGVNb3ZlZCBleHRlbmRzIFNDX1ZhdWx0TW92ZU9yUmVuYW1lRXZlbnQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF9jb2RlID0gXCJmaWxlLW1vdmVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJGaWxlIG1vdmVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgbW92ZV9vcl9yZW5hbWU6IFwibW92ZVwiID0gXCJtb3ZlXCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiID0gXCJmaWxlXCI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDcmVhdGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVDcmVhdGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZURlbGV0ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZURlbGV0ZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlUmVuYW1lZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudEZpbGVOYW1lIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZmlsZV9uYW1lXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlIG5hbWUgd2l0aCBhIGZpbGUgZXh0ZW5zaW9uLiBJZiB5b3UgbmVlZCBpdCB3aXRob3V0IHRoZSBleHRlbnNpb24sIHVzZSB7e2V2ZW50X3RpdGxlfX0gaW5zdGVhZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgICAgICBTQ19FdmVudF9GaWxlQ3JlYXRlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVEZWxldGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNb3ZlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlUmVuYW1lZCxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVNZW51IHwgU0NfRXZlbnRfRmlsZUNyZWF0ZWQgfCBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkIHwgU0NfRXZlbnRfRmlsZURlbGV0ZWQgfCBTQ19FdmVudF9GaWxlTW92ZWQgfCBTQ19FdmVudF9GaWxlUmVuYW1lZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoc2NfZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc2NfZXZlbnQuZ2V0RmlsZSgpLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1vdmVkXCI7XHJcbmltcG9ydCB7Z2V0RmlsZVBhdGh9IGZyb20gXCIuLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuaW1wb3J0IHtURmlsZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudEZpbGVQYXRoIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZmlsZV9wYXRoXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyBwYXRoIHRvIHRoZSBldmVudCByZWxhdGVkIGZpbGUsIGVpdGhlciBhcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbSwgb3IgYXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBtb2RlOiB7XHJcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcImFic29sdXRlXCIsIFwicmVsYXRpdmVcIl0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN1cHBvcnRlZF9zY19ldmVudHMgPSBbXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1lbnUsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZUNyZWF0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlRGVsZXRlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZVJlbmFtZWQsXHJcbiAgICBdO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKHNjX2V2ZW50OiBTQ19FdmVudF9GaWxlTWVudSB8IFNDX0V2ZW50X0ZpbGVDcmVhdGVkIHwgU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZCB8IFNDX0V2ZW50X0ZpbGVEZWxldGVkIHwgU0NfRXZlbnRfRmlsZU1vdmVkIHwgU0NfRXZlbnRfRmlsZVJlbmFtZWQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KHNjX2V2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGU6IFRGaWxlID0gc2NfZXZlbnQuZ2V0RmlsZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRGaWxlUGF0aCh0aGlzLmFwcCwgZmlsZSwgdGhpcy5hcmd1bWVudHMubW9kZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBdXRvY29tcGxldGVJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSwgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBldmVudCByZWxhdGVkIGZpbGUsIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlLCByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tldmVudF9maWxlX3BhdGg6cmVsYXRpdmV9fTwvc3Ryb25nPiBvciA8c3Ryb25nPnt7ZXZlbnRfZmlsZV9wYXRoOmFic29sdXRlfX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfQWJzdHJhY3RGaWxlTWVudUV2ZW50fSBmcm9tIFwiLi9TQ19BYnN0cmFjdEZpbGVNZW51RXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9Gb2xkZXJNZW51IGV4dGVuZHMgU0NfQWJzdHJhY3RGaWxlTWVudUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZm9sZGVyLW1lbnVcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkZvbGRlciBtZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZm9sZGVyXCIgPSBcImZvbGRlclwiO1xyXG5cclxuICAgIHB1YmxpYyBnZXRGb2xkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZGVyO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMuMCBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX1ZhdWx0RXZlbnR9IGZyb20gXCIuL1NDX1ZhdWx0RXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9Gb2xkZXJDcmVhdGVkIGV4dGVuZHMgU0NfVmF1bHRFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcImZvbGRlci1jcmVhdGVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJGb2xkZXIgY3JlYXRlZFwiO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHZhdWx0X2V2ZW50ID0gXCJjcmVhdGVcIjtcclxuICAgIHByb3RlY3RlZCBmaWxlX29yX2ZvbGRlcjogXCJmb2xkZXJcIiA9IFwiZm9sZGVyXCI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMy4wIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfVmF1bHRFdmVudH0gZnJvbSBcIi4vU0NfVmF1bHRFdmVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X0ZvbGRlckRlbGV0ZWQgZXh0ZW5kcyBTQ19WYXVsdEV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZm9sZGVyLWRlbGV0ZWRcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkZvbGRlciBkZWxldGVkXCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdmF1bHRfZXZlbnQgPSBcImRlbGV0ZVwiO1xyXG4gICAgcHJvdGVjdGVkIGZpbGVfb3JfZm9sZGVyOiBcImZvbGRlclwiID0gXCJmb2xkZXJcIjtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19WYXVsdE1vdmVPclJlbmFtZUV2ZW50fSBmcm9tIFwiLi9TQ19WYXVsdE1vdmVPclJlbmFtZUV2ZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZCBleHRlbmRzIFNDX1ZhdWx0TW92ZU9yUmVuYW1lRXZlbnQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF9jb2RlID0gXCJmb2xkZXItcmVuYW1lZFwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiRm9sZGVyIHJlbmFtZWRcIjtcclxuICAgIHByb3RlY3RlZCBtb3ZlX29yX3JlbmFtZTogXCJyZW5hbWVcIiA9IFwicmVuYW1lXCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZm9sZGVyXCIgPSBcImZvbGRlclwiO1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMuMCBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX1ZhdWx0TW92ZU9yUmVuYW1lRXZlbnR9IGZyb20gXCIuL1NDX1ZhdWx0TW92ZU9yUmVuYW1lRXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9Gb2xkZXJNb3ZlZCBleHRlbmRzIFNDX1ZhdWx0TW92ZU9yUmVuYW1lRXZlbnQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF9jb2RlID0gXCJmb2xkZXItbW92ZWRcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkZvbGRlciBtb3ZlZFwiO1xyXG4gICAgcHJvdGVjdGVkIG1vdmVfb3JfcmVuYW1lOiBcIm1vdmVcIiA9IFwibW92ZVwiO1xyXG4gICAgcHJvdGVjdGVkIGZpbGVfb3JfZm9sZGVyOiBcImZvbGRlclwiID0gXCJmb2xkZXJcIjtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJNZW51fSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZvbGRlck1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlckNyZWF0ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRm9sZGVyQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRm9sZGVyRGVsZXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJSZW5hbWVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZvbGRlclJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJNb3ZlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGb2xkZXJOYW1lIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZm9sZGVyX25hbWVcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkZpbGUgZXZlbnRzOiBHaXZlcyB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlJ3MgcGFyZW50IGZvbGRlciBuYW1lLiBGb2xkZXIgZXZlbnRzOiBHaXZlcyB0aGUgc2VsZWN0ZWQgZm9sZGVyJ3MgbmFtZS4gTm8gYW5jZXN0b3IgZm9sZGVycyBhcmUgaW5jbHVkZWQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN1cHBvcnRlZF9zY19ldmVudHMgPSBbXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1lbnUsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyTWVudSxcclxuICAgICAgICBTQ19FdmVudF9GaWxlQ3JlYXRlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVEZWxldGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNb3ZlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlUmVuYW1lZCxcclxuICAgICAgICBTQ19FdmVudF9Gb2xkZXJDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZvbGRlckRlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZCxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVNZW51IHwgU0NfRXZlbnRfRm9sZGVyTWVudSB8IFNDX0V2ZW50X0ZpbGVDcmVhdGVkIHwgU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZCB8IFNDX0V2ZW50X0ZpbGVEZWxldGVkIHwgU0NfRXZlbnRfRmlsZU1vdmVkIHwgU0NfRXZlbnRfRmlsZVJlbmFtZWQgfCBTQ19FdmVudF9Gb2xkZXJDcmVhdGVkIHwgU0NfRXZlbnRfRm9sZGVyRGVsZXRlZCB8IFNDX0V2ZW50X0ZvbGRlck1vdmVkIHwgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoc2NfZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gc2NfZXZlbnQuZ2V0Rm9sZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZvbGRlci5uYW1lKTsgLy8gVE9ETzogQ29uc2lkZXIgY2hhbmdpbmcgdG8gYGZvbGRlci5pc1Jvb3QoKSA/IFwiLlwiIDogZm9sZGVyLm5hbWU7YCBhcyBpcyBkb25lIGluIFZhcmlhYmxlX05ld05vdGVGaWxlTmFtZS5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJNZW51fSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZvbGRlck1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlckNyZWF0ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRm9sZGVyQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRm9sZGVyRGVsZXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJSZW5hbWVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZvbGRlclJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJNb3ZlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0Rm9sZGVyUGF0aH0gZnJvbSBcIi4uL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uLy4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGb2xkZXJQYXRoIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZm9sZGVyX3BhdGhcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkZpbGUgZXZlbnRzOiBHaXZlcyBwYXRoIHRvIHRoZSBldmVudCByZWxhdGVkIGZpbGUncyBwYXJlbnQgZm9sZGVyLiBGb2xkZXIgZXZlbnRzOiBHaXZlcyBwYXRoIHRvIHRoZSBldmVudCByZWxhdGVkIGZvbGRlci4gVGhlIHBhdGggaXMgZWl0aGVyIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLCBvciByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIG1vZGU6IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW1wiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiXSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIG1vZGU6IFwiYWJzb2x1dGVcIiB8IFwicmVsYXRpdmVcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgICAgICBTQ19FdmVudF9Gb2xkZXJNZW51LFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZURlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1vdmVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZvbGRlckNyZWF0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyRGVsZXRlZCxcclxuICAgICAgICBTQ19FdmVudF9Gb2xkZXJNb3ZlZCxcclxuICAgICAgICBTQ19FdmVudF9Gb2xkZXJSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZShzY19ldmVudDogU0NfRXZlbnRfRmlsZU1lbnUgfCBTQ19FdmVudF9Gb2xkZXJNZW51IHwgU0NfRXZlbnRfRmlsZUNyZWF0ZWQgfCBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkIHwgU0NfRXZlbnRfRmlsZURlbGV0ZWQgfCBTQ19FdmVudF9GaWxlTW92ZWQgfCBTQ19FdmVudF9GaWxlUmVuYW1lZCB8IFNDX0V2ZW50X0ZvbGRlckNyZWF0ZWQgfCBTQ19FdmVudF9Gb2xkZXJEZWxldGVkIHwgU0NfRXZlbnRfRm9sZGVyTW92ZWQgfCBTQ19FdmVudF9Gb2xkZXJSZW5hbWVkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmb2xkZXIgPSBzY19ldmVudC5nZXRGb2xkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZ2V0Rm9sZGVyUGF0aCh0aGlzLmFwcCwgZm9sZGVyLCB0aGlzLmFyZ3VtZW50cy5tb2RlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiRmlsZSBldmVudHM6IEdpdmVzIHBhdGggdG8gdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSdzIHBhcmVudCBmb2xkZXIuIEZvbGRlciBldmVudHM6IEdpdmVzIHBhdGggdG8gdGhlIGV2ZW50IHJlbGF0ZWQgZm9sZGVyLiBUaGUgcGF0aCBpcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiRmlsZSBldmVudHM6IEdpdmVzIHBhdGggdG8gdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSdzIHBhcmVudCBmb2xkZXIuIEZvbGRlciBldmVudHM6IEdpdmVzIHBhdGggdG8gdGhlIGV2ZW50IHJlbGF0ZWQgZm9sZGVyLiBUaGUgcGF0aCBpcyByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkZpbGUgZXZlbnRzOiBHaXZlcyBwYXRoIHRvIHRoZSBldmVudCByZWxhdGVkIGZpbGUncyBwYXJlbnQgZm9sZGVyLiBGb2xkZXIgZXZlbnRzOiBHaXZlcyBwYXRoIHRvIHRoZSBldmVudCByZWxhdGVkIGZvbGRlci4gVGhlIHBhdGggaXMgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJGaWxlIGV2ZW50czogR2l2ZXMgcGF0aCB0byB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlJ3MgcGFyZW50IGZvbGRlci4gRm9sZGVyIGV2ZW50czogR2l2ZXMgcGF0aCB0byB0aGUgZXZlbnQgcmVsYXRlZCBmb2xkZXIuIFRoZSBwYXRoIGlzIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhlbHBOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz57e2V2ZW50X2ZvbGRlcl9wYXRoOnJlbGF0aXZlfX08L3N0cm9uZz4gb3IgPHN0cm9uZz57e2V2ZW50X2ZvbGRlcl9wYXRoOmFic29sdXRlfX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1vdmVkXCI7XHJcbmltcG9ydCB7RXZlbnRWYXJpYWJsZX0gZnJvbSBcIi4vRXZlbnRWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0V2ZW50VGl0bGUgZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJldmVudF90aXRsZVwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSBuYW1lIHdpdGhvdXQgYSBmaWxlIGV4dGVuc2lvbi4gSWYgeW91IG5lZWQgaXQgd2l0aCB0aGUgZXh0ZW5zaW9uLCB1c2Uge3tldmVudF9maWxlX25hbWV9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZURlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1vdmVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZShzY19ldmVudDogU0NfRXZlbnRfRmlsZU1lbnUgfCBTQ19FdmVudF9GaWxlQ3JlYXRlZCB8IFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQgfCBTQ19FdmVudF9GaWxlRGVsZXRlZCB8IFNDX0V2ZW50X0ZpbGVNb3ZlZCB8IFNDX0V2ZW50X0ZpbGVSZW5hbWVkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShzY19ldmVudC5nZXRGaWxlKCkuYmFzZW5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1vdmVkXCI7XHJcbmltcG9ydCB7Z2V0RmlsZUV4dGVuc2lvbn0gZnJvbSBcIi4uL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uLy4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGaWxlRXh0ZW5zaW9uIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZmlsZV9leHRlbnNpb25cIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRoZSBldmVudCByZWxhdGVkIGZpbGUgbmFtZSdzIGVuZGluZy4gVXNlIHt7ZXZlbnRfZmlsZV9leHRlbnNpb246d2l0aC1kb3R9fSB0byBpbmNsdWRlIGEgcHJlY2VkaW5nIGRvdC4gSWYgdGhlIGV4dGVuc2lvbiBpcyBlbXB0eSwgbm8gZG90IGlzIGFkZGVkLiB7e2V2ZW50X2ZpbGVfZXh0ZW5zaW9uOm5vLWRvdH19IG5ldmVyIGluY2x1ZGVzIGEgZG90LlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgXCJkb3RcIjoge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJ3aXRoLWRvdFwiLCBcIm5vLWRvdFwiXSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIFwiZG90XCI6IFwid2l0aC1kb3RcIiB8IFwibm8tZG90XCIsXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN1cHBvcnRlZF9zY19ldmVudHMgPSBbXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1lbnUsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZUNyZWF0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlRGVsZXRlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZVJlbmFtZWQsXHJcbiAgICBdO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKHNjX2V2ZW50OiBTQ19FdmVudF9GaWxlTWVudSB8IFNDX0V2ZW50X0ZpbGVDcmVhdGVkIHwgU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZCB8IFNDX0V2ZW50X0ZpbGVEZWxldGVkIHwgU0NfRXZlbnRfRmlsZU1vdmVkIHwgU0NfRXZlbnRfRmlsZVJlbmFtZWQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KHNjX2V2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBzY19ldmVudC5nZXRGaWxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEZpbGVFeHRlbnNpb24oZmlsZSwgdGhpcy5hcmd1bWVudHMuZG90ID09PSBcIndpdGgtZG90XCIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXV0b2NvbXBsZXRlSXRlbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOm5vLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGhvdXQgYSBwcmVjZWRpbmcgZG90LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOndpdGgtZG90fX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlIG5hbWUncyBlbmRpbmcgd2l0aCBhIHByZWNlZGluZyBkb3QuIElmIHRoZSBleHRlbnNpb24gaXMgZW1wdHksIG5vIGRvdCBpcyBpbmNsdWRlZC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6bm8tZG90fX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlIG5hbWUncyBlbmRpbmcgd2l0aG91dCBhIHByZWNlZGluZyBkb3QuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOndpdGgtZG90fX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgZXZlbnQgcmVsYXRlZCBmaWxlIG5hbWUncyBlbmRpbmcgd2l0aCBhIHByZWNlZGluZyBkb3QuIElmIHRoZSBleHRlbnNpb24gaXMgZW1wdHksIG5vIGRvdCBpcyBpbmNsdWRlZC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tldmVudF9maWxlX2V4dGVuc2lvbjp3aXRoLWRvdH19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tldmVudF9maWxlX2V4dGVuc2lvbjpuby1kb3R9fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG5cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1vdmVkXCI7XHJcbmltcG9ydCB7RXZlbnRWYXJpYWJsZX0gZnJvbSBcIi4vRXZlbnRWYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGaWxlVGFnc30gZnJvbSBcIi4uL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0V2ZW50VGFncyBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X3RhZ3NcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIGFsbCB0YWdzIGRlZmluZWQgaW4gdGhlIGV2ZW50IHJlbGF0ZWQgbm90ZS4gUmVwbGFjZSB0aGUgXFxcInNlcGFyYXRvclxcXCIgcGFydCB3aXRoIGEgY29tbWEsIHNwYWNlIG9yIHdoYXRldmVyIGNoYXJhY3RlcnMgeW91IHdhbnQgdG8gdXNlIGFzIGEgc2VwYXJhdG9yIGJldHdlZW4gdGFncy4gQSBzZXBhcmF0b3IgaXMgYWx3YXlzIG5lZWRlZCB0byBiZSBkZWZpbmVkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZURlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1vdmVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHNlcGFyYXRvcjoge1xyXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBzZXBhcmF0b3I6IHN0cmluZyxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVNZW51IHwgU0NfRXZlbnRfRmlsZUNyZWF0ZWQgfCBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkIHwgU0NfRXZlbnRfRmlsZURlbGV0ZWQgfCBTQ19FdmVudF9GaWxlTW92ZWQgfCBTQ19FdmVudF9GaWxlUmVuYW1lZCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KHNjX2V2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBzY19ldmVudC5nZXRGaWxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEZpbGVUYWdzKHRoaXMuYXBwLCBmaWxlKS5qb2luKHRoaXMuYXJndW1lbnRzLnNlcGFyYXRvcikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDcmVhdGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVDcmVhdGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZURlbGV0ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZURlbGV0ZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlUmVuYW1lZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0RmlsZVlBTUxWYWx1ZX0gZnJvbSBcIi4uL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtURmlsZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRZQU1MVmFsdWUgZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJldmVudF95YW1sX3ZhbHVlXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJSZWFkcyBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoZSBldmVudCByZWxhdGVkIGZpbGUncyBmcm9udG1hdHRlci4gVGFrZXMgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LiBZb3UgY2FuIGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcyB3aXRoIGRvdCBub3RhdGlvbjogcHJvcGVydHkxLnByb3BlcnR5MlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcHJvcGVydHlfbmFtZToge1xyXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgcHJvcGVydHlfbmFtZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZURlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1vdmVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZShzY19ldmVudDogU0NfRXZlbnRfRmlsZU1lbnUgfCBTQ19FdmVudF9GaWxlQ3JlYXRlZCB8IFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQgfCBTQ19FdmVudF9GaWxlRGVsZXRlZCB8IFNDX0V2ZW50X0ZpbGVNb3ZlZCB8IFNDX0V2ZW50X0ZpbGVSZW5hbWVkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gc2NfZXZlbnQuZ2V0RmlsZSgpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEZpbGVZQU1MVmFsdWUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgY29udGFpbnMgZXJyb3IgbWVzc2FnZShzKS5cclxuICAgICAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlcyhyZXN1bHQgYXMgc3RyaW5nW10pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG9rLCBpdCdzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0IGFzIHN0cmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHlhbWxfdmFsdWVfY2FjaGU6IHN0cmluZ1tdIHwgc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBnZXRGaWxlWUFNTFZhbHVlKGFjdGl2ZV9maWxlOiBURmlsZSk6IHN0cmluZ1tdIHwgc3RyaW5nIHtcclxuICAgICAgICBpZiAoIXRoaXMueWFtbF92YWx1ZV9jYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLnlhbWxfdmFsdWVfY2FjaGUgPSBnZXRGaWxlWUFNTFZhbHVlKHRoaXMuYXBwLCBhY3RpdmVfZmlsZSwgdGhpcy5hcmd1bWVudHMucHJvcGVydHlfbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnlhbWxfdmFsdWVfY2FjaGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy55YW1sX3ZhbHVlX2NhY2hlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0F2YWlsYWJsZShzY19ldmVudDogU0NfRXZlbnRfRmlsZU1lbnUgfCBudWxsKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKCFzdXBlci5pc0F2YWlsYWJsZShzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYWN0aXZlX2ZpbGUgPSBzY19ldmVudC5nZXRGaWxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmdldEZpbGVZQU1MVmFsdWUoYWN0aXZlX2ZpbGUpID09PSBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyOlxyXG4gKiAgLSBWaW5heSBSYWp1ciAoY3JlYXRlZCBtb3N0IG9mIHRoZSBjb250ZW50IG9mIHRoZSBWYXJpYWJsZV9DYXJldFBvc2l0aW9uIGNsYXNzKVxyXG4gKiAgLSBKYXJra28gTGlubmFudmlydGEgKHNvbWUgbWlub3Ivc3RydWN0dXJhbCBjaGFuZ2VzKVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3Q6XHJcbiAqICAtIFZpbmF5IFJhanVyOiBodHRwczovL2dpdGh1Yi5jb20vdnJhanVyXHJcbiAqICAtIEphcmtrbyBMaW5uYW52aXJ0YTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtJUGFyYW1ldGVycywgVmFyaWFibGV9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRW52aXJvbm1lbnQgZXh0ZW5kcyBWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZW52aXJvbm1lbnRcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlJ3MgdmFsdWUuIEl0J3MgYW4gb3JpZ2luYWwgdmFsdWUgcmVjZWl2ZWQgd2hlbiBPYnNpZGlhbiB3YXMgc3RhcnRlZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYWx3YXlzX2F2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgdmFyaWFibGU6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIHZhcmlhYmxlOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHJlcXVlc3RlZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBleGlzdHMuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFllcywgaXQgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzcy5lbnZbdGhpcy5hcmd1bWVudHMudmFyaWFibGVdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgLy8gRnJlYWsgb3V0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoYEVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVkICcke3RoaXMuYXJndW1lbnRzLnZhcmlhYmxlfScgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tlbnZpcm9ubWVudDp2YXJpYWJsZX19PC9zdHJvbmc+XCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQgIT09IHByb2Nlc3MuZW52W3RoaXMuYXJndW1lbnRzLnZhcmlhYmxlXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gaWYgdGhlIHBhc3NlZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lIGV4aXN0cy5cIjtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7RXZlbnRWYXJpYWJsZX0gZnJvbSBcIi4vRXZlbnRWYXJpYWJsZVwiO1xyXG5pbXBvcnQge2V4dHJhY3RGaWxlTmFtZX0gZnJvbSBcIi4uLy4uL0NvbW1vblwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVSZW5hbWVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVSZW5hbWVkXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRPbGRGaWxlTmFtZSBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X29sZF9maWxlX25hbWVcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRoZSByZW5hbWVkIGZpbGUncyBvbGQgbmFtZSB3aXRoIGEgZmlsZSBleHRlbnNpb24uIElmIHlvdSBuZWVkIGl0IHdpdGhvdXQgdGhlIGV4dGVuc2lvbiwgdXNlIHt7ZXZlbnRfb2xkX3RpdGxlfX0gaW5zdGVhZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlUmVuYW1lZCxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVSZW5hbWVkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShleHRyYWN0RmlsZU5hbWUoc2NfZXZlbnQuZ2V0RmlsZU9sZFJlbGF0aXZlUGF0aCgpLCB0cnVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldFZhdWx0QWJzb2x1dGVQYXRoLFxyXG4gICAgbm9ybWFsaXplUGF0aDIsXHJcbn0gZnJvbSBcIi4uLy4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uLy4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1vdmVkXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRPbGRGaWxlUGF0aCBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X29sZF9maWxlX3BhdGhcIjtcclxuICAgIHB1YmxpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRoZSByZW5hbWVkL21vdmVkIGZpbGUncyBvbGQgcGF0aCwgZWl0aGVyIGFzIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLCBvciBhcyByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIG1vZGU6IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW1wiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiXSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIG1vZGU6IFwiYWJzb2x1dGVcIiB8IFwicmVsYXRpdmVcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZVJlbmFtZWQsXHJcbiAgICBdO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKHNjX2V2ZW50OiBTQ19FdmVudF9GaWxlTW92ZWQgfCBTQ19FdmVudF9GaWxlUmVuYW1lZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoc2NfZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlsZV9vbGRfcmVsYXRpdmVfcGF0aCA9IHNjX2V2ZW50LmdldEZpbGVPbGRSZWxhdGl2ZVBhdGgoKTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFyZ3VtZW50cy5tb2RlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5vcm1hbGl6ZVBhdGgyKGZpbGVfb2xkX3JlbGF0aXZlX3BhdGgpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhYnNvbHV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5vcm1hbGl6ZVBhdGgyKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKSArIFwiL1wiICsgZmlsZV9vbGRfcmVsYXRpdmVfcGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIlVucmVjb2duaXplZCBtb2RlIHBhcmFtZXRlcjogXCIgKyB0aGlzLmFyZ3VtZW50cy5tb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIHJlbmFtZWQvbW92ZWQgZmlsZSdzIG9sZCBwYXRoLCBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIHJlbmFtZWQvbW92ZWQgZmlsZSdzIG9sZCBwYXRoLCByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSByZW5hbWVkL21vdmVkIGZpbGUncyBvbGQgcGF0aCwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgcmVuYW1lZC9tb3ZlZCBmaWxlJ3Mgb2xkIHBhdGgsIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhlbHBOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz57e2V2ZW50X2ZpbGVfcGF0aDpyZWxhdGl2ZX19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tldmVudF9maWxlX3BhdGg6YWJzb2x1dGV9fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7ZXh0cmFjdEZpbGVOYW1lfSBmcm9tIFwiLi4vLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRm9sZGVyUmVuYW1lZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJSZW5hbWVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1vdmVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVNb3ZlZFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0V2ZW50T2xkRm9sZGVyTmFtZSBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X29sZF9mb2xkZXJfbmFtZVwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiRmlsZSBldmVudHM6IEdpdmVzIHRoZSBtb3ZlZCBmaWxlJ3Mgb2xkIHBhcmVudCBmb2xkZXIncyBuYW1lLiBGb2xkZXIgZXZlbnRzOiBHaXZlcyB0aGUgcmVuYW1lZCBmb2xkZXIncyBvbGQgbmFtZS5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZCxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVNb3ZlZCB8IFNDX0V2ZW50X0ZvbGRlclJlbmFtZWQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KHNjX2V2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGV4dHJhY3RGaWxlTmFtZShzY19ldmVudC5nZXRGb2xkZXJPbGRSZWxhdGl2ZVBhdGgoKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRWYXVsdEFic29sdXRlUGF0aCxcclxuICAgIG5vcm1hbGl6ZVBhdGgyLFxyXG59IGZyb20gXCIuLi8uLi9Db21tb25cIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVyc30gZnJvbSBcIi4uL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7SUF1dG9jb21wbGV0ZUl0ZW19IGZyb20gXCIuLi8uLi9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlclJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRm9sZGVyUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJNb3ZlZFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0V2ZW50T2xkRm9sZGVyUGF0aCBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X29sZF9mb2xkZXJfcGF0aFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiRmlsZSBldmVudHM6IEdpdmVzIHRoZSBtb3ZlZCBmaWxlJ3Mgb2xkIHBhcmVudCBmb2xkZXIncyBwYXRoLiBGb2xkZXIgZXZlbnRzOiBHaXZlcyB0aGUgcmVuYW1lZC9tb3ZlZCBmb2xkZXIncyBvbGQgcGF0aC4gVGhlIHBhdGggaXMgZWl0aGVyIGFzIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLCBvciBhcyByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIG1vZGU6IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW1wiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiXSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIG1vZGU6IFwiYWJzb2x1dGVcIiB8IFwicmVsYXRpdmVcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyTW92ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZCxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVNb3ZlZCB8IFNDX0V2ZW50X0ZvbGRlclJlbmFtZWQgfCBTQ19FdmVudF9Gb2xkZXJNb3ZlZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoc2NfZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZm9sZGVyX29sZF9yZWxhdGl2ZV9wYXRoID0gc2NfZXZlbnQuZ2V0Rm9sZGVyT2xkUmVsYXRpdmVQYXRoKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hcmd1bWVudHMubW9kZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVsYXRpdmVcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShub3JtYWxpemVQYXRoMihmb2xkZXJfb2xkX3JlbGF0aXZlX3BhdGgpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhYnNvbHV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5vcm1hbGl6ZVBhdGgyKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKSArIFwiL1wiICsgZm9sZGVyX29sZF9yZWxhdGl2ZV9wYXRoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiVW5yZWNvZ25pemVkIG1vZGUgcGFyYW1ldGVyOiBcIiArIHRoaXMuYXJndW1lbnRzLm1vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXV0b2NvbXBsZXRlSXRlbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJGaWxlIGV2ZW50czogR2l2ZXMgdGhlIG1vdmVkIGZpbGUncyBvbGQgcGFyZW50IGZvbGRlcidzIHBhdGguIEZvbGRlciBldmVudHM6IEdpdmVzIHRoZSByZW5hbWVkL21vdmVkIGZvbGRlcidzIG9sZCBwYXRoLiBUaGUgcGF0aCBpcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiRmlsZSBldmVudHM6IEdpdmVzIHRoZSBtb3ZlZCBmaWxlJ3Mgb2xkIHBhcmVudCBmb2xkZXIncyBwYXRoLiBGb2xkZXIgZXZlbnRzOiBHaXZlcyB0aGUgcmVuYW1lZC9tb3ZlZCBmb2xkZXIncyBvbGQgcGF0aC4gVGhlIHBhdGggaXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJGaWxlIGV2ZW50czogR2l2ZXMgdGhlIG1vdmVkIGZpbGUncyBvbGQgcGFyZW50IGZvbGRlcidzIHBhdGguIEZvbGRlciBldmVudHM6IEdpdmVzIHRoZSByZW5hbWVkL21vdmVkIGZvbGRlcidzIG9sZCBwYXRoLiBUaGUgcGF0aCBpcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkZpbGUgZXZlbnRzOiBHaXZlcyB0aGUgbW92ZWQgZmlsZSdzIG9sZCBwYXJlbnQgZm9sZGVyJ3MgcGF0aC4gRm9sZGVyIGV2ZW50czogR2l2ZXMgdGhlIHJlbmFtZWQvbW92ZWQgZm9sZGVyJ3Mgb2xkIHBhdGguIFRoZSBwYXRoIGlzIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhlbHBOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz57e2V2ZW50X2ZpbGVfcGF0aDpyZWxhdGl2ZX19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tldmVudF9maWxlX3BhdGg6YWJzb2x1dGV9fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7ZXh0cmFjdEZpbGVOYW1lfSBmcm9tIFwiLi4vLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudE9sZFRpdGxlIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfb2xkX3RpdGxlXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgcmVuYW1lZCBmaWxlJ3Mgb2xkIG5hbWUgd2l0aG91dCBhIGZpbGUgZXh0ZW5zaW9uLiBJZiB5b3UgbmVlZCBpdCB3aXRoIHRoZSBleHRlbnNpb24sIHVzZSB7e2V2ZW50X29sZF9maWxlX25hbWV9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZShzY19ldmVudDogU0NfRXZlbnRfRmlsZVJlbmFtZWQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KHNjX2V2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGV4dHJhY3RGaWxlTmFtZShzY19ldmVudC5nZXRGaWxlT2xkUmVsYXRpdmVQYXRoKCksIGZhbHNlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX05ld05vdGVGb2xkZXJOYW1lIGV4dGVuZHMgVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcIm5ld19ub3RlX2ZvbGRlcl9uYW1lXCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgZm9sZGVyIG5hbWUgZm9yIFxcXCJEZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgbm90ZXNcXFwiIChhIHNldHRpbmcgaW4gT2JzaWRpYW4pLiBObyBhbmNlc3RvciBmb2xkZXJzIGFyZSBpbmNsdWRlZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBQcm9taXNlPHN0cmluZ3xudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7IC8vIE5lZWRlZCBqdXN0IGluIGNhc2UgbmV3IG5vdGVzIHNob3VsZCBiZSBjcmVhdGVkIGluIHRoZSBzYW1lIGZvbGRlciBhcyB0aGUgY3VycmVudGx5IG9wZW4gZmlsZS5cclxuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5hcHAuZmlsZU1hbmFnZXIuZ2V0TmV3RmlsZVBhcmVudChjdXJyZW50X2ZpbGUgPyBjdXJyZW50X2ZpbGUucGF0aCA6IFwiXCIpOyAvLyBJZiBubyBmaWxlIGlzIG9wZW4sIHVzZSBhbiBlbXB0eSBzdHJpbmcgYXMgaW5zdHJ1Y3RlZCBpbiAuZ2V0TmV3RmlsZVBhcmVudCgpJ3MgZG9jdW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgaWYgKCFmb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiQ2Fubm90IGRldGVybWluZSBhIGZvbGRlciBuYW1lIGZvciBuZXcgbm90ZXMuIFBsZWFzZSBjcmVhdGUgYSBkaXNjdXNzaW9uIGluIEdpdEh1Yi5cIik7IC8vIEkgZ3Vlc3MgdGhpcyBuZXZlciBoYXBwZW5zLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm9sZGVyLmlzUm9vdCgpID8gXCIuXCIgOiBmb2xkZXIubmFtZSk7IC8vIElmIHRoZSBmb2xkZXIgaXMgdGhlIHZhdWx0J3Mgcm9vdCBmb2xkZXIsIHJldHVybiBcIi5cIiBpbnN0ZWFkIG9mIFwiIFwiIChhIHNwYWNlIGNoYXJhY3RlcikuIEkgZG9uJ3Qga25vdyB3aHkgdGhlIG5hbWUgaXMgXCIgXCIgd2hlbiB0aGUgZm9sZGVyIGlzIHJvb3QuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gICAgSVBhcmFtZXRlcnMsXHJcbiAgICBWYXJpYWJsZSxcclxufSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtnZXRGb2xkZXJQYXRofSBmcm9tIFwiLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9OZXdOb3RlRm9sZGVyUGF0aCBleHRlbmRzIFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJuZXdfbm90ZV9mb2xkZXJfcGF0aFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgcGF0aCB0byB0aGUgXFxcIkRlZmF1bHQgbG9jYXRpb24gZm9yIG5ldyBub3Rlc1xcXCIgZm9sZGVyIChhIHNldHRpbmcgaW4gT2JzaWRpYW4pLCBlaXRoZXIgYXMgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0sIG9yIGFzIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50X2ZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpOyAvLyBOZWVkZWQganVzdCBpbiBjYXNlIG5ldyBub3RlcyBzaG91bGQgYmUgY3JlYXRlZCBpbiB0aGUgc2FtZSBmb2xkZXIgYXMgdGhlIGN1cnJlbnRseSBvcGVuIGZpbGUuXHJcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwLmZpbGVNYW5hZ2VyLmdldE5ld0ZpbGVQYXJlbnQoY3VycmVudF9maWxlID8gY3VycmVudF9maWxlLnBhdGggOiBcIlwiKTsgLy8gSWYgbm8gZmlsZSBpcyBvcGVuLCB1c2UgYW4gZW1wdHkgc3RyaW5nIGFzIGluc3RydWN0ZWQgaW4gLmdldE5ld0ZpbGVQYXJlbnQoKSdzIGRvY3VtZW50YXRpb24uXHJcbiAgICAgICAgICAgIGlmIChmb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEZvbGRlclBhdGgodGhpcy5hcHAsIGZvbGRlciwgdGhpcy5hcmd1bWVudHMubW9kZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJDYW5ub3QgZGV0ZXJtaW5lIGEgZm9sZGVyIHBhdGggZm9yIG5ldyBub3Rlcy4gUGxlYXNlIGNyZWF0ZSBhIGRpc2N1c3Npb24gaW4gR2l0SHViLlwiKTsgLy8gSSBndWVzcyB0aGlzIG5ldmVyIGhhcHBlbnMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBdXRvY29tcGxldGVJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIFxcXCJEZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgbm90ZXNcXFwiIGZvbGRlciAoYSBzZXR0aW5nIGluIE9ic2lkaWFuKSwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIFxcXCJEZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgbm90ZXNcXFwiIGZvbGRlciAoYSBzZXR0aW5nIGluIE9ic2lkaWFuKSwgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBcXFwiRGVmYXVsdCBsb2NhdGlvbiBmb3IgbmV3IG5vdGVzXFxcIiBmb2xkZXIgKGEgc2V0dGluZyBpbiBPYnNpZGlhbiksIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgXFxcIkRlZmF1bHQgbG9jYXRpb24gZm9yIG5ldyBub3Rlc1xcXCIgZm9sZGVyIChhIHNldHRpbmcgaW4gT2JzaWRpYW4pLCByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tmb2xkZXJfcGF0aDpyZWxhdGl2ZX19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tmb2xkZXJfcGF0aDphYnNvbHV0ZX19PC9zdHJvbmc+XCI7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0ZpbGVWYXJpYWJsZX0gZnJvbSBcIi4vRmlsZVZhcmlhYmxlXCI7XHJcbmltcG9ydCB7bm9ybWFsaXplUGF0aH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRmlsZVVSSSBleHRlbmRzIEZpbGVWYXJpYWJsZXtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJmaWxlX3VyaVwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgYW4gT2JzaWRpYW4gVVJJIHRoYXQgb3BlbnMgdGhlIGN1cnJlbnQgZmlsZS5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBQcm9taXNlPHN0cmluZ3xudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZV9maWxlID0gdGhpcy5nZXRGaWxlKCk7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVfZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcy5wbHVnaW4uZ2V0T2JzaWRpYW5VUkkoXCJvcGVuXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBub3JtYWxpemVQYXRoKGFjdGl2ZV9maWxlLnBhdGgpLCAvLyBVc2Ugbm9ybWFsaXplUGF0aCgpIGluc3RlYWQgb2Ygbm9ybWFsaXplUGF0aDIoKSBiZWNhdXNlIC8gc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXFwgb24gV2luZG93cyBiZWNhdXNlIHRoaXMgaXMgdXNlZCBhcyBhIFVSSSwgbm90IGFzIGEgZmlsZSBzeXN0ZW0gcGF0aC5cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDcmVhdGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVDcmVhdGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZURlbGV0ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZURlbGV0ZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlUmVuYW1lZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuaW1wb3J0IHtcclxuICAgIG5vcm1hbGl6ZVBhdGgsXHJcbiAgICBURmlsZSxcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudEZpbGVVUkkgZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyB2YXJpYWJsZV9uYW1lID0gXCJldmVudF9maWxlX3VyaVwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgYW4gT2JzaWRpYW4gVVJJIHRoYXQgb3BlbnMgdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZS5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgICAgICBTQ19FdmVudF9GaWxlQ3JlYXRlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVEZWxldGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNb3ZlZCxcclxuICAgICAgICBTQ19FdmVudF9GaWxlUmVuYW1lZCxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoc2NfZXZlbnQ6IFNDX0V2ZW50X0ZpbGVNZW51IHwgU0NfRXZlbnRfRmlsZUNyZWF0ZWQgfCBTQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkIHwgU0NfRXZlbnRfRmlsZURlbGV0ZWQgfCBTQ19FdmVudF9GaWxlTW92ZWQgfCBTQ19FdmVudF9GaWxlUmVuYW1lZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoc2NfZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlsZTogVEZpbGUgPSBzY19ldmVudC5nZXRGaWxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMucGx1Z2luLmdldE9ic2lkaWFuVVJJKFwib3BlblwiLCB7XHJcbiAgICAgICAgICAgICAgICBmaWxlOiBub3JtYWxpemVQYXRoKGZpbGUucGF0aCksIC8vIFVzZSBub3JtYWxpemVQYXRoKCkgaW5zdGVhZCBvZiBub3JtYWxpemVQYXRoMigpIGJlY2F1c2UgLyBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byBcXCBvbiBXaW5kb3dzIGJlY2F1c2UgdGhpcyBpcyB1c2VkIGFzIGEgVVJJLCBub3QgYXMgYSBmaWxlIHN5c3RlbSBwYXRoLlxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHtGaWxlVmFyaWFibGV9IGZyb20gXCIuL0ZpbGVWYXJpYWJsZVwiO1xyXG5pbXBvcnQge2dldEZpbGVDb250ZW50V2l0aG91dFlBTUx9IGZyb20gXCIuLi9Db21tb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9Ob3RlQ29udGVudCBleHRlbmRzIEZpbGVWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgdmFyaWFibGVfbmFtZSA9IFwibm90ZV9jb250ZW50XCI7XHJcbiAgICBwdWJsaWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBub3RlJ3MgY29udGVudCB3aXRob3V0IFlBTUwgZnJvbnRtYXR0ZXIuIElmIHlvdSBuZWVkIFlBTUwgaW5jbHVkZWQsIHVzZSB7e2ZpbGVfY29udGVudH19IGluc3RlYWQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmd8bnVsbD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVfZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2V0RmlsZUNvbnRlbnRXaXRob3V0WUFNTCh0aGlzLmFwcCwgYWN0aXZlX2ZpbGUpLnRoZW4oKGZpbGVfY29udGVudF93aXRob3V0X3lhbWw6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlX2NvbnRlbnRfd2l0aG91dF95YW1sKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDcmVhdGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVDcmVhdGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ29udGVudE1vZGlmaWVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZURlbGV0ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZURlbGV0ZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlUmVuYW1lZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNb3ZlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTW92ZWRcIjtcclxuaW1wb3J0IHtnZXRGaWxlQ29udGVudFdpdGhvdXRZQU1MfSBmcm9tIFwiLi4vLi4vQ29tbW9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnROb3RlQ29udGVudCBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X25vdGVfY29udGVudFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSdzIGNvbnRlbnQgd2l0aG91dCBZQU1MIGZyb250bWF0dGVyLiBJZiB5b3UgbmVlZCBZQU1MIGluY2x1ZGVkLCB1c2Uge3tldmVudF9maWxlX2NvbnRlbnR9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZURlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1vdmVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZShzY19ldmVudDogU0NfRXZlbnRfRmlsZU1lbnUgfCBTQ19FdmVudF9GaWxlQ3JlYXRlZCB8IFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQgfCBTQ19FdmVudF9GaWxlRGVsZXRlZCB8IFNDX0V2ZW50X0ZpbGVNb3ZlZCB8IFNDX0V2ZW50X0ZpbGVSZW5hbWVkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZXRGaWxlQ29udGVudFdpdGhvdXRZQU1MKHRoaXMuYXBwLCBzY19ldmVudC5nZXRGaWxlKCkpLnRoZW4oKGZpbGVfY29udGVudDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlX2NvbnRlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQge0ZpbGVWYXJpYWJsZX0gZnJvbSBcIi4vRmlsZVZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRmlsZUNvbnRlbnQgZXh0ZW5kcyBGaWxlVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImZpbGVfY29udGVudFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSdzIGNvbnRlbnQsIGluY2x1ZGluZyBZQU1MIGZyb250bWF0dGVyLiBJZiB5b3UgbmVlZCBZQU1MIGV4Y2x1ZGVkLCB1c2Uge3tub3RlX2NvbnRlbnR9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlX2ZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICAgICAgaWYgKCFhY3RpdmVfZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGZpbGUgY29udGVudC5cclxuICAgICAgICAgICAgYXBwLnZhdWx0LnJlYWQoYWN0aXZlX2ZpbGUpLnRoZW4oKGZpbGVfY29udGVudDogc3RyaW5nKSA9PiByZXNvbHZlKGZpbGVfY29udGVudCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZU1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlQ3JlYXRlZH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRmlsZVJlbmFtZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZVJlbmFtZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRmlsZU1vdmVkXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGaWxlQ29udGVudCBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X2ZpbGVfY29udGVudFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGV2ZW50IHJlbGF0ZWQgZmlsZSdzIGNvbnRlbnQsIGluY2x1ZGluZyBZQU1MIGZyb250bWF0dGVyLiBJZiB5b3UgbmVlZCBZQU1MIGV4Y2x1ZGVkLCB1c2Uge3tldmVudF9ub3RlX2NvbnRlbnR9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDcmVhdGVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZURlbGV0ZWQsXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1vdmVkLFxyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVSZW5hbWVkLFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZShzY19ldmVudDogU0NfRXZlbnRfRmlsZU1lbnUgfCBTQ19FdmVudF9GaWxlQ3JlYXRlZCB8IFNDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWQgfCBTQ19FdmVudF9GaWxlRGVsZXRlZCB8IFNDX0V2ZW50X0ZpbGVNb3ZlZCB8IFNDX0V2ZW50X0ZpbGVSZW5hbWVkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydChzY19ldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBmaWxlIGNvbnRlbnQuXHJcbiAgICAgICAgICAgIGFwcC52YXVsdC5yZWFkKHNjX2V2ZW50LmdldEZpbGUoKSkudGhlbigoZmlsZV9jb250ZW50OiBzdHJpbmcpID0+IHJlc29sdmUoZmlsZV9jb250ZW50KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMuMCBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0VkaXRvclZhcmlhYmxlfSBmcm9tIFwiLi9FZGl0b3JWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0NhcmV0UGFyYWdyYXBoIGV4dGVuZHMgRWRpdG9yVmFyaWFibGUge1xyXG4gICAgcHVibGljIHZhcmlhYmxlX25hbWUgPSBcImNhcmV0X3BhcmFncmFwaFwiO1xyXG4gICAgcHVibGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgYSB0ZXh0IGxpbmUgYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIGdlbmVyYXRlVmFsdWUoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVpcmVFZGl0b3IoKSB8fCAhdGhpcy5pc1ZpZXdNb2RlU291cmNlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoJ3RvJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldExpbmUoY2FyZXRQb3NpdGlvbi5saW5lKTtcclxuICAgIH1cclxuXHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0NsaXBib2FyZH0gZnJvbSBcIi4vVmFyaWFibGVfQ2xpcGJvYXJkXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfQ2FyZXRQb3NpdGlvbn0gZnJvbSBcIi4vVmFyaWFibGVfQ2FyZXRQb3NpdGlvblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0RhdGV9IGZyb20gXCIuL1ZhcmlhYmxlX0RhdGVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9GaWxlRXh0ZW5zaW9ufSBmcm9tIFwiLi9WYXJpYWJsZV9GaWxlRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRmlsZU5hbWV9IGZyb20gXCIuL1ZhcmlhYmxlX0ZpbGVOYW1lXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRmlsZVBhdGh9IGZyb20gXCIuL1ZhcmlhYmxlX0ZpbGVQYXRoXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRm9sZGVyTmFtZX0gZnJvbSBcIi4vVmFyaWFibGVfRm9sZGVyTmFtZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0ZvbGRlclBhdGh9IGZyb20gXCIuL1ZhcmlhYmxlX0ZvbGRlclBhdGhcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9TZWxlY3Rpb259IGZyb20gXCIuL1ZhcmlhYmxlX1NlbGVjdGlvblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX1RhZ3N9IGZyb20gXCIuL1ZhcmlhYmxlX1RhZ3NcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9UaXRsZX0gZnJvbSBcIi4vVmFyaWFibGVfVGl0bGVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9WYXVsdFBhdGh9IGZyb20gXCIuL1ZhcmlhYmxlX1ZhdWx0UGF0aFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX1dvcmtzcGFjZX0gZnJvbSBcIi4vVmFyaWFibGVfV29ya3NwYWNlXCI7XHJcbmltcG9ydCB7REVCVUdfT059IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX1Bhc3N0aHJvdWdofSBmcm9tIFwiLi9WYXJpYWJsZV9QYXNzdGhyb3VnaFwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfWUFNTFZhbHVlfSBmcm9tIFwiLi9WYXJpYWJsZV9ZQU1MVmFsdWVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudEZpbGVOYW1lfSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGaWxlTmFtZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0V2ZW50RmlsZVBhdGh9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVQYXRoXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRGb2xkZXJOYW1lfSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGb2xkZXJOYW1lXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRGb2xkZXJQYXRofSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGb2xkZXJQYXRoXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRUaXRsZX0gZnJvbSBcIi4vZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50VGl0bGVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudEZpbGVFeHRlbnNpb259IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVFeHRlbnNpb25cIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudFRhZ3N9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudFRhZ3NcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudFlBTUxWYWx1ZX0gZnJvbSBcIi4vZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50WUFNTFZhbHVlXCI7XHJcbmltcG9ydCB7Q3VzdG9tVmFyaWFibGVJbnN0YW5jZX0gZnJvbSBcIi4uL21vZGVscy9jdXN0b21fdmFyaWFibGUvQ3VzdG9tVmFyaWFibGVJbnN0YW5jZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0Vudmlyb25tZW50fSBmcm9tIFwiLi9WYXJpYWJsZV9FbnZpcm9ubWVudFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0V2ZW50T2xkRmlsZU5hbWV9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudE9sZEZpbGVOYW1lXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRPbGRGaWxlUGF0aH0gZnJvbSBcIi4vZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50T2xkRmlsZVBhdGhcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudE9sZEZvbGRlck5hbWV9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudE9sZEZvbGRlck5hbWVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudE9sZEZvbGRlclBhdGh9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudE9sZEZvbGRlclBhdGhcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudE9sZFRpdGxlfSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRPbGRUaXRsZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX05ld05vdGVGb2xkZXJOYW1lfSBmcm9tIFwiLi9WYXJpYWJsZV9OZXdOb3RlRm9sZGVyTmFtZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX05ld05vdGVGb2xkZXJQYXRofSBmcm9tIFwiLi9WYXJpYWJsZV9OZXdOb3RlRm9sZGVyUGF0aFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0ZpbGVVUkl9IGZyb20gXCIuL1ZhcmlhYmxlX0ZpbGVVUklcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudEZpbGVVUkl9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVVUklcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9Ob3RlQ29udGVudH0gZnJvbSBcIi4vVmFyaWFibGVfTm90ZUNvbnRlbnRcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudE5vdGVDb250ZW50fSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnROb3RlQ29udGVudFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0ZpbGVDb250ZW50fSBmcm9tIFwiLi9WYXJpYWJsZV9GaWxlQ29udGVudFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0V2ZW50RmlsZUNvbnRlbnR9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVDb250ZW50XCI7XHJcbmltcG9ydCB7VmFyaWFibGVfQ2FyZXRQYXJhZ3JhcGh9IGZyb20gXCIuL1ZhcmlhYmxlX0NhcmV0UGFyYWdyYXBoXCI7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRWYXJpYWJsZXMocGx1Z2luOiBTQ19QbHVnaW4pOiBWYXJpYWJsZVNldCB7XHJcblxyXG4gICAgY29uc3QgdmFyaWFibGVzID0gbmV3IFZhcmlhYmxlU2V0KFtdKTtcclxuXHJcbiAgICAvLyBMb2FkIEN1c3RvbVZhcmlhYmxlc1xyXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgbG9hZGluZyBidWlsdC1pbiB2YXJpYWJsZXMgc28gdGhhdCB0aGVzZSB1c2VyLWRlZmluZWQgdmFyaWFibGVzIHdpbGwgYXBwZWFyIGZpcnN0IGluIGFsbCBsaXN0cyBjb250YWluaW5nIHZhcmlhYmxlcy5cclxuICAgIHBsdWdpbi5nZXRDdXN0b21WYXJpYWJsZUluc3RhbmNlcygpLmZvckVhY2goKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZTogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSkgPT4ge1xyXG4gICAgICAgIHZhcmlhYmxlcy5hZGQoY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmNyZWF0ZUN1c3RvbVZhcmlhYmxlKCkpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBMb2FkIGJ1aWx0LWluIHZhcmlhYmxlcy5cclxuICAgIGNvbnN0IGJ1aWx0X2luX3ZhcmlhYmxlczogVmFyaWFibGVbXSA9IFtcclxuICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVzXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0NhcmV0UGFyYWdyYXBoKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0NhcmV0UG9zaXRpb24ocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfQ2xpcGJvYXJkKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0RhdGUocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRW52aXJvbm1lbnQocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRmlsZUNvbnRlbnQocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRmlsZUV4dGVuc2lvbihwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9GaWxlTmFtZShwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9GaWxlUGF0aChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9GaWxlVVJJKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0ZvbGRlck5hbWUocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRm9sZGVyUGF0aChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9OZXdOb3RlRm9sZGVyTmFtZShwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9OZXdOb3RlRm9sZGVyUGF0aChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9Ob3RlQ29udGVudChwbHVnaW4pLFxyXG4gICAgICAgIC8vIFZhcmlhYmxlX091dHB1dCBpcyBub3QgbG9hZGVkIGhlcmUsIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgaW4gT3V0cHV0V3JhcHBlcnMuXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX1NlbGVjdGlvbihwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9UYWdzKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX1RpdGxlKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX1ZhdWx0UGF0aChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9Xb3Jrc3BhY2UocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfWUFNTFZhbHVlKHBsdWdpbiksXHJcblxyXG4gICAgICAgIC8vIEV2ZW50IHZhcmlhYmxlc1xyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudEZpbGVDb250ZW50KHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50RmlsZUV4dGVuc2lvbihwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudEZpbGVOYW1lKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50RmlsZVBhdGgocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRXZlbnRGaWxlVVJJKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50Rm9sZGVyTmFtZShwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudEZvbGRlclBhdGgocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRXZlbnROb3RlQ29udGVudChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudE9sZEZpbGVOYW1lKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50T2xkRmlsZVBhdGgocGx1Z2luKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRXZlbnRPbGRGb2xkZXJOYW1lKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50T2xkRm9sZGVyUGF0aChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudE9sZFRpdGxlKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50VGFncyhwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudFRpdGxlKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50WUFNTFZhbHVlKHBsdWdpbiksXHJcbiAgICBdO1xyXG4gICAgaWYgKERFQlVHX09OKSB7XHJcbiAgICAgICAgLy8gVmFyaWFibGVzIHRoYXQgYXJlIG9ubHkgZGVzaWduZWQgZm9yICdTaGVsbCBjb21tYW5kcyB0ZXN0IHN1aXRlJy5cclxuICAgICAgICBidWlsdF9pbl92YXJpYWJsZXMucHVzaChcclxuICAgICAgICAgICAgbmV3IFZhcmlhYmxlX1Bhc3N0aHJvdWdoKHBsdWdpbiksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgYnVpbHRfaW5fdmFyaWFibGUgb2YgYnVpbHRfaW5fdmFyaWFibGVzKSB7XHJcbiAgICAgICAgLy8gSmF2YVNjcmlwdCdzIFNldCBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIHRvIGFkZCBtdWx0aXBsZSBpdGVtcyBhdCBvbmNlLCBzbyBuZWVkIHRvIGl0ZXJhdGUgdGhlbSBhbmQgYWRkIG9uZS1ieS1vbmUuXHJcbiAgICAgICAgdmFyaWFibGVzLmFkZChidWlsdF9pbl92YXJpYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhcmlhYmxlcztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlU2V0IGV4dGVuZHMgU2V0PFZhcmlhYmxlPiB7fSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uL0RlYnVnXCI7XHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuLi9ldmVudHMvU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtlc2NhcGVWYWx1ZX0gZnJvbSBcIi4vZXNjYXBlcnMvRXNjYXBlVmFsdWVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZVNldH0gZnJvbSBcIi4vbG9hZFZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge1ZhcmlhYmxlLCBWYXJpYWJsZVZhbHVlUmVzdWx0fSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7cmVtb3ZlRnJvbVNldH0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBwbHVnaW5cclxuICogQHBhcmFtIGNvbnRlbnRcclxuICogQHBhcmFtIHNoZWxsIFVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHZhcmlhYmxlIHZhbHVlcy4gQ2FuIGJlIG51bGwsIGlmIG5vIGVzY2FwaW5nIGlzIHdhbnRlZC5cclxuICogQHBhcmFtIHRfc2hlbGxfY29tbWFuZCBXaWxsIG9ubHkgYmUgdXNlZCB0byByZWFkIGRlZmF1bHQgdmFsdWUgY29uZmlndXJhdGlvbnMuIENhbiBiZSBudWxsIGlmIG5vIFRTaGVsbENvbW1hbmQgaXMgYXZhaWxhYmxlLCBidXQgdGhlbiBubyBkZWZhdWx0IHZhbHVlcyBjYW4gYmUgYWNjZXNzZWQuXHJcbiAqIEBwYXJhbSBzY19ldmVudCBVc2UgdW5kZWZpbmVkLCBpZiBwYXJzaW5nIGlzIG5vdCBoYXBwZW5pbmcgZHVyaW5nIGFuIGV2ZW50LlxyXG4gKiBAcGFyYW0gdmFyaWFibGVzIElmIHlvdSB3YW50IHRvIHBhcnNlIG9ubHkgYSBjZXJ0YWluIHNldCBvZiB2YXJpYWJsZXMsIGRlZmluZSB0aGVtIGluIHRoaXMgcGFyYW1ldGVyLiBJZiB0aGlzIGlzIG9taXR0ZWQsIGFsbCB2YXJpYWJsZXMgd2lsbCBiZSBwYXJzZWQuXHJcbiAqIEBwYXJhbSByYXdfdmFsdWVfYXVnbWVudGVyIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgZXZlcnkgc3Vic3RpdHV0aW9uLiBBbGxvd3MgbW9kaWZ5aW5nIG9yIGNvbXBsZXRlbHkgY2hhbmdpbmcgdGhlIHJlc3VsdGVkIHZhcmlhYmxlIHZhbHVlcy5cclxuICogQHBhcmFtIGVzY2FwZWRfdmFsdWVfYXVnbWVudGVyIFNhbWUgYXMgcmF3X3ZhbHVlX2F1Z21lbnRlciwgYnV0IGNhbGxlZCBhZnRlciBlc2NhcGluZyB0aGUgdmFsdWUuIENhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHdyYXAgdmFsdWVzIGluIGh0bWwgZWxlbWVudHMgZm9yIGRpc3BsYXlpbmcgcHVycG9zZXMuXHJcbiAqIEByZXR1cm4gUGFyc2luZ1Jlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVzKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICBzaGVsbDogc3RyaW5nIHwgbnVsbCxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQgfCBudWxsLFxyXG4gICAgICAgIHNjX2V2ZW50PzogU0NfRXZlbnQgfCBudWxsLFxyXG4gICAgICAgIHZhcmlhYmxlczogVmFyaWFibGVTZXQgPSBwbHVnaW4uZ2V0VmFyaWFibGVzKCksXHJcbiAgICAgICAgcmF3X3ZhbHVlX2F1Z21lbnRlcjogKCh2YXJpYWJsZTogVmFyaWFibGUsIHJhd192YWx1ZTogVmFyaWFibGVWYWx1ZVJlc3VsdCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbCxcclxuICAgICAgICBlc2NhcGVkX3ZhbHVlX2F1Z21lbnRlcjogKCh2YXJpYWJsZTogVmFyaWFibGUsIGVzY2FwZWRfdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nKSB8IG51bGwgPSBudWxsLFxyXG4gICAgKTogUHJvbWlzZTxQYXJzaW5nUmVzdWx0PiB7XHJcblxyXG4gICAgZGVidWdMb2coXCJwYXJzZVZhcmlhYmxlcygpOiBTdGFydGluZyB0byBwYXJzZSBcIiArIGNvbnRlbnQgKyBcIiB3aXRoIFwiICsgdmFyaWFibGVzLnNpemUgKyBcIiB2YXJpYWJsZXMuXCIpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgYSBwYXJzaW5nIHJlc3VsdCBvYmplY3RcclxuICAgIGNvbnN0IHBhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0ID0ge1xyXG4gICAgICAgIG9yaWdpbmFsX2NvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgcGFyc2VkX2NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3VjY2VlZGVkOiBmYWxzZSxcclxuICAgICAgICBlcnJvcl9tZXNzYWdlczogW10sXHJcbiAgICAgICAgY291bnRfcGFyc2VkX3ZhcmlhYmxlczogMCxcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQgPSBjb250ZW50OyAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSB2YXJpYWJsZSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gYWx0ZXIgdGhlIG9yaWdpbmFsIHZhbHVlIG9mICdjb250ZW50JyBkdXJpbmcgaXRlcmF0aW5nIGl0cyByZWdleCBtYXRjaGVzLiBPcmlnaW5hbGx5IHRoaXMgY29weSB3YXMganVzdCBhbm90aGVyIGxvY2FsIHZhcmlhYmxlLCBidXQgbm93IGl0J3MgY2hhbmdlZCB0byBiZSBhIHByb3BlcnR5IGluIGFuIG9iamVjdC5cclxuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdmFyaWFibGVzKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHZhcmlhYmxlLmdldFBhdHRlcm4oKSwgXCJpZ3VcIik7IC8vIGk6IGNhc2UtaW5zZW5zaXRpdmU7IGc6IG1hdGNoIGFsbCBvY2N1cnJlbmNlcyBpbnN0ZWFkIG9mIGp1c3QgdGhlIGZpcnN0IG9uZS4gdTogc3VwcG9ydCA0LWJ5dGUgdW5pY29kZSBjaGFyYWN0ZXJzIHRvby5cclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJfbmFtZXMgPSB2YXJpYWJsZS5nZXRQYXJhbWV0ZXJOYW1lcygpO1xyXG4gICAgICAgIGxldCBhcmd1bWVudF9tYXRjaGVzOiBSZWdFeHBFeGVjQXJyYXk7IC8vIE5lZWQgdG8gcHJlZml4IHdpdGggXyBiZWNhdXNlIEphdmFTY3JpcHQgcmVzZXJ2ZXMgdGhlIHZhcmlhYmxlIG5hbWUgJ2FyZ3VtZW50cycuXHJcbiAgICAgICAgd2hpbGUgKChhcmd1bWVudF9tYXRjaGVzID0gcGF0dGVybi5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhcmlhYmxlIGRvZXMgbm90IGNvbnRhaW4gb2xkIGFyZ3VtZW50cyBvciBvbGQgZXJyb3IgbWVzc2FnZXMuIE5lZWRlZCBiZWNhdXNlIHZhcmlhYmxlIGluc3RhbmNlcyBhcmUgcmV1c2VkIGJldHdlZW4gcGFyc2luZyBjYWxscy5cclxuICAgICAgICAgICAgdmFyaWFibGUucmVzZXQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IGhvdyBtYW55IHRpbWVzIGFueSB2YXJpYWJsZXMgaGF2ZSBhcHBlYXJlZC5cclxuICAgICAgICAgICAgcGFyc2luZ19yZXN1bHQuY291bnRfcGFyc2VkX3ZhcmlhYmxlcysrO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0dWZmIHRoYXQgc2hvdWxkIG5vdCBiZSBpdGVyYXRlZCBpbiBhIGxhdGVyIGxvb3AuXHJcbiAgICAgICAgICAgIGNvbnN0IF9hcmd1bWVudHMgPSBhcmd1bWVudF9tYXRjaGVzLmZpbHRlcigodmFsdWU6IHVua25vd24gLyogV29uJ3QgYmUgdXNlZCAqLywga2V5OiB1bmtub3duKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIiA9PT0gdHlwZW9mIGtleTtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbGVhdmVzIG91dCBmb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIG5vbi1udW1lcmljIGtleXMgKGFuZCB0aGVpciB2YWx1ZXMpOlxyXG4gICAgICAgICAgICAgICAgLy8gLSBcImdyb3Vwc1wiXHJcbiAgICAgICAgICAgICAgICAvLyAtIFwiaW5kZXhcIlxyXG4gICAgICAgICAgICAgICAgLy8gLSBcImlucHV0XCJcclxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBmdXR1cmUsIHRoZXJlIGNhbiBhbHNvIGNvbWUgbW9yZSBlbGVtZW50cyB0aGF0IHdpbGwgYmUgc2tpcHBlZC4gRS5nLiBcImluZGljZXNcIi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm90aGluZ2lzbG9zdC9vYnNpZGlhbi1keW5hbWljLWhpZ2hsaWdodHMvaXNzdWVzLzI1I2lzc3VlY29tbWVudC0xMDM4NTYzOTkwIChyZWZlcmVuY2VkIDIwMjItMDItMjIpLlxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUge3t2YXJpYWJsZX19IHN0cmluZyB0aGF0IHdpbGwgYmUgc3Vic3RpdHV0ZWQgKD0gcmVwbGFjZWQgd2l0aCB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSkuXHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnN0aXR1dGUgPSBfYXJndW1lbnRzLnNoaWZ0KCk7IC8vICdfYXJndW1lbnRzWzBdJyBjb250YWlucyB0aGUgd2hvbGUgbWF0Y2gsIG5vdCBqdXN0IGFuIGFyZ3VtZW50LiBHZXQgaXQgYW5kIHJlbW92ZSBpdCBmcm9tICdfYXJndW1lbnRzJy5cclxuXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgYWxsIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gX2FyZ3VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnQgaXMgbm90IG9taXR0ZWQuIEl0IGNhbiBiZSBvbWl0dGVkICg9IHVuZGVmaW5lZCksIGlmIHRoZSBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuXHJcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBfYXJndW1lbnRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50IGlzIHByZXNlbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJndW1lbnQgPSBfYXJndW1lbnRzW2ldLnNsaWNlKDEpOyAvLyAuc2xpY2UoMSk6IFJlbW92ZSBhIHByZWNlZGluZyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyX25hbWUgPSBwYXJhbWV0ZXJfbmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0QXJndW1lbnQocGFyYW1ldGVyX25hbWUsIGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2hvdWxkIHRoZSB2YXJpYWJsZSdzIHZhbHVlIGJlIGVzY2FwZWQ/IChVc3VhbGx5IHllcykuXHJcbiAgICAgICAgICAgIGxldCBlc2NhcGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoXCJ7eyFcIiA9PT0gc3Vic3RpdHV0ZS5zbGljZSgwLCAzKSkgeyAvLyAuc2xpY2UoMCwgMykgPSBnZXQgY2hhcmFjdGVycyAwLi4uMiwgc28gc3RvcCBiZWZvcmUgMy4gVGhlICdlbmQnIHBhcmFtZXRlciBpcyBjb25mdXNpbmcuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdmFyaWFibGUgdXNhZ2UgYmVnaW5zIHdpdGgge3shIGluc3RlYWQgb2Yge3tcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIHZhcmlhYmxlJ3MgdmFsdWUgc2hvdWxkIE5PVCBiZSBlc2NhcGVkLlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFzaGVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRXNjYXBpbmcgaXMgZm9yY2VkIE9GRi5cclxuICAgICAgICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlX3ZhbHVlX3Jlc3VsdCA9IGF3YWl0IHZhcmlhYmxlLmdldFZhbHVlKFxyXG4gICAgICAgICAgICAgICAgdF9zaGVsbF9jb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgc2NfZXZlbnQsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVmaW5lIGEgcmVjdXJzaXZlIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gcGFyc2UgcG9zc2libGUgdmFyaWFibGVzIGluIGEgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgY3VycmVudCB2YXJpYWJsZS5cclxuICAgICAgICAgICAgICAgIChyYXdfZGVmYXVsdF92YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgcmVtb3ZpbmcgdGhlIGN1cnJlbnQgdmFyaWFibGUgZnJvbSB0aGUgc2V0IG9mIHBhcnNlYWJsZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGN1bXVsYXRlIGluIGRlZXAgbmVzdGVkIHBhcnNpbmc6IFBvc3NpYmxlIGRlZXBlciBwYXJzaW5nIHJvdW5kcyB3aWxsIGFsd2F5cyBoYXZlIG5hcnJvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5hcnJvd2VyIHNldHMgb2YgdmFyaWFibGVzIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZHVjZWRfdmFyaWFibGVzID0gcmVtb3ZlRnJvbVNldCh2YXJpYWJsZXMsIHZhcmlhYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VWYXJpYWJsZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3X2RlZmF1bHRfdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIC8vIERpc2FibGUgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGF0IHRoaXMgcGhhc2UgdG8gYXZvaWQgZG91YmxlIGVzY2FwaW5nLCBhcyBlc2NhcGluZyB3aWxsIGJlIGRvbmUgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NfZXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZWRfdmFyaWFibGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdfdmFsdWVfYXVnbWVudGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkX3ZhbHVlX2F1Z21lbnRlcixcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBtb2RpZmljYXRpb24gb2YgdGhlIHJhdyB2YWx1ZS5cclxuICAgICAgICAgICAgaWYgKHJhd192YWx1ZV9hdWdtZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBhdWdtZW50ZXIgY2FuIG1vZGlmeSB0aGUgY29udGVudCBvZiB0aGUgdmFyaWFibGVfdmFsdWVfcmVzdWx0IG9iamVjdC5cclxuICAgICAgICAgICAgICAgIHJhd192YWx1ZV9hdWdtZW50ZXIodmFyaWFibGUsIHZhcmlhYmxlX3ZhbHVlX3Jlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmF3X3ZhcmlhYmxlX3ZhbHVlID0gdmFyaWFibGVfdmFsdWVfcmVzdWx0LnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgcG9zc2libGUgZXJyb3IgbWVzc2FnZXMgdGhhdCBtaWdodCBoYXZlIGNvbWUgZnJvbSByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZV92YWx1ZV9yZXN1bHQuc3VjY2VlZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzaW5nIHdhcyBvay5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFc2NhcGUgdGhlIHZhbHVlIGlmIG5lZWRlZC5cclxuICAgICAgICAgICAgICAgIGxldCB1c2VfdmFyaWFibGVfdmFsdWU6IHN0cmluZztcclxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYW4gZXNjYXBlZCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICB1c2VfdmFyaWFibGVfdmFsdWUgPSBlc2NhcGVWYWx1ZShzaGVsbCwgcmF3X3ZhcmlhYmxlX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gZXNjYXBpbmcgaXMgd2FudGVkLCBzbyB1c2UgdGhlIHJhdyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICB1c2VfdmFyaWFibGVfdmFsdWUgPSByYXdfdmFyaWFibGVfdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXVnbWVudCB0aGUgZXNjYXBlZCB2YWx1ZSwgaWYgd2FudGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRfdmFsdWVfYXVnbWVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlX3ZhcmlhYmxlX3ZhbHVlID0gZXNjYXBlZF92YWx1ZV9hdWdtZW50ZXIodmFyaWFibGUsIHVzZV92YXJpYWJsZV92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdmFyaWFibGUgbmFtZSB3aXRoIHRoZSB2YXJpYWJsZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIHBhcnNpbmdfcmVzdWx0LnBhcnNlZF9jb250ZW50ID0gcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQucmVwbGFjZShzdWJzdGl0dXRlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gdGhlIHJlcGxhY2luZyBpbiBhIGZ1bmN0aW9uIGluIG9yZGVyIHRvIGF2b2lkIGEgcG9zc2libGUgJCBjaGFyYWN0ZXIgdG8gYmUgaW50ZXJwcmV0ZWQgYnkgSmF2YVNjcmlwdCB0byBpbnRlcmFjdCB3aXRoIHRoZSByZWdleC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZSNzcGVjaWZ5aW5nX2Ffc3RyaW5nX2FzX2FfcGFyYW1ldGVyIChyZWZlcmVuY2VkIDIwMjEtMTEtMDIuKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VfdmFyaWFibGVfdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGhhcyBiZWVuIHByb2JsZW0ocykgd2l0aCB0aGlzIHZhcmlhYmxlLlxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJwYXJzZVZhcmlhYmxlcygpOiBQYXJzaW5nIGNvbnRlbnQgXCIgKyBjb250ZW50ICsgXCIgZmFpbGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIHBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMgPSB2YXJpYWJsZV92YWx1ZV9yZXN1bHQuZXJyb3JfbWVzc2FnZXM7IC8vIFJldHVybmluZyBub3cgcHJldmVudHMgcGFyc2luZyByZXN0IG9mIHRoZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2luZ19yZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWJ1Z0xvZyhcInBhcnNlVmFyaWFibGVzKCk6IFBhcnNpbmcgY29udGVudCBcIiArIGNvbnRlbnQgKyBcIiBzdWNjZWVkZWQuXCIpO1xyXG4gICAgcGFyc2luZ19yZXN1bHQuc3VjY2VlZGVkID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJzaW5nX3Jlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGFsbCB2YXJpYWJsZXMgZnJvbSB0aGUgY29udGVudCBzdHJpbmcsIGFuZCByZXR1cm5zIGEgVmFyaWFibGVTZXQgY29udGFpbmluZyBhbGwgdGhlIGZvdW5kIHZhcmlhYmxlcy5cclxuICpcclxuICogVGhpcyBpcyBuZWVkZWQgaW4gc2l0dWF0aW9ucyB3aGVyZSB2YXJpYWJsZXMgd2lsbCBub3QgYmUgcGFyc2VkICg9IHZhcmlhYmxlIHZhbHVlcyBhcmUgbm90IG5lZWRlZCksIGJ1dCB3aGVyZSBpdCdzIGp1c3RcclxuICogbmVlZGVkIHRvIGtub3cgd2hhdCB2YXJpYWJsZXMgZS5nLiBhIHNoZWxsIGNvbW1hbmQgcmVsaWVzIG9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBwYXJhbSBjb250ZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlZFZhcmlhYmxlcyhcclxuICAgICAgICBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBjb250ZW50OiBzdHJpbmcsXHJcbiAgICApOiBWYXJpYWJsZVNldCB7XHJcbiAgICBjb25zdCBzZWFyY2hfZm9yX3ZhcmlhYmxlczogVmFyaWFibGVTZXQgPSBwbHVnaW4uZ2V0VmFyaWFibGVzKClcclxuICAgIGNvbnN0IGZvdW5kX3ZhcmlhYmxlcyA9IG5ldyBWYXJpYWJsZVNldCgpO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHNlYXJjaF9mb3JfdmFyaWFibGVzKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHZhcmlhYmxlLmdldFBhdHRlcm4oKSwgXCJpZ3VcIik7IC8vIGk6IGNhc2UtaW5zZW5zaXRpdmU7IGc6IG1hdGNoIGFsbCBvY2N1cnJlbmNlcyBpbnN0ZWFkIG9mIGp1c3QgdGhlIGZpcnN0IG9uZS4gdTogc3VwcG9ydCA0LWJ5dGUgdW5pY29kZSBjaGFyYWN0ZXJzIHRvby5cclxuICAgICAgICBpZiAocGF0dGVybi5leGVjKGNvbnRlbnQpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgdmFyaWFibGUgd2FzIGZvdW5kLlxyXG4gICAgICAgICAgICBmb3VuZF92YXJpYWJsZXMuYWRkKHZhcmlhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvdW5kX3ZhcmlhYmxlcztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYXJzaW5nUmVzdWx0IHtcclxuICAgIG9yaWdpbmFsX2NvbnRlbnQ6IHN0cmluZztcclxuICAgIHBhcnNlZF9jb250ZW50OiBzdHJpbmc7XHJcbiAgICBzdWNjZWVkZWQ6IGJvb2xlYW47XHJcbiAgICBlcnJvcl9tZXNzYWdlczogc3RyaW5nW107XHJcbiAgICBjb3VudF9wYXJzZWRfdmFyaWFibGVzOiBudW1iZXI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7QXBwfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7XHJcbiAgICBPdXRwdXRIYW5kbGluZ01vZGUsXHJcbiAgICBPdXRwdXRTdHJlYW0sXHJcbn0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbENvZGVcIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uL0RlYnVnXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCwgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtqb2luT2JqZWN0UHJvcGVydGllc30gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX091dHB1dH0gZnJvbSBcIi4uL3ZhcmlhYmxlcy9WYXJpYWJsZV9PdXRwdXRcIjtcclxuaW1wb3J0IHtwYXJzZVZhcmlhYmxlc30gZnJvbSBcIi4uL3ZhcmlhYmxlcy9wYXJzZVZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge1ZhcmlhYmxlU2V0fSBmcm9tIFwiLi4vdmFyaWFibGVzL2xvYWRWYXJpYWJsZXNcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPdXRwdXRDaGFubmVsIHtcclxuXHJcbiAgICAvLyBDbGFzcyBzcGVjaWZpYyBwcm9wZXJ0aWVzXHJcbiAgICAvKipcclxuICAgICAqIEh1bWFuIHJlYWRhYmxlIG5hbWUsIHVzZWQgaW4gc2V0dGluZ3MuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgYWNjZXB0ZWRfb3V0cHV0X3N0cmVhbXM6IE91dHB1dFN0cmVhbVtdID0gW1wic3Rkb3V0XCIsIFwic3RkZXJyXCJdO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBhY2NlcHRzX2VtcHR5X291dHB1dDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgb3V0cHV0IGNoYW5uZWwgd2FudHMgdG8gaGFuZGxlIGEgdW5pZmllZCBvdXRwdXQgb3Igbm90LiBJZiB5ZXMsIHRoaXMgcHJvcGVydHkgc2hvdWxkIGRlZmluZSBhXHJcbiAgICAgKiBkZWxpbWl0ZXIgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGEgZ2x1ZSBiZXR3ZWVuIGRpZmZlcmVudCBvdXRwdXQgc3RyZWFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgY29tYmluZV9vdXRwdXRfc3RyZWFtczogZmFsc2UgfCBzdHJpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgaW4gT3V0cHV0TW9kYWwgdG8gcmVkaXJlY3Qgb3V0cHV0IGJhc2VkIG9uIGhvdGtleXMuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBvdXRwdXQgY2hhbm5lbCBpcyBjb21wbGV0ZWx5XHJcbiAgICAgKiBleGNsdWRlZCBmcm9tIE91dHB1dE1vZGFsLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGhvdGtleV9sZXR0ZXI6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSBvdmVycmlkZGVuIGluIGNoaWxkIGNsYXNzZXMgaW4gb3JkZXIgdG8gdmFyeSB0aGUgdGl0bGUgZGVwZW5kaW5nIG9uIG91dHB1dF9zdHJlYW0uXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0X3N0cmVhbVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFRpdGxlKG91dHB1dF9zdHJlYW06IE91dHB1dFN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluc3RhbmNlIHNwZWNpZmljIHByb3BlcnRpZXNcclxuICAgIHByb3RlY3RlZCBhcHA6IEFwcDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwbHVnaW5cclxuICAgICAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmRcclxuICAgICAqIEBwYXJhbSBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0SGFuZGxpbmdNb2RlXHJcbiAgICAgKiBAcGFyYW0gcHJvY2Vzc1Rlcm1pbmF0b3IgV2lsbCBiZSBjYWxsZWQgaWYgdXNlciBkZWNpZGVzIHRvIGVuZCB0aGUgcHJvY2Vzcy4gU2V0IHRvIG51bGwgaWYgdGhlIHByb2Nlc3MgaGFzIGFscmVhZHkgZW5kZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcm90ZWN0ZWQgcGx1Z2luOiBTQ19QbHVnaW4sXHJcbiAgICAgICAgcHJvdGVjdGVkIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCxcclxuICAgICAgICBwcm90ZWN0ZWQgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCxcclxuICAgICAgICBwcm90ZWN0ZWQgb3V0cHV0SGFuZGxpbmdNb2RlOiBPdXRwdXRIYW5kbGluZ01vZGUsXHJcbiAgICAgICAgcHJvdGVjdGVkIHByb2Nlc3NUZXJtaW5hdG9yOiAoKCkgPT4gdm9pZCkgfCBudWxsLFxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIGNsYXNzZXMgY2FuIGRvIGhlcmUgaW5pdGlhbGl6YXRpb25zIHRoYXQgYXJlIGNvbW1vbiB0byBib3RoIGhhbmRsZUJ1ZmZlcmVkKCkgYW5kIGhhbmRsZVJlYWx0aW1lKCkuXHJcbiAgICAgKlxyXG4gICAgICogSW5pdHMgY291bGQgYmUgZG9uZSBpbiBjb250cnVjdG9yKCksIHRvbywgYnV0IHRoaXMgaXMgY2xlYW5lciAtIG5vIG5lZWQgdG8gZGVhbCB3aXRoIHBhcmFtZXRlcnMgYW5kIG5vIG5lZWQgZm9yIGEgc3VwZXIoKVxyXG4gICAgICogY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgYnkgZGVmYXVsdC5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvdXRwdXQgU3ViY2xhc3NlcyBzaG91bGQgZGVmaW5lIHRoaXMgYXMgc3RyaW5nLCBpZiB0aGV5IGVuYWJsZSAnY29tYmluZV9vdXRwdXRfc3RyZWFtcycuIE90aGVyd2lzZSwgdGhleSBzaG91bGQgZGVmaW5lIHRoaXMgYXMgT3V0cHV0U3RyZWFtcy5cclxuICAgICAqIEBwYXJhbSBlcnJvcl9jb2RlXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBfaGFuZGxlQnVmZmVyZWQob3V0cHV0OiBPdXRwdXRTdHJlYW1zIHwgc3RyaW5nLCBlcnJvcl9jb2RlOiBudW1iZXIgfCBudWxsKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgaGFuZGxlQnVmZmVyZWQob3V0cHV0OiBPdXRwdXRTdHJlYW1zLCBlcnJvcl9jb2RlOiBudW1iZXIgfCBudWxsLCBlbmFibGVPdXRwdXRXcmFwcGluZyA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVIYW5kbGluZ01vZGUoXCJidWZmZXJlZFwiKTtcclxuXHJcbiAgICAgICAgLy8gUXVhbGlmeSBvdXRwdXRcclxuICAgICAgICBpZiAoT3V0cHV0Q2hhbm5lbC5pc091dHB1dEVtcHR5KG91dHB1dCkpIHtcclxuICAgICAgICAgICAgLy8gVGhlIG91dHB1dCBpcyBlbXB0eVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGljKCkuYWNjZXB0c19lbXB0eV9vdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgT3V0cHV0Q2hhbm5lbCBkb2VzIG5vdCBhY2NlcHQgZW1wdHkgb3V0cHV0LCBpLmUuIGVtcHR5IG91dHB1dCBzaG91bGQgYmUganVzdCBpZ25vcmVkLlxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2codGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCIuaGFuZGxlQnVmZmVyZWQoKTogSWdub3JpbmcgZW1wdHkgb3V0cHV0LlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZWJ1Z0xvZyh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5oYW5kbGVCdWZmZXJlZCgpOiBIYW5kbGluZyBvdXRwdXQuLi5cIik7XHJcblxyXG4gICAgICAgIC8vIE91dHB1dCBpcyBvay5cclxuICAgICAgICAvLyBIYW5kbGUgaXQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlQnVmZmVyZWQoYXdhaXQgdGhpcy5wcmVwYXJlX291dHB1dChvdXRwdXQsIGVuYWJsZU91dHB1dFdyYXBwaW5nKSwgZXJyb3JfY29kZSk7XHJcbiAgICAgICAgZGVidWdMb2coXCJPdXRwdXQgaGFuZGxpbmcgaXMgZG9uZS5cIilcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2hhbmRsZVJlYWx0aW1lKG91dHB1dENvbnRlbnQ6IHN0cmluZywgb3V0cHV0U3RyZWFtTmFtZTogT3V0cHV0U3RyZWFtKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvdXRwdXRTdHJlYW1OYW1lXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0Q29udGVudFxyXG4gICAgICogQHBhcmFtIGVuYWJsZU91dHB1dFdyYXBwaW5nIE5vIGNhbGxlciBhY3R1YWxseSBzZXRzIHRoaXMgdG8gZmFsc2UgYXQgdGhlIG1vbWVudCwgdW5saWtlIHRoZSBoYW5kbGVCdWZmZXJlZCgpIG1ldGhvZCdzIGNvdW50ZXJwYXJ0LiBCdXQgaGF2ZSB0aGlzIGp1c3QgaW4gY2FzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGhhbmRsZVJlYWx0aW1lKG91dHB1dFN0cmVhbU5hbWU6IE91dHB1dFN0cmVhbSwgb3V0cHV0Q29udGVudDogc3RyaW5nLCBlbmFibGVPdXRwdXRXcmFwcGluZyA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVIYW5kbGluZ01vZGUoXCJyZWFsdGltZVwiKTtcclxuXHJcbiAgICAgICAgLy8gUXVhbGlmeSBvdXRwdXRcclxuICAgICAgICBpZiAoXCJcIiA9PT0gb3V0cHV0Q29udGVudCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgb3V0cHV0IGlzIGVtcHR5XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0aWMoKS5hY2NlcHRzX2VtcHR5X291dHB1dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBPdXRwdXRDaGFubmVsIGRvZXMgbm90IGFjY2VwdCBlbXB0eSBvdXRwdXQsIGkuZS4gZW1wdHkgb3V0cHV0IHNob3VsZCBiZSBqdXN0IGlnbm9yZWQuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5oYW5kbGVSZWFsdGltZSgpOiBJZ25vcmluZyBlbXB0eSBvdXRwdXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlYnVnTG9nKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiLmhhbmRsZVJlYWx0aW1lKCk6IEhhbmRsaW5nIG91dHB1dC4uLlwiKTtcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0IGlzIG9rLlxyXG5cclxuICAgICAgICAvLyBJZiBhbGxvd2VkLCB3cmFwIHRoZSBvdXRwdXQgd2l0aCBvdXRwdXQgd3JhcHBlciB0ZXh0LlxyXG4gICAgICAgIGlmIChlbmFibGVPdXRwdXRXcmFwcGluZykge1xyXG4gICAgICAgICAgICAvLyBXcmFwIG91dHB1dCAoYnV0IG9ubHkgaWYgYSB3cmFwcGVyIGlzIGRlZmluZWQpXHJcbiAgICAgICAgICAgIG91dHB1dENvbnRlbnQgPSBhd2FpdCB0aGlzLndyYXBPdXRwdXQob3V0cHV0U3RyZWFtTmFtZSwgb3V0cHV0Q29udGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgaXQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlUmVhbHRpbWUob3V0cHV0Q29udGVudCwgb3V0cHV0U3RyZWFtTmFtZSk7XHJcblxyXG4gICAgICAgIGRlYnVnTG9nKFwiT3V0cHV0IGhhbmRsaW5nIGlzIGRvbmUuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZW5kUmVhbHRpbWUoZXhpdENvZGU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgYnkgZGVmYXVsdC5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYSBzaGVsbCBjb21tYW5kIGlzIGV4ZWN1dGVkIGluIFwicmVhbHRpbWVcIiBtb2RlLCBhIHNlcGFyYXRlIGVuZGluZyBjYWxsIHNob3VsZCBiZSBtYWRlIGluIG9yZGVyIHRvIHBhc3MgYW5cclxuICAgICAqIGV4aXQgY29kZSB0byB0aGUgT3V0cHV0Q2hhbm5lbC4gU29tZSBPdXRwdXRDaGFubmVscyBkaXNwbGF5IHRoZSBjb2RlIHRvIHVzZXIsIGJ1dCBtb3N0IGRvIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXhpdENvZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuZFJlYWx0aW1lKGV4aXRDb2RlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVIYW5kbGluZ01vZGUoXCJyZWFsdGltZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZW5kUmVhbHRpbWUoZXhpdENvZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVxdWlyZUhhbmRsaW5nTW9kZShyZXF1aXJlZE1vZGU6IE91dHB1dEhhbmRsaW5nTW9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dEhhbmRsaW5nTW9kZSAhPT0gcmVxdWlyZWRNb2RlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoaXMub3V0cHV0SGFuZGxpbmdNb2RlIG11c3QgYmUgJ1wiK3JlcXVpcmVkTW9kZStcIicuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFjY2VwdHNPdXRwdXRTdHJlYW0ob3V0cHV0X3N0cmVhbTogT3V0cHV0U3RyZWFtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRfb3V0cHV0X3N0cmVhbXMuY29udGFpbnMob3V0cHV0X3N0cmVhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIHRoZSBmb2xsb3dpbmcgcHJlcGFyYXRpb25zOlxyXG4gICAgICogIC0gQ29tYmluZXMgb3V0cHV0IHN0cmVhbXMgKGlmIHdhbnRlZCBieSB0aGUgT3V0cHV0Q2hhbm5lbCkuXHJcbiAgICAgKiAgLSBXcmFwcyBvdXRwdXQgKGlmIGRlZmluZWQgaW4gc2hlbGwgY29tbWFuZCBjb25maWd1cmF0aW9uKS5cclxuICAgICAqIEBwYXJhbSBvdXRwdXRfc3RyZWFtc1xyXG4gICAgICogQHBhcmFtIGVuYWJsZU91dHB1dFdyYXBwaW5nXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIHByZXBhcmVfb3V0cHV0KG91dHB1dF9zdHJlYW1zOiBPdXRwdXRTdHJlYW1zLCBlbmFibGVPdXRwdXRXcmFwcGluZzogYm9vbGVhbik6IFByb21pc2U8T3V0cHV0U3RyZWFtcyB8IHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHdyYXBPdXRwdXRJZkVuYWJsZWQgPSBhc3luYyAob3V0cHV0U3RyZWFtTmFtZTogT3V0cHV0U3RyZWFtLCBvdXRwdXRDb250ZW50OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZU91dHB1dFdyYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXcmFwIG91dHB1dCBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud3JhcE91dHB1dChvdXRwdXRTdHJlYW1OYW1lLCBvdXRwdXRDb250ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFdyYXBwaW5nIGlzIGRpc2FibGVkLCByZXR1cm4gdW5tb2RpZmllZCBvdXRwdXQgY29udGVudC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRDb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgd3JhcF9vdXRwdXRzX3NlcGFyYXRlbHkgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRfb3V0cHV0X3N0cmVhbXM6IE91dHB1dFN0cmVhbXMgPSB7fTtcclxuICAgICAgICAgICAgbGV0IG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtO1xyXG4gICAgICAgICAgICBmb3IgKG91dHB1dF9zdHJlYW1fbmFtZSBpbiBvdXRwdXRfc3RyZWFtcykge1xyXG4gICAgICAgICAgICAgICAgd3JhcHBlZF9vdXRwdXRfc3RyZWFtc1tvdXRwdXRfc3RyZWFtX25hbWVdID0gYXdhaXQgd3JhcE91dHB1dElmRW5hYmxlZChcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfc3RyZWFtX25hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3N0cmVhbXNbb3V0cHV0X3N0cmVhbV9uYW1lXSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRfb3V0cHV0X3N0cmVhbXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgb3V0cHV0cyBzaG91bGQgYmUgY29tYmluZWQuXHJcbiAgICAgICAgY29uc3QgY29tYmluZU91dHB1dFN0cmVhbXMgPSB0aGlzLnN0YXRpYygpLmNvbWJpbmVfb3V0cHV0X3N0cmVhbXM7XHJcbiAgICAgICAgaWYgKGNvbWJpbmVPdXRwdXRTdHJlYW1zKSB7XHJcbiAgICAgICAgICAgIC8vIENvbWJpbmUgb3V0cHV0IHN0cmluZ3MgaW50byBhIHNpbmdsZSBzdHJpbmcuXHJcblxyXG4gICAgICAgICAgICAvLyBDYW4gb3V0cHV0IHdyYXBwaW5nIGJlIGNvbWJpbmVkP1xyXG4gICAgICAgICAgICBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQuaXNPdXRwdXRXcmFwcGVyU3Rkb3V0U2FtZUFzU3RkZXJyKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE91dHB1dCB3cmFwcGluZyBjYW4gYmUgY29tYmluZWQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgd3JhcE91dHB1dElmRW5hYmxlZChcclxuICAgICAgICAgICAgICAgICAgICBcInN0ZG91dFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5PYmplY3RQcm9wZXJ0aWVzKG91dHB1dF9zdHJlYW1zLCBjb21iaW5lT3V0cHV0U3RyZWFtcyksIC8vIFVzZSBjb21iaW5lT3V0cHV0U3RyZWFtcyBhcyBhIGdsdWUgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE91dHB1dCB3cmFwcGluZyBuZWVkcyB0byBiZSBkb25lIHNlcGFyYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVkX291dHB1dF9zdHJlYW1zID0gYXdhaXQgd3JhcF9vdXRwdXRzX3NlcGFyYXRlbHkoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luT2JqZWN0UHJvcGVydGllcyh3cmFwcGVkX291dHB1dF9zdHJlYW1zLCBjb21iaW5lT3V0cHV0U3RyZWFtcyk7IC8vIFVzZSBjb21iaW5lT3V0cHV0U3RyZWFtcyBhcyBhIGdsdWUgc3RyaW5nLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBjb21iaW5lLCBoYW5kbGUgZWFjaCBzdHJlYW0gc2VwYXJhdGVseVxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgd3JhcF9vdXRwdXRzX3NlcGFyYXRlbHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdXJyb3VuZHMgdGhlIGdpdmVuIG91dHB1dCB0ZXh0IHdpdGggYW4gb3V0cHV0IHdyYXBwZXIuIElmIG5vIG91dHB1dCB3cmFwcGVyIGlzIGRlZmluZWQsIHJldHVybnMgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBvdXRwdXQgdGV4dCB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIHdyYXBPdXRwdXQob3V0cHV0X3N0cmVhbTogT3V0cHV0U3RyZWFtLCBvdXRwdXRfY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHByZXBhcnNlZCBvdXRwdXQgd3JhcHBlciBjb250ZW50LiBJdCBoYXMgYWxsIG90aGVyIHZhcmlhYmxlcyBwYXJzZWQsIGV4Y2VwdCB7e291dHB1dH19LlxyXG4gICAgICAgIGNvbnN0IHBhcnNpbmdfcmVzdWx0X2tleToga2V5b2YgU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCA9IFwib3V0cHV0X3dyYXBwZXJfXCIrb3V0cHV0X3N0cmVhbSBhcyBrZXlvZiBTaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0O1xyXG4gICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyX2NvbnRlbnQgPSB0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHRbcGFyc2luZ19yZXN1bHRfa2V5XSBhcyBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIG91dHB1dCB3cmFwcGVyIGNvbnRlbnQgZXhpc3RzLlxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG91dHB1dF93cmFwcGVyX2NvbnRlbnQpIHtcclxuICAgICAgICAgICAgLy8gTm8gT3V0cHV0V3JhcHBlciBpcyBkZWZpbmVkIGZvciB0aGlzIHNoZWxsIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgb3V0cHV0IHRleHQgd2l0aG91dCBtb2RpZmljYXRpb25zLlxyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIk91dHB1dCB3cmFwcGluZzogTm8gd3JhcHBlciBpcyBkZWZpbmVkIGZvciAnXCIgKyBvdXRwdXRfc3RyZWFtICsgXCInLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dF9jb250ZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIHt7b3V0cHV0fX0gdmFyaWFibGVcclxuICAgICAgICBjb25zdCBvdXRwdXRfdmFyaWFibGUgPSBuZXcgVmFyaWFibGVfT3V0cHV0KHRoaXMucGx1Z2luLCBvdXRwdXRfY29udGVudCk7XHJcbiAgICAgICAgY29uc3QgcGFyc2luZ19yZXN1bHQgPSBhd2FpdCBwYXJzZVZhcmlhYmxlcyhcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgICAgIG91dHB1dF93cmFwcGVyX2NvbnRlbnQsXHJcbiAgICAgICAgICAgIG51bGwsIC8vIE5vIHNoZWxsIGFueW1vcmUsIHNvIG5vIG5lZWQgZm9yIGVzY2FwaW5nLlxyXG4gICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgbnVsbCwgLy8gTm8gc3VwcG9ydCBmb3Ige3tldmVudF8qfX0gdmFyaWFibGVzIGlzIG5lZWRlZCwgYmVjYXVzZSB0aGV5IGFyZSBhbHJlYWR5IHBhcnNlZCBpbiBvdXRwdXRfd3JhcHBlcl9jb250ZW50LiBUaGlzIHBoYXNlIG9ubHkgcGFyc2VzIHt7b3V0cHV0fX0gdmFyaWFibGUsIG5vdGhpbmcgZWxzZS5cclxuICAgICAgICAgICAgbmV3IFZhcmlhYmxlU2V0KFtvdXRwdXRfdmFyaWFibGVdKSwgLy8gT25seSBwYXJzZSB0aGUge3tvdXRwdXR9fSB2YXJpYWJsZS5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBJbnNwZWN0IHRoZSBwYXJzaW5nIHJlc3VsdC4gSXQgc2hvdWxkIGFsd2F5cyBzdWNjZWVkLCBhcyB0aGUge3tvdXRwdXR9fSB2YXJpYWJsZSBzaG91bGQgbm90IGdpdmUgYW55IGVycm9ycy5cclxuICAgICAgICBpZiAocGFyc2luZ19yZXN1bHQuc3VjY2VlZGVkKSB7XHJcbiAgICAgICAgICAgIC8vIFN1Y2NlZWRlZC5cclxuICAgICAgICAgICAgZGVidWdMb2coXCJPdXRwdXQgd3JhcHBpbmc6IFdyYXBwaW5nIFwiICsgb3V0cHV0X3N0cmVhbSArIFwiIHN1Y2NlZWRlZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzaW5nX3Jlc3VsdC5wYXJzZWRfY29udGVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGYWlsZWQgZm9yIHNvbWUgcmVhc29uLlxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihcIk91dHB1dCB3cmFwcGluZyBmYWlsZWQsIHNlZSBlcnJvcihzKSBiZWxvdy5cIik7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9ycyhwYXJzaW5nX3Jlc3VsdC5lcnJvcl9tZXNzYWdlcyk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dHB1dCB3cmFwcGluZyBmYWlsZWQ6IFBhcnNpbmcge3tvdXRwdXR9fSByZXN1bHRlZCBpbiBlcnJvcihzKTogXCIgKyBwYXJzaW5nX3Jlc3VsdC5lcnJvcl9tZXNzYWdlcy5qb2luKFwiIFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIG1vdmVkIHRvIGEgZ2xvYmFsIGZ1bmN0aW9uIGlzT3V0cHV0U3RyZWFtRW1wdHkoKSBpZiBuZWVkZWQuXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpc091dHB1dEVtcHR5KG91dHB1dDogT3V0cHV0U3RyZWFtcykge1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IG91dHB1dC5zdGRlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkID09PSBvdXRwdXQuc3Rkb3V0IHx8IFwiXCIgPT09IG91dHB1dC5zdGRvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgT3V0cHV0Q2hhbm5lbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPdXRwdXRDaGFubmVscyB7XHJcbiAgICBzdGRvdXQ/OiBPdXRwdXRDaGFubmVsLFxyXG4gICAgc3RkZXJyPzogT3V0cHV0Q2hhbm5lbCxcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbH0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbFwiO1xyXG5pbXBvcnQge091dHB1dFN0cmVhbXN9IGZyb20gXCIuL091dHB1dENoYW5uZWxGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW19IGZyb20gXCIuL091dHB1dENoYW5uZWxDb2RlXCI7XHJcbmltcG9ydCB7Tm90aWNlfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbF9Ob3RpZmljYXRpb24gZXh0ZW5kcyBPdXRwdXRDaGFubmVsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCByZWNlaXZlZCBvdXRwdXQgY3VtdWxhdGl2ZWx5LiBTdWJzZXF1ZW50IGhhbmRsaW5ncyB3aWxsIHRoZW4gdXNlIHRoZSB3aG9sZSBvdXRwdXQsIG5vdCBqdXN0IG5ldyBwYXJ0cy5cclxuICAgICAqIE9ubHkgdXNlZCBpbiBcInJlYWx0aW1lXCIgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYWx0aW1lQ29udGVudEJ1ZmZlciA9IFwiXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBhIE5vdGljZSBpbnN0YW5jZSBzbyB0aGF0IHRoZSBtZXNzYWdlIGNhbiBiZSB1cGRhdGVkIGR1cmluZyBzdWJzZXF1ZW50IGhhbmRsaW5ncy5cclxuICAgICAqIE9ubHkgdXNlZCBpbiBcInJlYWx0aW1lXCIgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYWx0aW1lTm90aWNlOiBOb3RpY2U7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFsdGltZU5vdGljZVRpbWVvdXQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZmxhZyBmb3IgaW5kaWNhdGluZyB0aGF0IGlmIGFueSBzdGRlcnIgb3V0cHV0IGhhcyBoYXBwZW5lZCwgYWxsIHN1YnNlcXVlbnQgaGFuZGxpbmdzIHNob3VsZCBmb3JtYXQgdGhlIG91dHB1dFxyXG4gICAgICogTm90aWNlIG1lc3NhZ2Ugd2l0aCBlcnJvciBmb3JtYXR0aW5nIChpLmUuIHNob3cgWy4uLl0gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWVzc2FnZSkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYWx0aW1lSGFzU3RkZXJyT2NjdXJyZWQgPSBmYWxzZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFRpdGxlKG91dHB1dF9zdHJlYW06IE91dHB1dFN0cmVhbSk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoIChvdXRwdXRfc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRvdXRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vdGlmaWNhdGlvbiBiYWxsb29uXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRlcnJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yIGJhbGxvb25cIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIF9oYW5kbGVCdWZmZXJlZChvdXRwdXQ6IE91dHB1dFN0cmVhbXMsIGVycm9yX2NvZGU6IG51bWJlciB8IG51bGwpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSBvdXRwdXQgc3RyZWFtcy5cclxuICAgICAgICAvLyBUaGVyZSBjYW4gYmUgYm90aCBcInN0ZG91dFwiIGFuZCBcInN0ZGVyclwiIHByZXNlbnQgYXQgdGhlIHNhbWUgdGltZSwgb3IganVzdCBvbmUgb2YgdGhlbS4gSWYgYm90aCBhcmUgcHJlc2VudCwgdHdvXHJcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgbGV0IG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtO1xyXG4gICAgICAgIGZvciAob3V0cHV0X3N0cmVhbV9uYW1lIGluIG91dHB1dCkge1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXRfbWVzc2FnZSA9IG91dHB1dFtvdXRwdXRfc3RyZWFtX25hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeShvdXRwdXRfc3RyZWFtX25hbWUsIG91dHB1dF9tZXNzYWdlLCBlcnJvcl9jb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIF9oYW5kbGVSZWFsdGltZShvdXRwdXRDb250ZW50OiBzdHJpbmcsIG91dHB1dFN0cmVhbU5hbWU6IE91dHB1dFN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgbmV3IGNvbnRlbnRcclxuICAgICAgICB0aGlzLnJlYWx0aW1lQ29udGVudEJ1ZmZlciArPSBvdXRwdXRDb250ZW50O1xyXG5cclxuICAgICAgICAvLyBSYWlzZSBhIGZsYWcgaWYgc2VlaW5nICdzdGRlcnInIG91dHB1dC5cclxuICAgICAgICBpZiAoXCJzdGRlcnJcIiA9PT0gb3V0cHV0U3RyZWFtTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lSGFzU3RkZXJyT2NjdXJyZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG9lcyBhIE5vdGljZSBleGlzdCBhbHJlYWR5P1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWx0aW1lTm90aWNlKSB7XHJcbiAgICAgICAgICAgIC8vIFJldXNlIGFuIGV4aXN0aW5nIE5vdGljZS5cclxuXHJcbiAgICAgICAgICAgIC8vIFNob3VsZCBvdXRwdXQgYmUgZm9ybWF0dGVkIGFzIGFuIGVycm9yIG1lc3NhZ2U/XHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVkTWVzc2FnZTogc3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZUhhc1N0ZGVyck9jY3VycmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBlcnJvciBmb3JtYXR0aW5nIHRvIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZE1lc3NhZ2UgPSBPdXRwdXRDaGFubmVsX05vdGlmaWNhdGlvbi5mb3JtYXRFcnJvck1lc3NhZ2UodGhpcy5yZWFsdGltZUNvbnRlbnRCdWZmZXIsIG51bGwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlIG91dHB1dCBhcy1pc1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZE1lc3NhZ2UgPSB0aGlzLnJlYWx0aW1lQ29udGVudEJ1ZmZlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSB1cGRhdGVkIG91dHB1dFxyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lTm90aWNlLnNldE1lc3NhZ2UodXBkYXRlZE1lc3NhZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIG5vdGljZSBoaWRpbmcgdGltZW91dFxyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVhbHRpbWVOb3RpY2VUaW1lb3V0KTsgLy8gUmVtb3ZlIG9sZCB0aW1lb3V0XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTm90aWZpY2F0aW9uSGlkaW5nKG91dHB1dFN0cmVhbU5hbWUpOyAvLyBBZGQgbmV3IHRpbWVvdXRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgTm90aWNlLlxyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lTm90aWNlID0gdGhpcy5ub3RpZnkoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lSGFzU3RkZXJyT2NjdXJyZWQgPyBcInN0ZGVyclwiIDogXCJzdGRvdXRcIixcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWVDb250ZW50QnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIDAsIC8vIFVzZSAwIHRpbWVvdXQgc28gdGhhdCB0aGUgTm90aWNlIHdvbid0IGhpZGUgYXV0b21hdGljYWxseS5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRpbWVvdXQgZm9yIGhpZGluZyB0aGUgTm90aWNlXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTm90aWZpY2F0aW9uSGlkaW5nKG91dHB1dFN0cmVhbU5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGVybWluYXRpbmcgYnV0dG9uXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBOb3RpY2Uubm90aWNlRWwgYmVsb25ncyB0byBPYnNpZGlhbidzIFBSSVZBVEUgQVBJLCBhbmQgaXQgbWF5IGNoYW5nZSB3aXRob3V0IGEgcHJpb3Igbm90aWNlLiBPbmx5XHJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBidXR0b24gaWYgbm90aWNlRWwgZXhpc3RzIGFuZCBpcyBhbiBIVE1MRWxlbWVudC5cclxuICAgICAgICBjb25zdCBub3RpY2VFbCA9IHRoaXMucmVhbHRpbWVOb3RpY2Uubm90aWNlRWw7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gbm90aWNlRWwgJiYgbm90aWNlRWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5jcmVhdGVSZXF1ZXN0VGVybWluYXRpbmdCdXR0b24obm90aWNlRWwsIHRoaXMucHJvY2Vzc1Rlcm1pbmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2VuZFJlYWx0aW1lKGV4aXRDb2RlOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGV4aXRDb2RlICE9PSAwIHx8IHRoaXMucmVhbHRpbWVIYXNTdGRlcnJPY2N1cnJlZCkge1xyXG4gICAgICAgICAgICAvLyBJZiBhIE5vdGljZSBleGlzdHMsIHVwZGF0ZSBpdCB3aXRoIHRoZSBleGl0Q29kZVxyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lTm90aWNlPy5zZXRNZXNzYWdlKE91dHB1dENoYW5uZWxfTm90aWZpY2F0aW9uLmZvcm1hdEVycm9yTWVzc2FnZShcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWVDb250ZW50QnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgZXhpdENvZGUsIC8vIElmIGV4aXRDb2RlIGlzIG51bGwsIGl0IG1lYW5zIHVzZXIgdGVybWluYXRlZCB0aGUgcHJvY2VzcywgYW5kIGl0IHdpbGwgc2hvdyB1cCBhcyBcIlsuLi5dXCIuIEl0J3Mgb2ssIGl0IGluZGljYXRlcyB0aGF0IG5vIGV4aXQgY29kZSB3YXMgcmVjZWl2ZWQuXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRlcm1pbmF0aW5nIGJ1dHRvblxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgTm90aWNlLm5vdGljZUVsIGJlbG9uZ3MgdG8gT2JzaWRpYW4ncyBQUklWQVRFIEFQSSwgYW5kIGl0IG1heSBjaGFuZ2Ugd2l0aG91dCBhIHByaW9yIG5vdGljZS4gT25seVxyXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgYnV0dG9uIGlmIG5vdGljZUVsIGV4aXN0cyBhbmQgaXMgYW4gSFRNTEVsZW1lbnQuXHJcbiAgICAgICAgY29uc3Qgbm90aWNlRWwgPSB0aGlzLnJlYWx0aW1lTm90aWNlPy5ub3RpY2VFbDtcclxuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBub3RpY2VFbCAmJiBub3RpY2VFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIG5vdGljZUVsLmZpbmQoXCIuU0MtaWNvbi10ZXJtaW5hdGUtcHJvY2Vzc1wiKT8ucmVtb3ZlKCk7IC8vID8gPSBPbmx5IHRyeSB0byByZW1vdmUgaWYgdGhlIGJ1dHRvbiBleGlzdHMuIEl0IGRvZXMgbm90IGV4aXN0IGlmIC5zZXRNZXNzYWdlKCkgd2FzIGNhbGxlZCBhYm92ZSBhcyBpdCBvdmVyd3JpdGVzIGFsbCBjb250ZW50IGluIHRoZSBOb3RpY2UuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdXRwdXRTdHJlYW1OYW1lXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0Q29udGVudFxyXG4gICAgICogQHBhcmFtIGV4aXRDb2RlXHJcbiAgICAgKiBAcGFyYW0gbm90aWNlVGltZW91dCBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgbm90aWNlL2Vycm9yIHRpbWVvdXQgc2V0dGluZy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbm90aWZ5KG91dHB1dFN0cmVhbU5hbWU6IE91dHB1dFN0cmVhbSwgb3V0cHV0Q29udGVudDogc3RyaW5nLCBleGl0Q29kZTogbnVtYmVyIHwgbnVsbCwgbm90aWNlVGltZW91dD86IG51bWJlcik6IE5vdGljZSB7XHJcbiAgICAgICAgc3dpdGNoIChvdXRwdXRTdHJlYW1OYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRvdXRcIjpcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBvdXRwdXRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24ob3V0cHV0Q29udGVudCwgbm90aWNlVGltZW91dCA/PyB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RkZXJyXCI6XHJcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBvdXRwdXRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5uZXdFcnJvcihPdXRwdXRDaGFubmVsX05vdGlmaWNhdGlvbi5mb3JtYXRFcnJvck1lc3NhZ2Uob3V0cHV0Q29udGVudCwgZXhpdENvZGUpLCBub3RpY2VUaW1lb3V0ID8/IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGZvcm1hdEVycm9yTWVzc2FnZShvdXRwdXRDb250ZW50OiBzdHJpbmcsIGV4aXRDb2RlOiBudW1iZXIgfCBudWxsKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAobnVsbCA9PT0gZXhpdENvZGUpIHtcclxuICAgICAgICAgICAgLy8gSWYgYSBcInJlYWx0aW1lXCIgcHJvY2VzcyBpcyBub3QgZmluaXNoZWQsIHRoZXJlIGlzIG5vIGV4aXQgY29kZSB5ZXQuXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgWWVhIEkga25vdyBcIi4uLlwiIGlzIG5vdCBhIG51bWJlciBub3IgbnVsbC4gOilcclxuICAgICAgICAgICAgZXhpdENvZGUgPSBcIi4uLlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBleGl0Q29kZSArIFwiXTogXCIgKyBvdXRwdXRDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlTm90aWZpY2F0aW9uSGlkaW5nKG91dHB1dFN0cmVhbU5hbWU6IE91dHB1dFN0cmVhbSkge1xyXG5cclxuICAgICAgICAvLyBIaWRlIGJ5IHRpbWVvdXRcclxuICAgICAgICBsZXQgbm9ybWFsVGltZW91dDogbnVtYmVyO1xyXG4gICAgICAgIHN3aXRjaCAob3V0cHV0U3RyZWFtTmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwic3Rkb3V0XCI6XHJcbiAgICAgICAgICAgICAgICBub3JtYWxUaW1lb3V0ID0gdGhpcy5wbHVnaW4uZ2V0Tm90aWZpY2F0aW9uTWVzc2FnZUR1cmF0aW9uTXMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RkZXJyXCI6XHJcbiAgICAgICAgICAgICAgICBub3JtYWxUaW1lb3V0ID0gdGhpcy5wbHVnaW4uZ2V0RXJyb3JNZXNzYWdlRHVyYXRpb25NcygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhbHRpbWVOb3RpY2VUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIE5vdGljZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZU5vdGljZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lTm90aWNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZU5vdGljZVRpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vcm1hbFRpbWVvdXQsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIE5vdGljZSdzIGNsaWNrIGV2ZW50LlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgTm90aWNlLm5vdGljZUVsIGJlbG9uZ3MgdG8gT2JzaWRpYW4ncyBQUklWQVRFIEFQSSwgYW5kIGl0IG1heSBjaGFuZ2Ugd2l0aG91dCBhIHByaW9yIG5vdGljZS4gT25seVxyXG4gICAgICAgIC8vIGRlZmluZSB0aGUgY2xpY2sgbGlzdGVuZXIgaWYgbm90aWNlRWwgZXhpc3RzIGFuZCBpcyBhbiBIVE1MRWxlbWVudC5cclxuICAgICAgICBjb25zdCBub3RpY2VFbCA9IHRoaXMucmVhbHRpbWVOb3RpY2Uubm90aWNlRWw7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gbm90aWNlRWwgJiYgbm90aWNlRWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBub3RpY2VFbC5vbkNsaWNrRXZlbnQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlYWx0aW1lTm90aWNlVGltZW91dCk7IC8vIE1ha2Ugc3VyZSB0aW1lb3V0IHdpbGwgbm90IGFjY2lkZW50YWxseSB0cnkgdG8gbGF0ZXIgaGlkZSBhbiBhbHJlYWR5IGhpZGRlbiBOb3RpZmljYXRpb24uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lTm90aWNlVGltZW91dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWVOb3RpY2UgPSB1bmRlZmluZWQ7IC8vIEdpdmUgYSBzaWduYWwgdG8gX2hhbmRsZVJlYWx0aW1lKCkgdGhhdCBpZiBuZXcgb3V0cHV0IGNvbWVzLCBhIG5ldyBOb3RpY2Ugc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbH0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbFwiO1xyXG5pbXBvcnQge2dldEVkaXRvciwgZ2V0Vmlld30gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0VkaXRvcn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE91dHB1dENoYW5uZWxfQ3VycmVudEZpbGUgZXh0ZW5kcyBPdXRwdXRDaGFubmVsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIGNhbiBiZSBib3RoIFwic3Rkb3V0XCIgYW5kIFwic3RkZXJyXCIgcHJlc2VudCBhdCB0aGUgc2FtZSB0aW1lLCBvciBqdXN0IG9uZSBvZiB0aGVtLiBJZiBib3RoIGFyZSBwcmVzZW50LCB0aGV5XHJcbiAgICAgKiB3aWxsIGJlIGpvaW5lZCB0b2dldGhlciB3aXRoIFwiIFwiIGFzIGEgc2VwYXJhdG9yLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGNvbWJpbmVfb3V0cHV0X3N0cmVhbXMgPSBcIiBcIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgX2hhbmRsZUJ1ZmZlcmVkKG91dHB1dENvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlKG91dHB1dENvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhc3luYyBfaGFuZGxlUmVhbHRpbWUob3V0cHV0Q29udGVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGUob3V0cHV0Q29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGUob3V0cHV0X21lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEVkaXRvcih0aGlzLmFwcCk7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFZpZXcodGhpcy5hcHApO1xyXG5cclxuICAgICAgICBpZiAobnVsbCA9PT0gZWRpdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBpdCdzIG5vdCBwb3NzaWJsZSB0byBnZXQgYW4gZWRpdG9yLlxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihcIkNvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlISBQbGVhc2UgY3JlYXRlIGEgZGlzY3Vzc2lvbiBpbiBHaXRIdWIuIFRoZSBjb21tYW5kIG91dHB1dCBpcyBpbiB0aGUgbmV4dCBlcnJvciBib3g6XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihvdXRwdXRfbWVzc2FnZSk7IC8vIEdvb2QgdG8gb3V0cHV0IGl0IGF0IGxlYXN0IHNvbWUgd2F5LlxyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIk91dHB1dENoYW5uZWxfQ3VycmVudEZpbGU6IENvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlLlwiKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmlldyBpcyBpbiBzb3VyY2UgbW9kZVxyXG4gICAgICAgIGlmIChudWxsID09PSB2aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBpdCdzIG5vdCBwb3NzaWJsZSB0byBnZXQgYW4gZWRpdG9yLCBidXQgaXQncyBub3QgYSBiaWcgcHJvYmxlbS5cclxuICAgICAgICAgICAgZGVidWdMb2coXCJPdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlOiBDb3VsZCBub3QgZ2V0IGEgdmlldyBpbnN0YW5jZS5cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2UgZG8gaGF2ZSBhIHZpZXdcclxuICAgICAgICAgICAgaWYgKFwic291cmNlXCIgIT09IHZpZXcuZ2V0TW9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXYXJuIHRoYXQgdGhlIG91dHB1dCBtaWdodCBnbyB0byBhbiB1bmV4cGVjdGVkIHBsYWNlIGluIHRoZSBub3RlIGZpbGUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24oXCJOb3RlIHRoYXQgeW91ciBhY3RpdmUgbm90ZSBpcyBub3QgaW4gJ0VkaXQnIG1vZGUhIFRoZSBvdXRwdXQgY29tZXMgdmlzaWJsZSB3aGVuIHlvdSBzd2l0Y2ggdG8gJ0VkaXQnIG1vZGUgYWdhaW4hXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgY3VycmVudCBmaWxlXHJcbiAgICAgICAgdGhpcy5pbnNlcnRJbnRvRWRpdG9yKGVkaXRvciwgb3V0cHV0X21lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbnNlcnRJbnRvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBvdXRwdXRfbWVzc2FnZTogc3RyaW5nKTogdm9pZDtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbF9DdXJyZW50RmlsZX0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbF9DdXJyZW50RmlsZVwiO1xyXG5pbXBvcnQge0VkaXRvcn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbF9DdXJyZW50RmlsZUNhcmV0IGV4dGVuZHMgT3V0cHV0Q2hhbm5lbF9DdXJyZW50RmlsZSB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHRpdGxlID0gXCJDdXJyZW50IGZpbGU6IGNhcmV0IHBvc2l0aW9uXCI7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBob3RrZXlfbGV0dGVyID0gXCJSXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIHRleHQgaW50byB0aGUgZ2l2ZW4gZWRpdG9yLCBhdCBjYXJldCBwb3NpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWRpdG9yXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0X21lc3NhZ2VcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGluc2VydEludG9FZGl0b3IoZWRpdG9yOiBFZGl0b3IsIG91dHB1dF9tZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihvdXRwdXRfbWVzc2FnZSk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge091dHB1dENoYW5uZWxfQ3VycmVudEZpbGV9IGZyb20gXCIuL091dHB1dENoYW5uZWxfQ3VycmVudEZpbGVcIjtcclxuaW1wb3J0IHtFZGl0b3J9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dENoYW5uZWxfQ3VycmVudEZpbGVUb3AgZXh0ZW5kcyBPdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlIHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgdGl0bGUgPSBcIkN1cnJlbnQgZmlsZTogdG9wXCI7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBob3RrZXlfbGV0dGVyID0gXCJUXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIHRleHQgaW50byB0aGUgZ2l2ZW4gZWRpdG9yLCBhdCB0b3AuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVkaXRvclxyXG4gICAgICogQHBhcmFtIG91dHB1dF9tZXNzYWdlXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbnNlcnRJbnRvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBvdXRwdXRfbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdG9wX3Bvc2l0aW9uID0gZWRpdG9yLm9mZnNldFRvUG9zKDApO1xyXG4gICAgICAgIGVkaXRvci5yZXBsYWNlUmFuZ2Uob3V0cHV0X21lc3NhZ2UsIHRvcF9wb3NpdGlvbik7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge091dHB1dENoYW5uZWx9IGZyb20gXCIuL091dHB1dENoYW5uZWxcIjtcclxuaW1wb3J0IHtFT0x9IGZyb20gXCJvc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dENoYW5uZWxfU3RhdHVzQmFyIGV4dGVuZHMgT3V0cHV0Q2hhbm5lbCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHRpdGxlID0gXCJTdGF0dXMgYmFyXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGFjY2VwdHNfZW1wdHlfb3V0cHV0ID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGhvdGtleV9sZXR0ZXIgPSBcIlNcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCByZWNlaXZlZCBvdXRwdXQgY3VtdWxhdGl2ZWx5LiBTdWJzZXF1ZW50IGhhbmRsaW5ncyB3aWxsIHRoZW4gdXNlIHRoZSB3aG9sZSBvdXRwdXQsIG5vdCBqdXN0IG5ldyBwYXJ0cy5cclxuICAgICAqIE9ubHkgdXNlZCBpbiBcInJlYWx0aW1lXCIgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYWx0aW1lQ29udGVudEJ1ZmZlciA9IFwiXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lIHN0ZG91dCBhbmQgc3RkZXJyIChpbiBjYXNlIGJvdGggb2YgdGhlbSBoYXBwZW4gdG8gYmUgcHJlc2VudCkuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgY29tYmluZV9vdXRwdXRfc3RyZWFtcyA9IEVPTCArIEVPTDtcclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgX2hhbmRsZUJ1ZmZlcmVkKG91dHB1dENvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdHVzQmFyQ29udGVudChvdXRwdXRDb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgX2hhbmRsZVJlYWx0aW1lKG91dHB1dENvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVDb250ZW50QnVmZmVyICs9IG91dHB1dENvbnRlbnQ7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0dXNCYXJDb250ZW50KHRoaXMucmVhbHRpbWVDb250ZW50QnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldFN0YXR1c0JhckNvbnRlbnQob3V0cHV0Q29udGVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHVzX2Jhcl9lbGVtZW50ID0gdGhpcy5wbHVnaW4uZ2V0T3V0cHV0U3RhdHVzQmFyRWxlbWVudCgpO1xyXG5cclxuICAgICAgICBvdXRwdXRDb250ZW50ID0gb3V0cHV0Q29udGVudC50cmltKCk7XHJcblxyXG4gICAgICAgIC8vIEZ1bGwgb3V0cHV0IChzaG93biB3aGVuIGhvdmVyaW5nIHdpdGggbW91c2UpXHJcbiAgICAgICAgc3RhdHVzX2Jhcl9lbGVtZW50LnNldEF0dHIoXCJhcmlhLWxhYmVsXCIsIG91dHB1dENvbnRlbnQpO1xyXG5cclxuICAgICAgICAvLyBTaG93IGxhc3QgbGluZSBwZXJtYW5lbnRseS5cclxuICAgICAgICBjb25zdCBvdXRwdXRfbWVzc2FnZV9saW5lcyA9IG91dHB1dENvbnRlbnQuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvdSk7XHJcbiAgICAgICAgY29uc3QgbGFzdF9vdXRwdXRfbGluZSA9IG91dHB1dF9tZXNzYWdlX2xpbmVzW291dHB1dF9tZXNzYWdlX2xpbmVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHN0YXR1c19iYXJfZWxlbWVudC5zZXRUZXh0KGxhc3Rfb3V0cHV0X2xpbmUpO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlXCI7XHJcbmltcG9ydCB7RWRpdG9yLCBFZGl0b3JQb3NpdGlvbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbF9DdXJyZW50RmlsZUJvdHRvbSBleHRlbmRzIE91dHB1dENoYW5uZWxfQ3VycmVudEZpbGUge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSB0aXRsZSA9IFwiQ3VycmVudCBmaWxlOiBib3R0b21cIjtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGhvdGtleV9sZXR0ZXIgPSBcIkJcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgdGV4dCBpbnRvIHRoZSBnaXZlbiBlZGl0b3IsIGF0IGJvdHRvbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWRpdG9yXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0X21lc3NhZ2VcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGluc2VydEludG9FZGl0b3IoZWRpdG9yOiBFZGl0b3IsIG91dHB1dF9tZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBib3R0b21fcG9zaXRpb246IEVkaXRvclBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICBjaDogZWRpdG9yLmdldExpbmUoZWRpdG9yLmxhc3RMaW5lKCkpLmxlbmd0aCwgICAvLyBUaGUgbGFzdCBjaGFyYWN0ZXIqIG9mIC4uLlxyXG4gICAgICAgICAgICBsaW5lOiBlZGl0b3IubGFzdExpbmUoKSwgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gdGhlIGxhc3QgbGluZS5cclxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKikgQnV0IGRvIG5vdCBzdWJ0cmFjdCAxLCBiZWNhdXNlIGNoIGlzIHplcm8tYmFzZWQsIHNvIHdoZW4gLmxlbmd0aCBpcyB1c2VkIHdpdGhvdXQgLTEsIHdlIGFyZSBwb2ludGluZyBBRlRFUiB0aGUgbGFzdCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgZWRpdG9yLnJlcGxhY2VSYW5nZShvdXRwdXRfbWVzc2FnZSwgYm90dG9tX3Bvc2l0aW9uKTtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbH0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbFwiO1xyXG5pbXBvcnQge2NvcHlUb0NsaXBib2FyZH0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbF9DbGlwYm9hcmQgZXh0ZW5kcyBPdXRwdXRDaGFubmVsIHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgdGl0bGUgPSBcIkNsaXBib2FyZFwiO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaG90a2V5X2xldHRlciA9IFwiTFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIHJlY2VpdmVkIG91dHB1dCBjdW11bGF0aXZlbHkuIFN1YnNlcXVlbnQgaGFuZGxpbmdzIHdpbGwgdGhlbiB1c2UgdGhlIHdob2xlIG91dHB1dCwgbm90IGp1c3QgbmV3IHBhcnRzLlxyXG4gICAgICogT25seSB1c2VkIGluIFwicmVhbHRpbWVcIiBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVhbHRpbWVDb250ZW50QnVmZmVyID0gXCJcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIGNhbiBiZSBib3RoIFwic3Rkb3V0XCIgYW5kIFwic3RkZXJyXCIgcHJlc2VudCBhdCB0aGUgc2FtZSB0aW1lLCBvciBqdXN0IG9uZSBvZiB0aGVtLiBJZiBib3RoIGFyZSBwcmVzZW50LCB0aGV5XHJcbiAgICAgKiB3aWxsIGJlIGpvaW5lZCB0b2dldGhlciB3aXRoIFwiIFwiIGFzIGEgc2VwYXJhdG9yLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGNvbWJpbmVfb3V0cHV0X3N0cmVhbXMgPSBcIiBcIjsgLy8gVE9ETzogQ2hhbmdlIHRvIFwiXCIgYXMgdGhlcmUgc2hvdWxkIGJlIG5vIGV4dHJhIHNwYWNlIGJldHdlZW4gc3Rkb3V0IGFuZCBzdGRlcnIuIENvbXBhcmUgaXQgdG8gdGhlIHRlcm1pbmFsOiBBRkFJSyB0aGVyZSBpcyBubyBzZXBhcmF0aW9uIGJldHdlZW4gc3Rkb3V0IGFuZCBzdGRlcnIgb3V0cHV0cywganVzdCB0aGF0IHR5cGljYWxseSBlYWNoIG91dHB1dCBlbmRzIHdpdGggYSBuZXdsaW5lLlxyXG5cclxuICAgIHByb3RlY3RlZCBhc3luYyBfaGFuZGxlQnVmZmVyZWQob3V0cHV0Q29udGVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgYXdhaXQgY29weVRvQ2xpcGJvYXJkKG91dHB1dENvbnRlbnQpO1xyXG4gICAgICAgIHRoaXMubm90aWZ5KG91dHB1dENvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhc3luYyBfaGFuZGxlUmVhbHRpbWUob3V0cHV0Q29udGVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZUNvbnRlbnRCdWZmZXIgKz0gb3V0cHV0Q29udGVudDtcclxuICAgICAgICBhd2FpdCBjb3B5VG9DbGlwYm9hcmQodGhpcy5yZWFsdGltZUNvbnRlbnRCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMubm90aWZ5KHRoaXMucmVhbHRpbWVDb250ZW50QnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG5vdGlmeShvdXRwdXRfbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLm91dHB1dF9jaGFubmVsX2NsaXBib2FyZF9hbHNvX291dHB1dHNfdG9fbm90aWZpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgdXNlciBzbyB0aGV5IGtub3cgYSkgd2hhdCB3YXMgY29waWVkIHRvIGNsaXBib2FyZCwgYW5kIGIpIHRoYXQgdGhlaXIgY29tbWFuZCBoYXMgZmluaXNoZWQgZXhlY3V0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24oXCJDb3BpZWQgdG8gY2xpcGJvYXJkOiBcIiArIEVPTCArIG91dHB1dF9tZXNzYWdlICsgRU9MICsgRU9MICsgXCIoTm90aWZpY2F0aW9uIGNhbiBiZSB0dXJuZWQgb2ZmIGluIHNldHRpbmdzLilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtIb3RrZXksIE1vZGlmaWVyLCBQbGF0Zm9ybX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi9EZWJ1Z1wiO1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IE1vdmUgdGhpcyB0byBUU2hlbGxDb21tYW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdGtleXNGb3JTaGVsbENvbW1hbmQocGx1Z2luOiBTQ19QbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZyk6IEhvdGtleVtdIHtcclxuICAgIC8vIFJldHJpZXZlIGFsbCBob3RrZXlzIHNldCBieSB1c2VyLlxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgY29uc3QgYXBwX2N1c3RvbV9ob3RrZXlzID0gcGx1Z2luLmFwcC5ob3RrZXlNYW5hZ2VyPy5jdXN0b21LZXlzO1xyXG4gICAgaWYgKCFhcHBfY3VzdG9tX2hvdGtleXMpIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcImdldEhvdGtleXNGb3JTaGVsbENvbW1hbmQoKSBmYWlsZWQsIHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlwiKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgb25seSBvdXIgaG90a2V5cy5cclxuICAgIGNvbnN0IGhvdGtleV9pbmRleCA9IHBsdWdpbi5nZXRQbHVnaW5JZCgpICsgXCI6XCIgKyBwbHVnaW4uZ2VuZXJhdGVPYnNpZGlhbkNvbW1hbmRJZChzaGVsbF9jb21tYW5kX2lkKTsgLy8gRS5nLiBcIm9ic2lkaWFuLXNoZWxsY29tbWFuZHM6c2hlbGwtY29tbWFuZC0wXCJcclxuICAgIGRlYnVnTG9nKFwiZ2V0SG90a2V5c0ZvclNoZWxsQ29tbWFuZCgpIHN1Y2NlZWRlZC5cIilcclxuICAgIHJldHVybiBhcHBfY3VzdG9tX2hvdGtleXNbaG90a2V5X2luZGV4XSA/PyBbXTsgLy8gSWYgbm8gaG90a2V5IGFycmF5IGlzIHNldCBmb3IgdGhpcyBjb21tYW5kLCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuIEFsdGhvdWdoIEkgZG8gYmVsaWV2ZSB0aGF0IGFsbCBjb21tYW5kcyBkbyBoYXZlIGFuIGFycmF5IGFueXdheSwgYnV0IGhhdmUgdGhpcyBjaGVjayBqdXN0IGluIGNhc2UuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBJcyB0aGVyZSBhIHdheSB0byBtYWtlIE9ic2lkaWFuIGRvIHRoaXMgY29udmVyc2lvbiBmb3IgdXM/IENoZWNrIHRoaXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9wamVieS9ob3RrZXktaGVscGVyL2Jsb2IvYzhhMDMyZTRjNTJiZDljZTA4Y2I5MDljZWMxNWQxZWQ5ZDBhMzQzOS9zcmMvcGx1Z2luLmpzI0w0LUw2XHJcbiAqXHJcbiAqIEBwYXJhbSBob3RrZXlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gSG90a2V5VG9TdHJpbmcoaG90a2V5OiBIb3RrZXkpIHtcclxuICAgIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBob3RrZXkubW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyOiBNb2RpZmllcikgPT4ge1xyXG4gICAgICAgIGxldCBtb2RpZmllcl9rZXkgPSBtb2RpZmllci50b1N0cmluZygpOyAvLyBUaGlzIGlzIG9uZSBvZiAnTW9kJyB8ICdDdHJsJyB8ICdNZXRhJyB8ICdTaGlmdCcgfCAnQWx0J1xyXG4gICAgICAgIGlmIChcIk1vZFwiID09PSBtb2RpZmllcl9rZXkpIHtcclxuICAgICAgICAgICAgLy8gQ2hhbmdlIFwiTW9kXCIgdG8gc29tZXRoaW5nIG1vcmUgbWVhbmluZ2Z1bC5cclxuICAgICAgICAgICAgbW9kaWZpZXJfa2V5ID0gQ21kT3JDdHJsKCk7IC8vIGlzTWFjT1Mgc2hvdWxkIGFsc28gYmUgdHJ1ZSBpZiB0aGUgZGV2aWNlIGlzIGlQaG9uZS9pUGFkLiBDYW4gYmUgaGFuZHkgaWYgdGhpcyBwbHVnaW4gZ2V0cyBtb2JpbGUgc3VwcG9ydCBzb21lIGRheS5cclxuICAgICAgICB9XHJcbiAgICAgICAga2V5cy5wdXNoKG1vZGlmaWVyX2tleSk7XHJcbiAgICB9KTtcclxuICAgIGtleXMucHVzaChob3RrZXkua2V5KTsgLy8gVGhpcyBpcyBzb21ldGhpbmcgbGlrZSBhIGxldHRlciAoJ0EnLCAnQicgZXRjKSBvciBzcGFjZS9lbnRlci93aGF0ZXZlci5cclxuICAgIHJldHVybiBrZXlzLmpvaW4oXCIgKyBcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbWRPckN0cmwoKTogXCJDbWRcIiB8IFwiQ3RybFwiIHtcclxuICAgIHJldHVybiBQbGF0Zm9ybS5pc01hY09TID8gXCJDbWRcIiA6IFwiQ3RybFwiXHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge091dHB1dENoYW5uZWx9IGZyb20gXCIuL091dHB1dENoYW5uZWxcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldE91dHB1dENoYW5uZWxDbGFzc2VzLFxyXG4gICAgaW5pdGlhbGl6ZU91dHB1dENoYW5uZWwsXHJcbiAgICBPdXRwdXRTdHJlYW1zLFxyXG59IGZyb20gXCIuL091dHB1dENoYW5uZWxGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtCdXR0b25Db21wb25lbnQsIFNldHRpbmcsIFRleHRBcmVhQ29tcG9uZW50fSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsQ29kZSwgT3V0cHV0U3RyZWFtfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsQ29kZVwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCwgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtTQ19Nb2RhbH0gZnJvbSBcIi4uL1NDX01vZGFsXCI7XHJcbmltcG9ydCB7Z2V0U2VsZWN0aW9uRnJvbVRleHRhcmVhfSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7Q21kT3JDdHJsfSBmcm9tIFwiLi4vSG90a2V5c1wiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbF9Nb2RhbCBleHRlbmRzIE91dHB1dENoYW5uZWwge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSB0aXRsZSA9IFwiQXNrIGFmdGVyIGV4ZWN1dGlvblwiO1xyXG5cclxuICAgIHByaXZhdGUgbW9kYWw6IE91dHB1dE1vZGFsO1xyXG5cclxuICAgIHByb3RlY3RlZCBpbml0aWFsaXplKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYSBtb2RhbCAoYnV0IGRvbid0IG9wZW4geWV0KVxyXG4gICAgICAgIHRoaXMubW9kYWwgPSBuZXcgT3V0cHV0TW9kYWwoXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLFxyXG4gICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LFxyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NUZXJtaW5hdG9yLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIF9oYW5kbGVCdWZmZXJlZChvdXRwdXRzOiBPdXRwdXRTdHJlYW1zLCBlcnJvcl9jb2RlOiBudW1iZXIgfCBudWxsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gUGFzcyBvdXRwdXRzIHRvIG1vZGFsXHJcbiAgICAgICAgdGhpcy5tb2RhbC5zZXRPdXRwdXRDb250ZW50cyhvdXRwdXRzKTtcclxuXHJcbiAgICAgICAgLy8gRGVmaW5lIGEgcG9zc2libGUgZXJyb3IgY29kZSB0byBiZSBzaG93biBvbiB0aGUgbW9kYWwuXHJcbiAgICAgICAgaWYgKGVycm9yX2NvZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbC5zZXRFeGl0Q29kZShlcnJvcl9jb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvbmVcclxuICAgICAgICB0aGlzLm1vZGFsLm9wZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgX2hhbmRsZVJlYWx0aW1lKG91dHB1dENvbnRlbnQ6IHN0cmluZywgb3V0cHV0U3RyZWFtTmFtZTogT3V0cHV0U3RyZWFtKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5tb2RhbC5hZGRPdXRwdXRDb250ZW50KG91dHB1dFN0cmVhbU5hbWUsIG91dHB1dENvbnRlbnQpO1xyXG4gICAgICAgIGlmICghdGhpcy5tb2RhbC5pc09wZW4oKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLm9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXhpdENvZGUgQ2FuIGJlIG51bGwgaWYgdXNlciB0ZXJtaW5hdGVkIHRoZSBwcm9jZXNzIGJ5IGNsaWNraW5nIGEgYnV0dG9uLiBJbiBvdGhlciBwbGFjZXMgZXhpdENvZGUgY2FuIGJlIG51bGwgaWYgcHJvY2VzcyBpcyBzdGlsbCBydW5uaW5nLCBidXQgaGVyZSB0aGF0IGNhbm5vdCBiZSB0aGUgY2FzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBfZW5kUmVhbHRpbWUoZXhpdENvZGU6IG51bWJlciB8IG51bGwpIHtcclxuICAgICAgICAvLyBEZWxldGUgdGVybWluYXRvciBidXR0b24gYXMgdGhlIHByb2Nlc3MgaXMgYWxyZWFkeSBlbmRlZC5cclxuICAgICAgICB0aGlzLm1vZGFsLnJlbW92ZVByb2Nlc3NUZXJtaW5hdG9yQnV0dG9uKCk7XHJcblxyXG4gICAgICAgIC8vIFBhc3MgZXhpdENvZGUgdG8gdGhlIG1vZGFsXHJcbiAgICAgICAgdGhpcy5tb2RhbC5zZXRFeGl0Q29kZShleGl0Q29kZSk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBPdXRwdXRNb2RhbCBleHRlbmRzIFNDX01vZGFsIHtcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZDtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdDtcclxuICAgIHByaXZhdGUgZXhpdF9jb2RlOiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIEZpZWxkcyBhbmQgSFRNTCBlbGVtZW50c1xyXG4gICAgcHJpdmF0ZSBvdXRwdXRGaWVsZHNDb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXRGaWVsZHM6IHtba2V5OiBzdHJpbmddOiBTZXR0aW5nfSA9IHt9O1xyXG4gICAgcHJpdmF0ZSBleGl0Q29kZUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBwcm9jZXNzVGVybWluYXRvckJ1dHRvbkNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcGx1Z2luOiBTQ19QbHVnaW4sXHJcbiAgICAgICAgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLFxyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQ6IFNoZWxsQ29tbWFuZFBhcnNpbmdSZXN1bHQsXHJcbiAgICAgICAgcHJpdmF0ZSBwcm9jZXNzVGVybWluYXRvcjogKCgpID0+IHZvaWQpIHwgbnVsbCxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbik7XHJcblxyXG4gICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kID0gdF9zaGVsbF9jb21tYW5kO1xyXG4gICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCA9IHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQ7XHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlT3V0cHV0RmllbGRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBkb2luZyBcImJ1ZmZlcmVkXCIgb3V0cHV0IGhhbmRsaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdXRwdXRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRPdXRwdXRDb250ZW50cyhvdXRwdXRzOiBPdXRwdXRTdHJlYW1zKSB7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3V0cHV0cykuZm9yRWFjaCgob3V0cHV0U3RyZWFtTmFtZTogT3V0cHV0U3RyZWFtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEZpZWxkOiBTZXR0aW5nID0gdGhpcy5vdXRwdXRGaWVsZHNbb3V0cHV0U3RyZWFtTmFtZV07XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3QgdGV4dGFyZWFDb21wb25lbnQgPSBvdXRwdXRGaWVsZC5jb21wb25lbnRzLmZpcnN0KCkgYXMgVGV4dEFyZWFDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBvdXRwdXRzW291dHB1dFN0cmVhbU5hbWVdO1xyXG4gICAgICAgICAgICB0ZXh0YXJlYUNvbXBvbmVudC5zZXRWYWx1ZShvdXRwdXRDb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgZmllbGQgdmlzaWJsZSAoaWYgaXQncyBub3QgYWxyZWFkeSlcclxuICAgICAgICAgICAgb3V0cHV0RmllbGQuc2V0dGluZ0VsLm1hdGNoUGFyZW50KFwiLlNDLWhpZGVcIikucmVtb3ZlQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gZG9pbmcgXCJyZWFsdGltZVwiIG91dHB1dCBoYW5kbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0U3RyZWFtTmFtZVxyXG4gICAgICogQHBhcmFtIG91dHB1dENvbnRlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZE91dHB1dENvbnRlbnQob3V0cHV0U3RyZWFtTmFtZTogT3V0cHV0U3RyZWFtLCBvdXRwdXRDb250ZW50OiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXRGaWVsZDogU2V0dGluZyA9IHRoaXMub3V0cHV0RmllbGRzW291dHB1dFN0cmVhbU5hbWVdO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgZmllbGQgdmFsdWVcclxuICAgICAgICBjb25zdCB0ZXh0YXJlYUNvbXBvbmVudCA9IG91dHB1dEZpZWxkLmNvbXBvbmVudHMuZmlyc3QoKSBhcyBUZXh0QXJlYUNvbXBvbmVudDtcclxuICAgICAgICB0ZXh0YXJlYUNvbXBvbmVudC5zZXRWYWx1ZSh0ZXh0YXJlYUNvbXBvbmVudC5nZXRWYWx1ZSgpICsgb3V0cHV0Q29udGVudCk7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgZmllbGQgdmlzaWJsZSAoaWYgaXQncyBub3QgYWxyZWFkeSlcclxuICAgICAgICBvdXRwdXRGaWVsZC5zZXR0aW5nRWwubWF0Y2hQYXJlbnQoXCIuU0MtaGlkZVwiKT8ucmVtb3ZlQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKCk7XHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmFkZENsYXNzKFwiU0MtbW9kYWwtb3V0cHV0XCIpO1xyXG5cclxuICAgICAgICAvLyBIZWFkaW5nXHJcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IHRoaXMuc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdC5hbGlhcztcclxuICAgICAgICB0aGlzLnRpdGxlRWwuaW5uZXJUZXh0ID0gaGVhZGluZyA/IGhlYWRpbmcgOiBcIlNoZWxsIGNvbW1hbmQgb3V0cHV0XCI7ICAvLyBUT0RPOiBVc2UgdGhpcy5zZXRUaXRsZSgpIGluc3RlYWQuXHJcblxyXG4gICAgICAgIC8vIFNoZWxsIGNvbW1hbmQgcHJldmlld1xyXG4gICAgICAgIHRoaXMubW9kYWxFbC5jcmVhdGVFbChcInByZVwiLCB7dGV4dDogdGhpcy5zaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LnNoZWxsX2NvbW1hbmQsIGF0dHI6IHtjbGFzczogXCJTQy1uby1tYXJnaW4gU0Mtd3JhcHBhYmxlXCJ9fSk7IC8vIG5vIG1hcmdpbiBzbyB0aGF0IGV4aXQgY29kZSB3aWxsIGJlIGNsb3NlLlxyXG5cclxuICAgICAgICAvLyBDb250YWluZXIgZm9yIHRlcm1pbmF0aW5nIGJ1dHRvbiBhbmQgZXhpdCBjb2RlXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1Jlc3VsdENvbnRhaW5lciA9IHRoaXMubW9kYWxFbC5jcmVhdGVEaXYoKTtcclxuXHJcbiAgICAgICAgLy8gJ1JlcXVlc3QgdG8gdGVybWluYXRlIHRoZSBwcm9jZXNzJyBpY29uIGJ1dHRvblxyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NUZXJtaW5hdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Rlcm1pbmF0b3JCdXR0b25Db250YWluZXIgPSBwcm9jZXNzUmVzdWx0Q29udGFpbmVyLmNyZWF0ZUVsKCdzcGFuJyk7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmNyZWF0ZVJlcXVlc3RUZXJtaW5hdGluZ0J1dHRvbih0aGlzLnByb2Nlc3NUZXJtaW5hdG9yQnV0dG9uQ29udGFpbmVyLCB0aGlzLnByb2Nlc3NUZXJtaW5hdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4aXQgY29kZSAocHV0IG9uIHNhbWUgbGluZSB3aXRoIHByb2Nlc3MgdGVybWluYXRvciBidXR0b24sIGlmIGV4aXN0cylcclxuICAgICAgICB0aGlzLmV4aXRDb2RlRWxlbWVudCA9IHByb2Nlc3NSZXN1bHRDb250YWluZXIuY3JlYXRlRWwoXCJzbWFsbFwiLCB7dGV4dDogXCJFeGVjdXRpbmcuLi5cIiwgYXR0cjoge3N0eWxlOiBcImZvbnQtd2VpZ2h0OiBib2xkO1wifX0pOyAvLyBTaG93IFwiRXhlY3V0aW5nLi4uXCIgYmVmb3JlIGFuIGFjdHVhbCBleGl0IGNvZGUgaXMgcmVjZWl2ZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuZXhpdF9jb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheUV4aXRDb2RlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdXRwdXQgZmllbGRzXHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLHRoaXMub3V0cHV0RmllbGRzQ29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgLy8gRm9jdXMgb24gdGhlIGZpcnN0IG91dHB1dCBmaWVsZFxyXG4gICAgICAgIHRoaXMuZm9jdXNGaXJzdEZpZWxkKCk7XHJcblxyXG4gICAgICAgIC8vIEEgdGlwIGFib3V0IHNlbGVjdGluZyB0ZXh0LlxyXG4gICAgICAgIHRoaXMubW9kYWxFbC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICB0ZXh0OiBcIlRpcCEgSWYgeW91IHNlbGVjdCBzb21ldGhpbmcsIG9ubHkgdGhlIHNlbGVjdGVkIHRleHQgd2lsbCBiZSB1c2VkLlwiLFxyXG4gICAgICAgICAgICBhdHRyOiB7Y2xhc3M6IFwic2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uXCIgLyogQSBDU1MgY2xhc3MgZGVmaW5lZCBieSBPYnNpZGlhbi4gKi99LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlT3V0cHV0RmllbGRzKCkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHBhcmVudC1sZXNzIGNvbnRhaW5lci4gb25PcGVuKCkgd2lsbCBwbGFjZSBpdCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cclxuICAgICAgICB0aGlzLm91dHB1dEZpZWxkc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgZmllbGQgY29udGFpbmVycyBpbiBjb3JyZWN0IG9yZGVyXHJcbiAgICAgICAgbGV0IHN0ZG91dEZpZWxkQ29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDtcclxuICAgICAgICBsZXQgc3RkZXJyRmllbGRDb250YWluZXI6IEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0T3V0cHV0Q2hhbm5lbE9yZGVyKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZG91dC1maXJzdFwiOiB7XHJcbiAgICAgICAgICAgICAgICBzdGRvdXRGaWVsZENvbnRhaW5lciA9IHRoaXMub3V0cHV0RmllbGRzQ29udGFpbmVyLmNyZWF0ZURpdigpO1xyXG4gICAgICAgICAgICAgICAgc3RkZXJyRmllbGRDb250YWluZXIgPSB0aGlzLm91dHB1dEZpZWxkc0NvbnRhaW5lci5jcmVhdGVEaXYoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRlcnItZmlyc3RcIjoge1xyXG4gICAgICAgICAgICAgICAgc3RkZXJyRmllbGRDb250YWluZXIgPSB0aGlzLm91dHB1dEZpZWxkc0NvbnRhaW5lci5jcmVhdGVEaXYoKTtcclxuICAgICAgICAgICAgICAgIHN0ZG91dEZpZWxkQ29udGFpbmVyID0gdGhpcy5vdXRwdXRGaWVsZHNDb250YWluZXIuY3JlYXRlRGl2KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGZpZWxkc1xyXG4gICAgICAgIHRoaXMub3V0cHV0RmllbGRzLnN0ZG91dCA9IHRoaXMuY3JlYXRlT3V0cHV0RmllbGQoXCJzdGRvdXRcIiwgc3Rkb3V0RmllbGRDb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0RmllbGRzLnN0ZGVyciA9IHRoaXMuY3JlYXRlT3V0cHV0RmllbGQoXCJzdGRlcnJcIiwgc3RkZXJyRmllbGRDb250YWluZXIpO1xyXG5cclxuICAgICAgICAvLyBIaWRlIHRoZSBmaWVsZHMnIGNvbnRhaW5lcnMgYXQgdGhlIGJlZ2lubmluZy4gVGhleSB3aWxsIGJlIHNob3duIHdoZW4gY29udGVudCBpcyBhZGRlZC5cclxuICAgICAgICBzdGRvdXRGaWVsZENvbnRhaW5lci5hZGRDbGFzcyhcIlNDLWhpZGVcIik7XHJcbiAgICAgICAgc3RkZXJyRmllbGRDb250YWluZXIuYWRkQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlT3V0cHV0RmllbGQob3V0cHV0X3N0cmVhbTogT3V0cHV0U3RyZWFtLCBjb250YWluZXJFbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBvdXRwdXRfdGV4dGFyZWE6IFRleHRBcmVhQ29tcG9uZW50O1xyXG5cclxuICAgICAgICBjb250YWluZXJFbGVtZW50LmNyZWF0ZUVsKFwiaHJcIiwge2F0dHI6IHtjbGFzczogXCJTQy1uby1tYXJnaW5cIn19KTtcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0IHN0cmVhbSBuYW1lXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUob3V0cHV0X3N0cmVhbSlcclxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKVxyXG4gICAgICAgICAgICAuc2V0Q2xhc3MoXCJTQy1uby1ib3R0b20tYm9yZGVyXCIpXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBUZXh0YXJlYVxyXG4gICAgICAgIGNvbnN0IHRleHRhcmVhX3NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbGVtZW50KVxyXG4gICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dGFyZWEgPT4gb3V0cHV0X3RleHRhcmVhID0gdGV4dGFyZWEpXHJcbiAgICAgICAgO1xyXG4gICAgICAgIHRleHRhcmVhX3NldHRpbmcuaW5mb0VsLmFkZENsYXNzKFwiU0MtaGlkZVwiKTsgLy8gTWFrZSByb29tIGZvciB0aGUgdGV4dGFyZWEgYnkgaGlkaW5nIHRoZSBsZWZ0IGNvbHVtbi5cclxuICAgICAgICB0ZXh0YXJlYV9zZXR0aW5nLnNldHRpbmdFbC5hZGRDbGFzcyhcIlNDLW91dHB1dC1jaGFubmVsLW1vZGFsLXRleHRhcmVhLWNvbnRhaW5lclwiLCBcIlNDLW5vLXRvcC1ib3JkZXJcIik7XHJcblxyXG4gICAgICAgIC8vIEFkZCBjb250cm9scyBmb3IgcmVkaXJlY3RpbmcgdGhlIG91dHB1dCB0byBhbm90aGVyIGNoYW5uZWwuXHJcbiAgICAgICAgY29uc3QgcmVkaXJlY3Rfc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiUmVkaXJlY3Q6XCIpXHJcbiAgICAgICAgICAgIC5zZXRDbGFzcyhcIlNDLW5vLXRvcC1ib3JkZXJcIilcclxuICAgICAgICAgICAgLnNldENsYXNzKFwiU0Mtb3V0cHV0LWNoYW5uZWwtbW9kYWwtcmVkaXJlY3Rpb24tYnV0dG9ucy1jb250YWluZXJcIikgLy8gSSB0aGluayB0aGlzIGNhbGxzIGFjdHVhbGx5IEhUTUxEaXZFbGVtZW50LmFkZENsYXNzKCksIHNvIGl0IHNob3VsZCBub3Qgb3ZlcnJpZGUgdGhlIHByZXZpb3VzIC5zZXRDbGFzcygpLlxyXG4gICAgICAgIDtcclxuICAgICAgICBjb25zdCBvdXRwdXRDaGFubmVscyA9IGdldE91dHB1dENoYW5uZWxDbGFzc2VzKCk7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3V0cHV0Q2hhbm5lbHMpLmZvckVhY2goKG91dHB1dF9jaGFubmVsX25hbWU6IE91dHB1dENoYW5uZWxDb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxDbGFzcyA9IG91dHB1dENoYW5uZWxzW291dHB1dF9jaGFubmVsX25hbWVdO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgY2hhbm5lbCBpcyBub3QgZXhjbHVkZWQgYnkgY2hlY2tpbmcgdGhhdCBpcyBoYXMgYSBob3RrZXkgZGVmaW5lZC5cclxuICAgICAgICAgICAgaWYgKG91dHB1dENoYW5uZWxDbGFzcy5ob3RrZXlfbGV0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIG91dHB1dCBjaGFubmVsIGFjY2VwdHMgdGhpcyBvdXRwdXQgc3RyZWFtLiBFLmcuIE91dHB1dENoYW5uZWxfT3BlbkZpbGVzIGRvZXMgbm90IGFjY2VwdCBcInN0ZGVyclwiLlxyXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dENoYW5uZWxDbGFzcy5hY2NlcHRzT3V0cHV0U3RyZWFtKG91dHB1dF9zdHJlYW0pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRhcmVhX2VsZW1lbnQgPSB0ZXh0YXJlYV9zZXR0aW5nLnNldHRpbmdFbC5maW5kKFwidGV4dGFyZWFcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmaW5lIGFuIG91dHB1dCBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlX291dHB1dCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3Qgb3V0cHV0IHRvIHRoZSBzZWxlY3RlZCBjaGFubmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dF9zdHJlYW1zOiBPdXRwdXRTdHJlYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9zdHJlYW1zW291dHB1dF9zdHJlYW1dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFNlbGVjdGlvbkZyb21UZXh0YXJlYSh0ZXh0YXJlYV9lbGVtZW50LCB0cnVlKSAvLyBVc2UgdGhlIHNlbGVjdGlvbiwgb3IuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8/IG91dHB1dF90ZXh0YXJlYS5nZXRWYWx1ZSgpIC8vIC4uLnVzZSB0aGUgd2hvbGUgdGV4dCwgaWYgbm90aGluZyBpcyBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRDaGFubmVsID0gaW5pdGlhbGl6ZU91dHB1dENoYW5uZWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfY2hhbm5lbF9uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnVmZmVyZWRcIiwgLy8gVXNlIFwiYnVmZmVyZWRcIiBtb2RlIGV2ZW4gaWYgdGhpcyBtb2RhbCB3YXMgb3BlbmVkIGluIFwicmVhbHRpbWVcIiBtb2RlLCBiZWNhdXNlIGF0IHRoaXMgcG9pbnQgdGhlIG91dHB1dCByZWRpcmVjdGlvbiBpcyBhIHNpbmdsZS10aW1lIGpvYiwgbm90IHJlY3VycmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Rlcm1pbmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG91dHB1dENoYW5uZWwuaGFuZGxlQnVmZmVyZWQob3V0cHV0X3N0cmVhbXMsIHRoaXMuZXhpdF9jb2RlLCBmYWxzZSk7IC8vIGZhbHNlOiBEaXNhYmxlIG91dHB1dCB3cmFwcGluZyBhcyBpdCdzIGFscmVhZHkgd3JhcHBlZCBiZWZvcmUgdGhlIG91dHB1dCBjb250ZW50IHdhcyBwYXNzZWQgdG8gdGhpcyBtb2RhbC5cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWRpcmVjdF9idXR0b246IEJ1dHRvbkNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdF9zZXR0aW5nLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdF9idXR0b24gPSBidXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgb3V0cHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlX291dHB1dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5pc2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNsaWNrLCBjb250cm9sL2NvbW1hbmQga2V5IGlzIHByZXNzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIHRoZSBtb2RhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBjbGljaywgY29udHJvbCBrZXkgaXMgbm90IHByZXNzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBjbG9zZSB0aGUgbW9kYWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhX2VsZW1lbnQuZm9jdXMoKTsgLy8gQnJpbmcgdGhlIGZvY3VzIGJhY2sgdG8gdGhlIHRleHRhcmVhIGluIG9yZGVyIHRvIHNob3cgYSBwb3NzaWJsZSBoaWdobGlnaHQgKD1zZWxlY3Rpb24pIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmluZSBidXR0b24gdGV4dHMgYW5kIGFzc2lnbiBob3RrZXlzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0X2NoYW5uZWxfdGl0bGU6IHN0cmluZyA9IG91dHB1dENoYW5uZWxDbGFzcy5nZXRUaXRsZShvdXRwdXRfc3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0dG9uIHRleHRcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdF9idXR0b24uc2V0QnV0dG9uVGV4dChvdXRwdXRfY2hhbm5lbF90aXRsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRpcHMgYWJvdXQgaG90a2V5c1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0X2J1dHRvbi5zZXRUb29sdGlwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBgUmVkaXJlY3Q6IE5vcm1hbCBjbGljayBPUiAke0NtZE9yQ3RybCgpfSArICR7b3V0cHV0Q2hhbm5lbENsYXNzLmhvdGtleV9sZXR0ZXJ9LmBcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBFT0wgKyBFT0wgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgUmVkaXJlY3QgYW5kIGNsb3NlIHRoZSBtb2RhbDogJHtDbWRPckN0cmwoKX0gKyBjbGljayBPUiAke0NtZE9yQ3RybCgpfSArIFNoaWZ0ICsgJHtvdXRwdXRDaGFubmVsQ2xhc3MuaG90a2V5X2xldHRlcn0uYFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGhvdGtleTogQ3RybC9DbWQgKyBudW1iZXI6IGhhbmRsZSBvdXRwdXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtcIkN0cmxcIl0sIG91dHB1dENoYW5uZWxDbGFzcy5ob3RrZXlfbGV0dGVyLCBoYW5kbGVfb3V0cHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gaG90a2V5OiBDdHJsL0NtZCArIFNoaWZ0ICsgbnVtYmVyOiBoYW5kbGUgb3V0cHV0IGFuZCBjbG9zZSB0aGUgbW9kYWwuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXCJDdHJsXCIsIFwiU2hpZnRcIl0sIG91dHB1dENoYW5uZWxDbGFzcy5ob3RrZXlfbGV0dGVyLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZV9vdXRwdXQoKS50aGVuKCk7IC8vIHRoZW4oKTogTm8gbmVlZCB0byB3YWl0IGZvciBvdXRwdXQgaGFuZGxpbmcgdG8gZmluaXNoIGJlZm9yZSBjbG9zaW5nIHRoZSBtb2RhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0YXJlYV9zZXR0aW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVQcm9jZXNzVGVybWluYXRvckJ1dHRvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzVGVybWluYXRvckJ1dHRvbkNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NUZXJtaW5hdG9yQnV0dG9uQ29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgb25seSBpZiBhbiBleGl0IGNvZGUgd2FzIHJlY2VpdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBleGl0X2NvZGUgQ2FuIGJlIG51bGwgaWYgdXNlciB0ZXJtaW5hdGVkIHRoZSBwcm9jZXNzIGJ5IGNsaWNraW5nIGEgYnV0dG9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RXhpdENvZGUoZXhpdF9jb2RlOiBudW1iZXIgfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5leGl0X2NvZGUgPSBleGl0X2NvZGU7XHJcblxyXG4gICAgICAgIC8vIFRyeSB0byBzaG93IHRoZSBleGl0IGNvZGUuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMuZXhpdF9jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGhhcyB0ZXJtaW5hdGVkIHRoZSBwcm9jZXNzLCBzbyB0aGVyZSdzIG5vIGV4aXQgY29kZSBldmVuIHRob3VnaCB0aGUgcHJvY2VzcyBoYXMgZW5kZWQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4aXRDb2RlRWxlbWVudC5pbm5lclRleHQgPSBcIlVzZXIgdGVybWluYXRlZFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzcGxheUV4aXN0Q29kZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBpZiBvbk9wZW4oKSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgb25PcGVuKCkgd2lsbCBiZSBjYWxsZWQgbGF0ZXIsIGl0IHdpbGwgY2FsbCBkaXNwbGF5RXhpdENvZGUoKSBpdHNlbGYgd2hlbiBpdCBzZWVzIHRoYXQgdGhpcy5leGl0X2NvZGUgaXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUV4aXRDb2RlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNwbGF5RXhpdENvZGUoKSB7XHJcbiAgICAgICAgdGhpcy5leGl0Q29kZUVsZW1lbnQuaW5uZXJUZXh0ID0gXCJFeGl0IGNvZGU6IFwiICsgdGhpcy5leGl0X2NvZGUudG9TdHJpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZvY3VzRmlyc3RGaWVsZCgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldE91dHB1dENoYW5uZWxPcmRlcigpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRvdXQtZmlyc3RcIjoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWVsZHMuc3Rkb3V0LmNvbnRyb2xFbC5maW5kKFwidGV4dGFyZWFcIikuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRlcnItZmlyc3RcIjoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWVsZHMuc3RkZXJyLmNvbnRyb2xFbC5maW5kKFwidGV4dGFyZWFcIikuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhcHByb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcGVyZm9ybSBhbnkgYWN0aW9uLCBqdXN0IGNsb3NlIHRoZSBtb2RhbC5cclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge091dHB1dENoYW5uZWx9IGZyb20gXCIuL091dHB1dENoYW5uZWxcIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsQ29kZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgRWRpdG9yU2VsZWN0aW9uT3JDYXJldCxcclxuICAgIG5vcm1hbGl6ZVBhdGgsXHJcbiAgICBQYW5lVHlwZSxcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtcclxuICAgIGdldEVkaXRvcixcclxuICAgIGdldFZhdWx0QWJzb2x1dGVQYXRoLFxyXG4gICAgaXNJbnRlZ2VyLFxyXG4gICAgaXNXaW5kb3dzLFxyXG4gICAgcHJlcGFyZUVkaXRvclBvc2l0aW9uLFxyXG59IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dENoYW5uZWxfT3BlbkZpbGVzIGV4dGVuZHMgT3V0cHV0Q2hhbm5lbCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHRpdGxlID0gXCJPcGVuIGZpbGVzXCI7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBob3RrZXlfbGV0dGVyID0gXCJPXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG91dHB1dCBjaGFubmVsIGlzIG5vdCBzdWl0YWJsZSBmb3Igc3RkZXJyLCBhcyBzdGRlcnIgY2FuIGNvbnRhaW4gdW5leHBlY3RlZCBtZXNzYWdlcy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBhY2NlcHRlZF9vdXRwdXRfc3RyZWFtczogT3V0cHV0U3RyZWFtW10gPSBbXCJzdGRvdXRcIl07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVCdWZmZXJlZChvdXRwdXQ6IE91dHB1dFN0cmVhbXMsIGVycm9yX2NvZGU6IG51bWJlciB8IG51bGwpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBsZXQgaGFuZGxpbmdQaXBlbGluZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGxldCBvdXRwdXRfc3RyZWFtX25hbWU6IE91dHB1dFN0cmVhbTtcclxuICAgICAgICBmb3IgKG91dHB1dF9zdHJlYW1fbmFtZSBpbiBvdXRwdXQpIHtcclxuICAgICAgICAgICAgaGFuZGxpbmdQaXBlbGluZSA9IGhhbmRsaW5nUGlwZWxpbmUuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUob3V0cHV0W291dHB1dF9zdHJlYW1fbmFtZV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsaW5nUGlwZWxpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVSZWFsdGltZShvdXRwdXRDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUob3V0cHV0Q29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGUob3V0cHV0Q29udGVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlYWQgZmlsZSBkZWZpbml0aW9ucy4gVXN1YWxseSB0aGVyZSdzIGp1c3Qgb25lLCBidXQgdGhlcmUgY2FuIGJlIG1hbnkuIERlZmluaXRpb25zIGFyZSBzZXBhcmF0ZWQgYnkgbmV3bGluZVxyXG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXJzLiBFYWNoIGZpbGUgZGVmaW5pdGlvbiBkZWZpbmVzIG9uZSBmaWxlIHRvIGJlIG9wZW5lZC5cclxuICAgICAgICAgICAgY29uc3QgZmlsZV9kZWZpbml0aW9uc19zdHJpbmcgPSBvdXRwdXRDb250ZW50LnRyaW0oKTsgLy8gQ29udGFpbnMgYXQgbGVhc3QgZmlsZSBuYW1lKHMpLCBhbmQgTUFZQkU6IGEgY2FyZXQgcG9zaXRpb24sIG5ldyBwYW5lIG9wdGlvbiwgYW5kIHZpZXcgc3RhdGVcclxuICAgICAgICAgICAgY29uc3QgZmlsZV9kZWZpbml0aW9ucyA9IGZpbGVfZGVmaW5pdGlvbnNfc3RyaW5nLnNwbGl0KC9bXFxyXFxuXSsvdSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGFsbCBmaWxlIGRlZmluaXRpb25zIHRoYXQgc2hvdWxkIGJlIG9wZW5lZC5cclxuICAgICAgICAgICAgbGV0IG9wZW5pbmdfcGlwZWxpbmUgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlX2RlZmluaXRpb24gb2YgZmlsZV9kZWZpbml0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhaW4gZWFjaCBmaWxlIG9wZW5pbmcgdG8gaGFwcGVuIG9uZSBhZnRlciBhbm90aGVyLiBJZiBvbmUgZmlsZSBvcGVuaW5nIGZhaWxzIGZvciB3aGF0ZXZlciByZWFzb24sIGl0XHJcbiAgICAgICAgICAgICAgICAvLyBpcyBvayB0byBjb250aW51ZSB0byBvcGVuIHRoZSBuZXh0IGZpbGUuIFRoaXMgaXMgd2h5IC5maW5hbGx5KCkgaXMgdXNlZCBpbnN0ZWFkIG9mIC50aGVuKCkuXHJcbiAgICAgICAgICAgICAgICBvcGVuaW5nX3BpcGVsaW5lID0gb3BlbmluZ19waXBlbGluZS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnByZXRGaWxlT3BlbmluZ0RlZmluaXRpb24oZmlsZV9kZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcGVuaW5nX3BpcGVsaW5lLmZpbmFsbHkoKCkgPT4gcmVzb2x2ZSgpIC8qIFRlbGwgdGhhdCBhbGwgb3BlbmluZ3MgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gKi8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW50ZXJwcmV0RmlsZU9wZW5pbmdEZWZpbml0aW9uKGZpbGVfZGVmaW5pdGlvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgZGVidWdMb2coXCJPdXRwdXRDaGFubmVsX09wZW5GaWxlczogSW50ZXJwcmV0aW5nIGZpbGUgb3BlbmluZyBkZWZpbml0aW9uOiBcIiArIGZpbGVfZGVmaW5pdGlvbik7XHJcbiAgICAgICAgICAgIC8vIEdldCBwYXJ0cyB0aGF0IGRlZmluZSBkaWZmZXJlbnQgZGV0YWlscyBhYm91dCBob3cgdGhlIGZpbGUgc2hvdWxkIGJlIG9wZW5lZFxyXG4gICAgICAgICAgICBjb25zdCBmaWxlX2RlZmluaXRpb25fcGFydHMgPSBmaWxlX2RlZmluaXRpb24uc3BsaXQoXCI6XCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYWx3YXlzIHRoZSBmaWxlIHBhdGhcclxuICAgICAgICAgICAgbGV0IG9wZW5fZmlsZV9wYXRoID0gZmlsZV9kZWZpbml0aW9uX3BhcnRzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBPbiBXaW5kb3dzOiBDaGVjayBpZiBhbiBhYnNvbHV0ZSBwYXRoIHdhcyBzcGxpdCBpbmNvcnJlY3RseS4gKEUuZy4gYSBwYXRoIHN0YXJ0aW5nIHdpdGggXCJDOlxcLi4uXCIpLlxyXG4gICAgICAgICAgICBpZiAoaXNXaW5kb3dzKCkgJiYgZmlsZV9kZWZpbml0aW9uX3BhcnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkX3BhdGggPSBvcGVuX2ZpbGVfcGF0aCArIFwiOlwiICsgZmlsZV9kZWZpbml0aW9uX3BhcnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZShjb21iaW5lZF9wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFllcywgdGhlIGZpcnN0IHR3byBwYXJ0cyBkbyBmb3JtIGFuIGFic29sdXRlIHBhdGggdG9nZXRoZXIsIHNvIHRoZXkgc2hvdWxkIG5vdCBiZSBzcGxpdC5cclxuICAgICAgICAgICAgICAgICAgICBvcGVuX2ZpbGVfcGF0aCA9IGNvbWJpbmVkX3BhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9kZWZpbml0aW9uX3BhcnRzLnNoaWZ0KCk7IC8vIFJlbW92ZSB0aGUgc2Vjb25kIHBhcnQgc28gdGhhdCBpdCB3b24ndCBiZSBhY2NpZGVudGFsbHkgcHJvY2Vzc2VkIGluIHRoZSAnU3BlY2lhbCBmZWF0dXJlcycgcGFydC5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVHJpbSB0aGUgZmlsZSBwYXRoLCBmb3IgYmVpbmcgYWJsZSB0byB1c2UgY2xlYW5lciBzZXBhcmF0aW9uIGJldHdlZW4gZmlsZSBuYW1lIGFuZCBvdGhlciBwYXJ0cywgZS5nOiBNeUZpbGUubWQgOiBuZXctcGFuZVxyXG4gICAgICAgICAgICBvcGVuX2ZpbGVfcGF0aCA9IG9wZW5fZmlsZV9wYXRoLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgZmVhdHVyZXNcclxuICAgICAgICAgICAgY29uc3QgY2FyZXRfcGFydHM6IG51bWJlcltdID0gW107IC8vIElmIGNhcmV0IHBvc2l0aW9uIGlzIHByZXNlbnQgaW4gZmlsZV9kZWZpbml0aW9uX3BhcnRzLCB0aGUgZmlyc3QgaXRlbSBpbiB0aGlzIGFycmF5IHdpbGwgYmUgdGhlIGNhcmV0IGxpbmUsIHRoZSBzZWNvbmQgd2lsbCBiZSB0aGUgY29sdW1uLiBJZiBtb3JlIHBhcnRzIGFyZSBwcmVzZW50LCB0aGV5IHdpbGwgYmUgdXNlZCBmb3IgbWFraW5nIHNlbGVjdGlvbnMuXHJcbiAgICAgICAgICAgIGxldCBuZXdMZWFmOiBQYW5lVHlwZSB8IGZhbHNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjYW5fY3JlYXRlX2ZpbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGZpbGVfZGVmaW5pdGlvbl9pbnRlcnByZXRpbmdfZmFpbGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmaWxlX2RlZmluaXRpb25fcGFydHMuZm9yRWFjaCgoZmlsZV9kZWZpbml0aW9uX3BhcnQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgZmlsZV9kZWZpbml0aW9uX3BhcnQgPSBmaWxlX2RlZmluaXRpb25fcGFydC50b0xvY2FsZUxvd2VyQ2FzZSgpLnRyaW0oKTsgLy8gLnRyaW0oKSBpcyBmb3IgYmVpbmcgYWJsZSB0byB1c2UgY2xlYW5lciBzZXBhcmF0aW9uIGJldHdlZW4gZS5nLiBkaWZmZXJlbnQgc2VsZWN0aW9uczogTXlGaWxlLm1kOjE6MToxOi0xIDogNToxOjU6LTFcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBhcnQgdHlwZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW50ZWdlcihmaWxlX2RlZmluaXRpb25fcGFydCwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbnVtYmVyLCBzbyBjb25zaWRlciBpdCBhcyBhIGNhcmV0IHBvc2l0aW9uIHBhcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRfcGFydHMucHVzaChwYXJzZUludChmaWxlX2RlZmluaXRpb25fcGFydCkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtdWx0aXBsZU5ld1BhcnRzRXJyb3JNZXNzYWdlID0gXCJDYW5ub3Qgb3BlbiBmaWxlOiBPbmx5IG9uZSBvZiB0aGUgZm9sbG93aW5nIGNhbiBiZSBkZWZpbmVkOiBuZXctcGFuZSwgbmV3LXRhYiwgb3IgbmV3LXdpbmRvdy5cIjtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpbGVfZGVmaW5pdGlvbl9wYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZXctcGFuZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vIG5ldy0qIGRlZmluaXRpb24gaXMgdXNlZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TGVhZiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMZWFmID0gXCJzcGxpdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihtdWx0aXBsZU5ld1BhcnRzRXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlX2RlZmluaXRpb25faW50ZXJwcmV0aW5nX2ZhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5ldy10YWJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBubyBuZXctKiBkZWZpbml0aW9uIGlzIHVzZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xlYWYgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVhZiA9IFwidGFiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKG11bHRpcGxlTmV3UGFydHNFcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfZGVmaW5pdGlvbl9pbnRlcnByZXRpbmdfZmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmV3LXdpbmRvd1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vIG5ldy0qIGRlZmluaXRpb24gaXMgdXNlZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TGVhZiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMZWFmID0gXCJ3aW5kb3dcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IobXVsdGlwbGVOZXdQYXJ0c0Vycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9kZWZpbml0aW9uX2ludGVycHJldGluZ19mYWlsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYW4tY3JlYXRlLWZpbGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbl9jcmVhdGVfZmlsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKFwiQ2Fubm90IG9wZW4gZmlsZTogVW5yZWNvZ25pc2VkIGRlZmluaXRpb24gcGFydDogXCIgKyBmaWxlX2RlZmluaXRpb25fcGFydCArIFwiIGluIFwiICsgZmlsZV9kZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfZGVmaW5pdGlvbl9pbnRlcnByZXRpbmdfZmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZmlsZV9kZWZpbml0aW9uX2ludGVycHJldGluZ19mYWlsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHBhdGggaXMgcmVsYXRpdmVcclxuICAgICAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZShvcGVuX2ZpbGVfcGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXRoIGlzIGFic29sdXRlLlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIGNvbnZlcnRlZCB0byByZWxhdGl2ZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhdWx0X2Fic29sdXRlX3BhdGg6IHN0cmluZyA9IGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcGVuX2ZpbGVfcGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgodmF1bHRfYWJzb2x1dGVfcGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgdG8gcmVsYXRpdmUgaXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICBvcGVuX2ZpbGVfcGF0aCA9IG9wZW5fZmlsZV9wYXRoLnN1YnN0cih2YXVsdF9hYnNvbHV0ZV9wYXRoLmxlbmd0aCk7IC8vIEdldCBldmVyeXRoaW5nIGFmdGVyIHRoZSBwb2ludCB3aGVyZSB0aGUgdmF1bHQgcGF0aCBlbmRzLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5ub3QgY29udmVydCB0byByZWxhdGl2ZSwgYmVjYXVzZSB0aGUgZmlsZSBkb2VzIG5vdCByZXNpZGUgaW4gdGhlIHZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoXCJDYW5ub3Qgb3BlbiBmaWxlICdcIiArIG9wZW5fZmlsZV9wYXRoICsgXCInIGFzIHRoZSBwYXRoIGlzIG91dHNpZGUgdGhpcyB2YXVsdC5cIilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBmaWxlIHBhdGhcclxuICAgICAgICAgICAgb3Blbl9maWxlX3BhdGggPSBub3JtYWxpemVQYXRoKG9wZW5fZmlsZV9wYXRoKTsgLy8gbm9ybWFsaXplUGF0aCgpIGlzIHVzZWQgb24gcHVycG9zZSwgaW5zdGVhZCBvZiBub3JtYWxpemVQYXRoMigpLCBiZWNhdXNlIGJhY2tzbGFzaGVzIFxcIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzIC9cclxuXHJcbiAgICAgICAgICAgIHRoaXMub3BlbkZpbGVJblRhYihvcGVuX2ZpbGVfcGF0aCwgbmV3TGVhZiwgY2FuX2NyZWF0ZV9maWxlKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGlzIG5vdyBvcGVuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjaywgZGlkIHdlIGhhdmUgYSBjYXJldCBwb3NpdGlvbiBhdmFpbGFibGUuIElmIG5vdCwgZG8gbm90aGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50X2NhcmV0X3BhcnRzOiBudW1iZXIgPSBjYXJldF9wYXJ0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRfY2FyZXRfcGFydHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWWVzLCBhIGNhcmV0IHBvc2l0aW9uIHdhcyBkZWZpbmVkIGluIHRoZSBvdXRwdXQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29ycmVjdCBhbW91bnQgb2YgY2FyZXQgcG9zaXRpb24gcGFydHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMCBwYXJ0czogbm8gY2FyZXQgcG9zaXRpb25pbmcgbmVlZHMgdG8gYmUgZG9uZSAoYnV0IGluIHRoaXMgcGFydCBvZiBjb2RlIHRoZSBhbW91bnQgb2YgcGFydHMgaXMgYWx3YXlzIGdyZWF0ZXIgdGhhbiAwKS5cclxuICAgICAgICAgICAgICAgICAgICAvLyAxIHBhcnQ6IGNhcmV0IGxpbmUgaXMgZGVmaW5lZCwgbm8gY29sdW1uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDIgcGFydHM6IGNhcmV0IGxpbmUgYW5kIGNvbHVtbiBhcmUgZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzIHBhcnRzOiBOT1QgQUxMT1dFRC5cclxuICAgICAgICAgICAgICAgICAgICAvLyA0IHBhcnRzOiBzZWxlY3Rpb24gc3RhcnRpbmcgcG9zaXRpb24gKGxpbmUsIGNvbHVtbikgYW5kIHNlbGVjdGlvbiBlbmQgcG9zaXRpb24gKGxpbmUsIGNvbHVtbikgYXJlIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNSBwYXJ0cyBvciBtb3JlOiBOT1QgQUxMT1dFRC4gRXhjZXB0aW9uOiBhbnkgbnVtYmVyIG9mIHNldHMgb2YgZm91ciBwYXJ0cyBpcyBhbGxvd2VkLCBpLmUuIDggcGFydHMsIDEyIHBhcnRzLCAxNiBwYXJ0cyBldGMuIGFyZSBhbGxvd2VkIGFzIHRoZXkgY2FuIGRlZmluZSBtdWx0aXBsZSBzZWxlY3Rpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yX21lc3NhZ2VfYmFzZTogc3RyaW5nID0gXCJGaWxlIG9wZW5lZCwgYnV0IGNhcmV0IGNhbm5vdCBiZSBwb3NpdGlvbmVkIGR1ZSB0byBhbiBpbmNvcnJlY3QgYW1vdW50IChcIiArIGNvdW50X2NhcmV0X3BhcnRzICsgXCIpIG9mIG51bWVyaWMgdmFsdWVzIGluIHRoZSBvdXRwdXQ6IFwiICsgZmlsZV9kZWZpbml0aW9uICsgRU9MICsgRU9MO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudF9jYXJldF9wYXJ0cyA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29ycmVjdCBhbW91bnQgb2YgY2FyZXQgcGFydHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoZXJyb3JfbWVzc2FnZV9iYXNlICsgXCJUaHJlZSBudW1lcmljIHBhcnRzIGlzIGFuIGluY29ycmVjdCBhbW91bnQsIGNvcnJlY3Qgd291bGQgYmUgMSwyIG9yIDQgcGFydHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfY2FyZXRfcGFydHMgPiA0ICYmIGNvdW50X2NhcmV0X3BhcnRzICUgNCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnJlY3QgYW1vdW50IG9mIGNhcmV0IHBhcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKGVycm9yX21lc3NhZ2VfYmFzZSArIFwiUGVyaGFwcyB0b28gbWFueSBudW1lcmljIHBhcnRzIGFyZSBkZWZpbmVkPyBJZiBtb3JlIHRoYW4gZm91ciBwYXJ0cyBhcmUgZGVmaW5lZCwgbWFrZSBzdXJlIHRvIGRlZmluZSBjb21wbGV0ZSBzZXRzIG9mIGZvdXIgcGFydHMuIFRoZSBhbW91bnQgb2YgbnVtZXJpYyBwYXJ0cyBuZWVkcyB0byBiZSBkaXZpZGFibGUgYnkgNC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgZmlsZSBpcyBhbHJlYWR5IGxvYWRlZCwgcmVuZGVyaW5nIGl0IG1heSB0YWtlIHNvbWUgdGltZSwgdGh1cyB0aGUgaGVpZ2h0IG9mIHRoZSBjb250ZW50IG1heSBpbmNyZWFzZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhpcyByZWFzb24sIHRoZXJlIG5lZWRzIHRvIGJlIGEgdGlueSBkZWxheSBiZWZvcmUgc2V0dGluZyB0aGUgY2FyZXQgcG9zaXRpb24uIElmIHRoZSBjYXJldCBwb3NpdGlvbiBpcyBzZXQgaW1tZWRpYXRlbHksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNhcmV0IHdpbGwgYmUgcGxhY2VkIGluIGEgY29ycmVjdCBwb3NpdGlvbiwgYnV0IGl0IG1pZ2h0IGJlIHRoYXQgdGhlIGVkaXRvciBkb2VzIG5vdCBzY3JvbGwgaW50byBjb3JyZWN0IHBvc2l0aW9uLCBzbyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYXJldCBtaWdodCBiZSBvdXQgb2YgdGhlIHZpZXcsIGV2ZW4gd2hlbiBpdCdzIGluIGEgY29ycmVjdCBwbGFjZS4gKE9ic2lkaWFuIHZlcnNpb24gMC4xMy4yMykuXHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBnZXRFZGl0b3IodGhpcy5hcHApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudF9jYXJldF9wYXJ0cyA+PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uIG1vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgc2VsZWN0aW9ucyBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uczogRWRpdG9yU2VsZWN0aW9uT3JDYXJldFtdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNhcmV0X3BhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tX2xpbmUgPSBjYXJldF9wYXJ0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tX2NvbHVtbiA9IGNhcmV0X3BhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvX2xpbmUgPSBjYXJldF9wYXJ0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b19jb2x1bW4gPSBjYXJldF9wYXJ0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiBwcmVwYXJlRWRpdG9yUG9zaXRpb24oZWRpdG9yLCBmcm9tX2xpbmUsIGZyb21fY29sdW1uKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQ6IHByZXBhcmVFZGl0b3JQb3NpdGlvbihlZGl0b3IsIHRvX2xpbmUsIHRvX2NvbHVtbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRTZWxlY3Rpb25zKHNlbGVjdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgY2FyZXQgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcmV0X2xpbmU6IG51bWJlciA9IGNhcmV0X3BhcnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcmV0X2NvbHVtbjogbnVtYmVyID0gY2FyZXRfcGFydHNbMV0gPz8gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHByZXBhcmVFZGl0b3JQb3NpdGlvbihlZGl0b3IsIGNhcmV0X2xpbmUsIGNhcmV0X2NvbHVtbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHBsYWNpbmcgY2FyZXRzIC8gc2VsZWN0aW5nIHRleHQsIGhhdmUgYSBzbWFsbCBkZWxheSBhZnRlciBhbGxvd2luZyB0byBvcGVuIGFub3RoZXIgZmlsZSAoaW4gY2FzZSBtdWx0aXBsZSBmaWxlcyBhcmUgb3BlbmVkIGluIGEgcm93KS4gVGhpcyBhbGxvd3MgdGhlIHNlbGVjdGlvbiB0byBiZSByZW1lbWJlcmVkIGluIHRoZSBwYW5lJ3MgaGlzdG9yeS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHJlc29sdmUsIDMwMCk7IC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBBRERJVElPTkFMIGRlbGF5LCByZW1lbWJlciB0byBjaGFuZ2UgaXQgaW4gdGhlIGRvY3VtZW50YXRpb24sIHRvby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGVkaXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoXCJGaWxlIG9wZW5lZCwgYnV0IGNhcmV0IGNhbm5vdCBiZSBwb3NpdGlvbmVkIGJlY2F1c2Ugbm8gZWRpdG9yIHdhcyBmb3VuZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMCk7IC8vIDUwMG1zIGlzIHByb2JhYmx5IGxvbmcgZW5vdWdoIGV2ZW4gaWYgYSBuZXcgdGFiIGlzIG9wZW5lZCAodGFrZXMgbW9yZSB0aW1lIHRoYW4gb3BlbmluZyBhIGZpbGUgaW50byBhbiBleGlzdGluZyB0YWIpLiBUaGlzIGNhbiBiZSBtYWRlIGludG8gYSBzZXR0aW5nIHNvbWV0aW1lLiBJZiB5b3UgY2hhbmdlIHRoaXMsIHJlbWVtYmVyIHRvIGNoYW5nZSBpdCBpbiB0aGUgZG9jdW1lbnRhdGlvbiwgdG9vLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjYXJldCBwYXJ0cyBleGlzdC4gQWxsIGlzIGRvbmUgbm93LlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKGVycm9yX21lc3NhZ2U6IHN0cmluZyB8IHVua25vd24pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JfbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZW5pbmcgdGhlIGZpbGUgaGFzIGZhaWxlZC5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihlcnJvcl9tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBvdGhlciBydW50aW1lIGVycm9yIGhhcyBvY2N1cnJlZC5cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl9tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb3BlbkZpbGVJblRhYihmaWxlX3BhdGg6IHN0cmluZywgbmV3TGVhZjogUGFuZVR5cGUgfCBmYWxzZSwgY2FuX2NyZWF0ZV9maWxlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpbGUgZXhpc3RzIChvciBjYW4gYmUgY3JlYXRlZClcclxuICAgICAgICBjb25zdCBzb3VyY2VfcGF0aCA9IFwiXCI7IC8vIFRPRE86IFdoZW4gYWRkaW5nIGFuIG9wdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGZpbGVzLCByZWFkIHRoaXMgZG9jdW1lbnRhdGlvbiBmcm9tIE9ic2lkaWFuIEFQSSdzIGdldE5ld0ZpbGVQYXJlbnQoKTogXCJzb3VyY2VQYXRoIOKAkyBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBvcGVuL2ZvY3VzZWQgZmlsZSwgdXNlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIG5ldyBmaWxlcyB0byBiZSBjcmVhdGVkIOKAnGluIHRoZSBzYW1lIGZvbGRlcuKAnS4gVXNlIGFuIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBpcyBubyBhY3RpdmUgZmlsZS5cIlxyXG4gICAgICAgIGNvbnN0IGZpbGVfZXhpc3RzX29yX2Nhbl9iZV9jcmVhdGVkID0gY2FuX2NyZWF0ZV9maWxlIHx8IG51bGwgIT09IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZmlsZV9wYXRoLCBzb3VyY2VfcGF0aCk7XHJcbiAgICAgICAgaWYgKGZpbGVfZXhpc3RzX29yX2Nhbl9iZV9jcmVhdGVkKSB7XHJcbiAgICAgICAgICAgIC8vIFllcywgdGhlIGZpbGUgZXhpc3RzIChvciBjYW4gYmUgY3JlYXRlZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwLndvcmtzcGFjZS5vcGVuTGlua1RleHQoZmlsZV9wYXRoLCBzb3VyY2VfcGF0aCwgbmV3TGVhZik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8sIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LCBhbmQgaXQgbWF5IG5vdCBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJDYW5ub3Qgb3BlbiBmaWxlICdcIiArIGZpbGVfcGF0aCArIFwiJywgYXMgaXQgZG9lcyBub3QgZXhpc3QuIChJZiB5b3Ugd2FudCB0byBhbGxvdyBmaWxlIGNyZWF0aW9uLCBhZGQgOmNhbi1jcmVhdGUtZmlsZSB0byB0aGUgc2hlbGwgY29tbWFuZCBvdXRwdXQuKVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxfTm90aWZpY2F0aW9ufSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsX05vdGlmaWNhdGlvblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWwsIE91dHB1dENoYW5uZWxzfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsXCI7XHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbF9DdXJyZW50RmlsZUNhcmV0fSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlQ2FyZXRcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlVG9wfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlVG9wXCI7XHJcbmltcG9ydCB7XHJcbiAgICBPdXRwdXRDaGFubmVsQ29kZSxcclxuICAgIE91dHB1dENoYW5uZWxDb2RlcyxcclxuICAgIE91dHB1dEhhbmRsaW5nTW9kZSxcclxuICAgIE91dHB1dFN0cmVhbSxcclxufSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsQ29kZVwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxfU3RhdHVzQmFyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsX1N0YXR1c0JhclwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxfQ3VycmVudEZpbGVCb3R0b219IGZyb20gXCIuL091dHB1dENoYW5uZWxfQ3VycmVudEZpbGVCb3R0b21cIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsX0NsaXBib2FyZH0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbF9DbGlwYm9hcmRcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0LCBUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxfTW9kYWx9IGZyb20gXCIuL091dHB1dENoYW5uZWxfTW9kYWxcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsX09wZW5GaWxlc30gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbF9PcGVuRmlsZXNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0U3RyZWFtcyB7XHJcbiAgICBzdGRvdXQ/OiBzdHJpbmc7XHJcbiAgICBzdGRlcnI/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IG91dHB1dENoYW5uZWxDbGFzc2VzOiB7XHJcbiAgICBba2V5OiBzdHJpbmddOiB0eXBlb2YgT3V0cHV0Q2hhbm5lbDtcclxufSA9IHt9O1xyXG5cclxuLy8gUmVnaXN0ZXIgb3V0cHV0IGNoYW5uZWxzXHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbChcIm5vdGlmaWNhdGlvblwiLCBPdXRwdXRDaGFubmVsX05vdGlmaWNhdGlvbik7XHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbChcImN1cnJlbnQtZmlsZS1jYXJldFwiLCBPdXRwdXRDaGFubmVsX0N1cnJlbnRGaWxlQ2FyZXQpO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWwoXCJjdXJyZW50LWZpbGUtdG9wXCIsIE91dHB1dENoYW5uZWxfQ3VycmVudEZpbGVUb3ApO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWwoXCJjdXJyZW50LWZpbGUtYm90dG9tXCIsIE91dHB1dENoYW5uZWxfQ3VycmVudEZpbGVCb3R0b20pO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWwoXCJvcGVuLWZpbGVzXCIsIE91dHB1dENoYW5uZWxfT3BlbkZpbGVzKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsKFwic3RhdHVzLWJhclwiLCBPdXRwdXRDaGFubmVsX1N0YXR1c0Jhcik7XHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbChcImNsaXBib2FyZFwiLCBPdXRwdXRDaGFubmVsX0NsaXBib2FyZCk7XHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbChcIm1vZGFsXCIsIE91dHB1dENoYW5uZWxfTW9kYWwpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGEgJ1dhaXQgdW50aWwgZmluaXNoZWQnIHR5cGUgb2Ygc2hlbGwgY29tbWFuZCBmaW5pc2hlcyBpdHMgZXhlY3V0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmRcclxuICogQHBhcmFtIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHRcclxuICogQHBhcmFtIHN0ZG91dFxyXG4gKiBAcGFyYW0gc3RkZXJyXHJcbiAqIEBwYXJhbSBlcnJvcl9jb2RlIFRPRE86IFJlbmFtZSB0byBleGl0Q29kZSBldmVyeXdoZXJlIGluIHRoZSBjb2RlYmFzZS5cclxuICogQHBhcmFtIG91dHB1dF9jaGFubmVsc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUJ1ZmZlcmVkT3V0cHV0KFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCxcclxuICAgICAgICBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBTaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0LFxyXG4gICAgICAgIHN0ZG91dDogc3RyaW5nLFxyXG4gICAgICAgIHN0ZGVycjogc3RyaW5nLFxyXG4gICAgICAgIGVycm9yX2NvZGU6IG51bWJlciB8IG51bGwsXHJcbiAgICAgICAgb3V0cHV0X2NoYW5uZWxzOiBPdXRwdXRDaGFubmVsQ29kZXNcclxuICAgICk6IHZvaWQge1xyXG4gICAgLy8gVGVybWlub2xvZ3k6IFN0cmVhbSA9IG91dHB1dHMgc3RyZWFtIGZyb20gYSBjb21tYW5kLCBjYW4gYmUgXCJzdGRvdXRcIiBvciBcInN0ZGVyclwiLiBDaGFubmVsID0gYSBtZXRob2QgZm9yIHRoaXMgYXBwbGljYXRpb24gdG8gcHJlc2VudCB0aGUgb3V0cHV0IG90IHVzZXIsIGUuZy4gXCJub3RpZmljYXRpb25cIi5cclxuXHJcbiAgICBjb25zdCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gPSB0X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpOyAvLyBUT0RPOiBSZWZhY3RvciBPdXRwdXRDaGFubmVscyB0byB1c2UgVFNoZWxsQ29tbWFuZCBpbnN0ZWFkIG9mIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdHMgZGlyZWN0bHkuXHJcblxyXG4gICAgLy8gSW5zZXJ0IHN0ZG91dCBhbmQgc3RkZXJyIHRvIGFuIG9iamVjdCBpbiBhIGNvcnJlY3Qgb3JkZXJcclxuICAgIGxldCBvdXRwdXQ6IE91dHB1dFN0cmVhbXMgPSB7fTtcclxuICAgIGlmIChzdGRvdXQubGVuZ3RoICYmIHN0ZGVyci5sZW5ndGgpIHtcclxuICAgICAgICAvLyBCb3RoIHN0ZG91dCBhbmQgc3RkZXJyIGhhdmUgY29udGVudFxyXG4gICAgICAgIC8vIERlY2lkZSB0aGUgb3V0cHV0IG9yZGVyID09IEZpbmQgb3V0IHdoaWNoIGRhdGEgc3RyZWFtIHNob3VsZCBiZSBwcm9jZXNzZWQgZmlyc3QsIHN0ZG91dCBvciBzdGRlcnIuXHJcbiAgICAgICAgc3dpdGNoIChzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24ub3V0cHV0X2NoYW5uZWxfb3JkZXIpIHtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZG91dC1maXJzdFwiOlxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZG91dDogc3Rkb3V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZGVycjogc3RkZXJyLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RkZXJyLWZpcnN0XCI6XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RkZXJyOiBzdGRlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Rkb3V0OiBzdGRvdXQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzdGRvdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gT25seSBzdGRvdXQgaGFzIGNvbnRlbnRcclxuICAgICAgICBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIHN0ZG91dDogc3Rkb3V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHN0ZGVyci5sZW5ndGgpIHtcclxuICAgICAgICAvLyBPbmx5IHN0ZGVyciBoYXMgY29udGVudFxyXG4gICAgICAgIG91dHB1dCA9IHtcclxuICAgICAgICAgICAgc3RkZXJyOiBzdGRlcnIsXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTmVpdGhlciBzdGRvdXQgbm9yIHN0ZGVyciBoYXZlIGNvbnRlbnRcclxuICAgICAgICAvLyBQcm92aWRlIGVtcHR5IG91dHB1dCwgc29tZSBvdXRwdXQgY2hhbm5lbHMgd2lsbCBwcm9jZXNzIGl0LCB3aGlsZSBvdGhlciB3aWxsIGp1c3QgaWdub3JlIGl0LlxyXG4gICAgICAgIG91dHB1dCA9IHtcclxuICAgICAgICAgICAgXCJzdGRvdXRcIjogXCJcIixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNob3VsZCBzdGRlcnIgYmUgcHJvY2Vzc2VkIHNhbWUgdGltZSB3aXRoIHN0ZG91dD9cclxuICAgIGlmIChvdXRwdXRfY2hhbm5lbHMuc3Rkb3V0ID09PSBvdXRwdXRfY2hhbm5lbHMuc3RkZXJyKSB7XHJcbiAgICAgICAgLy8gU3Rkb3V0IGFuZCBzdGRlcnIgdXNlIHRoZSBzYW1lIGNoYW5uZWwuXHJcbiAgICAgICAgLy8gTWFrZSBvbmUgaGFuZGxpbmcgY2FsbC5cclxuICAgICAgICBoYW5kbGVfc3RyZWFtKFxyXG4gICAgICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCxcclxuICAgICAgICAgICAgb3V0cHV0X2NoYW5uZWxzLnN0ZG91dCxcclxuICAgICAgICAgICAgb3V0cHV0LFxyXG4gICAgICAgICAgICBlcnJvcl9jb2RlLFxyXG4gICAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFN0ZG91dCBhbmQgc3RkZXJyIHVzZSBkaWZmZXJlbnQgY2hhbm5lbHMuXHJcbiAgICAgICAgLy8gTWFrZSB0d28gaGFuZGxpbmcgY2FsbHMuXHJcbiAgICAgICAgbGV0IG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtO1xyXG4gICAgICAgIGZvciAob3V0cHV0X3N0cmVhbV9uYW1lIGluIG91dHB1dCkge1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXRfY2hhbm5lbF9uYW1lID0gb3V0cHV0X2NoYW5uZWxzW291dHB1dF9zdHJlYW1fbmFtZV07XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dF9tZXNzYWdlID0gb3V0cHV0W291dHB1dF9zdHJlYW1fbmFtZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRlZF9vdXRwdXQ6IE91dHB1dFN0cmVhbXMgPSB7fTtcclxuICAgICAgICAgICAgc2VwYXJhdGVkX291dHB1dFtvdXRwdXRfc3RyZWFtX25hbWVdID0gb3V0cHV0X21lc3NhZ2U7XHJcbiAgICAgICAgICAgIGhhbmRsZV9zdHJlYW0oXHJcbiAgICAgICAgICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgICAgICAgICB0X3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgICAgICAgICBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0X2NoYW5uZWxfbmFtZSxcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRlZF9vdXRwdXQsXHJcbiAgICAgICAgICAgICAgICBlcnJvcl9jb2RlLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZV9zdHJlYW0oXHJcbiAgICAgICAgcGx1Z2luOiBTQ19QbHVnaW4sXHJcbiAgICAgICAgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLFxyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQ6IFNoZWxsQ29tbWFuZFBhcnNpbmdSZXN1bHQsXHJcbiAgICAgICAgb3V0cHV0X2NoYW5uZWxfbmFtZTogT3V0cHV0Q2hhbm5lbENvZGUsXHJcbiAgICAgICAgb3V0cHV0OiBPdXRwdXRTdHJlYW1zLFxyXG4gICAgICAgIGVycm9yX2NvZGU6IG51bWJlcnxudWxsXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICBpZiAoXCJpZ25vcmVcIiAhPT0gb3V0cHV0X2NoYW5uZWxfbmFtZSkge1xyXG4gICAgICAgIC8vIFRoZSBvdXRwdXQgc2hvdWxkIG5vdCBiZSBpZ25vcmVkLlxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IGFuIG91dHB1dCBjaGFubmVsIGNsYXNzIGV4aXN0c1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG91dHB1dENoYW5uZWxDbGFzc2VzW291dHB1dF9jaGFubmVsX25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG91dHB1dCBjaGFubmVsIGNsYXNzIGZvdW5kIGZvciBjaGFubmVsICdcIiArIG91dHB1dF9jaGFubmVsX25hbWUgKyBcIicuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIGNoYW5uZWxcclxuICAgICAgICBjb25zdCBvdXRwdXRDaGFubmVsOiBPdXRwdXRDaGFubmVsID0gaW5pdGlhbGl6ZU91dHB1dENoYW5uZWwoXHJcbiAgICAgICAgICAgIG91dHB1dF9jaGFubmVsX25hbWUsXHJcbiAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgdF9zaGVsbF9jb21tYW5kLFxyXG4gICAgICAgICAgICBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LFxyXG4gICAgICAgICAgICBcImJ1ZmZlcmVkXCIsXHJcbiAgICAgICAgICAgIG51bGwsIC8vIFwiQnVmZmVyZWRcIiBvdXRwdXQgaGFuZGxpbmcgZG9lcyBub3QgdXNlIGEgdGVybWluYXRvciwgYXMgdGhlIHByb2Nlc3MgaGFzIGFscmVhZHkgZW5kZWQuXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSBoYW5kbGluZyB0aGUgb3V0cHV0XHJcbiAgICAgICAgYXdhaXQgb3V0cHV0Q2hhbm5lbC5oYW5kbGVCdWZmZXJlZChvdXRwdXQsIGVycm9yX2NvZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSZWFsdGltZU91dHB1dEhhbmRsaW5nKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHRTaGVsbENvbW1hbmQ6IFRTaGVsbENvbW1hbmQsXHJcbiAgICAgICAgc2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdDogU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCxcclxuICAgICAgICBvdXRwdXRDaGFubmVsQ29kZXM6IE91dHB1dENoYW5uZWxDb2RlcyxcclxuICAgICAgICBwcm9jZXNzVGVybWluYXRvcjogKCgpID0+IHZvaWQpIHwgbnVsbCxcclxuICAgICk6IE91dHB1dENoYW5uZWxzIHtcclxuXHJcbiAgICBjb25zdCBvdXRwdXRDaGFubmVsczogT3V0cHV0Q2hhbm5lbHMgPSB7fTtcclxuXHJcbiAgICAvLyBzdGRvdXRcclxuICAgIGlmIChcImlnbm9yZVwiICE9PSBvdXRwdXRDaGFubmVsQ29kZXMuc3Rkb3V0KSB7XHJcbiAgICAgICAgb3V0cHV0Q2hhbm5lbHMuc3Rkb3V0ID0gaW5pdGlhbGl6ZU91dHB1dENoYW5uZWwoXHJcbiAgICAgICAgICAgIG91dHB1dENoYW5uZWxDb2Rlcy5zdGRvdXQsXHJcbiAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgdFNoZWxsQ29tbWFuZCxcclxuICAgICAgICAgICAgc2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCxcclxuICAgICAgICAgICAgXCJyZWFsdGltZVwiLFxyXG4gICAgICAgICAgICBwcm9jZXNzVGVybWluYXRvcixcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0ZGVyclxyXG4gICAgaWYgKFwiaWdub3JlXCIgIT09IG91dHB1dENoYW5uZWxDb2Rlcy5zdGRlcnIpIHtcclxuICAgICAgICBpZiAob3V0cHV0Q2hhbm5lbENvZGVzLnN0ZGVyciA9PT0gb3V0cHV0Q2hhbm5lbENvZGVzLnN0ZG91dCkge1xyXG4gICAgICAgICAgICAvLyBzdGRlcnIgc2hvdWxkIHVzZSB0aGUgc2FtZSBjaGFubmVsIGluc3RhbmNlIGFzIHN0ZG91dC5cclxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbHMuc3RkZXJyID0gb3V0cHV0Q2hhbm5lbHMuc3Rkb3V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHN0ZGVyciB1c2VzIGEgZGlmZmVyZW50IGNoYW5uZWwgdGhhbiBzdGRvdXQuXHJcbiAgICAgICAgICAgIG91dHB1dENoYW5uZWxzLnN0ZGVyciA9IGluaXRpYWxpemVPdXRwdXRDaGFubmVsKFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbENvZGVzLnN0ZGVycixcclxuICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgIHRTaGVsbENvbW1hbmQsXHJcbiAgICAgICAgICAgICAgICBzaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgXCJyZWFsdGltZVwiLFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1Rlcm1pbmF0b3IsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXRDaGFubmVscztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE91dHB1dENoYW5uZWxzT3B0aW9uTGlzdChvdXRwdXRfc3RyZWFtOiBPdXRwdXRTdHJlYW0pIHtcclxuICAgIGNvbnN0IGxpc3Q6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XHJcbiAgICB9ID0ge2lnbm9yZTogXCJJZ25vcmVcIn07XHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3V0cHV0Q2hhbm5lbENsYXNzZXMpIHtcclxuICAgICAgICBjb25zdCBjaGFubmVsQ2xhc3M6IHR5cGVvZiBPdXRwdXRDaGFubmVsID0gb3V0cHV0Q2hhbm5lbENsYXNzZXNbbmFtZV07XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgc3RyZWFtIGlzIHN1aXRhYmxlIGZvciB0aGUgY2hhbm5lbFxyXG4gICAgICAgIGlmIChjaGFubmVsQ2xhc3MuYWNjZXB0c091dHB1dFN0cmVhbShvdXRwdXRfc3RyZWFtKSkge1xyXG4gICAgICAgICAgICBsaXN0W25hbWVdID0gY2hhbm5lbENsYXNzLmdldFRpdGxlKG91dHB1dF9zdHJlYW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsaXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3V0cHV0Q2hhbm5lbENsYXNzZXMoKSB7XHJcbiAgICByZXR1cm4gb3V0cHV0Q2hhbm5lbENsYXNzZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplT3V0cHV0Q2hhbm5lbChcclxuICAgICAgICBjaGFubmVsQ29kZTogT3V0cHV0Q2hhbm5lbENvZGUsXHJcbiAgICAgICAgcGx1Z2luOiBTQ19QbHVnaW4sXHJcbiAgICAgICAgdFNoZWxsQ29tbWFuZDogVFNoZWxsQ29tbWFuZCxcclxuICAgICAgICBzaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0OiBTaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0LFxyXG4gICAgICAgIG91dHB1dEhhbmRsaW5nTW9kZTogT3V0cHV0SGFuZGxpbmdNb2RlLFxyXG4gICAgICAgIHByb2Nlc3NUZXJtaW5hdG9yOiAoKCkgPT4gdm9pZCkgfCBudWxsLFxyXG4gICAgKTogT3V0cHV0Q2hhbm5lbCB7XHJcbiAgICAvLyBAdHMtaWdub3JlIFRPRE86IEZpbmQgb3V0IGhvdyB0byB0ZWxsIFR5cGVTY3JpcHQgdGhhdCBhIHN1YmNsYXNzIGlzIGJlaW5nIGluc3RhdGlhdGVkIGluc3RlYWQgb2YgdGhlIGFic3RyYWN0IGJhc2UgY2xhc3M6XHJcbiAgICByZXR1cm4gbmV3IG91dHB1dENoYW5uZWxDbGFzc2VzW2NoYW5uZWxDb2RlXShcclxuICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgdFNoZWxsQ29tbWFuZCxcclxuICAgICAgICBzaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0LFxyXG4gICAgICAgIG91dHB1dEhhbmRsaW5nTW9kZSxcclxuICAgICAgICBwcm9jZXNzVGVybWluYXRvcixcclxuICAgICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyT3V0cHV0Q2hhbm5lbChjaGFubmVsQ29kZTogT3V0cHV0Q2hhbm5lbENvZGUsIGNoYW5uZWxDbGFzczogdHlwZW9mIE91dHB1dENoYW5uZWwpIHtcclxuICAgIGlmICh1bmRlZmluZWQgIT09IG91dHB1dENoYW5uZWxDbGFzc2VzW2NoYW5uZWxDb2RlXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dHB1dENoYW5uZWwgbmFtZWQgJ1wiICsgY2hhbm5lbENvZGUgKyBcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkIVwiKTtcclxuICAgIH1cclxuICAgIG91dHB1dENoYW5uZWxDbGFzc2VzW2NoYW5uZWxDb2RlXSA9IGNoYW5uZWxDbGFzcztcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7ZXh0cmFjdEZpbGVOYW1lLCBnZXRPcGVyYXRpbmdTeXN0ZW0sIGlzV2luZG93c30gZnJvbSBcIi4vQ29tbW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUGxhdGZvcm1TaGVsbHMgPSB7XHJcbiAgICBkYXJ3aW46IHtcclxuICAgICAgICBcIi9iaW4vYmFzaFwiOiBcIkJhc2hcIixcclxuICAgICAgICBcIi9iaW4vZGFzaFwiOiBcIkRhc2hcIixcclxuICAgICAgICBcIi9iaW4venNoXCI6IFwiWnNoIChaIHNoZWxsKVwiLFxyXG4gICAgfSxcclxuICAgIGxpbnV4OiB7XHJcbiAgICAgICAgXCIvYmluL2Jhc2hcIjogXCJCYXNoXCIsXHJcbiAgICAgICAgXCIvYmluL2Rhc2hcIjogXCJEYXNoXCIsXHJcbiAgICAgICAgXCIvYmluL3pzaFwiOiBcIlpzaCAoWiBzaGVsbClcIixcclxuICAgIH0sXHJcbiAgICB3aW4zMjoge1xyXG4gICAgICAgIFwicHdzaC5leGVcIjogXCJQb3dlclNoZWxsIENvcmVcIixcclxuICAgICAgICBcIlBvd2VyU2hlbGwuZXhlXCI6IFwiUG93ZXJTaGVsbCA1XCIsXHJcbiAgICAgICAgXCJDTUQuRVhFXCI6IFwiY21kLmV4ZVwiLFxyXG4gICAgfSxcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJzRGVmYXVsdFNoZWxsKCk6IHN0cmluZyB7XHJcbiAgICBpZiAoaXNXaW5kb3dzKCkpIHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQ29tU3BlYztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LlNIRUxMO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNTaGVsbFN1cHBvcnRlZChzaGVsbDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzaGVsbF9maWxlX25hbWUgPSBleHRyYWN0RmlsZU5hbWUoc2hlbGwpO1xyXG4gICAgY29uc3Qgc3VwcG9ydGVkX3NoZWxscyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFBsYXRmb3JtU2hlbGxzW2dldE9wZXJhdGluZ1N5c3RlbSgpXSk7XHJcblxyXG4gICAgLy8gTGludXggYW5kIG1hY09TOiBBZGQgdGhlIGFtYmlndW91cyAnc2gnIGFzIGEgc3VwcG9ydGVkIHNoZWxsLiBJdCdzIG5vdCBwcmVzZW50IGluIFBsYXRmb3JtU2hlbGxzLCBiZWNhdXNlIGl0J3NcclxuICAgIC8vIG5vdCBkZXNpcmVkIHRvIGJlIGFuIGV4cGxpY2l0bHkgc2VsZWN0YWJsZSBzaGVsbCBhcyBpdCdzIHVuY2VydGFpbiwgd2hpY2ggc2hlbGwgaXQgYWN0dWFsbHkgcG9pbnRzIHRvLiBCdXQgaGF2ZVxyXG4gICAgLy8gaXQgc3VwcG9ydGVkIHdoZW4gaXQgY29tZXMgZnJvbSB0aGUgXCJVc2Ugc3lzdGVtIGRlZmF1bHQgKHNoKVwiIG9wdGlvbi5cclxuICAgIGlmICghaXNXaW5kb3dzKCkpIHtcclxuICAgICAgICAvLyBUaGUgcGxhdGZvcm0gaXMgZWl0aGVyIExpbnV4IG9yIG1hY09TLlxyXG4gICAgICAgIC8vIEFkZCAnc2gnIHN1cHBvcnQuXHJcbiAgICAgICAgc3VwcG9ydGVkX3NoZWxscy5wdXNoKFwic2hcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBzdXBwb3J0ZWRfc2hlbGxfcGF0aCBvZiBzdXBwb3J0ZWRfc2hlbGxzKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgc2hlbGwgZmlsZSBuYW1lcyBtYXRjaC4gSXQgZG9lc24ndCBtYXR0ZXIgaW4gd2hpY2ggZGlyZWN0b3J5IHRoZSBzaGVsbCBpcyBsb2NhdGVkIGluLlxyXG4gICAgICAgIGlmIChleHRyYWN0RmlsZU5hbWUoc3VwcG9ydGVkX3NoZWxsX3BhdGgpLnRvTG93ZXJDYXNlKCkgPT09IHNoZWxsX2ZpbGVfbmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaGVsbCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbi8vIFNFVFRJTkdTIEFORCBERUZBVUxUIFZBTFVFU1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb259IGZyb20gXCIuL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1xyXG4gICAgQ3VzdG9tVmFyaWFibGVDb25maWd1cmF0aW9uLFxyXG4gICAgUHJvbXB0Q29uZmlndXJhdGlvbixcclxufSBmcm9tIFwiLi4vaW1wb3J0c1wiO1xyXG5pbXBvcnQge091dHB1dFdyYXBwZXJDb25maWd1cmF0aW9ufSBmcm9tIFwiLi4vbW9kZWxzL291dHB1dF93cmFwcGVyL091dHB1dFdyYXBwZXJcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFNldHRpbmdzVmVyc2lvblN0cmluZyA9IFwicHJpb3ItdG8tMC43LjBcIiB8IHN0cmluZztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU0NfTWFpblNldHRpbmdzIHtcclxuXHJcbiAgICAvLyBDb21tb246XHJcbiAgICBzZXR0aW5nc192ZXJzaW9uOiBTZXR0aW5nc1ZlcnNpb25TdHJpbmc7XHJcblxyXG4gICAgLy8gSGlkZGVuIHNldHRpbmdzIChubyBVSSBjb250cm9scyBpbiB0aGUgc2V0dGluZ3MgcGFuZWwpXHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUsIGxvZ2dpbmcgc3R1ZmYgdG8gY29uc29sZS5sb2coKSB3aWxsIGJlIGVuYWJsZWQuXHJcbiAgICAgKiBNaWdodCBhbHNvIGVuYWJsZSBzb21lIHRlc3Rpbmcge3t2YXJpYWJsZXN9fSBpbiB0aGUgZnV0dXJlLCBwZXJoYXBzLlxyXG4gICAgICovXHJcbiAgICBkZWJ1ZzogYm9vbGVhbjtcclxuICAgIG9ic2lkaWFuX2NvbW1hbmRfcGFsZXR0ZV9wcmVmaXg6IHN0cmluZztcclxuXHJcbiAgICAvLyBWYXJpYWJsZXM6XHJcbiAgICBwcmV2aWV3X3ZhcmlhYmxlc19pbl9jb21tYW5kX3BhbGV0dGU6IGJvb2xlYW47XHJcbiAgICBzaG93X2F1dG9jb21wbGV0ZV9tZW51OiBib29sZWFuO1xyXG5cclxuICAgIC8vIEVudmlyb25tZW50czpcclxuICAgIHdvcmtpbmdfZGlyZWN0b3J5OiBzdHJpbmc7XHJcbiAgICBkZWZhdWx0X3NoZWxsczogSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmc7XHJcbiAgICBlbnZpcm9ubWVudF92YXJpYWJsZV9wYXRoX2F1Z21lbnRhdGlvbnM6IElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nO1xyXG5cclxuICAgIC8vIE91dHB1dDpcclxuICAgIGVycm9yX21lc3NhZ2VfZHVyYXRpb246IG51bWJlcjtcclxuICAgIG5vdGlmaWNhdGlvbl9tZXNzYWdlX2R1cmF0aW9uOiBudW1iZXI7XHJcbiAgICBleGVjdXRpb25fbm90aWZpY2F0aW9uX21vZGU6IEV4ZWN1dGlvbk5vdGlmaWNhdGlvbk1vZGU7XHJcbiAgICBvdXRwdXRfY2hhbm5lbF9jbGlwYm9hcmRfYWxzb19vdXRwdXRzX3RvX25vdGlmaWNhdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBFdmVudHM6XHJcbiAgICBlbmFibGVfZXZlbnRzOiBib29sZWFuO1xyXG5cclxuICAgIC8vIE1vZGFsczpcclxuICAgIGFwcHJvdmVfbW9kYWxzX2J5X3ByZXNzaW5nX2VudGVyX2tleTogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBTaGVsbCBjb21tYW5kczpcclxuICAgIC8qKiBJZiBpdCdzIGEgbnVtYmVyLCBsaW1pdCB0aGUgbWF4IGhlaWdodCBvZiBhIHRleHRhcmVhLiBJZiBpdCdzIGZhbHNlLCBkb24ndCBsaW1pdCBhdCBhbGwuICovXHJcbiAgICBtYXhfdmlzaWJsZV9saW5lc19pbl9zaGVsbF9jb21tYW5kX2ZpZWxkczogbnVtYmVyIHwgZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXYXMgYmVmb3JlIDAuMTUuMDogQW4gb2JqZWN0IHdoZXJlIHRoZSBrZXkgd2FzIGFuIGlkIGFuZCB2YWx1ZSB3YXMgYSBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgICAqIE5vdyBpdCdzIGFuIGFycmF5IG9mIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24gb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgc2hlbGxfY29tbWFuZHM6IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25bXTtcclxuXHJcbiAgICAvLyBQcm9tcHRzOlxyXG4gICAgcHJvbXB0czogUHJvbXB0Q29uZmlndXJhdGlvbltdO1xyXG5cclxuICAgIC8vIEN1c3RvbSB2YXJpYWJsZXNcclxuICAgIGN1c3RvbV92YXJpYWJsZXM6IEN1c3RvbVZhcmlhYmxlQ29uZmlndXJhdGlvbltdO1xyXG5cclxuICAgIC8vIE91dHB1dCB3cmFwcGVyc1xyXG4gICAgb3V0cHV0X3dyYXBwZXJzOiBPdXRwdXRXcmFwcGVyQ29uZmlndXJhdGlvbltdO1xyXG5cclxuICAgIC8vIExlZ2FjeTpcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2Ugc2hlbGxfY29tbWFuZHMgb2JqZWN0IGluc3RlYWQgb2YgdGhpcyBhcnJheS4gRnJvbSBub3cgb24sIHRoaXMgYXJyYXkgY2FuIGJlIHVzZWQgb25seSBmb3IgbWlncmF0aW5nIG9sZCBjb25maWd1cmF0aW9uIHRvIHNoZWxsX2NvbW1hbmRzLiovXHJcbiAgICBjb21tYW5kcz86IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFNldHRpbmdzKGlzX25ld19pbnN0YWxsYXRpb246IGJvb2xlYW4pOiBTQ19NYWluU2V0dGluZ3Mge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBDb21tb246XHJcbiAgICAgICAgc2V0dGluZ3NfdmVyc2lvbjogaXNfbmV3X2luc3RhbGxhdGlvblxyXG4gICAgICAgICAgICA/IFNDX1BsdWdpbi5TZXR0aW5nc1ZlcnNpb24gLy8gRm9yIG5ldyBpbnN0YWxsYXRpb25zLCBhIHNwZWNpZmljIHNldHRpbmdzIHZlcnNpb24gbnVtYmVyIGNhbiBiZSB1c2VkLCBhcyBtaWdyYXRpb25zIGRvIG5vdCBuZWVkIHRvIGJlIHRha2VuIGludG8gYWNjb3VudC5cclxuICAgICAgICAgICAgOiBcInByaW9yLXRvLTAuNy4wXCIgIC8vIFRoaXMgd2lsbCBiZSBzdWJzdGl0dXRlZCBieSBTaGVsbENvbW1hbmRzUGx1Z2luLnNhdmVTZXR0aW5ncygpIHdoZW4gdGhlIHNldHRpbmdzIGFyZSBzYXZlZC5cclxuICAgICAgICAsXHJcblxyXG4gICAgICAgIC8vIEhpZGRlbiBzZXR0aW5ncyAobm8gVUkgY29udHJvbHMgaW4gdGhlIHNldHRpbmdzIHBhbmVsKVxyXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcclxuICAgICAgICBvYnNpZGlhbl9jb21tYW5kX3BhbGV0dGVfcHJlZml4OiBcIkV4ZWN1dGU6IFwiLFxyXG5cclxuICAgICAgICAvLyBWYXJpYWJsZXM6XHJcbiAgICAgICAgcHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlOiB0cnVlLFxyXG4gICAgICAgIHNob3dfYXV0b2NvbXBsZXRlX21lbnU6IHRydWUsXHJcblxyXG4gICAgICAgIC8vIEVudmlyb25tZW50czpcclxuICAgICAgICB3b3JraW5nX2RpcmVjdG9yeTogXCJcIixcclxuICAgICAgICBkZWZhdWx0X3NoZWxsczoge30sXHJcbiAgICAgICAgZW52aXJvbm1lbnRfdmFyaWFibGVfcGF0aF9hdWdtZW50YXRpb25zOiB7fSxcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0OlxyXG4gICAgICAgIGVycm9yX21lc3NhZ2VfZHVyYXRpb246IDIwLFxyXG4gICAgICAgIG5vdGlmaWNhdGlvbl9tZXNzYWdlX2R1cmF0aW9uOiAxMCxcclxuICAgICAgICBleGVjdXRpb25fbm90aWZpY2F0aW9uX21vZGU6IFwiZGlzYWJsZWRcIixcclxuICAgICAgICBvdXRwdXRfY2hhbm5lbF9jbGlwYm9hcmRfYWxzb19vdXRwdXRzX3RvX25vdGlmaWNhdGlvbjogdHJ1ZSxcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzOlxyXG4gICAgICAgIGVuYWJsZV9ldmVudHM6IHRydWUsXHJcblxyXG4gICAgICAgIC8vIE1vZGFsczpcclxuICAgICAgICBhcHByb3ZlX21vZGFsc19ieV9wcmVzc2luZ19lbnRlcl9rZXk6IHRydWUsXHJcblxyXG4gICAgICAgIC8vIFNoZWxsIGNvbW1hbmRzOlxyXG4gICAgICAgIG1heF92aXNpYmxlX2xpbmVzX2luX3NoZWxsX2NvbW1hbmRfZmllbGRzOiBmYWxzZSwgLy8gTm8gbGltaXQgYnkgZGVmYXVsdC5cclxuICAgICAgICBzaGVsbF9jb21tYW5kczogW10sXHJcblxyXG4gICAgICAgIC8vIFByb21wdHM6XHJcbiAgICAgICAgcHJvbXB0czogW10sXHJcblxyXG4gICAgICAgIC8vIEN1c3RvbSB2YXJpYWJsZXNcclxuICAgICAgICBjdXN0b21fdmFyaWFibGVzOiBbXSxcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0IHdyYXBwZXJzXHJcbiAgICAgICAgb3V0cHV0X3dyYXBwZXJzOiBbXSxcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbCBPU2VzIHN1cHBvcnRlZCBieSB0aGUgU2hlbGwgY29tbWFuZHMgcGx1Z2luLlxyXG4gKiBWYWx1ZXMgYXJlIGJvcnJvd2VkIGZyb20gTm9kZUpTLlBsYXRmb3JtLlxyXG4gKiBcImRhcndpblwiID0gTWFjaW50b3NoLlxyXG4gKlxyXG4gKiBUaGlzIHR5cGUgbXVzdCBiZSBzeW5jaHJvbm91cyB0byBJT3BlcmF0aW5nU3lzdGVtU3BlY2lmaWNTdHJpbmcgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBAc2VlIE5vZGVKUy5QbGF0Zm9ybVxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUGxhdGZvcm1JZCA9IFwiZGFyd2luXCIgfCBcImxpbnV4XCIgfCBcIndpbjMyXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUGxhdGZvcm1OYW1lczogSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmcgPSB7XHJcbiAgICBkYXJ3aW46IFwiTWFjaW50b3NoXCIsXHJcbiAgICBsaW51eDogXCJMaW51eFwiLFxyXG4gICAgd2luMzI6IFwiV2luZG93c1wiLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsbCBPU2VzIHN1cHBvcnRlZCBieSB0aGUgU2hlbGwgY29tbWFuZHMgcGx1Z2luLlxyXG4gKiBWYWx1ZXMgYXJlIGJvcnJvd2VkIGZyb20gTm9kZUpTLlBsYXRmb3JtLlxyXG4gKlxyXG4gKiBUaGlzIGludGVyZmFjZSBtdXN0IGJlIHN5bmNocm9ub3VzIHRvIE9wZXJhdGluZ1N5c3RlbU5hbWUgdHlwZS5cclxuICpcclxuICogQHNlZSBOb2RlSlMuUGxhdGZvcm1cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmcge1xyXG4gICAgLyoqIFRoaXMgaXMgTWFjaW50b3NoICovXHJcbiAgICBkYXJ3aW4/OiBzdHJpbmcsXHJcbiAgICBsaW51eD86IHN0cmluZyxcclxuICAgIHdpbjMyPzogc3RyaW5nLFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nV2l0aERlZmF1bHQgZXh0ZW5kcyBJUGxhdGZvcm1TcGVjaWZpY1N0cmluZ3tcclxuICAgIGRlZmF1bHQ6IHN0cmluZyxcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgSUNvbW1hbmRQYWxldHRlT3B0aW9ucyA9IHtcclxuICAgIGVuYWJsZWQ6IHN0cmluZztcclxuICAgIHVubGlzdGVkOiBzdHJpbmc7XHJcbiAgICBkaXNhYmxlZDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgQ29tbWFuZFBhbGV0dGVPcHRpb25zOiBJQ29tbWFuZFBhbGV0dGVPcHRpb25zID0ge1xyXG4gICAgZW5hYmxlZDogXCJDb21tYW5kIHBhbGV0dGUgJiBob3RrZXlzXCIsXHJcbiAgICB1bmxpc3RlZDogXCJIb3RrZXlzIG9ubHlcIixcclxuICAgIGRpc2FibGVkOiBcIkV4Y2x1ZGVkXCIsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEV4ZWN1dGlvbk5vdGlmaWNhdGlvbk1vZGUgPSBcImRpc2FibGVkXCIgfCBcInF1aWNrXCIgfCBcInBlcm1hbmVudFwiIHwgXCJpZi1sb25nXCI7IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICAgIENoaWxkUHJvY2VzcyxcclxuICAgIHNwYXduLFxyXG4gICAgU3Bhd25PcHRpb25zLFxyXG59IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBjbG9uZU9iamVjdCxcclxuICAgIGdldE9wZXJhdGluZ1N5c3RlbSxcclxuICAgIGdldFZhdWx0QWJzb2x1dGVQYXRoLFxyXG59IGZyb20gXCIuL0NvbW1vblwiO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgaGFuZGxlQnVmZmVyZWRPdXRwdXQsXHJcbiAgICBzdGFydFJlYWx0aW1lT3V0cHV0SGFuZGxpbmcsXHJcbn0gZnJvbSBcIi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcywgU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCwgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge2lzU2hlbGxTdXBwb3J0ZWR9IGZyb20gXCIuL1NoZWxsXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuL0RlYnVnXCI7XHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge1xyXG4gICAgQ29uZmlybWF0aW9uTW9kYWwsXHJcbiAgICBjb252ZXJ0TmV3bGluZXNUb1BBVEhTZXBhcmF0b3JzLFxyXG4gICAgZ2V0UEFUSEVudmlyb25tZW50VmFyaWFibGVOYW1lLFxyXG4gICAgZ2V0UEFUSFNlcGFyYXRvcixcclxuICAgIFByZWFjdGlvbixcclxufSBmcm9tIFwiLi9pbXBvcnRzXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5pbXBvcnQge1xyXG4gICAgRXhlY3V0aW9uTm90aWZpY2F0aW9uTW9kZSxcclxuICAgIFBsYXRmb3JtTmFtZXMsXHJcbn0gZnJvbSBcIi4vc2V0dGluZ3MvU0NfTWFpblNldHRpbmdzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBPdXRwdXRDaGFubmVsQ29kZSxcclxuICAgIE91dHB1dENoYW5uZWxDb2RlcyxcclxuICAgIE91dHB1dFN0cmVhbSxcclxufSBmcm9tIFwiLi9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbENvZGVcIjtcclxuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSBcInN0cmVhbVwiO1xyXG5pbXBvcnQge05vdGljZX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbH0gZnJvbSBcIi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTaGVsbENvbW1hbmRFeGVjdXRvciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBwcml2YXRlIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCxcclxuXHJcbiAgICAgICAgLyoqIE5lZWRlZCBmb3IgUHJlYWN0aW9ucyB0byBiZSBhYmxlIHRvIGFjY2VzcyBhbGwgdmFyaWFibGVzLCBpbiBjYXNlIGFueSB2YXJpYWJsZXMgYXJlIHVzZWQgYnkgYSBQcmVhY3Rpb24uIFVzZSBudWxsLCBpZiB0aGUgc2hlbGwgY29tbWFuZCBleGVjdXRpb24gaGFwcGVucyBvdXRzaWRlIG9mIGFueSBldmVudCBjb250ZXh0LiAqL1xyXG4gICAgICAgIHByaXZhdGUgc2NfZXZlbnQ6IFNDX0V2ZW50IHwgbnVsbCxcclxuICAgICkge31cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIHByZWFjdGlvbnMsIGFuZCBpZiB0aGV5IGFsbCBnaXZlIHJlc29sdmVkIFByb21pc2VzLCBleGVjdXRlcyB0aGUgc2hlbGwgY29tbWFuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGRvUHJlYWN0aW9uc0FuZEV4ZWN1dGVTaGVsbENvbW1hbmQocGFyc2luZ19wcm9jZXNzPzogU2hlbGxDb21tYW5kUGFyc2luZ1Byb2Nlc3MsIG92ZXJyaWRpbmdfb3V0cHV0X2NoYW5uZWw/OiBPdXRwdXRDaGFubmVsQ29kZSkge1xyXG4gICAgICAgIGNvbnN0IHByZWFjdGlvbnMgPSB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRQcmVhY3Rpb25zKCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgYW4gYWxyZWFkeSBzdGFydGVkIFBhcnNpbmdQcm9jZXNzIGV4aXN0P1xyXG4gICAgICAgIGlmICghcGFyc2luZ19wcm9jZXNzKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIFBhcnNpbmdQcm9jZXNzIHlldC5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIG9uZSBhbmQgcGFyc2UgYWxsIHZhcmlhYmxlcyB0aGF0IGFyZSBzYWZlIHRvIHBhcnNlIGJlZm9yZSBwcmVhY3Rpb25zLlxyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIkdvaW5nIHRvIHByZXBhcmUgcG9zc2libGUgUHJlYWN0aW9ucywgYnV0IHdpbGwgZmlyc3Qgc3RhcnQgYSB2YXJpYWJsZSBwYXJzaW5nIHByb2Nlc3MuIERlcGVuZGluZyBvbiBwb3NzaWJsZSBQcmVhY3Rpb25zLCB0aGlzIG1pZ2h0IG5vdCB5ZXQgcGFyc2UgYWxsIHZhcmlhYmxlcy5cIik7XHJcbiAgICAgICAgICAgIHBhcnNpbmdfcHJvY2VzcyA9IHRoaXMudF9zaGVsbF9jb21tYW5kLmNyZWF0ZVBhcnNpbmdQcm9jZXNzKHRoaXMuc2NfZXZlbnQpO1xyXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgZmlyc3Qgc2V0IG9mIHZhcmlhYmxlcywgbm90IGFsbCBzZXRzLlxyXG4gICAgICAgICAgICBpZiAoIWF3YWl0IHBhcnNpbmdfcHJvY2Vzcy5wcm9jZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgZXJyb3JzIGhhcHBlbmVkLlxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJXaWxsIG5vdCBwcmVwYXJlIHBvc3NpYmxlIFByZWFjdGlvbnMsIGJlY2F1c2UgdGhlIHBhcnNpbmcgcHJvY2VzcyBmYWlsZWQuIFdpbGwgY2FuY2VsIHNoZWxsIGNvbW1hbmQgZXhlY3V0aW9uLlwiKTtcclxuICAgICAgICAgICAgICAgIHBhcnNpbmdfcHJvY2Vzcy5kaXNwbGF5RXJyb3JNZXNzYWdlcygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVidWdMb2coXCJHb2luZyB0byBwcmVwYXJlIHBvc3NpYmxlIFByZWFjdGlvbnMgd2l0aCBhbiBhbHJlYWR5IHN0YXJ0ZWQgdmFyaWFibGUgcGFyc2luZyBwcm9jZXNzLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHBpcGVsaW5lIGZvciBwcmVhY3Rpb25zLlxyXG4gICAgICAgIGxldCBwcmVhY3Rpb25fcGlwZWxpbmUgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IC8vIFdpbGwgY29udGFpbiBhIHNlcmllcyBvZiBwcmVhY3Rpb24gcGVyZm9ybXMuXHJcblxyXG4gICAgICAgIC8vIENvbmZpcm0gZXhlY3V0aW9uIGZyb20gYSB1c2VyLCBpZiBuZWVkZWQuXHJcbiAgICAgICAgLy8gSSBoYXZlbid0IGRlY2lkZWQgeWV0IGlmIEkgd2FudCB0byBtb3ZlIHRoaXMgdG8gYmUgaXRzIG93biBQcmVhY3Rpb24gc3ViY2xhc3MuIE1pZ2h0IG1ha2Ugc2Vuc2UsIGJ1dCByZXF1aXJlcyBjb25maWd1cmF0aW9uIG1pZ3JhdGlvbi5cclxuICAgICAgICBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmNvbmZpcm1fZXhlY3V0aW9uKSB7XHJcbiAgICAgICAgICAgIHByZWFjdGlvbl9waXBlbGluZSA9IHByZWFjdGlvbl9waXBlbGluZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQXNraW5nIGEgY29uZmlybWF0aW9uIGZyb20gYSB1c2VyIHRvIGV4ZWN1dGUgc2hlbGwgY29tbWFuZCAjXCIgKyB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRJZCgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWF0aW9uX21vZGFsID0gbmV3IENvbmZpcm1hdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXNPclNoZWxsQ29tbWFuZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkV4ZWN1dGUgdGhpcyBzaGVsbCBjb21tYW5kP1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlllcywgZXhlY3V0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uX21vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25fbW9kYWwucHJvbWlzZS50aGVuKChleGVjdXRpb25fY29uZmlybWVkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGVjdXRpb25fY29uZmlybWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgUHJvbXB0TW9kYWwgaGFzIGJlZW4gY2xvc2VkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciB3YW50ZWQgdG8gZXhlY3V0ZSB0aGUgc2hlbGwgY29tbWFuZCBvciBjYW5jZWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uX2NvbmZpcm1lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgd2FudHMgdG8gZXhlY3V0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIlVzZXIgY29uZmlybWVkIHRvIGV4ZWN1dGUgc2hlbGwgY29tbWFuZCAjXCIgKyB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRJZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIHdhbnRzIHRvIGNhbmNlbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIlVzZXIgY2FuY2VsbGVkIGV4ZWN1dGlvbiBvZiBzaGVsbCBjb21tYW5kICNcIiArIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldElkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSBwcmVhY3Rpb25zXHJcbiAgICAgICAgcHJlYWN0aW9ucy5mb3JFYWNoKChwcmVhY3Rpb246IFByZWFjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhgQWRkaW5nIFByZWFjdGlvbiBvZiB0eXBlICcke3ByZWFjdGlvbi5jb25maWd1cmF0aW9uLnR5cGV9JyB0byBwaXBlbGluZS5gKTtcclxuICAgICAgICAgICAgcHJlYWN0aW9uX3BpcGVsaW5lID0gcHJlYWN0aW9uX3BpcGVsaW5lLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coYENhbGxpbmcgUHJlYWN0aW9uIG9mIHR5cGUgJyR7cHJlYWN0aW9uLmNvbmZpZ3VyYXRpb24udHlwZX0nLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWFjdGlvbi5wZXJmb3JtKHBhcnNpbmdfcHJvY2VzcywgdGhpcy5zY19ldmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICgwID09PSBwcmVhY3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIk5vIFByZWFjdGlvbnMgdG8gcGVyZm9ybS4gVGhpcyBpcyBvay5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmVhY3Rpb25fcGlwZWxpbmUudGhlbihhc3luYyAoY2FuX2V4ZWN1dGU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhbl9leGVjdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBlaXRoZXIgYWxsIHZhcmlhYmxlcywgb3IgaWYgc29tZSB2YXJpYWJsZXMgYXJlIGFscmVhZHkgcGFyc2VkLCB0aGVuIGp1c3QgdGhlIHJlc3QuIE1pZ2h0IGFsc28gYmUgdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gYWxsIHZhcmlhYmxlcyBhcmUgYWxyZWFkeSBwYXJzZWQuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIlBhcnNpbmcgYWxsIHRoZSByZXN0IG9mIHRoZSB2YXJpYWJsZXMgKGlmIHRoZXJlIGFyZSBhbnkgbGVmdCkuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IHBhcnNpbmdfcHJvY2Vzcy5wcm9jZXNzUmVzdCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2luZyB0aGUgcmVzdCBvZiB0aGUgdmFyaWFibGVzIHN1Y2NlZWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIHNoZWxsIGNvbW1hbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2luZ19yZXN1bHRzID0gcGFyc2luZ19wcm9jZXNzLmdldFBhcnNpbmdSZXN1bHRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZDogcGFyc2luZ19yZXN1bHRzW1wic2hlbGxfY29tbWFuZFwiXS5wYXJzZWRfY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IHBhcnNpbmdfcmVzdWx0c1tcImFsaWFzXCJdLnBhcnNlZF9jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudF92YXJpYWJsZV9wYXRoX2F1Z21lbnRhdGlvbjogcGFyc2luZ19yZXN1bHRzLmVudmlyb25tZW50X3ZhcmlhYmxlX3BhdGhfYXVnbWVudGF0aW9uLnBhcnNlZF9jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfd3JhcHBlcl9zdGRvdXQ6IHBhcnNpbmdfcmVzdWx0cy5vdXRwdXRfd3JhcHBlcl9zdGRvdXQucGFyc2VkX2NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF93cmFwcGVyX3N0ZGVycjogcGFyc2luZ19yZXN1bHRzLm91dHB1dF93cmFwcGVyX3N0ZGVyci5wYXJzZWRfY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VlZGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIldpbGwgY2FsbCBTaGVsbENvbW1hbmRFeGVjdXRvci5leGVjdXRlU2hlbGxDb21tYW5kKCkuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVNoZWxsQ29tbWFuZChzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LCBvdmVycmlkaW5nX291dHB1dF9jaGFubmVsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2luZyBoYXMgZmFpbGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiUGFyc2luZyB0aGUgcmVzdCBvZiB0aGUgdmFyaWFibGVzIGZhaWxlZC5cIilcclxuICAgICAgICAgICAgICAgICAgICBwYXJzaW5nX3Byb2Nlc3MuZGlzcGxheUVycm9yTWVzc2FnZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbmNlbCBleGVjdXRpb25cclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiU2hlbGwgY29tbWFuZCBleGVjdXRpb24gY2FuY2VsbGVkLlwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERvZXMgbm90IGFzayBmb3IgY29uZmlybWF0aW9uIGJlZm9yZSBleGVjdXRpb24uIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmOiBhKSBhIGNvbmZpcm1hdGlvbiBpcyBhbHJlYWR5IGFza2VkIGZyb20gYSB1c2VyLCBvciBiKSB0aGlzIGNvbW1hbmQgaXMgZGVmaW5lZCBub3QgdG8gbmVlZCBhIGNvbmZpcm1hdGlvbi5cclxuICAgICAqIFVzZSBjb25maXJtQW5kRXhlY3V0ZVNoZWxsQ29tbWFuZCgpIGluc3RlYWQgdG8gaGF2ZSBhIGNvbmZpcm1hdGlvbiBhc2tlZCBiZWZvcmUgdGhlIGV4ZWN1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCBUaGUgYWN0dWFsIHNoZWxsIGNvbW1hbmQgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGlzIHRha2VuIGZyb20gdGhpcyBvYmplY3QncyAnLnNoZWxsX2NvbW1hbmQnIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIG92ZXJyaWRpbmdfb3V0cHV0X2NoYW5uZWwgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgYWxsIG91dHB1dCBzdHJlYW1zIHdpbGwgYmUgZGlyZWN0ZWQgdG8gdGhpcyBvdXRwdXQgY2hhbm5lbC4gT3RoZXJ3aXNlLCBvdXRwdXQgY2hhbm5lbHMgYXJlIGRldGVybWluZWQgZnJvbSB0aGlzLnRfc2hlbGxfY29tbWFuZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBleGVjdXRlU2hlbGxDb21tYW5kKHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQ6IFNoZWxsQ29tbWFuZFBhcnNpbmdSZXN1bHQsIG92ZXJyaWRpbmdfb3V0cHV0X2NoYW5uZWw/OiBPdXRwdXRDaGFubmVsQ29kZSkge1xyXG4gICAgICAgIGNvbnN0IHdvcmtpbmdfZGlyZWN0b3J5ID0gdGhpcy5nZXRXb3JraW5nRGlyZWN0b3J5KCk7XHJcblxyXG4gICAgICAgIC8vIERlZmluZSBvdXRwdXQgY2hhbm5lbHNcclxuICAgICAgICBsZXQgb3V0cHV0Q2hhbm5lbHMgPSB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRPdXRwdXRDaGFubmVscygpO1xyXG4gICAgICAgIGlmIChvdmVycmlkaW5nX291dHB1dF9jaGFubmVsKSB7XHJcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgc2hlbGwgY29tbWFuZCdzIG5vcm1hbCBjaGFubmVscyBhbmQgdXNlIHRlbXBvcmFyaWx5IHNvbWV0aGluZyBlbHNlLlxyXG4gICAgICAgICAgIG91dHB1dENoYW5uZWxzID0ge1xyXG4gICAgICAgICAgICAgICAnc3Rkb3V0Jzogb3ZlcnJpZGluZ19vdXRwdXRfY2hhbm5lbCxcclxuICAgICAgICAgICAgICAgJ3N0ZGVycic6IG92ZXJyaWRpbmdfb3V0cHV0X2NoYW5uZWwsXHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgc2hlbGwgY29tbWFuZCBpcyBub3QgZW1wdHlcclxuICAgICAgICBjb25zdCBzaGVsbF9jb21tYW5kID0gc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdC5zaGVsbF9jb21tYW5kLnRyaW0oKTtcclxuICAgICAgICBpZiAoIXNoZWxsX2NvbW1hbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEl0IGlzIGVtcHR5XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yX21lc3NhZ2UgPSB0aGlzLmdldEVycm9yTWVzc2FnZUZvckVtcHR5U2hlbGxDb21tYW5kKCk7XHJcbiAgICAgICAgICAgIGRlYnVnTG9nKGVycm9yX21lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihlcnJvcl9tZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgY3VycmVudGx5IGRlZmluZWQgc2hlbGwgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgcGx1Z2luLiBJZiB1c2luZyBzeXN0ZW0gZGVmYXVsdCBzaGVsbCwgaXQncyBwb3NzaWJsZVxyXG4gICAgICAgIC8vIHRoYXQgdGhlIHNoZWxsIGlzIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQuIEFsc28sIHRoZSBzZXR0aW5ncyBmaWxlIGNhbiBiZSBlZGl0ZWQgbWFudWFsbHksIGFuZCBpbmNvcnJlY3RcclxuICAgICAgICAvLyBzaGVsbCBjYW4gYmUgd3JpdHRlbiB0aGVyZS5cclxuICAgICAgICBjb25zdCBzaGVsbCA9IHRoaXMudF9zaGVsbF9jb21tYW5kLmdldFNoZWxsKCk7XHJcbiAgICAgICAgaWYgKCFpc1NoZWxsU3VwcG9ydGVkKHNoZWxsKSkge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIlNoZWxsIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiICsgc2hlbGwpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihcIlRoaXMgcGx1Z2luIGRvZXMgbm90IHN1cHBvcnQgdGhlIGZvbGxvd2luZyBzaGVsbDogXCIgKyBzaGVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmluZSBhbiBvYmplY3QgZm9yIGVudmlyb25tZW50IHZhcmlhYmxlcy5cclxuICAgICAgICBjb25zdCBlbnZpcm9ubWVudF92YXJpYWJsZXMgPSBjbG9uZU9iamVjdDx0eXBlb2YgcHJvY2Vzcy5lbnY+KHByb2Nlc3MuZW52KTsgLy8gTmVlZCB0byBjbG9uZSBwcm9jZXNzLmVudiwgb3RoZXJ3aXNlIHRoZSBtb2RpZmljYXRpb25zIGJlbG93IHdpbGwgYmUgc3RvcmVkIHBlcm1hbmVudGx5IHVudGlsIE9ic2lkaWFuIGlzIGhhcmQtcmVzdGFydGVkICg9IGNsb3NlZCBhbmQgbGF1bmNoZWQgYWdhaW4pLlxyXG5cclxuICAgICAgICAvLyBBdWdtZW50IHRoZSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIChpZiB3YW50ZWQpXHJcbiAgICAgICAgY29uc3QgYXVnbWVudGVkX3BhdGggPSB0aGlzLmF1Z21lbnRQQVRIRW52aXJvbm1lbnRWYXJpYWJsZShzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LmVudmlyb25tZW50X3ZhcmlhYmxlX3BhdGhfYXVnbWVudGF0aW9uKTtcclxuICAgICAgICBpZiAoYXVnbWVudGVkX3BhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBlbnZpcm9ubWVudF92YXJpYWJsZXNbZ2V0UEFUSEVudmlyb25tZW50VmFyaWFibGVOYW1lKCldID0gYXVnbWVudGVkX3BhdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB3b3JraW5nIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGEgZm9sZGVyXHJcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHdvcmtpbmdfZGlyZWN0b3J5KSkge1xyXG4gICAgICAgICAgICAvLyBXb3JraW5nIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGV4ZWN1dGlvblxyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIldvcmtpbmcgZGlyZWN0b3J5IGRvZXMgbm90IGV4aXN0OiBcIiArIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoXCJXb3JraW5nIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdDogXCIgKyB3b3JraW5nX2RpcmVjdG9yeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFmcy5sc3RhdFN5bmMod29ya2luZ19kaXJlY3RvcnkpLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgICAgLy8gV29ya2luZyBkaXJlY3RvcnkgaXMgbm90IGEgZGlyZWN0b3J5LlxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGV4ZWN1dGlvblxyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIldvcmtpbmcgZGlyZWN0b3J5IGV4aXN0cyBidXQgaXMgbm90IGEgZm9sZGVyOiBcIiArIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoXCJXb3JraW5nIGRpcmVjdG9yeSBleGlzdHMgYnV0IGlzIG5vdCBhIGZvbGRlcjogXCIgKyB3b3JraW5nX2RpcmVjdG9yeSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV29ya2luZyBkaXJlY3RvcnkgaXMgT0tcclxuICAgICAgICAgICAgLy8gUHJlcGFyZSBleGVjdXRpb24gb3B0aW9uc1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBTcGF3bk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBcImN3ZFwiOiB3b3JraW5nX2RpcmVjdG9yeSxcclxuICAgICAgICAgICAgICAgIFwic2hlbGxcIjogc2hlbGwsXHJcbiAgICAgICAgICAgICAgICBcImVudlwiOiBlbnZpcm9ubWVudF92YXJpYWJsZXMsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBzaGVsbCBjb21tYW5kXHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwiRXhlY3V0aW5nIGNvbW1hbmQgXCIgKyBzaGVsbF9jb21tYW5kICsgXCIgaW4gXCIgKyB3b3JraW5nX2RpcmVjdG9yeSArIFwiLi4uXCIpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRfcHJvY2VzcyA9IHNwYXduKHNoZWxsX2NvbW1hbmQsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbW1vbiBlcnJvciBoYW5kbGluZyByZWdhcmRsZXNzIG9mIG91dHB1dCBoYW5kbGluZyBtb2RlXHJcbiAgICAgICAgICAgICAgICBjaGlsZF9wcm9jZXNzLm9uKFwiZXJyb3JcIiwgKGVycm9yOiBFcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2JhYmx5IG1vc3QgZXJyb3JzIHdpbGwgTk9UIGVuZCB1cCBoZXJlLCBJIGd1ZXNzIHRoaXMgZXZlbnQgb2NjdXJzIGZvciBzb21lIHJhcmUgZXJyb3JzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBxdW90ZSBmcm9tIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sI2V2ZW50LWVycm9yIChyZWFkIDIwMjItMTAtMjkpOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vID4gVGhlICdlcnJvcicgZXZlbnQgaXMgZW1pdHRlZCB3aGVuZXZlcjpcclxuICAgICAgICAgICAgICAgICAgICAvLyA+IC0gVGhlIHByb2Nlc3MgY291bGQgbm90IGJlIHNwYXduZWQsIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPiAtIFRoZSBwcm9jZXNzIGNvdWxkIG5vdCBiZSBraWxsZWQsIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPiAtIFNlbmRpbmcgYSBtZXNzYWdlIHRvIHRoZSBjaGlsZCBwcm9jZXNzIGZhaWxlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJTaGVsbCBjb21tYW5kIGZhaWxlZCB0byBleGVjdXRlOiBSZWNlaXZlZCBhIG5vbi1zdGRlcnIgZXJyb3IgbWVzc2FnZTogXCIgKyBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihcIlNoZWxsIGNvbW1hbmQgZmFpbGVkIHRvIGV4ZWN1dGUuIEVycm9yOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVmaW5lIG91dHB1dCBlbmNvZGluZ1xyXG4gICAgICAgICAgICAgICAgY2hpbGRfcHJvY2Vzcy5zdGRvdXQuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpOyAvLyBSZWNlaXZlIHN0ZG91dCBhbmQgLi4uXHJcbiAgICAgICAgICAgICAgICBjaGlsZF9wcm9jZXNzLnN0ZGVyci5zZXRFbmNvZGluZyhcInV0ZjhcIik7IC8vIC4uLiBzdGRlcnIgYXMgc3RyaW5ncywgbm90IGFzIEJ1ZmZlciBvYmplY3RzLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBhIHRlcm1pbmF0b3JcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NUZXJtaW5hdG9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkX3Byb2Nlc3Mua2lsbChcIlNJR1RFUk1cIik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhvb2sgaW50byBjaGlsZF9wcm9jZXNzIGZvciBvdXRwdXQgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0T3V0cHV0SGFuZGxpbmdNb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYnVmZmVyZWRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXRwdXQgd2lsbCBiZSBidWZmZXJlZCBhbmQgaGFuZGxlZCBhcyBhIHNpbmdsZSBiYXRjaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCdWZmZXJlZE91dHB1dChjaGlsZF9wcm9jZXNzLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LCBvdXRwdXRDaGFubmVscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYWx0aW1lXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0IHdpbGwgYmUgaGFuZGxlZCBvbi10aGUtZ28uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVhbHRpbWVPdXRwdXQoY2hpbGRfcHJvY2Vzcywgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCwgb3V0cHV0Q2hhbm5lbHMsIHByb2Nlc3NUZXJtaW5hdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGlzcGxheSBhIG5vdGlmaWNhdGlvbiBvZiB0aGUgZXhlY3V0aW9uIChpZiB3YW50ZWQpLlxyXG4gICAgICAgICAgICAgICAgaWYgKFwiZGlzYWJsZWRcIiAhPT0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhlY3V0aW9uX25vdGlmaWNhdGlvbl9tb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXhlY3V0aW9uTm90aWZpY2F0aW9uKGNoaWxkX3Byb2Nlc3MsIHNoZWxsX2NvbW1hbmQsIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4ZWN1dGlvbl9ub3RpZmljYXRpb25fbW9kZSwgcHJvY2Vzc1Rlcm1pbmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIEFuIGV4Y2VwdGlvbiBoYXMgaGFwcGVuZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2hlbGwgY29tbWFuZCB3YXMgdG9vIGxvbmcuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhjZXB0aW9uLm1lc3NhZ2UubWF0Y2goL3NwYXduXFxzK0VOQU1FVE9PTE9ORy9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IHdhcyB0b28gbG9uZy4gU2hvdyBhbiBlcnJvciBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKFwiU2hlbGwgY29tbWFuZCBleGVjdXRpb24gZmFpbGVkIGJlY2F1c2UgaXQncyB0b28gbG9uZzogXCIgKyBzaGVsbF9jb21tYW5kLmxlbmd0aCArIFwiIGNoYXJhY3RlcnMuIChVbmZvcnR1bmF0ZWx5IHRoZSBtYXggbGltaXQgaXMgdW5rbm93bikuXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2hlbGwgY29tbWFuZCB3YXMgbm90IHRvbyBsb25nLCB0aGlzIGV4Y2VwdGlvbiBpcyBhYm91dCBzb21ldGhpbmcgZWxzZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRocm93IHRoZSBleGNlcHRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgIGV4Y2VwdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUJ1ZmZlcmVkT3V0cHV0KGNoaWxkX3Byb2Nlc3M6IENoaWxkUHJvY2Vzcywgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogU2hlbGxDb21tYW5kUGFyc2luZ1Jlc3VsdCwgb3V0cHV0Q2hhbm5lbHM6IE91dHB1dENoYW5uZWxDb2Rlcykge1xyXG4gICAgICAgIGNoaWxkX3Byb2Nlc3Mub24oXCJleGl0XCIsIChleGl0Q29kZSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IG91dHB1dHNcclxuICAgICAgICAgICAgY29uc3Qgc3Rkb3V0OiBzdHJpbmcgPSBjaGlsZF9wcm9jZXNzLnN0ZG91dC5yZWFkKCkgPz8gXCJcIjtcclxuICAgICAgICAgICAgbGV0IHN0ZGVycjogc3RyaW5nID0gY2hpbGRfcHJvY2Vzcy5zdGRlcnIucmVhZCgpID8/IFwiXCI7IC8vIGxldCBpbnN0ZWFkIG9mIGNvbnN0OiBzdGRlcnIgY2FuIGJlIGVtcHRpZWQgbGF0ZXIgZHVlIHRvIGlnbm9yaW5nLlxyXG5cclxuICAgICAgICAgICAgLy8gRGlkIHRoZSBzaGVsbCBjb21tYW5kIGV4ZWN1dGUgc3VjY2Vzc2Z1bGx5P1xyXG4gICAgICAgICAgICBpZiAoZXhpdENvZGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21lIGVycm9yIG9jY3VycmVkXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkNvbW1hbmQgZXhlY3V0ZWQgYW5kIGZhaWxlZC4gRXJyb3IgbnVtYmVyOiBcIiArIGV4aXRDb2RlICsgXCIuIFN0ZGVycjogXCIgKyBzdGRlcnIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXJyb3Igc2hvdWxkIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBvciBub3RcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRJZ25vcmVFcnJvckNvZGVzKCkuY29udGFpbnMoZXhpdENvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgaGFzIGlnbm9yZWQgdGhpcyBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIlVzZXIgaGFzIGlnbm9yZWQgdGhpcyBlcnJvciwgc28gd29uJ3QgZGlzcGxheSBpdC5cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBvbmx5IHN0ZG91dCBvdXRwdXQgc3RyZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgc3RkZXJyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBleGl0Q29kZSA9IG51bGw7IC8vIFRPRE86IGNvbnNpZGVyIGlmIGV4aXRDb2RlIHNob3VsZCBqdXN0IGJlIGxlZnQgdW50b3VjaGVkLiBJdCBjb3VsZCBiZSBpbmZvcm1hdGl2ZSB0byAnQXNrIGFmdGVyIGV4ZWN1dGlvbicgb3V0cHV0IGNoYW5uZWwgdGhhdCBzaG93cyBleGl0IGNvZGUgdG8gdXNlci5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGNhbiBiZSBzaG93bi5cclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIldpbGwgZGlzcGxheSB0aGUgZXJyb3IgdG8gdXNlci5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGF0IGxlYXN0IHN0ZG91dCAoYW5kIG1heWJlIHN0ZGVycikgb3V0cHV0IHN0cmVhbVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlQnVmZmVyZWRPdXRwdXQodGhpcy5wbHVnaW4sIHRoaXMudF9zaGVsbF9jb21tYW5kLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LCBzdGRvdXQsIHN0ZGVyciwgZXhpdENvZGUsIG91dHB1dENoYW5uZWxzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFByb2JhYmx5IG5vIGVycm9ycywgYnV0IGRvIG9uZSBtb3JlIGNoZWNrLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV2ZW4gd2hlbiAnZXJyb3InIGlzIG51bGwgYW5kIGV2ZXJ5dGhpbmcgc2hvdWxkIGJlIG9rLCB0aGVyZSBtYXkgc3RpbGwgYmUgZXJyb3IgbWVzc2FnZXMgb3V0cHV0dGVkIGluIHN0ZGVyci5cclxuICAgICAgICAgICAgICAgIGlmIChzdGRlcnIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGEgc3BlY2lhbCBjYXNlOiBzaG91bGQgZXJyb3IgY29kZSAwIGJlIGlnbm9yZWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldElnbm9yZUVycm9yQ29kZXMoKS5jb250YWlucygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGNvZGUgMCBpcyBvbiB0aGUgaWdub3JlIGxpc3QsIHNvIHN1cHByZXNzIHN0ZGVyciBvdXRwdXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZGVyciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiU2hlbGwgY29tbWFuZCBleGVjdXRlZDogRW5jb3VudGVyZWQgZXJyb3IgY29kZSAwLCBidXQgc3RkZXJyIGlzIGlnbm9yZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiU2hlbGwgY29tbWFuZCBleGVjdXRlZDogRW5jb3VudGVyZWQgZXJyb3IgY29kZSAwLCBhbmQgc3RkZXJyIHdpbGwgYmUgcmVsYXllZCB0byBhbiBvdXRwdXQgaGFuZGxlci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIlNoZWxsIGNvbW1hbmQgZXhlY3V0ZWQ6IE5vIGVycm9ycy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlQnVmZmVyZWRPdXRwdXQodGhpcy5wbHVnaW4sIHRoaXMudF9zaGVsbF9jb21tYW5kLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LCBzdGRvdXQsIHN0ZGVyciwgMCwgb3V0cHV0Q2hhbm5lbHMpOyAvLyBVc2UgemVybyBhcyBhbiBlcnJvciBjb2RlIGluc3RlYWQgb2YgbnVsbCAoMCBtZWFucyBubyBlcnJvcikuIElmIHN0ZGVyciBoYXBwZW5zIHRvIGNvbnRhaW4gc29tZXRoaW5nLCBleGl0IGNvZGUgMCBnZXRzIGRpc3BsYXllZCBpbiBhbiBlcnJvciBiYWxsb29uIChpZiB0aGF0IGlzIHNlbGVjdGVkIGFzIGEgY2hhbm5lbCBmb3Igc3RkZXJyKS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlUmVhbHRpbWVPdXRwdXQoXHJcbiAgICAgICAgICAgIGNoaWxkUHJvY2VzczogQ2hpbGRQcm9jZXNzLFxyXG4gICAgICAgICAgICBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBTaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0LFxyXG4gICAgICAgICAgICBvdXRwdXRDaGFubmVsQ29kZXM6IE91dHB1dENoYW5uZWxDb2RlcyxcclxuICAgICAgICAgICAgcHJvY2Vzc1Rlcm1pbmF0b3I6ICgoKSA9PiB2b2lkKSB8IG51bGwsXHJcbiAgICAgICAgKSB7XHJcblxyXG4gICAgICAgIC8vIFByZXBhcmUgb3V0cHV0IGNoYW5uZWxzXHJcbiAgICAgICAgY29uc3Qgb3V0cHV0Q2hhbm5lbHMgPSBzdGFydFJlYWx0aW1lT3V0cHV0SGFuZGxpbmcoXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLFxyXG4gICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCxcclxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbENvZGVzLFxyXG4gICAgICAgICAgICBwcm9jZXNzVGVybWluYXRvcixcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBEZWZpbmUgYW4gb3V0cHV0IGhhbmRsZXJcclxuICAgICAgICBjb25zdCBoYW5kbGVOZXdPdXRwdXRDb250ZW50ID0gYXN5bmMgKG91dHB1dFN0cmVhbU5hbWU6IE91dHB1dFN0cmVhbSwgcmVhZGFibGVTdHJlYW06IFJlYWRhYmxlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGVtaXQgbmV3IGV2ZW50cyB3aGlsZSB0aGUgY3VycmVudCBoYW5kbGluZyBpcyBpbiBwcm9ncmVzcy4gKEkgdGhpbmspIGl0IG1pZ2h0IGNhdXNlIGEgcmFjZSBjb25kaXRpb24gd2hlcmUgYSBzaW11bHRhbmVvdXMgaGFuZGxpbmcgY291bGQgb3ZlcndyaXRlIGFub3RoZXIgaGFuZGxpbmcncyBkYXRhLiBQYXVzZSBib3RoIHN0cmVhbXMsIG5vdCBqdXN0IHRoZSBjdXJyZW50IG9uZSwgdG8gbWFpbnRhaW4gY29ycmVjdCBoYW5kbGluZyBvcmRlciBhbHNvIGJldHdlZW4gdGhlIHR3byBzdHJlYW1zLlxyXG4gICAgICAgICAgICBjaGlsZFByb2Nlc3Muc3Rkb3V0LnBhdXNlKCk7XHJcbiAgICAgICAgICAgIGNoaWxkUHJvY2Vzcy5zdGRlcnIucGF1c2UoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSByZWFkYWJsZVN0cmVhbS5yZWFkKCkgPz8gXCJcIjtcclxuICAgICAgICAgICAgYXdhaXQgb3V0cHV0Q2hhbm5lbHNbb3V0cHV0U3RyZWFtTmFtZV0uaGFuZGxlUmVhbHRpbWUob3V0cHV0U3RyZWFtTmFtZSwgb3V0cHV0Q29udGVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYW4gZW1pdCBuZXcgZXZlbnRzIGFnYWluLlxyXG4gICAgICAgICAgICBjaGlsZFByb2Nlc3Muc3Rkb3V0LnJlc3VtZSgpO1xyXG4gICAgICAgICAgICBjaGlsZFByb2Nlc3Muc3RkZXJyLnJlc3VtZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEhvb2sgaW50byBvdXRwdXQgc3RyZWFtcycgKHN1Y2ggYXMgc3Rkb3V0IGFuZCBzdGRlcnIpIG91dHB1dCByZXRyaWV2aW5nIGV2ZW50cy5cclxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgbWlnaHQgYmUganVzdCBvbmUgc3RyZWFtLCBlLmcuIG9ubHkgc3RkZXJyLCBpZiBzdGRvdXQgaXMgaWdub3JlZC4gSW4gdGhlIGZ1dHVyZSwgdGhlcmUgbWlnaHQgYWxzbyBiZSBtb3JlIHRoYW4gdHdvIHN0cmVhbXMsIHdoZW4gY3VzdG9tIHN0cmVhbXMgYXJlIGltcGxlbWVudGVkLlxyXG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0U3RyZWFtTmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdXRwdXRDaGFubmVscykgYXMgT3V0cHV0U3RyZWFtW10pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTdHJlYW06IFJlYWRhYmxlID0gY2hpbGRQcm9jZXNzW291dHB1dFN0cmVhbU5hbWVdO1xyXG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbS5vbihcclxuICAgICAgICAgICAgICAgIFwicmVhZGFibGVcIixcclxuICAgICAgICAgICAgICAgICgpID0+IGhhbmRsZU5ld091dHB1dENvbnRlbnQob3V0cHV0U3RyZWFtTmFtZSwgcmVhZGFibGVTdHJlYW0pLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSG9vayBpbnRvIGV4aXQgZXZlbnRzXHJcbiAgICAgICAgY2hpbGRQcm9jZXNzLm9uKFwiZXhpdFwiLCAoZXhpdENvZGU6IG51bWJlciwgc2lnbmFsOiBzdHJpbmcgLyogVE9ETzogUGFzcyBzaWduYWwgdG8gY2hhbm5lbHMgc28gaXQgY2FuIGJlIHNob3duIHRvIHVzZXJzIGluIHRoZSBmdXR1cmUgKi8pID0+IHtcclxuICAgICAgICAgICAgLy8gQ2FsbCBhbGwgT3V0cHV0Q2hhbm5lbHMnIGVuZFJlYWx0aW1lKCkuXHJcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlDYWxsZWRDaGFubmVsQ29kZXM6IE91dHB1dENoYW5uZWxDb2RlW10gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvdXRwdXRTdHJlYW1OYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG91dHB1dENoYW5uZWxzKSBhcyBPdXRwdXRTdHJlYW1bXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q2hhbm5lbDogT3V0cHV0Q2hhbm5lbCA9IG91dHB1dENoYW5uZWxzW291dHB1dFN0cmVhbU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q2hhbm5lbENvZGU6IE91dHB1dENoYW5uZWxDb2RlID0gb3V0cHV0Q2hhbm5lbENvZGVzW291dHB1dFN0cmVhbU5hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIE91dHB1dENoYW5uZWwgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlDYWxsZWRDaGFubmVsQ29kZXMuaW5jbHVkZXMob3V0cHV0Q2hhbm5lbENvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHlldCBjYWxsZWQsIHNvIGRvIHRoZSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWwuZW5kUmVhbHRpbWUoZXhpdENvZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIHRoYXQgdGhpcyBjaGFubmVsJ3MgZW5kUmVhbHRpbWUoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZC4gU29sdmVzIGEgc2l0dWF0aW9uIHdoZXJlIHN0ZGVyciBhbmQgc3Rkb3V0IHVzZXMgdGhlIHNhbWUgY2hhbm5lbCwgaW4gd2hpY2ggY2FzZSBlbmRSZWFsdGltZSgpIHNob3VsZCBub3QgYmUgYWNjaWRlbnRhbGx5IGNhbGxlZCB0d2ljZS5cclxuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q2FsbGVkQ2hhbm5lbENvZGVzLnB1c2gob3V0cHV0Q2hhbm5lbENvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRXb3JraW5nRGlyZWN0b3J5KCkge1xyXG4gICAgICAgIC8vIFJldHVybnMgZWl0aGVyIGEgdXNlciBkZWZpbmVkIHdvcmtpbmcgZGlyZWN0b3J5LCBvciBhbiBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIG9uZS5cclxuICAgICAgICBjb25zdCB3b3JraW5nX2RpcmVjdG9yeSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLndvcmtpbmdfZGlyZWN0b3J5O1xyXG4gICAgICAgIGlmICh3b3JraW5nX2RpcmVjdG9yeS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBObyB3b3JraW5nIGRpcmVjdG9yeSBzcGVjaWZpZWQsIHNvIHVzZSB0aGUgdmF1bHQgZGlyZWN0b3J5LlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VmF1bHRBYnNvbHV0ZVBhdGgodGhpcy5wbHVnaW4uYXBwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFwYXRoLmlzQWJzb2x1dGUod29ya2luZ19kaXJlY3RvcnkpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBpcyByZWxhdGl2ZS5cclxuICAgICAgICAgICAgLy8gSGVscCB0byBtYWtlIGl0IHJlZmVyIHRvIHRoZSB2YXVsdCdzIGRpcmVjdG9yeS4gV2l0aG91dCB0aGlzLCB0aGUgcmVsYXRpdmUgcGF0aCB3b3VsZCByZWZlciB0byBPYnNpZGlhbidzIGluc3RhbGxhdGlvbiBkaXJlY3RvcnkgKGF0IGxlYXN0IG9uIFdpbmRvd3MpLlxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMucGx1Z2luLmFwcCksIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdvcmtpbmdfZGlyZWN0b3J5O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXVnbWVudFBBVEhFbnZpcm9ubWVudFZhcmlhYmxlKHBhdGhfYXVnbWVudGF0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHBhdGhfYXVnbWVudGF0aW9uID0gY29udmVydE5ld2xpbmVzVG9QQVRIU2VwYXJhdG9ycyhwYXRoX2F1Z21lbnRhdGlvbiwgZ2V0T3BlcmF0aW5nU3lzdGVtKCkpO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW55dGhpbmcgdG8gYXVnbWVudC5cclxuICAgICAgICBpZiAocGF0aF9hdWdtZW50YXRpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBBdWdtZW50LlxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbF9wYXRoID0gcHJvY2Vzcy5lbnZbZ2V0UEFUSEVudmlyb25tZW50VmFyaWFibGVOYW1lKCldO1xyXG4gICAgICAgICAgICBsZXQgYXVnbWVudGVkX3BhdGg6IHN0cmluZztcclxuICAgICAgICAgICAgaWYgKHBhdGhfYXVnbWVudGF0aW9uLmNvbnRhaW5zKG9yaWdpbmFsX3BhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXVnbWVudGF0aW9uIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBQQVRILlxyXG4gICAgICAgICAgICAgICAgLy8gU2ltcGx5IHJlcGxhY2UgdGhlIHdob2xlIG9yaWdpbmFsIFBBVEggd2l0aCB0aGUgYXVnbWVudGVkIG9uZSwgYXMgdGhlcmUncyBubyBuZWVkIHRvIGNhcmUgYWJvdXQgaW5jbHVkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgY29udGVudC5cclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQXVnbWVudGluZyBlbnZpcm9ubWVudCB2YXJpYWJsZSBQQVRIIHNvIGl0IHdpbGwgYmVjb21lIFwiICsgcGF0aF9hdWdtZW50YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgYXVnbWVudGVkX3BhdGggPSBwYXRoX2F1Z21lbnRhdGlvbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBhdWdtZW50YXRpb24gZG9lcyBub3QgY29udGFpbiB0aGUgb3JpZ2luYWwgUEFUSC5cclxuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2Ygc2ltcGx5IHJlcGxhY2luZyB0aGUgb3JpZ2luYWwgUEFUSCwgYXBwZW5kIHRoZSBhdWdtZW50YXRpb24gYWZ0ZXIgaXQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBnZXRQQVRIU2VwYXJhdG9yKGdldE9wZXJhdGluZ1N5c3RlbSgpKTtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQXVnbWVudGluZyBlbnZpcm9ubWVudCB2YXJpYWJsZSBQQVRIIGJ5IGFkZGluZyBcIiArIHNlcGFyYXRvciArIHBhdGhfYXVnbWVudGF0aW9uICsgXCIgYWZ0ZXIgaXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgYXVnbWVudGVkX3BhdGggPSBvcmlnaW5hbF9wYXRoICsgc2VwYXJhdG9yICsgcGF0aF9hdWdtZW50YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVidWdMb2coXCJQQVRIIGF1Z21lbnRhdGlvbiByZXN1bHQ6IFwiICsgYXVnbWVudGVkX3BhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXVnbWVudGVkX3BhdGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gYXVnbWVudGluZyBpcyBuZWVkZWQuXHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwiTm8gYXVnbWVudGF0aW9uIGlzIGRlZmluZWQgZm9yIGVudmlyb25tZW50IHZhcmlhYmxlIFBBVEguIFRoaXMgaXMgY29tcGxldGVseSBvay5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBpdCdzIGZpcnN0IGNoZWNrZWQgdGhhdCBuZWl0aGVyIHNoZWxsIGNvbW1hbmQgdmVyc2lvbiBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0gbm9yIGEgJ2RlZmF1bHQnIHZlcnNpb24gZXhpc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0RXJyb3JNZXNzYWdlRm9yRW1wdHlTaGVsbENvbW1hbmQoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Tm9uRW1wdHlQbGF0Zm9ybUlkcygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNoZWxsIGNvbW1hbmQgY29udGFpbnMgdmVyc2lvbnMgZm9yIG90aGVyIHBsYXRmb3JtcywgYnV0IG5vdCBmb3IgdGhlIGN1cnJlbnQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50X3BsYXRmb3JtX25hbWUgPSBQbGF0Zm9ybU5hbWVzW2dldE9wZXJhdGluZ1N5c3RlbSgpXTtcclxuICAgICAgICAgICAgY29uc3QgdmVyc2lvbl93b3JkID0gdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Tm9uRW1wdHlQbGF0Zm9ybUlkcygpLmxlbmd0aCA+IDEgPyBcInZlcnNpb25zXCIgOiBcImEgdmVyc2lvblwiO1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlcl9wbGF0Zm9ybV9uYW1lcyA9IHRoaXMudF9zaGVsbF9jb21tYW5kLmdldE5vbkVtcHR5UGxhdGZvcm1JZHMoKS5tYXAocGxhdGZvcm1faWQgPT4gUGxhdGZvcm1OYW1lc1twbGF0Zm9ybV9pZF0pLmpvaW4oXCIgYW5kIFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGBUaGUgc2hlbGwgY29tbWFuZCBkb2VzIG5vdCBoYXZlIGEgdmVyc2lvbiBmb3IgJHtjdXJyZW50X3BsYXRmb3JtX25hbWV9LCBpdCBvbmx5IGhhcyAke3ZlcnNpb25fd29yZH0gZm9yICR7b3RoZXJfcGxhdGZvcm1fbmFtZXN9LmA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNoZWxsIGNvbW1hbmQgZG9lc24ndCBjb250YWluIGEgdmVyc2lvbiBmb3IgYW55IHBsYXRmb3JtcywgaXQncyBjb21wbGV0ZWx5IGVtcHR5LlxyXG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgc2hlbGwgY29tbWFuZCBpcyBlbXB0eS4gOihcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBhIG5vdGlmaWNhdGlvbiBiYWxsb29uIGluZGljYXRpbmcgYSB1c2VyIHRoYXQgYSBzaGVsbCBjb21tYW5kIGlzIGJlaW5nIGV4ZWN1dGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGlsZF9wcm9jZXNzXHJcbiAgICAgKiBAcGFyYW0gc2hlbGxfY29tbWFuZFxyXG4gICAgICogQHBhcmFtIGV4ZWN1dGlvbl9ub3RpZmljYXRpb25fbW9kZVxyXG4gICAgICogQHBhcmFtIHByb2Nlc3NUZXJtaW5hdG9yIFdpbGwgYmUgY2FsbGVkIGlmIHVzZXIgY2xpY2tzICdSZXF1ZXN0IHRvIHRlcm1pbmF0ZSB0aGUgcHJvY2VzcycgaWNvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2hvd0V4ZWN1dGlvbk5vdGlmaWNhdGlvbihcclxuICAgICAgICBjaGlsZF9wcm9jZXNzOiBDaGlsZFByb2Nlc3MsXHJcbiAgICAgICAgc2hlbGxfY29tbWFuZDogc3RyaW5nLFxyXG4gICAgICAgIGV4ZWN1dGlvbl9ub3RpZmljYXRpb25fbW9kZTogRXhlY3V0aW9uTm90aWZpY2F0aW9uTW9kZSxcclxuICAgICAgICBwcm9jZXNzVGVybWluYXRvcjogKCkgPT4gdm9pZCxcclxuICAgICkge1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZVJlcXVlc3RUZXJtaW5hdGluZ0J1dHRvbiA9IChub3RpY2U6IE5vdGljZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIE5vdGljZS5ub3RpY2VFbCBiZWxvbmdzIHRvIE9ic2lkaWFuJ3MgUFJJVkFURSBBUEksIGFuZCBpdCBtYXkgY2hhbmdlIHdpdGhvdXQgYSBwcmlvciBub3RpY2UuIE9ubHlcclxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBidXR0b24gaWYgbm90aWNlRWwgZXhpc3RzIGFuZCBpcyBhbiBIVE1MRWxlbWVudC5cclxuICAgICAgICAgICAgY29uc3Qgbm90aWNlRWwgPSBub3RpY2Uubm90aWNlRWw7XHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IG5vdGljZUVsICYmIG5vdGljZUVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmNyZWF0ZVJlcXVlc3RUZXJtaW5hdGluZ0J1dHRvbihub3RpY2VFbCwgcHJvY2Vzc1Rlcm1pbmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX25vdGlmaWNhdGlvbl9tZXNzYWdlID0gXCJFeGVjdXRpbmc6IFwiICsgKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldEFsaWFzKCkgfHwgc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgc3dpdGNoIChleGVjdXRpb25fbm90aWZpY2F0aW9uX21vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInF1aWNrXCI6IHtcclxuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSB0aW1lb3V0IGZyb20gc2V0dGluZ3MgZGVmaW5lZCBieSBhIHVzZXIuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzTm90aWZpY2F0aW9uID0gdGhpcy5wbHVnaW4ubmV3Tm90aWZpY2F0aW9uKGV4ZWN1dGlvbl9ub3RpZmljYXRpb25fbWVzc2FnZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlcXVlc3RUZXJtaW5hdGluZ0J1dHRvbihwcm9jZXNzTm90aWZpY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZXJtYW5lbnRcIjoge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgbm90aWZpY2F0aW9uIHVudGlsIHRoZSBwcm9jZXNzIGVuZHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzTm90aWZpY2F0aW9uID0gdGhpcy5wbHVnaW4ubmV3Tm90aWZpY2F0aW9uKGV4ZWN1dGlvbl9ub3RpZmljYXRpb25fbWVzc2FnZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXF1ZXN0VGVybWluYXRpbmdCdXR0b24ocHJvY2Vzc05vdGlmaWNhdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgbm90aWZpY2F0aW9uIHdoZW4gdGhlIHByb2Nlc3MgZmluaXNoZXMuXHJcbiAgICAgICAgICAgICAgICBjaGlsZF9wcm9jZXNzLm9uKFwiZXhpdFwiLCAoKSA9PiBwcm9jZXNzTm90aWZpY2F0aW9uLmhpZGUoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiaWYtbG9uZ1wiOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNob3cgdGhlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvY2VzcyBydW5zIGZvciBhbiBleHRlbmRlZCBwZXJpb2Qgb2YgdGltZSAoZGVmaW5lZCBiZWxvdykuXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb2Nlc3MgaXMgc3RpbGwgcnVubmluZy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY2hpbGRfcHJvY2Vzcy5leGl0Q29kZSAmJiAhY2hpbGRfcHJvY2Vzcy5raWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByb2Nlc3MgaXMgc3RpbGwgcnVubmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBub3RpZmljYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NOb3RpZmljYXRpb24gPSB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24oZXhlY3V0aW9uX25vdGlmaWNhdGlvbl9tZXNzYWdlLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVxdWVzdFRlcm1pbmF0aW5nQnV0dG9uKHByb2Nlc3NOb3RpZmljYXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgbm90aWZpY2F0aW9uIHdoZW4gdGhlIHByb2Nlc3MgZmluaXNoZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkX3Byb2Nlc3Mub24oXCJleGl0XCIsICgpID0+IHByb2Nlc3NOb3RpZmljYXRpb24uaGlkZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCAyMDAwKTsgLy8gSWYgeW91IGNoYW5nZSB0aGUgdGltZW91dCwgY2hhbmdlIGRvY3VtZW50YXRpb24sIHRvbyFcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uL0RlYnVnXCI7XHJcbmltcG9ydCB7XHJcbiAgICBNb2RlbFxyXG59IGZyb20gXCIuLi9pbXBvcnRzXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5zdGFuY2Uge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJhdGlvbiBvZiB0aGUgcGFyZW50IGluc3RhbmNlLiBFLmcuIGlmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGEgUHJvbXB0RmllbGQsIHRoZW4gcGFyZW50X2NvbmZpZ3VyYXRpb25zIGlzIGEgUHJvbXB0J3MgY29uZmlndXJhdGlvbi5cclxuICAgICAqIENhbiBiZSB0cnVzdGVkIHRvIGFsd2F5cyBleGlzdCwgdW5saWtlIHBhcmVudF9pbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBhcmVudF9jb25maWd1cmF0aW9uOiBJbnN0YW5jZUNvbmZpZ3VyYXRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFLmcuIGlmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGEgUHJvbXB0RmllbGQsIHRoZW4gcGFyZW50X2luc3RhbmNlIGlzIGEgUHJvbXB0LlxyXG4gICAgICogT25seSBwcmVzZW50IGZvciBpbnN0YW5jZXMgd2hvc2UgcGFyZW50IGlzIHNvbWV0aGluZyBlbHNlIHRoYW4gdGhlIHJvb3Qgc2V0dGluZ3Mgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGFyZW50X2luc3RhbmNlOiBJbnN0YW5jZSB8IG51bGw7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBtb2RlbDogTW9kZWwsXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb246IEluc3RhbmNlQ29uZmlndXJhdGlvbixcclxuICAgICAgICBwYXJlbnRfaW5zdGFuY2Vfb3JfY29uZmlndXJhdGlvbjogSW5zdGFuY2UgfCBJbnN0YW5jZUNvbmZpZ3VyYXRpb24sXHJcbiAgICApIHtcclxuICAgICAgICBkZWJ1Z0xvZyh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIjogQ3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXCIpO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgcGFyZW50IHR5cGVcclxuICAgICAgICBpZiAocGFyZW50X2luc3RhbmNlX29yX2NvbmZpZ3VyYXRpb24gaW5zdGFuY2VvZiBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAvLyBJdCdzIGFuIGluc3RhbmNlIG9iamVjdFxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudF9pbnN0YW5jZSA9IHBhcmVudF9pbnN0YW5jZV9vcl9jb25maWd1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudF9jb25maWd1cmF0aW9uID0gdGhpcy5wYXJlbnRfaW5zdGFuY2UuY29uZmlndXJhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJdCdzIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgICAgICAgICAgIC8vIE5vIHBhcmVudCBpbnN0YW5jZSBpcyBhdmFpbGFibGUsIHNvIHByb2JhYmx5IHRoaXMgaXMgYWJvdXQgU0NfTWFpblNldHRpbmdzIG9iamVjdCwgYXMgaXQgZG9lcyBub3QgaGF2ZSBNb2RlbC9JbnN0YW5jZSBjbGFzc2VzIChhdCBsZWFzdCB5ZXQpLlxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudF9pbnN0YW5jZSA9IG51bGw7IC8vIEl0J3MgbnVsbCBhbHJlYWR5LCBidXQgZG8gdGhpcyBqdXN0IHRvIG1ha2UgYSBzdGF0ZW1lbnQuXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50X2NvbmZpZ3VyYXRpb24gPSBwYXJlbnRfaW5zdGFuY2Vfb3JfY29uZmlndXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IGdldFRpdGxlKCk6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgc2V0SWZWYWxpZChmaWVsZDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnZhbGlkYXRlVmFsdWUodGhpcywgZmllbGQsIHZhbHVlKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uW2ZpZWxkXSA9IHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZUNvbmZpZ3VyYXRpb24ge1xyXG4gICAgW2tleTogc3RyaW5nXTogYW55O1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuaW1wb3J0IHtcclxuICAgIENvbmZpcm1hdGlvbk1vZGFsLFxyXG4gICAgSW5zdGFuY2UsXHJcbiAgICBJbnN0YW5jZUNvbmZpZ3VyYXRpb24sXHJcbn0gZnJvbSBcIi4uL2ltcG9ydHNcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNb2RlbCB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICkge31cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0U2luZ3VsYXJOYW1lKCk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqVE9ETzogQ2hhbmdlIHRoaXMgdG8gcHVibGljIGFuZCBjYWxsIGl0IGZyb20gSW5zdGFuY2UuY29uc3RydWN0b3IoKSBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbiBhIG5ldyBwcm9wZXJ0eSBJbnN0YW5jZS5wYXJlbnRfcmVsYXRpb24uIE1ha2Ugb3RoZXIgY2FsbGVycyB1c2UgdGhlIG5ldyBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBkZWZpbmVQYXJlbnRDb25maWd1cmF0aW9uUmVsYXRpb24oaW5zdGFuY2U6IEluc3RhbmNlKTogUGFyZW50TW9kZWxPbmVUb09uZVJlbGF0aW9uIHwgUGFyZW50TW9kZWxPbmVUb01hbnlJbmRleFJlbGF0aW9uIHwgUGFyZW50TW9kZWxPbmVUb01hbnlJZFJlbGF0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBpbnN0YW5jZSBvYmplY3RzIGZyb20gYWxyZWFkeSBleGlzdGluZyBjb25maWd1cmF0aW9uLiBJLmUuIGRvZXMgbm90IGNyZWF0ZSBORVcgaW5zdGFuY2VzIG9yIG5ldyBjb25maWd1cmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGxvYWRJbnN0YW5jZXMocGFyZW50X2luc3RhbmNlX29yX2NvbmZpZ3VyYXRpb246IEluc3RhbmNlIHwgSW5zdGFuY2VDb25maWd1cmF0aW9uKTogU2V0PEluc3RhbmNlPiB8IE1hcDxzdHJpbmcsIEluc3RhbmNlPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgYW5kIGFkZHMgaXRzIGNvbmZpZ3VyYXRpb24gdG8gdGhlIHBhcmVudCBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgbmV3SW5zdGFuY2UocGFyZW50X2luc3RhbmNlX29yX2NvbmZpZ3VyYXRpb246IEluc3RhbmNlIHwgSW5zdGFuY2VDb25maWd1cmF0aW9uKTogSW5zdGFuY2U7XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZVNldHRpbmdGaWVsZHMoaW5zdGFuY2U6IEluc3RhbmNlLCBwYXJlbnRfZWxlbWVudDogSFRNTEVsZW1lbnQsIHdpdGhfZGVsZXRpb24gPSB0cnVlKSB7XHJcbiAgICAgICAgZGVidWdMb2codGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCI6IENyZWF0aW5nIHNldHRpbmcgZmllbGRzLlwiKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyXHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ19maWVsZHNfY29udGFpbmVyID0gcGFyZW50X2VsZW1lbnQuY3JlYXRlRGl2KCk7IC8vIENyZWF0ZSBhIG5lc3RlZCBjb250YWluZXIgdGhhdCBjYW4gYmUgZWFzaWx5IGRlbGV0ZWQgaWYgdGhlIGluc3RhbmNlIGlzIGRlbGV0ZWQuXHJcblxyXG4gICAgICAgIGNvbnN0IG1haW5fc2V0dGluZ19maWVsZCA9IHRoaXMuX2NyZWF0ZVNldHRpbmdGaWVsZHMoaW5zdGFuY2UsIHNldHRpbmdfZmllbGRzX2NvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKHdpdGhfZGVsZXRpb24pIHtcclxuICAgICAgICAgICAgbWFpbl9zZXR0aW5nX2ZpZWxkLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKFwidHJhc2hcIilcclxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRGVsZXRlIHRoaXMgXCIgKyB0aGlzLmdldFNpbmd1bGFyTmFtZSgpLnRvTG9jYWxlTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYXNoIGljb24gaGFzIGJlZW4gY2xpY2tlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gdXAgYSBtb2RhbCBhc2tpbmcgZm9yIGNvbmZpcm1hdGlvbiBpZiB0aGUgaW5zdGFuY2UgY2FuIGJlIGRlbGV0ZWQgZnJvbSB0aGlzLnBhcmVudF9jb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbl9tb2RhbCA9IG5ldyBDb25maXJtYXRpb25Nb2RhbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRGVsZXRlIFwiICsgdGhpcy5nZXRTaW5ndWxhck5hbWUoKS50b0xvY2FsZUxvd2VyQ2FzZSgpICsgXCI6IFwiICsgaW5zdGFuY2UuZ2V0VGl0bGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgXCIgKyB0aGlzLmdldFNpbmd1bGFyTmFtZSgpLnRvTG9jYWxlTG93ZXJDYXNlKCkgKyBcIj9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJZZXMsIGRlbGV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uX21vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25fbW9kYWwucHJvbWlzZS50aGVuKGFzeW5jIChkZWxldGlvbl9jb25maXJtZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW9uX2NvbmZpcm1lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBoYXMgY29uZmlybWVkIHRoZSBkZWxldGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgY29uZmlndXJhdGlvbiBhbmQgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIGN1c3RvbSBjb2xsZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBzZXR0aW5nIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdfZmllbGRzX2NvbnRhaW5lci5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYWluX3NldHRpbmdfZmllbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNldHRpbmcgZmllbGRzIGludG8gdGhlIGdpdmVuIGNvbnRhaW5lcl9lbGVtZW50LCBhbmQgdGhlbiByZXR1cm5zIHRoZSBtYWluIFNldHRpbmcgdGhhdFxyXG4gICAgICogY2FuIGJlIHVzZWQgZm9yIGluamVjdGluZyBhIGRlbGV0aW5nIGJ1dHRvbiBpbnRvLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lcl9lbGVtZW50XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBfY3JlYXRlU2V0dGluZ0ZpZWxkcyhpbnN0YW5jZTogSW5zdGFuY2UsIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCk6IFNldHRpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBpbnN0YW5jZSBmcm9tIGNvbmZpZ3VyYXRpb24sIGFuZCBjYWxscyBfZGVsZXRlQ2hpbGQoKSB3aGljaCB3aWxsIGRlbGV0ZSB0aGUgaW5zdGFuY2UgZnJvbSBjdXN0b20gY29sbGVjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQ2FuIGJlIG1hZGUgcHVibGljIGlmIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZUluc3RhbmNlKGluc3RhbmNlOiBJbnN0YW5jZSkge1xyXG4gICAgICAgIGRlYnVnTG9nKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiOiBEZWxldGluZyBhbiBpbnN0YW5jZS5cIik7XHJcbiAgICAgICAgdGhpcy5fZGVsZXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aW9uID0gdGhpcy5kZWZpbmVQYXJlbnRDb25maWd1cmF0aW9uUmVsYXRpb24oaW5zdGFuY2UpO1xyXG4gICAgICAgIHN3aXRjaCAocmVsYXRpb24udHlwZSkge1xyXG4gICAgICAgICAgICAvLyBjYXNlIFwib25lLXRvLW9uZVwiOiAvLyBUT0RPOiBVbmNvbW1lbnQgd2hlbiBmaXJzdCBtb2RlbCB0aGF0IG5lZWRzIHRoaXMgaXMgaW1wbGVtZW50ZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVsYXRpb24gd2hlcmUgJ2tleScgcG9pbnRzIGRpcmVjdGx5IHRvIHRoZSBpbnN0YW5jZSdzIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhpcy5wYXJlbnRfY29uZmlndXJhdGlvblt0aGlzLnJlbGF0aW9uLmtleV07XHJcbiAgICAgICAgICAgICAgICAvLyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm9uZS10by1tYW55LWluZGV4XCI6IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZWxhdGlvbiB3aGVyZSAna2V5JyBwb2ludHMgdG8gYW4gaW5kZXhlZCBhcnJheSBvZiBpbnN0YW5jZSBjb25maWd1cmF0aW9ucy4gVXNlICdpbmRleCcgdG8gcGljayB0aGUgY29ycmVjdCBpbnN0YW5jZSBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50X2NvbmZpZ3VyYXRpb25bcmVsYXRpb24ua2V5XS5zcGxpY2UocmVsYXRpb24uaW5kZXgsIDEpOyAvLyBEbyBub3QgdXNlIGRlbGV0ZSwgYXMgaXQgd291bGQgcGxhY2UgbnVsbCBpbiB0aGUgbGlzdC5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGNhc2UgXCJvbmUtdG8tbWFueS1pZFwiOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVsYXRpb24gd2hlcmUgJ2tleScgcG9pbnRzIHRvIGFuIGluZGV4ZWQgYXJyYXkgb2YgaW5zdGFuY2UgY29uZmlndXJhdGlvbnMuIFVzZSAnaWQnIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCBpbmRleC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pZFRvSW5kZXgoaW5zdGFuY2UucGFyZW50X2NvbmZpZ3VyYXRpb25bcmVsYXRpb24ua2V5XSwgcmVsYXRpb24uaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmdcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS5kZWxldGVJbnN0YW5jZSgpOiBDb3VsZCBub3QgZmluZCBhbiBpbmRleCBmb3IgaWQgJHtyZWxhdGlvbi5pZH0uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnRfY29uZmlndXJhdGlvbltyZWxhdGlvbi5rZXldLnNwbGljZShpbmRleCwgMSk7IC8vIERvIG5vdCB1c2UgZGVsZXRlLCBhcyBpdCB3b3VsZCBwbGFjZSBudWxsIGluIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0XHRcdH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpZFRvSW5kZXgoY29uZmlndXJhdGlvbnM6IEluc3RhbmNlQ29uZmlndXJhdGlvbltdLCBpZDogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IHJlc3VsdF9pbmRleCA9IG51bGw7XHJcbiAgICAgICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgoaW5zdGFuY2VfY29uZmlndXJhdGlvbjogSW5zdGFuY2VDb25maWd1cmF0aW9uLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VfY29uZmlndXJhdGlvbi5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIHJlc3VsdF9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdF9pbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgc2hvdWxkIGRlbGV0ZSB0aGUgaW5zdGFuY2UgZnJvbSBjdXN0b20gY29sbGVjdGlvbnMuIEl0IHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IGFsbCBJbnN0YW5jZSBjbGFzc2VzIHRoYXQgaGF2ZSBkZWxldGFibGUgY2hpbGRyZW4uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBfZGVsZXRlSW5zdGFuY2UoaW5zdGFuY2U6IEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiLmRlbGV0ZUluc3RhbmNlKCk6IFRoaXMgY2xhc3MgZG9lcyBub3Qgb3ZlcnJpZGUgX2RlbGV0ZUluc3RhbmNlKCkgbWV0aG9kLiBNYXliZSB0aGUgY2xhc3MgaXMgbm90IHN1cHBvc2VkIHRvIGhhdmUgY2hpbGRyZW4/XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCB2YWxpZGF0ZVZhbHVlKGluc3RhbmNlOiBJbnN0YW5jZSwgZmllbGQ6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBhYnN0cmFjdCBUaGlzIGludGVyZmFjZSBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkuIFVzZSBvbmUgb2YgdGhlIGNoaWxkIGludGVyZmFjZXMgaW5zdGVhZC5cclxuICovXHJcbmludGVyZmFjZSBQYXJlbnRNb2RlbFJlbGF0aW9uIHtcclxuICAgIHR5cGU6IFwib25lLXRvLW9uZVwiIHwgXCJvbmUtdG8tbWFueS1pbmRleFwiIHwgXCJvbmUtdG8tbWFueS1pZFwiO1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFyZW50TW9kZWxPbmVUb09uZVJlbGF0aW9uIGV4dGVuZHMgUGFyZW50TW9kZWxSZWxhdGlvbiB7XHJcbiAgICB0eXBlOiBcIm9uZS10by1vbmVcIjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYXJlbnRNb2RlbE9uZVRvTWFueUluZGV4UmVsYXRpb24gZXh0ZW5kcyBQYXJlbnRNb2RlbFJlbGF0aW9uIHtcclxuICAgIHR5cGU6IFwib25lLXRvLW1hbnktaW5kZXhcIjtcclxuICAgIGluZGV4OiBudW1iZXI7IC8vIFRPRE86IEZpbmQgYSB3YXkgdG8gdXNlIHNvbWV0aGluZyBsaWtlOiBrZXlvZiBJbnN0YW5jZUNvbmZpZ3VyYXRpb25bdGhpc1tcImtleVwiXV0gLiAna2V5b2YnIG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIHN1aXRhYmxlIGZvciBhIG51bWVyaWMgaW5kZXggb2YgYW4gYXJyYXkuICdrZXlvZicgaXMgb25seSBhcHBsaWNhYmxlIGZvciBvYmplY3RzLlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBhcmVudE1vZGVsT25lVG9NYW55SWRSZWxhdGlvbiBleHRlbmRzIFBhcmVudE1vZGVsUmVsYXRpb24ge1xyXG4gICAgdHlwZTogXCJvbmUtdG8tbWFueS1pZFwiO1xyXG4gICAgaWQ6IHN0cmluZztcclxufVxyXG5cclxuXHJcbi8vIE1vZGVsIGNsYXNzIGNvbGxlY3Rpb25cclxuXHJcbmNvbnN0IG1vZGVsX2NsYXNzZXM6IE1hcDxzdHJpbmcsIE1vZGVsPiA9IG5ldyBNYXAoKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRyb2R1Y2VNb2RlbENsYXNzKG1vZGVsX2NsYXNzOiBNb2RlbCkge1xyXG4gICAgbW9kZWxfY2xhc3Nlcy5zZXQobW9kZWxfY2xhc3MuY29uc3RydWN0b3IubmFtZSwgbW9kZWxfY2xhc3MpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kZWw8TW9kZWxDbGFzcz4obW9kZWxfY2xhc3NfbmFtZTogc3RyaW5nKTogTW9kZWxDbGFzcyAge1xyXG4gICAgcmV0dXJuIG1vZGVsX2NsYXNzZXMuZ2V0KG1vZGVsX2NsYXNzX25hbWUpIGFzIHVua25vd24gYXMgTW9kZWxDbGFzcztcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtJbnN0YW5jZX0gZnJvbSBcIi4uL0luc3RhbmNlXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtTQ19NYWluU2V0dGluZ3N9IGZyb20gXCIuLi8uLi9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtnZXRJREdlbmVyYXRvcn0gZnJvbSBcIi4uLy4uL0lER2VuZXJhdG9yXCI7XHJcbmltcG9ydCB7T3V0cHV0V3JhcHBlck1vZGVsfSBmcm9tIFwiLi9PdXRwdXRXcmFwcGVyTW9kZWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRXcmFwcGVyIGV4dGVuZHMgSW5zdGFuY2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyBtb2RlbDogT3V0cHV0V3JhcHBlck1vZGVsLFxyXG4gICAgICAgIHByb3RlY3RlZCBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBwdWJsaWMgY29uZmlndXJhdGlvbjogT3V0cHV0V3JhcHBlckNvbmZpZ3VyYXRpb24sXHJcbiAgICAgICAgcHVibGljIHBhcmVudF9jb25maWd1cmF0aW9uOiBTQ19NYWluU2V0dGluZ3MsXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihtb2RlbCwgY29uZmlndXJhdGlvbiwgcGFyZW50X2NvbmZpZ3VyYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBJbnRyb2R1Y2UgdGhlIElEIHRvIGFuIElEIGdlbmVyYXRvciBzbyB0aGF0IGl0IHdvbid0IGFjY2lkZW50YWxseSBnZW5lcmF0ZSB0aGUgc2FtZSBJRCBhZ2FpbiB3aGVuIGNyZWF0aW5nIG5ldyBPdXRwdXRXcmFwcGVycy5cclxuICAgICAgICBnZXRJREdlbmVyYXRvcigpLmFkZFJlc2VydmVkSUQoY29uZmlndXJhdGlvbi5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldElEKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFRpdGxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udGl0bGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENvbnRlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5jb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0V3JhcHBlckNvbmZpZ3VyYXRpb24ge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBjb250ZW50OiBzdHJpbmc7XHJcbn0iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5hdXRvY29tcGxldGUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLypcclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20va3JhYWRlbi9hdXRvY29tcGxldGVcclxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTYgRGVueXMgS3Jhc25vc2hjaG9rXHJcbiAgICogTUlUIExpY2Vuc2VcclxuICAgKi9cclxuICBmdW5jdGlvbiBhdXRvY29tcGxldGUoc2V0dGluZ3MpIHtcclxuICAgICAgLy8ganVzdCBhbiBhbGlhcyB0byBtaW5pbWl6ZSBKUyBmaWxlIHNpemVcclxuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50O1xyXG4gICAgICB2YXIgY29udGFpbmVyID0gc2V0dGluZ3MuY29udGFpbmVyIHx8IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgICB2YXIgbW9iaWxlRmlyZWZveCA9IH51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgJiYgfnVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaWxlXCIpO1xyXG4gICAgICB2YXIgZGVib3VuY2VXYWl0TXMgPSBzZXR0aW5ncy5kZWJvdW5jZVdhaXRNcyB8fCAwO1xyXG4gICAgICB2YXIgcHJldmVudFN1Ym1pdCA9IHNldHRpbmdzLnByZXZlbnRTdWJtaXQgfHwgZmFsc2U7XHJcbiAgICAgIHZhciBkaXNhYmxlQXV0b1NlbGVjdCA9IHNldHRpbmdzLmRpc2FibGVBdXRvU2VsZWN0IHx8IGZhbHNlO1xyXG4gICAgICAvLyAna2V5dXAnIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIG9uIE1vYmlsZSBGaXJlZm94LCBzbyB3ZSBoYXZlIHRvIHVzZSAnaW5wdXQnIGV2ZW50IGluc3RlYWRcclxuICAgICAgdmFyIGtleVVwRXZlbnROYW1lID0gbW9iaWxlRmlyZWZveCA/IFwiaW5wdXRcIiA6IFwia2V5dXBcIjtcclxuICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgIHZhciBpbnB1dFZhbHVlID0gXCJcIjtcclxuICAgICAgdmFyIG1pbkxlbiA9IDI7XHJcbiAgICAgIHZhciBzaG93T25Gb2N1cyA9IHNldHRpbmdzLnNob3dPbkZvY3VzO1xyXG4gICAgICB2YXIgc2VsZWN0ZWQ7XHJcbiAgICAgIHZhciBrZXlwcmVzc0NvdW50ZXIgPSAwO1xyXG4gICAgICB2YXIgZGVib3VuY2VUaW1lcjtcclxuICAgICAgaWYgKHNldHRpbmdzLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBtaW5MZW4gPSBzZXR0aW5ncy5taW5MZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFzZXR0aW5ncy5pbnB1dCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdW5kZWZpbmVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbnB1dCA9IHNldHRpbmdzLmlucHV0O1xyXG4gICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJhdXRvY29tcGxldGUgXCIgKyAoc2V0dGluZ3MuY2xhc3NOYW1lIHx8IFwiXCIpO1xyXG4gICAgICAvLyBJT1MgaW1wbGVtZW50YXRpb24gZm9yIGZpeGVkIHBvc2l0aW9uaW5nIGhhcyBtYW55IGJ1Z3MsIHNvIHdlIHdpbGwgdXNlIGFic29sdXRlIHBvc2l0aW9uaW5nXHJcbiAgICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAvKipcclxuICAgICAgICogRGV0YWNoIHRoZSBjb250YWluZXIgZnJvbSBET01cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcclxuICAgICAgICAgIHZhciBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZTtcclxuICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gY2xlYXJEZWJvdW5jZVRpbWVyKCkge1xyXG4gICAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcclxuICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGF0dGFjaCgpIHtcclxuICAgICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGNvbnRhaW5lckRpc3BsYXllZCgpIHtcclxuICAgICAgICAgIHJldHVybiAhIWNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDbGVhciBhdXRvY29tcGxldGUgc3RhdGUgYW5kIGhpZGUgY29udGFpbmVyXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBjbGVhcigpIHtcclxuICAgICAgICAgIC8vIHByZXZlbnQgdGhlIHVwZGF0ZSBjYWxsIGlmIHRoZXJlIGFyZSBwZW5kaW5nIEFKQVggcmVxdWVzdHNcclxuICAgICAgICAgIGtleXByZXNzQ291bnRlcisrO1xyXG4gICAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBkZXRhY2goKTtcclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogVXBkYXRlIGF1dG9jb21wbGV0ZSBwb3NpdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XHJcbiAgICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9IGlucHV0Lm9mZnNldFdpZHRoICsgXCJweFwiO1xyXG4gICAgICAgICAgdmFyIG1heEhlaWdodCA9IDA7XHJcbiAgICAgICAgICB2YXIgaW5wdXRSZWN0O1xyXG4gICAgICAgICAgZnVuY3Rpb24gY2FsYygpIHtcclxuICAgICAgICAgICAgICB2YXIgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgIHZhciBjbGllbnRUb3AgPSBkb2NFbC5jbGllbnRUb3AgfHwgZG9jLmJvZHkuY2xpZW50VG9wIHx8IDA7XHJcbiAgICAgICAgICAgICAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGRvYy5ib2R5LmNsaWVudExlZnQgfHwgMDtcclxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICAgIGlucHV0UmVjdCA9IGlucHV0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgIHZhciB0b3AgPSBpbnB1dFJlY3QudG9wICsgaW5wdXQub2Zmc2V0SGVpZ2h0ICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xyXG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0gaW5wdXRSZWN0LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcclxuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gKGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS5ib3R0b20gPSBcIlwiO1xyXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIHRoZSBjYWxjIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB0d2ljZSwgb3RoZXJ3aXNlIHRoZSBjYWxjdWxhdGlvbiBtYXkgYmUgd3Jvbmcgb24gcmVzaXplIGV2ZW50IChjaHJvbWUgYnJvd3NlcilcclxuICAgICAgICAgIGNhbGMoKTtcclxuICAgICAgICAgIGNhbGMoKTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5jdXN0b21pemUgJiYgaW5wdXRSZWN0KSB7XHJcbiAgICAgICAgICAgICAgc2V0dGluZ3MuY3VzdG9taXplKGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogUmVkcmF3IHRoZSBhdXRvY29tcGxldGUgZGl2IGVsZW1lbnQgd2l0aCBzdWdnZXN0aW9uc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xyXG4gICAgICAgICAgLy8gZGVsZXRlIGFsbCBjaGlsZHJlbiBmcm9tIGF1dG9jb21wbGV0ZSBET00gY29udGFpbmVyXHJcbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbnNcclxuICAgICAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiAoaXRlbSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgaXRlbUVsZW1lbnQudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXIpIHtcclxuICAgICAgICAgICAgICByZW5kZXIgPSBzZXR0aW5ncy5yZW5kZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBmdW5jdGlvbiB0byByZW5kZXIgYXV0b2NvbXBsZXRlIGdyb3Vwc1xyXG4gICAgICAgICAgdmFyIHJlbmRlckdyb3VwID0gZnVuY3Rpb24gKGdyb3VwTmFtZSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGdyb3VwRGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgZ3JvdXBEaXYudGV4dENvbnRlbnQgPSBncm91cE5hbWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwRGl2O1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJHcm91cCkge1xyXG4gICAgICAgICAgICAgIHJlbmRlckdyb3VwID0gc2V0dGluZ3MucmVuZGVyR3JvdXA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgdmFyIHByZXZHcm91cCA9IFwiIzk/JFwiO1xyXG4gICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgIGlmIChpdGVtLmdyb3VwICYmIGl0ZW0uZ3JvdXAgIT09IHByZXZHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICBwcmV2R3JvdXAgPSBpdGVtLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBEaXYgPSByZW5kZXJHcm91cChpdGVtLmdyb3VwLCBpbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwRGl2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBncm91cERpdi5jbGFzc05hbWUgKz0gXCIgZ3JvdXBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGdyb3VwRGl2KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YXIgZGl2ID0gcmVuZGVyKGl0ZW0sIGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmIChkaXYpIHtcclxuICAgICAgICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KGl0ZW0sIGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgKz0gXCIgc2VsZWN0ZWRcIjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5TXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBlbXB0eSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICBlbXB0eS5jbGFzc05hbWUgPSBcImVtcHR5XCI7XHJcbiAgICAgICAgICAgICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gc2V0dGluZ3MuZW1wdHlNc2c7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXR0YWNoKCk7XHJcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgdXBkYXRlU2Nyb2xsKCk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlSWZEaXNwbGF5ZWQoKSB7XHJcbiAgICAgICAgICBpZiAoY29udGFpbmVyRGlzcGxheWVkKCkpIHtcclxuICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiByZXNpemVFdmVudEhhbmRsZXIoKSB7XHJcbiAgICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHNjcm9sbEV2ZW50SGFuZGxlcihlKSB7XHJcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24ga2V5dXBFdmVudEhhbmRsZXIoZXYpIHtcclxuICAgICAgICAgIHZhciBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xyXG4gICAgICAgICAgdmFyIGlnbm9yZSA9IHNldHRpbmdzLmtleXNUb0lnbm9yZSB8fCBbMzggLyogVXAgKi8sIDEzIC8qIEVudGVyICovLCAyNyAvKiBFc2MgKi8sIDM5IC8qIFJpZ2h0ICovLCAzNyAvKiBMZWZ0ICovLCAxNiAvKiBTaGlmdCAqLywgMTcgLyogQ3RybCAqLywgMTggLyogQWx0ICovLCAyMCAvKiBDYXBzTG9jayAqLywgOTEgLyogV2luZG93c0tleSAqLywgOSAvKiBUYWIgKi9dO1xyXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpZ25vcmVfMSA9IGlnbm9yZTsgX2kgPCBpZ25vcmVfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICB2YXIga2V5ID0gaWdub3JlXzFbX2ldO1xyXG4gICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChrZXlDb2RlID49IDExMiAvKiBGMSAqLyAmJiBrZXlDb2RlIDw9IDEyMyAvKiBGMTIgKi8gJiYgIXNldHRpbmdzLmtleXNUb0lnbm9yZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIHRoZSBkb3duIGtleSBpcyB1c2VkIHRvIG9wZW4gYXV0b2NvbXBsZXRlXHJcbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gNDAgLyogRG93biAqLyAmJiBjb250YWluZXJEaXNwbGF5ZWQoKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0YXJ0RmV0Y2goMCAvKiBLZXlib2FyZCAqLyk7XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcclxuICAgICAgICAgIHZhciBlbGVtZW50cyA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbMF07XHJcbiAgICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXHJcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jbGFzc05hbWUuaW5kZXhPZihcImdyb3VwXCIpICE9PSAtMSAmJiAhcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFRvcCA8IGNvbnRhaW5lci5zY3JvbGxUb3ApIHtcclxuICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJvdHRvbSA9IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdEJvdHRvbSA+IGNvbnRhaW5lckJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBzZWxlY3RCb3R0b20gLSBjb250YWluZXJCb3R0b207XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gc2VsZWN0UHJldigpIHtcclxuICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbGVjdCB0aGUgbmV4dCBpdGVtIGluIHN1Z2dlc3Rpb25zXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBzZWxlY3ROZXh0KCkge1xyXG4gICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPT09IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGtleWRvd25FdmVudEhhbmRsZXIoZXYpIHtcclxuICAgICAgICAgIHZhciBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xyXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IDM4IC8qIFVwICovIHx8IGtleUNvZGUgPT09IDQwIC8qIERvd24gKi8gfHwga2V5Q29kZSA9PT0gMjcgLyogRXNjICovKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lcklzRGlzcGxheWVkID0gY29udGFpbmVyRGlzcGxheWVkKCk7XHJcbiAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IDI3IC8qIEVzYyAqLykge1xyXG4gICAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJJc0Rpc3BsYXllZCB8fCBpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAga2V5Q29kZSA9PT0gMzggLyogVXAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgID8gc2VsZWN0UHJldigpXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklzRGlzcGxheWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTMgLyogRW50ZXIgKi8pIHtcclxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHByZXZlbnRTdWJtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZm9jdXNFdmVudEhhbmRsZXIoKSB7XHJcbiAgICAgICAgICBpZiAoc2hvd09uRm9jdXMpIHtcclxuICAgICAgICAgICAgICBzdGFydEZldGNoKDEgLyogRm9jdXMgKi8pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0RmV0Y2godHJpZ2dlcikge1xyXG4gICAgICAgICAgLy8gSWYgbXVsdGlwbGUga2V5cyB3ZXJlIHByZXNzZWQsIGJlZm9yZSB3ZSBnZXQgYW4gdXBkYXRlIGZyb20gc2VydmVyLFxyXG4gICAgICAgICAgLy8gdGhpcyBtYXkgY2F1c2UgcmVkcmF3aW5nIGF1dG9jb21wbGV0ZSBtdWx0aXBsZSB0aW1lcyBhZnRlciB0aGUgbGFzdCBrZXkgd2FzIHByZXNzZWQuXHJcbiAgICAgICAgICAvLyBUbyBhdm9pZCB0aGlzLCB0aGUgbnVtYmVyIG9mIHRpbWVzIGtleWJvYXJkIHdhcyBwcmVzc2VkIHdpbGwgYmUgc2F2ZWQgYW5kIGNoZWNrZWQgYmVmb3JlIHJlZHJhdy5cclxuICAgICAgICAgIHZhciBzYXZlZEtleXByZXNzQ291bnRlciA9ICsra2V5cHJlc3NDb3VudGVyO1xyXG4gICAgICAgICAgdmFyIGlucHV0VGV4dCA9IGlucHV0LnZhbHVlO1xyXG4gICAgICAgICAgdmFyIGN1cnNvclBvcyA9IGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XHJcbiAgICAgICAgICBpZiAoaW5wdXRUZXh0Lmxlbmd0aCA+PSBtaW5MZW4gfHwgdHJpZ2dlciA9PT0gMSAvKiBGb2N1cyAqLykge1xyXG4gICAgICAgICAgICAgIGNsZWFyRGVib3VuY2VUaW1lcigpO1xyXG4gICAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmZldGNoKGlucHV0VGV4dCwgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cHJlc3NDb3VudGVyID09PSBzYXZlZEtleXByZXNzQ291bnRlciAmJiBlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IChpdGVtcy5sZW5ndGggPCAxIHx8IGRpc2FibGVBdXRvU2VsZWN0KSA/IHVuZGVmaW5lZCA6IGl0ZW1zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LCB0cmlnZ2VyLCBjdXJzb3JQb3MpO1xyXG4gICAgICAgICAgICAgIH0sIHRyaWdnZXIgPT09IDAgLyogS2V5Ym9hcmQgKi8gPyBkZWJvdW5jZVdhaXRNcyA6IDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBibHVyRXZlbnRIYW5kbGVyKCkge1xyXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBjbGVhciwgYmVjYXVzZSB3aGVuIHdlIGNsaWNrIG9uIGFuIGl0ZW0sIGJsdXIgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGNsaWNrIGFuZCByZW1vdmUgaXRlbXMgZnJvbSBET01cclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaXhlcyAjMjY6IG9uIGxvbmcgY2xpY2tzIGZvY3VzIHdpbGwgYmUgbG9zdCBhbmQgb25TZWxlY3QgbWV0aG9kIHdpbGwgbm90IGJlIGNhbGxlZFxyXG4gICAgICAgKi9cclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAvKipcclxuICAgICAgICogRml4ZXMgIzMwOiBhdXRvY29tcGxldGUgY2xvc2VzIHdoZW4gc2Nyb2xsYmFyIGlzIGNsaWNrZWQgaW4gSUVcclxuICAgICAgICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTIxMDI2Ny8xMzE3MjM0OVxyXG4gICAgICAgKi9cclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5mb2N1cygpOyB9KTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgRE9NIGVsZW1lbnRzIGFuZCBjbGVhciBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XHJcbiAgICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcclxuICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gc2V0dXAgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyKTtcclxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95XHJcbiAgICAgIH07XHJcbiAgfVxuXG4gIHJldHVybiBhdXRvY29tcGxldGU7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvY29tcGxldGUuanMubWFwXG4iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhcmlhYmxlQXV0b2NvbXBsZXRlSXRlbXMocGx1Z2luOiBTQ19QbHVnaW4pIHtcclxuICAgIGlmICgwID09PSBhdXRvY29tcGxldGVfaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcGx1Z2luLmdldFZhcmlhYmxlcygpLmZvckVhY2goKHZhcmlhYmxlKSA9PiB7XHJcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZV9pdGVtcy5wdXNoKC4uLnZhcmlhYmxlLmdldEF1dG9jb21wbGV0ZUl0ZW1zKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF1dG9jb21wbGV0ZV9pdGVtcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtcygpIHtcclxuICAgIHdoaWxlIChhdXRvY29tcGxldGVfaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgYXV0b2NvbXBsZXRlX2l0ZW1zLnBvcCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBhdXRvY29tcGxldGVfaXRlbXM6IElBdXRvY29tcGxldGVJdGVtW10gPSBbXTsiLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQgYXV0b2NvbXBsZXRlIGZyb20gXCJhdXRvY29tcGxldGVyXCI7XHJcbmltcG9ydCB7cGFyc2VZYW1sfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQge2dldFZhcmlhYmxlQXV0b2NvbXBsZXRlSXRlbXN9IGZyb20gXCIuLi8uLi92YXJpYWJsZXMvZ2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtc1wiO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBwbHVnaW4gVXNlZCBmb3IgZ2V0dGluZyBhIGxpc3Qgb2YgVmFyaWFibGUgYXV0b2NvbXBsZXRlIGl0ZW1zLlxyXG4gKiBAcGFyYW0gaW5wdXRfZWxlbWVudFxyXG4gKiBAcGFyYW0gY2FsbF9vbl9jb21wbGV0aW9uIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdXNlciBoYXMgc2VsZWN0ZWQgYSBzdWdnZXN0aW9uIGFuZCBwZXJmb3JtZWQgdGhlIGF1dG9jb21wbGV0ZSBhY3Rpb24uIG9uQ2hhbmdlIGV2ZW50IHdpbGwgbm90IGJlIGNhbGxlZCwgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9wZW5pbmcgdGhlIGF1dG9jb21wbGV0ZSBtZW51IGFnYWluLCBzbyB0aGF0J3Mgd2h5IGEgc2VwYXJhdGUgY2FsbGJhY2sgaXMgdXNlZC5cclxuICogQHBhcmFtIGV4dHJhX2F1dG9jb21wbGV0ZV9pdGVtc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF1dG9jb21wbGV0ZShwbHVnaW46IFNDX1BsdWdpbiwgaW5wdXRfZWxlbWVudDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQsIGNhbGxfb25fY29tcGxldGlvbjogKGZpZWxkX3ZhbHVlOiBzdHJpbmcpID0+IHZvaWQsIGV4dHJhX2F1dG9jb21wbGV0ZV9pdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSA9IFtdKSB7XHJcblxyXG4gICAgYXV0b2NvbXBsZXRlPElBdXRvY29tcGxldGVJdGVtPih7XHJcbiAgICAgICAgaW5wdXQ6IGlucHV0X2VsZW1lbnQsXHJcbiAgICAgICAgZmV0Y2g6IChpbnB1dF92YWx1ZV9idXRfbm90X3VzZWQ6IHN0cmluZywgdXBkYXRlOiAoaXRlbXM6IElBdXRvY29tcGxldGVJdGVtW10pID0+IHZvaWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlX2l0ZW1zID0gbWVyZ2VfYW5kX3NvcnRfYXV0b2NvbXBsZXRlX2l0ZW1zKGdldFZhcmlhYmxlQXV0b2NvbXBsZXRlSXRlbXMocGx1Z2luKSwgQ3VzdG9tQXV0b2NvbXBsZXRlSXRlbXMsIGV4dHJhX2F1dG9jb21wbGV0ZV9pdGVtcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heF9zdWdnZXN0aW9ucyA9IDMwO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBzbyBmYXIgdHlwZWQgdGV4dCAtIGV4Y2x1ZGUgZXZlcnl0aGluZyB0aGF0IGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjYXJldC5cclxuICAgICAgICAgICAgY29uc3QgY2FyZXRfcG9zaXRpb24gPSBpbnB1dF9lbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlZF90ZXh0ID0gaW5wdXRfZWxlbWVudC52YWx1ZS5zbGljZSgwLCBjYXJldF9wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaF9xdWVyeSA9IGdldF9zZWFyY2hfcXVlcnkodHlwZWRfdGV4dCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoXCJcIiA9PT0gc2VhcmNoX3F1ZXJ5LnNlYXJjaF90ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBzdWdnZXN0aW9ucyBmb3IgZW1wdHkgd29yZC5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZShbXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgd29yZCBpcyBub3QgZW1wdHksIHNvIGNhbiBzdWdnZXN0IHNvbWV0aGluZy5cclxuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkX2l0ZW1zID0gYXV0b2NvbXBsZXRlX2l0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW1fbWF0Y2goaXRlbSwgc2VhcmNoX3F1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICBzb3J0X2F1dG9jb21wbGV0ZV9pdGVtcyhtYXRjaGVkX2l0ZW1zLCBzZWFyY2hfcXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZF9pdGVtcyA9IG1hdGNoZWRfaXRlbXMuc2xpY2UoMCwgbWF4X3N1Z2dlc3Rpb25zKTsgLy8gTGltaXQgdG8gYSByZWFzb25hYmxlIGFtb3VudCBvZiBzdWdnZXN0aW9ucy5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZShtYXRjaGVkX2l0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25TZWxlY3Q6IChpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEEgdXNlciBoYXMgc2VsZWN0ZWQgYW4gaXRlbSB0byBiZSBhdXRvY29tcGxldGVkXHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGl0ZW0gdGV4dCBhbmQgYWxyZWFkeSB0eXBlZCB0ZXh0XHJcbiAgICAgICAgICAgIGxldCBzdXBwbGVtZW50ID0gaXRlbS52YWx1ZTtcclxuICAgICAgICAgICAgbGV0IGNhcmV0X3Bvc2l0aW9uID0gaW5wdXRfZWxlbWVudC5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICAgICAgY29uc3QgdHlwZWRfdGV4dCA9IGlucHV0X2VsZW1lbnQudmFsdWUuc2xpY2UoMCwgY2FyZXRfcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfcXVlcnkgPSBnZXRfc2VhcmNoX3F1ZXJ5KHR5cGVkX3RleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfdGV4dCA9IHNlYXJjaF9xdWVyeS5zZWFyY2hfdGV4dDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogQ2hlY2sgaWYgfX0gaGFwcGVucyB0byBhcHBlYXIgYWZ0ZXIgdGhlIGNhcmV0XHJcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyX2NhcmV0ID0gaW5wdXRfZWxlbWVudC52YWx1ZS5zbGljZShjYXJldF9wb3NpdGlvbiwgY2FyZXRfcG9zaXRpb24gKyAyKTtcclxuICAgICAgICAgICAgaWYgKFwifX1cIiA9PT0gYWZ0ZXJfY2FyZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXBsYWNpbmcgd2lsbCBoYXBwZW4gaW4gYSB7e3ZhcmlhYmxlfX0uXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWNjaWRlbnRhbGx5IGluc2VydCBhbm90aGVyIH19IHBhaXIuXHJcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50ID0gc3VwcGxlbWVudC5yZXBsYWNlKC9cXH1cXH0kL3UsIFwiXCIpOyAvLyBPbmx5IHJlbW92ZXMgYSB0cmFpbGluZyB9fSBpZiB0aGVyZSBpcyBvbmUuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBzYXZlIHBhcnQgb2YgdGhlIGJlZ2lubmluZywgaW4gY2FzZSBpdCBzZWVtcyBsaWtlIG5vdCBiZWluZyBwYXJ0IG9mIHRoZSBzZWFyY2ggcXVlcnkuXHJcbiAgICAgICAgICAgIGxldCByZXBsYWNlX3N0YXJ0ID0gZmluZF9zdGFydGluZ19wb3NpdGlvbihzZWFyY2hfdGV4dCwgc3VwcGxlbWVudCk7IC8vIFRoZSBsZW5ndGggZGlmZmVyZW5jZSBvZiB0eXBlZF90ZXh0IGFuZCBzZWFyY2hfdGV4dCB3aWxsIGJlIGFkZGVkIGhlcmUgYmVsb3cuXHJcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gcmVwbGFjZV9zdGFydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgaWYgaXQgZG9lcywgZG8gbm90IHJlcGxhY2UgYW55dGhpbmcsIGp1c3QgaW5zZXJ0LlxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZV9zdGFydCA9IGNhcmV0X3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZV9zdGFydCArPSB0eXBlZF90ZXh0Lmxlbmd0aCAtIHNlYXJjaF90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hvb3NlIGEgbWV0aG9kIGZvciBkb2luZyB0aGUgaW5zZXJ0aW5nXHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGRvY3VtZW50LmV4ZWNDb21tYW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBleGVjQ29tbWFuZCgpIGlzIGRlcHJlY2F0ZWQsIGJ1dCBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgaXQgdG8gZG8gdGhlIGluc2VydGlvbiwgYmVjYXVzZSB0aGlzIHdheSBhbiB1bmRvIGhpc3RvcnkgY2FuIGJlIHByZXNlcnZlZC5cclxuICAgICAgICAgICAgICAgIGlucHV0X2VsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UocmVwbGFjZV9zdGFydCwgY2FyZXRfcG9zaXRpb24pOyAvLyBGaXJzdCBzZWxlY3QgdGhlIHBhcnQgdGhhdCB3aWxsIGJlIHJlcGxhY2VkLCBiZWNhdXNlIGV4ZWNDb21tYW5kKCkgZG9lcyBub3Qgc3VwcG9ydCBkZWZpbmluZyBwb3NpdGlvbnMuIFRoaXMgYWRkcyBhIGN1bWJlcnNvbWUgc2VsZWN0aW9uIHN0ZXAgdG8gdGhlIHVuZG8gaGlzdG9yeSwgYnV0IGF0IGxlYXN0IHVuZG9pbmcgd29ya3MuXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImluc2VydFRleHRcIiwgZmFsc2UsIHN1cHBsZW1lbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhlY0NvbW1hbmQoKSBpcyBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc2V0UmFuZ2VUZXh0KCkgdG8gZG8gdGhlIGluc2VydGlvbi4gSXQgd2lsbCBjbGVhciB1bmRvIGhpc3RvcnksIGJ1dCBhdCBsZWFzdCB0aGUgaW5zZXJ0aW9uIHdvcmtzLlxyXG4gICAgICAgICAgICAgICAgaW5wdXRfZWxlbWVudC5zZXRSYW5nZVRleHQoc3VwcGxlbWVudCwgcmVwbGFjZV9zdGFydCwgY2FyZXRfcG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBjYXJldCB0byBhIGxvZ2ljYWwgY29udGludWF0aW9uIHBvaW50XHJcbiAgICAgICAgICAgIGNhcmV0X3Bvc2l0aW9uID0gcmVwbGFjZV9zdGFydCArIHN1cHBsZW1lbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoc3VwcGxlbWVudC5tYXRjaCgvOlxcfVxcfSQvdSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBsYWNlIHRoZSBjYXJldCBhZnRlciB0aGUgY29sb24sIGluc3RlYWQgb2YgYWZ0ZXIgfX0uXHJcbiAgICAgICAgICAgICAgICBjYXJldF9wb3NpdGlvbiAtPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlucHV0X2VsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UoY2FyZXRfcG9zaXRpb24sIGNhcmV0X3Bvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgYSBob29rXHJcbiAgICAgICAgICAgIGNhbGxfb25fY29tcGxldGlvbihpbnB1dF9lbGVtZW50LnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbmRlcjogKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGl2X2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBkaXZfZWxlbWVudC5jcmVhdGVTcGFuKHt0ZXh0OiBpdGVtLnZhbHVlLCBhdHRyOiB7Y2xhc3M6IFwiU0MtYXV0b2NvbXBsZXRlLXZhbHVlXCJ9fSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmhlbHBfdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgZGl2X2VsZW1lbnQuY3JlYXRlU3Bhbih7dGV4dDogXCI6IFwiLCBhdHRyOiB7Y2xhc3M6IFwiU0MtYXV0b2NvbXBsZXRlLXNlcGFyYXRvclwifX0pO1xyXG4gICAgICAgICAgICAgICAgZGl2X2VsZW1lbnQuY3JlYXRlU3Bhbih7YXR0cjoge2NsYXNzOiBcIlNDLWF1dG9jb21wbGV0ZS1oZWxwLXRleHRcIn19KS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaXRlbS5oZWxwX3RleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZfZWxlbWVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1pbkxlbmd0aDogMiwgLy8gTWluaW11bSBsZW5ndGggd2hlbiBhdXRvY29tcGxldGUgbWVudSBzaG91bGQgcG9wIHVwLlxyXG4gICAgICAgIGNsYXNzTmFtZTogXCJTQy1hdXRvY29tcGxldGVcIiwgLy8gVGhlIGNvbXBvbmVudCBhbHdheXMgaGFzIGEgY2xhc3MgJ2F1dG9jb21wbGV0ZScsIGJ1dCBhZGQgJ1NDLWF1dG9jb21wbGV0ZScgc28gdGhhdCBTQydzIENTUyBjYW4gdGFyZ2V0ICdTQy1hdXRvY29tcGxldGUnLCBzbyBpdCB3aWxsIG5vdCBtZXNzIHVwIHN0dWZmIGlmIE9ic2lkaWFuIGhhcHBlbnMgdG8gaGF2ZSBhbiBlbGVtZW50IHdpdGggY2xhc3MgJ2F1dG9jb21wbGV0ZScuXHJcbiAgICAgICAga2V5c1RvSWdub3JlOiBbIDM4IC8qIFVwICovLCAxMyAvKiBFbnRlciAqLywgMjcgLyogRXNjICovLCAxNiAvKiBTaGlmdCAqLywgMTcgLyogQ3RybCAqLywgMTggLyogQWx0ICovLCAyMCAvKiBDYXBzTG9jayAqLywgOTEgLyogV2luZG93c0tleSAqLywgOSAvKiBUYWIgKi8gXSwgLy8gRGVmaW5lZCBqdXN0IHRvIHByZXZlbnQgaWdub3JpbmcgbGVmdCBhbmQgcmlnaHQga2V5cy5cclxuICAgICAgICBwcmV2ZW50U3VibWl0OiB0cnVlLCAvLyBQcmV2ZW50cyBjcmVhdGluZyBuZXdsaW5lcyBpbiB0ZXh0YXJlYXMgd2hlbiBlbnRlciBpcyBwcmVzc2VkIGluIHRoZSBhdXRvY29tcGxldGUgbWVudS5cclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBdXRvY29tcGxldGVJdGVtIHtcclxuICAgIGhlbHBfdGV4dDogc3RyaW5nO1xyXG4gICAgdmFsdWU6IHN0cmluZztcclxuICAgIGdyb3VwOiBzdHJpbmc7XHJcbiAgICB0eXBlOiBBdXRvY29tcGxldGVTZWFyY2hRdWVyeVR5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGl0ZW1fbWF0Y2goaXRlbTogSUF1dG9jb21wbGV0ZUl0ZW0sIHNlYXJjaF9xdWVyeTogSUF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5KTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBpdGVtX3ZhbHVlID0gaXRlbS52YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3Qgc2VhcmNoX3RleHQgPSBzZWFyY2hfcXVlcnkuc2VhcmNoX3RleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuXHJcbiAgICAvLyBNYXRjaCBxdWVyeSB0eXBlXHJcbiAgICBpZiAoaXRlbS50eXBlICE9PSBzZWFyY2hfcXVlcnkuc2VhcmNoX3R5cGUpIHtcclxuICAgICAgICAvLyBJZiB0aGUgcXVlcnkgdHlwZSBpcyBkaWZmZXJlbnQsIGRvIG5vdCBpbmNsdWRlIHRoaXMgaXRlbS5cclxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gZS5nLiBpZiB7eyBpcyB0eXBlZCwgYW5kIHRoZSBpdGVtIGlzIG5vdCBhIHZhcmlhYmxlLCBvciB7eyEgaXMgdHlwZWQsIGFuZCB0aGUgaXRlbSBpcyBub3QgYW4gdW5lc2NhcGVkIHZhcmlhYmxlLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYXRjaCB0ZXh0XHJcbiAgICBsZXQgc2VhcmNoX2NoYXJhY3Rlcjogc3RyaW5nO1xyXG4gICAgbGV0IHNlYXJjaF9wb3NpdGlvbiA9IDA7XHJcbiAgICBmb3IgKGxldCBzZWFyY2hfY2hhcmFjdGVyX2luZGV4ID0gMDsgc2VhcmNoX2NoYXJhY3Rlcl9pbmRleCA8IHNlYXJjaF90ZXh0Lmxlbmd0aDsgc2VhcmNoX2NoYXJhY3Rlcl9pbmRleCsrKSB7XHJcbiAgICAgICAgc2VhcmNoX2NoYXJhY3RlciA9IHNlYXJjaF90ZXh0W3NlYXJjaF9jaGFyYWN0ZXJfaW5kZXhdO1xyXG4gICAgICAgIGlmIChpdGVtX3ZhbHVlLmluY2x1ZGVzKHNlYXJjaF9jaGFyYWN0ZXIsIHNlYXJjaF9wb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjaGFyYWN0ZXIgd2FzIGZvdW5kIGluIGl0ZW1fdmFsdWUuXHJcbiAgICAgICAgICAgIHNlYXJjaF9wb3NpdGlvbiA9IGl0ZW1fdmFsdWUuaW5kZXhPZihzZWFyY2hfY2hhcmFjdGVyLCBzZWFyY2hfcG9zaXRpb24pICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNoYXJhY3RlciB3YXMgbm90IGZvdW5kLlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRfc3RhcnRpbmdfcG9zaXRpb24odHlwZWRfdGV4dDogc3RyaW5nLCBzdXBwbGVtZW50OiBzdHJpbmcpIHtcclxuICAgIHR5cGVkX3RleHQgPSB0eXBlZF90ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICBzdXBwbGVtZW50ID0gc3VwcGxlbWVudC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgZm9yIChsZXQgc3VwcGxlbWVudF9pbmRleCA9IHN1cHBsZW1lbnQubGVuZ3RoOyBzdXBwbGVtZW50X2luZGV4ID49IDA7IHN1cHBsZW1lbnRfaW5kZXgtLSkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRpYWxfc3VwcGxlbWVudCA9IHN1cHBsZW1lbnQuc2xpY2UoMCwgc3VwcGxlbWVudF9pbmRleCk7XHJcbiAgICAgICAgaWYgKHR5cGVkX3RleHQuY29udGFpbnMocGFydGlhbF9zdXBwbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZWRfdGV4dC5pbmRleE9mKHBhcnRpYWxfc3VwcGxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydHMgaW4gcGxhY2UsIGRvZXMgbm90IG1ha2UgYSBjb3B5LlxyXG4gKiBAcGFyYW0gYXV0b2NvbXBsZXRlX2l0ZW1zXHJcbiAqIEBwYXJhbSBzZWFyY2hfcXVlcnlcclxuICovXHJcbmZ1bmN0aW9uIHNvcnRfYXV0b2NvbXBsZXRlX2l0ZW1zKGF1dG9jb21wbGV0ZV9pdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSwgc2VhcmNoX3F1ZXJ5OiBJQXV0b2NvbXBsZXRlU2VhcmNoUXVlcnkpOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBzZWFyY2hfdGV4dF9leGNsdWRpbmdfY3VybHlfYnJhY2tldHMgPSBzZWFyY2hfcXVlcnkuc2VhcmNoX3RleHQucmVwbGFjZSgvXnt7IT8vLCBcIlwiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRfY29tbW9uX2JlZ2lubmluZ19sZW5ndGgoYXV0b2NvbXBsZXRlX2l0ZW06IElBdXRvY29tcGxldGVJdGVtLCBzZWFyY2hfcXVlcnk6IElBdXRvY29tcGxldGVTZWFyY2hRdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaF90ZXh0ID0gc2VhcmNoX3F1ZXJ5LnNlYXJjaF90ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgaXRlbV92YWx1ZSA9IGF1dG9jb21wbGV0ZV9pdGVtLnZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3Qgc2hvcnRlc3RfbGVuZ3RoID0gTWF0aC5taW4oc2VhcmNoX3RleHQubGVuZ3RoLCBpdGVtX3ZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgY2hhcmFjdGVyX2luZGV4ID0gMDsgY2hhcmFjdGVyX2luZGV4IDwgc2hvcnRlc3RfbGVuZ3RoOyBjaGFyYWN0ZXJfaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfY2hhcmFjdGVyID0gc2VhcmNoX3RleHRbY2hhcmFjdGVyX2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbV9jaGFyYWN0ZXIgPSBpdGVtX3ZhbHVlW2NoYXJhY3Rlcl9pbmRleF07XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hfY2hhcmFjdGVyICE9PSBpdGVtX2NoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbW1vbiBiZWdpbm5pbmcgaGFzIGVuZGVkLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3Rlcl9pbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hvcnRlc3RfbGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGF1dG9jb21wbGV0ZV9pdGVtcy5zb3J0KChhOiBJQXV0b2NvbXBsZXRlSXRlbSwgYjogSUF1dG9jb21wbGV0ZUl0ZW0pID0+IHtcclxuICAgICAgICBjb25zdCBib29zdF9hID0gTWF0aC5tYXgoZ2V0X2NvbW1vbl9iZWdpbm5pbmdfbGVuZ3RoKGEsIHNlYXJjaF9xdWVyeSksIDEpOyAvLyBCb29zdHMgYXJlIHVzZWQgYXMgbXVsdGlwbGllcnMsXHJcbiAgICAgICAgY29uc3QgYm9vc3RfYiA9IE1hdGgubWF4KGdldF9jb21tb25fYmVnaW5uaW5nX2xlbmd0aChiLCBzZWFyY2hfcXVlcnkpLCAxKTsgLy8gc28gdGhleSBjYW5ub3QgYmUgemVyby5cclxuICAgICAgICBjb25zdCBhX2xlbmd0aCA9IGEudmFsdWUubGVuZ3RoICogYm9vc3RfYjsgLy8gYm9vc3RfYiB3b3JzZW5zIEEgKD0gbWFrZXMgaXQgYXJ0aWZpY2lhbGx5IFwibG9uZ2VyXCIpXHJcbiAgICAgICAgY29uc3QgYl9sZW5ndGggPSBiLnZhbHVlLmxlbmd0aCAqIGJvb3N0X2E7IC8vIGJvb3N0X2Egd29yc2VucyBCXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNvcnRpbmcgbWV0aG9kLiBJZiB0aGUgc2VhcmNoIHF1ZXJ5IGlzIGp1c3QgYSBjb3VwbGUgb2YgY2hhcmFjdGVycywgdGhlIG1hdGNoZXMgd291bGQgYmUgcXVpdGUgdmFndWUsIHNvcnRpbmcgYnkgdGhlIG1hdGNoZWQgaXRlbXMnIGxlbmd0aCB3b3VsZCBub3QgdGVsbCBtdWNoLCBhbmQgdGhlIGxpc3Qgd291bGQganVzdCBsb29rIHN0cmFuZ2VseSBvcmRlcmVkLlxyXG4gICAgICAgIGlmIChzZWFyY2hfdGV4dF9leGNsdWRpbmdfY3VybHlfYnJhY2tldHMubGVuZ3RoIDwgMiB8fCBhX2xlbmd0aCA9PT0gYl9sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gU29ydCBhbHBoYWJldGljYWxseS5cclxuICAgICAgICAgICAgcmV0dXJuIGEudmFsdWUgPiBiLnZhbHVlID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNvcnQgYnkgbGVuZ3Rocy4gVGhlIHNob3J0ZXN0IGl0ZW0gaXMgcHJlZmVycmVkLiBJZiBhbiBpdGVtIGhhcyBhIGxvbmcgY29tbW9uIGJlZ2lubmluZyB3aXRoIHRoZSBzZWFyY2ggcXVlcnksIGJvb3N0IHRoZSBpdGVtIHVwLlxyXG4gICAgICAgICAgICByZXR1cm4gYV9sZW5ndGggLSBiX2xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbmNvbnN0IEN1c3RvbUF1dG9jb21wbGV0ZUl0ZW1zOiBJQXV0b2NvbXBsZXRlSXRlbVtdID0gW107XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3VzdG9tQXV0b2NvbXBsZXRlSXRlbXMoY3VzdG9tX2F1dG9jb21wbGV0ZV95YW1sOiBzdHJpbmcpIHtcclxuXHJcbiAgICAvLyBFbnN1cmUgdGhlIGNvbnRlbnQgaXMgbm90IGVtcHR5XHJcbiAgICBpZiAoMCA9PT0gY3VzdG9tX2F1dG9jb21wbGV0ZV95YW1sLnRyaW0oKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gXCJUaGUgY29udGVudCBpcyBlbXB0eS5cIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgdG8gcGFyc2UgWUFNTCBzeW50YXhcclxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgbGV0IHlhbWw6IGFueTsgLy8gJ2FueScgaXMgZGVmaW5lZCBpbiBvYnNpZGlhbi5kLnRzIGZvciB0aGUgcmV0dXJuIHR5cGUgb2YgcGFyc2VZYW1sKCksIHNvIEkgbWFkZSBFU0xpbnQgaWdub3JlIGl0LlxyXG4gICAgdHJ5IHtcclxuICAgICAgICB5YW1sID0gcGFyc2VZYW1sKGN1c3RvbV9hdXRvY29tcGxldGVfeWFtbCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIEEgc3ludGF4IGVycm9yIGhhcyBhcHBlYXJlZC5cclxuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcclxuICAgIH1cclxuICAgIGlmIChudWxsID09PSB5YW1sIHx8IHR5cGVvZiB5YW1sICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVW5hYmxlIHRvIHBhcnNlIHRoZSBjb250ZW50IGR1ZSB0byB1bmtub3duIHJlYXNvbi5cIlxyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0ZXJhdGUgYXV0b2NvbXBsZXRlIGl0ZW0gZ3JvdXBzXHJcbiAgICBjb25zdCBncm91cF9uYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHlhbWwpO1xyXG4gICAgY29uc3QgZXJyb3JfbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBncm91cF9uYW1lcy5mb3JFYWNoKChncm91cF9uYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCBncm91cF9pdGVtcyA9IHlhbWxbZ3JvdXBfbmFtZV07XHJcbiAgICAgICAgY29uc3QgZ3JvdXBfaXRlbV92YWx1ZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhncm91cF9pdGVtcyk7XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGUgYWxsIGF1dG9jb21wbGV0ZSBpdGVtcyBpbiB0aGUgZ3JvdXBcclxuICAgICAgICBncm91cF9pdGVtX3ZhbHVlcy5mb3JFYWNoKChhdXRvY29tcGxldGVfaXRlbV92YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZV9pdGVtX2xhYmVsID0gZ3JvdXBfaXRlbXNbYXV0b2NvbXBsZXRlX2l0ZW1fdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dG9jb21wbGV0ZV9pdGVtX2xhYmVsICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlcy5wdXNoKFwiQXV0b2NvbXBsZXRlIGl0ZW0gJ1wiICsgYXV0b2NvbXBsZXRlX2l0ZW1fdmFsdWUgKyBcIicgaGFzIGFuIGluY29ycmVjdCBoZWxwIHRleHQgdHlwZTogXCIgKyBhdXRvY29tcGxldGVfaXRlbV9sYWJlbCArIFwiIGlzIGEgXCIgKyB0eXBlb2YgYXV0b2NvbXBsZXRlX2l0ZW1fbGFiZWwgKyBcIiwgYnV0IGl0IHNob3VsZCBiZSBhIHN0cmluZy5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBhIGNvcnJlY3QgdHlwZSBmb3IgdGhlIGl0ZW1cclxuICAgICAgICAgICAgbGV0IHR5cGU6IEF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5VHlwZSA9IFwib3RoZXJcIjtcclxuICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZV9pdGVtX3ZhbHVlLnN0YXJ0c1dpdGgoXCJ7e1wiKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJub3JtYWwtdmFyaWFibGVcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGl0ZW0gaXMgb2ssIGFkZCBpdCB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICBDdXN0b21BdXRvY29tcGxldGVJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBhdXRvY29tcGxldGVfaXRlbV92YWx1ZSxcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogYXV0b2NvbXBsZXRlX2l0ZW1fbGFiZWwsXHJcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBfbmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibm9ybWFsLXZhcmlhYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbiB1bmVzY2FwZWQgdmVyc2lvbiBvZiB0aGUgdmFyaWFibGUsIHRvb1xyXG4gICAgICAgICAgICAgICAgQ3VzdG9tQXV0b2NvbXBsZXRlSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF1dG9jb21wbGV0ZV9pdGVtX3ZhbHVlLnJlcGxhY2UoL15cXHtcXHsvdSwgXCJ7eyFcIiksIC8vIEFkZCBhbiBleGNsYW1hdGlvbiBtYXJrIHRvIHRoZSB2YXJpYWJsZSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogYXV0b2NvbXBsZXRlX2l0ZW1fbGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwX25hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChlcnJvcl9tZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU29tZXRoaW5nIGZhaWxlZFxyXG4gICAgICAgIHJldHVybiBlcnJvcl9tZXNzYWdlcy5qb2luKFwiOyBcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWxsIG9rXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRPRE86IENhbiB0aGUgc29ydGluZyBiZSByZW1vdmVkIGZyb20gaGVyZT8gTm93IGF1dG9jb21wbGV0ZSBpdGVtcyBhcmUgc29ydGVkIGFnYWluIGV2ZXJ5IHRpbWUgd2hlbiBmaWx0ZXJpbmcsIGJhc2VkIG9uIHRoZSBrZXl3b3JkIChodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9vYnNpZGlhbi1zaGVsbGNvbW1hbmRzL2lzc3Vlcy8yNDkpLlxyXG4gKiBAcGFyYW0gYXV0b2NvbXBsZXRlX2l0ZW1fc2V0c1xyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VfYW5kX3NvcnRfYXV0b2NvbXBsZXRlX2l0ZW1zKC4uLmF1dG9jb21wbGV0ZV9pdGVtX3NldHM6IElBdXRvY29tcGxldGVJdGVtW11bXSkge1xyXG4gICAgY29uc3QgbWVyZ2VkX2F1dG9jb21wbGV0ZV9pdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSA9IFtdLmNvbmNhdCguLi5hdXRvY29tcGxldGVfaXRlbV9zZXRzKTtcclxuICAgIHJldHVybiBtZXJnZWRfYXV0b2NvbXBsZXRlX2l0ZW1zLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAvLyBGaXJzdCBjb21wYXJlIGdyb3Vwc1xyXG4gICAgICAgIGlmIChhLmdyb3VwIDwgYi5ncm91cCkge1xyXG4gICAgICAgICAgICAvLyBhJ3MgZ3JvdXAgc2hvdWxkIGNvbWUgYmVmb3JlIGIncyBncm91cC5cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYS5ncm91cCA+IGIuZ3JvdXApIHtcclxuICAgICAgICAgICAgLy8gYSdzIGdyb3VwIHNob3VsZCBjb21lIGFmdGVyIGIncyBncm91cC5cclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGdyb3VwcyBhcmUgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgdmFsdWVzLlxyXG4gICAgICAgICAgICBpZiAoYS52YWx1ZSA8IGIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgc2hvdWxkIGNvbWUgYmVmb3JlIGIuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS52YWx1ZSA+IGIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgc2hvdWxkIGNvbWUgYWZ0ZXIgYi5cclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlcyBhcmUgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JkZXIgZG9lcyBub3QgbWF0dGVyLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZSBBdXRvY29tcGxldGVTZWFyY2hRdWVyeVR5cGUgPSBcIm90aGVyXCIgfCBcIm5vcm1hbC12YXJpYWJsZVwiIHwgXCJ1bmVzY2FwZWQtdmFyaWFibGVcIjtcclxuaW50ZXJmYWNlIElBdXRvY29tcGxldGVTZWFyY2hRdWVyeSB7XHJcbiAgICBzZWFyY2hfdGV4dDogc3RyaW5nO1xyXG4gICAgc2VhcmNoX3R5cGU6IEF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5VHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZHVjZXMgYW4gaW5wdXQgc3RyaW5nIHRvIHRoZSBuZWFyZXN0IGxvZ2ljYWwgd29yZC5cclxuICogQHBhcmFtIHR5cGVkX3RleHRcclxuICovXHJcbmZ1bmN0aW9uIGdldF9zZWFyY2hfcXVlcnkodHlwZWRfdGV4dDogc3RyaW5nKTogSUF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5IHtcclxuICAgIGxldCBzZWFyY2hfdGV4dCA9IHR5cGVkX3RleHQubWF0Y2goL1xcUyo/JC91KVswXTsgLy8gUmVkdWNlIHRoZSB0ZXh0IC0gbGltaXQgdG8gYSBzaW5nbGUgd29yZCAoPSBleGNsdWRlIHNwYWNlcyBhbmQgZXZlcnl0aGluZyBiZWZvcmUgdGhlbSkuXHJcbiAgICBsZXQgc2VhcmNoX3R5cGU6IEF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5VHlwZSA9IFwib3RoZXJcIjsgLy8gTWF5IGJlIG92ZXJ3cml0dGVuLlxyXG5cclxuICAgIGlmIChzZWFyY2hfdGV4dC5jb250YWlucyhcIn19XCIpKSB7XHJcbiAgICAgICAgLy8gVGhlIHF1ZXJ5IGhhcHBlbnMgcmlnaHQgYWZ0ZXIgYSB7e3ZhcmlhYmxlfX0uXHJcbiAgICAgICAgLy8gTWFrZSB0aGUgcXVlcnkgc3RyaW5nIHRvIHN0YXJ0IGFmdGVyIHRoZSB9fSBwYWlyLCBpLmUuIHJlbW92ZSB9fSBhbmQgZXZlcnl0aGluZyBiZWZvcmUgaXQuIFRoaXMgaW1wcm92ZXMgdGhlIHNlYXJjaC5cclxuICAgICAgICBzZWFyY2hfdGV4dCA9IHNlYXJjaF90ZXh0LnJlcGxhY2UoLy4rXFx9XFx9L3UsIFwiXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlYXJjaF90ZXh0LmNvbnRhaW5zKFwie3tcIikpIHtcclxuICAgICAgICAvLyBBIHt7dmFyaWFibGV9fSBpcyBiZWluZyBxdWVyaWVkLlxyXG4gICAgICAgIC8vIE1ha2UgdGhlIHF1ZXJ5IHN0cmluZyB0byBzdGFydCBmcm9tIHRoZSB7eyBwYWlyLCBpLmUuIHJlbW92ZSBldmVyeXRoaW5nIGJlZm9yZSB7eyAuIFRoaXMgaW1wcm92ZXMgdGhlIHNlYXJjaC5cclxuICAgICAgICBzZWFyY2hfdGV4dCA9IHNlYXJjaF90ZXh0LnJlcGxhY2UoLy4rXFx7XFx7L3UsIFwie3tcIik7XHJcbiAgICAgICAgaWYgKHNlYXJjaF90ZXh0LmNvbnRhaW5zKFwie3shXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIEFuIF91bmVzY2FwZWRfIHZhcmlhYmxlIGlzIHNlYXJjaGVkIGZvci5cclxuICAgICAgICAgICAgc2VhcmNoX3R5cGUgPSBcInVuZXNjYXBlZC12YXJpYWJsZVwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEEgbm9ybWFsIHZhcmlhYmxlIGlzIHNlYXJjaGVkIGZvci5cclxuICAgICAgICAgICAgc2VhcmNoX3R5cGUgPSBcIm5vcm1hbC12YXJpYWJsZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VhcmNoX3RleHQ6IHNlYXJjaF90ZXh0LFxyXG4gICAgICAgIHNlYXJjaF90eXBlOiBzZWFyY2hfdHlwZSxcclxuICAgIH07XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX01vZGFsfSBmcm9tIFwiLi4vLi4vU0NfTW9kYWxcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQge1xyXG4gICAgU2V0dGluZyxcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtPdXRwdXRXcmFwcGVyfSBmcm9tIFwiLi9PdXRwdXRXcmFwcGVyXCI7XHJcbmltcG9ydCB7Y3JlYXRlQXV0b2NvbXBsZXRlfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9PdXRwdXR9IGZyb20gXCIuLi8uLi92YXJpYWJsZXMvVmFyaWFibGVfT3V0cHV0XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0V3JhcHBlclNldHRpbmdzTW9kYWwgZXh0ZW5kcyBTQ19Nb2RhbCB7XHJcblxyXG4gICAgcHJpdmF0ZSBhcHByb3ZlZCA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgb3V0cHV0X3dyYXBwZXI6IE91dHB1dFdyYXBwZXIsXHJcblxyXG4gICAgICAgIC8qKiBDYW4gYmUgdW5kZWZpbmVkIGlmIHRoZSBvdXRwdXQgd3JhcHBlciBpcyBjcmVhdGVkIGZyb20gYSBwbGFjZSB3aGVyZSB0aGVyZSBpcyBubyBuYW1lIGVsZW1lbnQuICovXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXRfd3JhcHBlcl9uYW1lX3NldHRpbmc/OiBTZXR0aW5nLFxyXG5cclxuICAgICAgICAvKiogSWYgZGVmaW5lZCwgYSBidXR0b24gd2lsbCBiZSBhZGRlZCBhbmQgb25fYWZ0ZXJfYXBwcm92YWwoKSAvIG9uX2FmdGVyX2NhbmNlbGxpbmcoKSB3aWxsIGJlIGNhbGxlZCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgYnV0dG9uIHdhcyBjbGlja2VkIG9yIG5vdC4gKi9cclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IG9rX2J1dHRvbl90ZXh0Pzogc3RyaW5nLFxyXG5cclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IG9uX2FmdGVyX2FwcHJvdmFsPzogKCkgPT4gdm9pZCxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IG9uX2FmdGVyX2NhbmNlbGxpbmc/OiAoKSA9PiB2b2lkLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIocGx1Z2luKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLm9uT3BlbigpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcl9lbGVtZW50ID0gdGhpcy5tb2RhbEVsLmNyZWF0ZURpdigpO1xyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LmFkZENsYXNzKFwiU0Mtc2V0dGluZy1ncm91cFwiKTsgLy8gTWFrZSBzZXR0aW5nIGZpZWxkcyB3aWRlciBpbiB0aGlzIGNvbnRhaW5lci5cclxuXHJcbiAgICAgICAgLy8gVGl0bGVcclxuICAgICAgICBjb25zdCB0aXRsZV9zZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiT3V0cHV0IHdyYXBwZXIgdGl0bGVcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJPbmx5IHVzZWQgaW4gc2V0dGluZ3MsIHdpbGwgbm90IGFwcGVhciBpbiBvdXRwdXQuXCIpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMub3V0cHV0X3dyYXBwZXIuZ2V0VGl0bGUoKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X3RpdGxlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dF93cmFwcGVyLmdldENvbmZpZ3VyYXRpb24oKS50aXRsZSA9IG5ld190aXRsZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aXRsZSBpbiBhIG5hbWUgc2V0dGluZy4gKE9ubHkgaWYgdGhlIG1vZGFsIHdhcyBjcmVhdGVkIGZyb20gYSBwbGFjZSB3aGVyZSBhbiBPdXRwdXRXcmFwcGVyIG5hbWUgZWxlbWVudCBleGlzdHMpLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0X3dyYXBwZXJfbmFtZV9zZXR0aW5nPy5zZXROYW1lKG5ld190aXRsZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlX2lucHV0X2VsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQgPSB0aXRsZV9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwiaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgICAgICAgLy8gQ29udGVudFxyXG4gICAgICAgIGNvbnN0IG91dHB1dF92YXJpYWJsZSA9IG5ldyBWYXJpYWJsZV9PdXRwdXQodGhpcy5wbHVnaW4sIFwiXCIpOyAvLyBGb3IgZ2V0dGluZyBhbiBhdXRvY29tcGxldGUgaXRlbS5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJDb250ZW50XCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVXNlIHt7b3V0cHV0fX0gYXMgYSBwbGFjZWhvbGRlciBmb3IgdGV4dCB0aGF0IHdpbGwgYmUgcmVjZWl2ZWQgZnJvbSBhIHNoZWxsIGNvbW1hbmQuIE90aGVyIHZhcmlhYmxlcyBhcmUgYXZhaWxhYmxlLCB0b28uXCIpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0YXJlYV9jb21wb25lbnQgPT4gdGV4dGFyZWFfY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5vdXRwdXRfd3JhcHBlci5jb25maWd1cmF0aW9uLmNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld19jb250ZW50OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dF93cmFwcGVyLmNvbmZpZ3VyYXRpb24uY29udGVudCA9IG5ld19jb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKCh0ZXh0YXJlYV9jb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvY29tcGxldGUgZm9yIENvbnRlbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLnNob3dfYXV0b2NvbXBsZXRlX21lbnUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYV9jb21wb25lbnQuaW5wdXRFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHRleHRhcmVhX2NvbXBvbmVudC5vbkNoYW5nZWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF92YXJpYWJsZS5nZXRBdXRvY29tcGxldGVJdGVtcygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBGb2N1cyBvbiB0aGUgdGl0bGUgZmllbGQuXHJcbiAgICAgICAgdGl0bGVfaW5wdXRfZWxlbWVudC5mb2N1cygpO1xyXG5cclxuICAgICAgICAvLyBPayBidXR0b25cclxuICAgICAgICBpZiAodGhpcy5va19idXR0b25fdGV4dCkge1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KHRoaXMub2tfYnV0dG9uX3RleHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5hcHByb3ZlKCkpLFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhcHByb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLm9uX2FmdGVyX2FwcHJvdmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwcm92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm9uX2FmdGVyX2FwcHJvdmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKCk7XHJcblxyXG4gICAgICAgIC8vIENhbGwgYSBjYW5jZWxsaW5nIGhvb2sgaWYgb25lIGlzIGRlZmluZWQgKGFuZCBpZiB0aGUgY2xvc2luZyBoYXBwZW5zIGR1ZSB0byBjYW5jZWxsaW5nLCBpLmUuIHRoZSBvayBidXR0b24gaXMgTk9UIGNsaWNrZWQpLlxyXG4gICAgICAgIGlmICghdGhpcy5hcHByb3ZlZCAmJiB0aGlzLm9uX2FmdGVyX2NhbmNlbGxpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbl9hZnRlcl9jYW5jZWxsaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMuMCBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gICAgTW9kZWwsXHJcbiAgICBQYXJlbnRNb2RlbE9uZVRvTWFueUlkUmVsYXRpb24sXHJcbn0gZnJvbSBcIi4uL01vZGVsXCI7XHJcbmltcG9ydCB7U2V0dGluZ30gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7XHJcbiAgICBPdXRwdXRXcmFwcGVyLFxyXG4gICAgT3V0cHV0V3JhcHBlckNvbmZpZ3VyYXRpb24sXHJcbn0gZnJvbSBcIi4vT3V0cHV0V3JhcHBlclwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vLi4vRGVidWdcIjtcclxuaW1wb3J0IHtnZXRJREdlbmVyYXRvcn0gZnJvbSBcIi4uLy4uL0lER2VuZXJhdG9yXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtfSBmcm9tIFwiLi4vLi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxDb2RlXCI7XHJcbmltcG9ydCB7T3V0cHV0V3JhcHBlclNldHRpbmdzTW9kYWx9IGZyb20gXCIuL091dHB1dFdyYXBwZXJTZXR0aW5nc01vZGFsXCI7XHJcbmltcG9ydCB7U0NfTWFpblNldHRpbmdzfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3MvU0NfTWFpblNldHRpbmdzXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0V3JhcHBlck1vZGVsIGV4dGVuZHMgTW9kZWwge1xyXG5cclxuICAgIHByaXZhdGUgb3V0cHV0X3dyYXBwZXJzID0gbmV3IE91dHB1dFdyYXBwZXJNYXAoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NyZWF0ZVNldHRpbmdGaWVsZHMob3V0cHV0X3dyYXBwZXI6IE91dHB1dFdyYXBwZXIsIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCk6IFNldHRpbmcge1xyXG4gICAgICAgIGRlYnVnTG9nKFwiQ3JlYXRpbmcgc2V0dGluZyBmaWVsZHMgZm9yIGFuIE91dHB1dFdyYXBwZXIgaW5zdGFuY2UuXCIpO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyX25hbWVfc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAvLyBDb25maWd1cmF0aW9uIGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0TmFtZShvdXRwdXRfd3JhcHBlci5nZXRUaXRsZSgpKVxyXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJEZWZpbmUgb3V0cHV0IHdyYXBwZXIgY29udGVudFwiKVxyXG4gICAgICAgICAgICAgICAgLnNldEljb24oXCJnZWFyXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuU2V0dGluZ3NNb2RhbChvdXRwdXRfd3JhcHBlciwgb3V0cHV0X3dyYXBwZXJfbmFtZV9zZXR0aW5nKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgICAgIHJldHVybiBvdXRwdXRfd3JhcHBlcl9uYW1lX3NldHRpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGRlZmluZVBhcmVudENvbmZpZ3VyYXRpb25SZWxhdGlvbihvdXRwdXRfd3JhcHBlcjogT3V0cHV0V3JhcHBlcik6IFBhcmVudE1vZGVsT25lVG9NYW55SWRSZWxhdGlvbiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogXCJvbmUtdG8tbWFueS1pZFwiLFxyXG4gICAgICAgICAgICBrZXk6IFwib3V0cHV0X3dyYXBwZXJzXCIsXHJcbiAgICAgICAgICAgIGlkOiBvdXRwdXRfd3JhcHBlci5nZXRJRCgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFNpbmd1bGFyTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIk91dHB1dCB3cmFwcGVyXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxvYWRJbnN0YW5jZXMocGFyZW50X2NvbmZpZ3VyYXRpb246IFNDX01haW5TZXR0aW5ncyk6IE91dHB1dFdyYXBwZXJNYXAge1xyXG4gICAgICAgIGRlYnVnTG9nKFwiTG9hZGluZyBPdXRwdXRXcmFwcGVyIGluc3RhbmNlcy5cIik7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRfd3JhcHBlcnMgPSBuZXcgT3V0cHV0V3JhcHBlck1hcCgpO1xyXG4gICAgICAgIHBhcmVudF9jb25maWd1cmF0aW9uLm91dHB1dF93cmFwcGVycy5mb3JFYWNoKChvdXRwdXRfd3JhcHBlcl9jb25maWd1cmF0aW9uOiBPdXRwdXRXcmFwcGVyQ29uZmlndXJhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXRfd3JhcHBlciA9IG5ldyBPdXRwdXRXcmFwcGVyKHRoaXMsIHRoaXMucGx1Z2luLCBvdXRwdXRfd3JhcHBlcl9jb25maWd1cmF0aW9uLCBwYXJlbnRfY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0X3dyYXBwZXJzLnNldChvdXRwdXRfd3JhcHBlcl9jb25maWd1cmF0aW9uLmlkLCBvdXRwdXRfd3JhcHBlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0X3dyYXBwZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBuZXdJbnN0YW5jZShwYXJlbnRfY29uZmlndXJhdGlvbjogU0NfTWFpblNldHRpbmdzKTogT3V0cHV0V3JhcHBlciB7XHJcbiAgICAgICAgZGVidWdMb2coXCJDcmVhdGluZyBhIG5ldyBPdXRwdXRXcmFwcGVyIGluc3RhbmNlLlwiKTtcclxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgbG9naWMgdG8gdGhlIGJhc2UgTW9kZWwgY2xhc3MuXHJcblxyXG4gICAgICAgIC8vIFNldHVwIGEgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFuZCBnZW5lcmF0ZSBhbiBJRFxyXG4gICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyX2NvbmZpZ3VyYXRpb24gPSB0aGlzLl9nZXREZWZhdWx0Q29uZmlndXJhdGlvbigpO1xyXG5cclxuICAgICAgICAvLyBJbnN0YW50aWF0ZSBhbiBPdXRwdXRXcmFwcGVyXHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X3dyYXBwZXIgPSBuZXcgT3V0cHV0V3JhcHBlcih0aGlzLCB0aGlzLnBsdWdpbiwgb3V0cHV0X3dyYXBwZXJfY29uZmlndXJhdGlvbiwgdGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0X3dyYXBwZXJzLnNldChvdXRwdXRfd3JhcHBlci5nZXRJRCgpLCBvdXRwdXRfd3JhcHBlcik7XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBjb25maWd1cmF0aW9uIGludG8gcGx1Z2luJ3Mgc2V0dGluZ3NcclxuICAgICAgICBwYXJlbnRfY29uZmlndXJhdGlvbi5vdXRwdXRfd3JhcHBlcnMucHVzaChvdXRwdXRfd3JhcHBlcl9jb25maWd1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBPdXRwdXRXcmFwcGVyXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dF93cmFwcGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZVZhbHVlKG91dHB1dF93cmFwcGVyOiBPdXRwdXRXcmFwcGVyLCBmaWVsZDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIE5vIHZhbGlkYXRpb24gaXMgbmVlZGVkLCBJIGd1ZXNzLiAnVGl0bGUnIGFuZCAnY29udGVudCcgY2FuIGJvdGggYmUgZW1wdHksIGFsdGhvdWdoIGFuIGVtcHR5IHRpdGxlIGRvZXMgbm90IG1ha2Ugc2Vuc2UuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVuU2V0dGluZ3NNb2RhbChvdXRwdXRfd3JhcHBlcjogT3V0cHV0V3JhcHBlciwgb3V0cHV0X3dyYXBwZXJfbmFtZV9zZXR0aW5nOiBTZXR0aW5nKSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJPcGVuaW5nIHNldHRpbmdzIG1vZGFsIGZvciBhbiBPdXRwdXRXcmFwcGVyIGluc3RhbmNlLlwiKTtcclxuICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBPdXRwdXRXcmFwcGVyU2V0dGluZ3NNb2RhbCh0aGlzLnBsdWdpbiwgb3V0cHV0X3dyYXBwZXIsIG91dHB1dF93cmFwcGVyX25hbWVfc2V0dGluZyk7XHJcbiAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldERlZmF1bHRDb25maWd1cmF0aW9uKCk6IE91dHB1dFdyYXBwZXJDb25maWd1cmF0aW9uIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogZ2V0SURHZW5lcmF0b3IoKS5nZW5lcmF0ZUlEKCksXHJcbiAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxyXG4gICAgICAgICAgICBjb250ZW50OiBcIlwiLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZWxldGVJbnN0YW5jZShkZWxldGFibGVfb3V0cHV0X3dyYXBwZXI6IE91dHB1dFdyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkRlbGV0aW5nIGFuIE91dHB1dFdyYXBwZXIgaW5zdGFuY2UuXCIpO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIE91dHB1dFdyYXBwZXIgZnJvbSBhbGwgVFNoZWxsQ29tbWFuZHMgdGhhdCB1c2UgaXQuXHJcbiAgICAgICAgY29uc3Qgc2hlbGxfY29tbWFuZHMgPSB0aGlzLnBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9pZCBpbiBzaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgICAgICBjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0X3dyYXBwZXJzID0gdF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5vdXRwdXRfd3JhcHBlcnM7XHJcbiAgICAgICAgICAgIE9iamVjdC5lYWNoKG91dHB1dF93cmFwcGVycywgKG91dHB1dF93cmFwcGVyX2lkOiBzdHJpbmcsIG91dHB1dF9zdHJlYW06IE91dHB1dFN0cmVhbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dF93cmFwcGVyX2lkID09PSBkZWxldGFibGVfb3V0cHV0X3dyYXBwZXIuZ2V0SUQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc2hlbGwgY29tbWFuZCB1c2VzIHRoZSBvdXRwdXQgd3JhcHBlciB0aGF0IGlzIGFib3V0IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRoZSBzaGVsbCBjb21tYW5kIG5vdCB0byB1c2UgYW55IG91dHB1dCB3cmFwcGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF93cmFwcGVyc1tvdXRwdXRfc3RyZWFtXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBPdXRwdXRXcmFwcGVyIGZyb20gdGhpcyBjbGFzcydzIGludGVybmFsIGxpc3QuXHJcbiAgICAgICAgdGhpcy5vdXRwdXRfd3JhcHBlcnMuZGVsZXRlKGRlbGV0YWJsZV9vdXRwdXRfd3JhcHBlci5nZXRJRCgpKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRXcmFwcGVyTWFwIGV4dGVuZHMgTWFwPHN0cmluZywgT3V0cHV0V3JhcHBlcj4ge30iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5pbXBvcnQge1xyXG4gICAgQ3VzdG9tVmFyaWFibGVNb2RlbCxcclxuICAgIGludHJvZHVjZU1vZGVsQ2xhc3MsXHJcbiAgICBQcm9tcHRGaWVsZE1vZGVsLFxyXG4gICAgUHJvbXB0TW9kZWwsXHJcbn0gZnJvbSBcIi4uL2ltcG9ydHNcIjtcclxuaW1wb3J0IHtPdXRwdXRXcmFwcGVyTW9kZWx9IGZyb20gXCIuL291dHB1dF93cmFwcGVyL091dHB1dFdyYXBwZXJNb2RlbFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGludHJvZHVjZU1vZGVscyhwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgZGVidWdMb2coXCJJbnRyb2R1Y2luZyBtb2RlbHMuXCIpXHJcblxyXG4gICAgLy8gS2VlcCBpbiBhbHBoYWJldGljYWwgb3JkZXIsIGlmIHBvc3NpYmxlLlxyXG4gICAgaW50cm9kdWNlTW9kZWxDbGFzcyhuZXcgQ3VzdG9tVmFyaWFibGVNb2RlbChwbHVnaW4pKTtcclxuICAgIGludHJvZHVjZU1vZGVsQ2xhc3MobmV3IFByb21wdEZpZWxkTW9kZWwocGx1Z2luKSk7XHJcbiAgICBpbnRyb2R1Y2VNb2RlbENsYXNzKG5ldyBQcm9tcHRNb2RlbChwbHVnaW4pKTtcclxuICAgIGludHJvZHVjZU1vZGVsQ2xhc3MobmV3IE91dHB1dFdyYXBwZXJNb2RlbChwbHVnaW4pKTtcclxufVxyXG4iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7Q3VzdG9tVmFyaWFibGVJbnN0YW5jZX0gZnJvbSBcIi4uL21vZGVscy9jdXN0b21fdmFyaWFibGUvQ3VzdG9tVmFyaWFibGVJbnN0YW5jZVwiO1xyXG5pbXBvcnQge3Jlc2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtc30gZnJvbSBcIi4vZ2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtc1wiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHNlcnZlcyBhcyB0aGUgYWN0dWFsIG9wZXJhdGlvbmFsIHZhcmlhYmxlIGNsYXNzIGZvciBjdXN0b20gdmFyaWFibGVzLiBJdCdzIHBhaXJlZCB3aXRoIHRoZSBDdXN0b21WYXJpYWJsZUluc3RhbmNlIGNsYXNzLCB3aGljaCBhY3RzXHJcbiAqIGFzIGEgY29uZmlndXJhdGlvbiBjbGFzcyB0byBoYW5kbGUgc2V0dGluZ3MgdG9nZXRoZXIgd2l0aCBDdXN0b21WYXJpYWJsZU1vZGVsIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEN1c3RvbVZhcmlhYmxlIGV4dGVuZHMgVmFyaWFibGUge1xyXG5cclxuICAgIHByaXZhdGUgdmFsdWU6IHN0cmluZyB8IG51bGwgPSBudWxsOyAvLyBUT0RPOiBXaGVuIGltcGxlbWVudGluZyB2YXJpYWJsZSB0eXBlcywgbWFrZSB0aGlzIGNsYXNzIGFic3RyYWN0IGFuZCBsZXQgc3ViY2xhc3NlcyBkZWZpbmUgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eS5cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWx3YXlzX2F2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHByaXZhdGUgY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlOiBDdXN0b21WYXJpYWJsZUluc3RhbmNlXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihwbHVnaW4pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydGllcygpO1xyXG4gICAgICAgIGRlYnVnTG9nKGBMb2FkZWQgQ3VzdG9tVmFyaWFibGUgJHt0aGlzLnZhcmlhYmxlX25hbWV9LmApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZW5lcmF0ZVZhbHVlKCk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKGBDdXN0b20gdmFyaWFibGUgJHt0aGlzLnZhcmlhYmxlX25hbWV9IGRvZXMgbm90IGhhdmUgYSB2YWx1ZSB5ZXQsIGFuZCBubyBkZWZhdWx0IHZhbHVlIGlzIGRlZmluZWQuYClcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiVGhpcyBjdXN0b20gdmFyaWFibGUgZG9lcyBub3QgaGF2ZSBhIHZhbHVlIHlldCwgYW5kIG5vIGRlZmF1bHQgdmFsdWUgaXMgZGVmaW5lZC5cIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogTWFrZSBpdCBwb3NzaWJsZSB0byBwcmV2ZW50IGNhbGxpbmcgb25DaGFuZ2UgY2FsbGJhY2tzOlxyXG4gICAgICogIC0gTWFrZSBpdCBwb3NzaWJsZSB0byBjYWxsIHRoZSBjYWxsYmFja3MgbGF0ZXIgb3V0c2lkZSB0aGlzIGNsYXNzLlxyXG4gICAgICogIC0gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IEN1c3RvbVZhcmlhYmxlVmlldyB1cGRhdGVzIHdoZW4gbXVsdGlwbGUgQ3VzdG9tVmFyaWFibGVzIGFyZSBhc3NpZ25lZCB2YWx1ZXMgaW4gb25lIGdvICh2aWEgU2hlbGwgY29tbWFuZCBVUkkpLlxyXG4gICAgICogIC0gU3RvcmUgdGhlIG9sZCB2YWx1ZSBpbnRvIHNvbWUga2luZCBvZiBoaXN0b3J5IGxpc3QuXHJcbiAgICAgKiAgLSBXaGVuIGNhbGxpbmcgdGhlIGNhbGxiYWNrcywgdGhlIGN1cnJlbnQgQ3VzdG9tVmFyaWFibGUgc2hvdWxkIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpbnN0ZWFkIG9mIHRoZSAndmFsdWUnIGFuZCAnb2xkX3ZhbHVlJyBwYXJhbWV0ZXJzICh3aGljaCBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSBDdXN0b21WYXJpYWJsZSBvYmplY3QpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2V0VmFsdWUodmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IG9sZF92YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgZGVidWdMb2coYEN1c3RvbVZhcmlhYmxlICR7dGhpcy52YXJpYWJsZV9uYW1lfTogU2V0dGluZyB2YWx1ZSB0bzogJHt2YWx1ZX0gKG9sZCB3YXM6ICR7b2xkX3ZhbHVlfSkuYCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAvLyBDYWxsIHRoZSBvbkNoYW5nZSBob29rLlxyXG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbE9uQ2hhbmdlQ2FsbGJhY2tzKHZhbHVlLCBvbGRfdmFsdWUgPz8gXCJcIik7IC8vIFVzZSBcIlwiIGlmIG9sZF92YWx1ZSBpcyBudWxsLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHZhcmlhYmxlX25hbWUgYW5kIGhlbHBfdGV4dCBwcm9wZXJ0aWVzIGZyb20gdGhlIGFzc29jaWF0ZWQgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZS5cclxuICAgICAqIENhbGxlZCB3aGVuIGxvYWRpbmcgdGhlIEN1c3RvbVZhcmlhYmxlIGFuZCB3aGVuIHRoZSBhc3NvY2lhdGVkIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UncyBzZXR0aW5ncyBhcmUgY2hhbmdlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVByb3BlcnRpZXMoKSB7XHJcbiAgICAgICAgZGVidWdMb2coYEN1c3RvbVZhcmlhYmxlICR7dGhpcy52YXJpYWJsZV9uYW1lfTogVXBkYXRpbmcgdmFyaWFibGUgbmFtZSBhbmQgaGVscCB0ZXh0LmApO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVfbmFtZSA9IHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmdldFByZWZpeGVkTmFtZSgpO1xyXG4gICAgICAgIHRoaXMuaGVscF90ZXh0ID0gdGhpcy5jdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuY29uZmlndXJhdGlvbi5kZXNjcmlwdGlvbjtcclxuICAgICAgICByZXNldFZhcmlhYmxlQXV0b2NvbXBsZXRlSXRlbXMoKTsgLy8gTWFrZSBhdXRvY29tcGxldGUgbGlzdHMgcmVsb2FkIHRoZWlyIGNvbnRlbnQgaW4gb3JkZXIgdG8gZ2V0IHRoZSBuZXcgdmFyaWFibGUgbmFtZS9oZWxwIHRleHQuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldElkZW50aWZpZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmdldElEKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiB0byBhIHN0YWNrIG9mIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoaXMgQ3VzdG9tVmFyaWFibGUncyB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAgICogQHBhcmFtIG9uX2NoYW5nZV9jYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25DaGFuZ2Uob25fY2hhbmdlX2NhbGxiYWNrOiBUQ3VzdG9tVmFyaWFibGVPbkNoYW5nZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5vbl9jaGFuZ2VfY2FsbGJhY2tzLmFkZChvbl9jaGFuZ2VfY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBvbl9jaGFuZ2VfY2FsbGJhY2tzID0gbmV3IFNldDxUQ3VzdG9tVmFyaWFibGVPbkNoYW5nZUNhbGxiYWNrPigpO1xyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgY2FsbE9uQ2hhbmdlQ2FsbGJhY2tzKG5ld192YWx1ZTogc3RyaW5nLCBvbGRfdmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIGRlYnVnTG9nKGBDdXN0b21WYXJpYWJsZSAke3RoaXMudmFyaWFibGVfbmFtZX06IENhbGxpbmcgb25DaGFuZ2UgY2FsbGJhY2tzLmApO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb25fY2hhbmdlX2NhbGxiYWNrIG9mIHRoaXMub25fY2hhbmdlX2NhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBhd2FpdCBvbl9jaGFuZ2VfY2FsbGJhY2sodGhpcywgbmV3X3ZhbHVlLCBvbGRfdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQ3VzdG9tVmFyaWFibGUgaGFzIGFuIGFzc2lnbmVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IHRoaXMudmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbnR5cGUgVEN1c3RvbVZhcmlhYmxlT25DaGFuZ2VDYWxsYmFjayA9ICh2YXJpYWJsZTogQ3VzdG9tVmFyaWFibGUsIG5ld192YWx1ZTogc3RyaW5nLCBvbGRfdmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjsiLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX01haW5TZXR0aW5nc30gZnJvbSBcIi4uLy4uL3NldHRpbmdzL1NDX01haW5TZXR0aW5nc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgQ3VzdG9tVmFyaWFibGUsXHJcbiAgICBDdXN0b21WYXJpYWJsZUNvbmZpZ3VyYXRpb24sXHJcbiAgICBDdXN0b21WYXJpYWJsZU1vZGVsLFxyXG4gICAgZ2V0SURHZW5lcmF0b3IsXHJcbiAgICBJbnN0YW5jZSxcclxufSBmcm9tIFwiLi4vLi4vaW1wb3J0c1wiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vLi4vRGVidWdcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHNlcnZlcyBhcyBhbiBhY2Nlc3NvciB0byBDdXN0b21WYXJpYWJsZSBjb25maWd1cmF0aW9ucy4gSXQncyBwYWlyZWQgd2l0aCB0aGUgQ3VzdG9tVmFyaWFibGUgY2xhc3MsIHdoaWNoIGFjdHNcclxuICogYXMgYW4gb3BlcmF0aW9uYWwgY2xhc3MgdG8gaW1wbGVtZW50IHRoZSB2YXJpYWJsZSBmdW5jdGlvbmFsaXR5LlxyXG4gKlxyXG4gKiBUT0RPOiBEZWNpZGUgYSBiZXR0ZXIgbmFtZSBmb3IgdGhpcyBjbGFzcy4gSXQncyB0b28gZWFzeSB0byBjb25mdXNlIHdpdGggdGhlIEN1c3RvbVZhcmlhYmxlIGNsYXNzIG5hbWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSBleHRlbmRzIEluc3RhbmNlIHtcclxuICAgIHB1YmxpYyByZWFkb25seSBwYXJlbnRfY29uZmlndXJhdGlvbjogU0NfTWFpblNldHRpbmdzO1xyXG4gICAgcHVibGljIGNvbmZpZ3VyYXRpb246IEN1c3RvbVZhcmlhYmxlQ29uZmlndXJhdGlvbjtcclxuICAgIHByaXZhdGUgY3VzdG9tX3ZhcmlhYmxlOiBDdXN0b21WYXJpYWJsZSA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IG1vZGVsOiBDdXN0b21WYXJpYWJsZU1vZGVsLFxyXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IEN1c3RvbVZhcmlhYmxlQ29uZmlndXJhdGlvbixcclxuICAgICAgICBwYXJlbnRfY29uZmlndXJhdGlvbjogU0NfTWFpblNldHRpbmdzLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIobW9kZWwsIGNvbmZpZ3VyYXRpb24sIHBhcmVudF9jb25maWd1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gSW50cm9kdWNlIHRoZSBJRCB0byBhbiBJRCBnZW5lcmF0b3Igc28gdGhhdCBpdCB3b24ndCBhY2NpZGVudGFsbHkgZ2VuZXJhdGUgdGhlIHNhbWUgSUQgYWdhaW4gd2hlbiBjcmVhdGluZyBuZXcgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZXMuXHJcbiAgICAgICAgZ2V0SURHZW5lcmF0b3IoKS5hZGRSZXNlcnZlZElEKGNvbmZpZ3VyYXRpb24uaWQpO1xyXG5cclxuICAgICAgICBkZWJ1Z0xvZyhgTG9hZGVkIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UgJHt0aGlzLmdldElEKCl9LmApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRJRCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRGdWxsTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gYHt7JHt0aGlzLmdldFByZWZpeGVkTmFtZSgpfX19YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gdW5kZXJzY29yZSBpbiBmcm9udCBvZiB0aGUgbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFByZWZpeGVkTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gXCJfXCIgKyB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VGl0bGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGdWxsTmFtZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDdXN0b21WYXJpYWJsZSgpOiBDdXN0b21WYXJpYWJsZSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbV92YXJpYWJsZSkge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSAke3RoaXMuZ2V0SUQoKX06IENhbm5vdCBmaW5kIGEgQ3VzdG9tVmFyaWFibGUuIE1heWJlIGl0J3Mgbm90IGxvYWRlZD9gKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiLmdldFZhcmlhYmxlKCk6IENhbm5vdCBmaW5kIGEgQ3VzdG9tVmFyaWFibGUuIE1heWJlIGl0J3Mgbm90IGxvYWRlZD9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbV92YXJpYWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlQ3VzdG9tVmFyaWFibGUoKTogQ3VzdG9tVmFyaWFibGUge1xyXG4gICAgICAgIGRlYnVnTG9nKGBDdXN0b21WYXJpYWJsZUluc3RhbmNlICR7dGhpcy5nZXRJRCgpfTogQ3JlYXRpbmcgYW4gb3BlcmF0aW9uYWwgQ3VzdG9tVmFyaWFibGUuYCk7XHJcbiAgICAgICAgdGhpcy5jdXN0b21fdmFyaWFibGUgPSBuZXcgQ3VzdG9tVmFyaWFibGUodGhpcy5tb2RlbC5wbHVnaW4sIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tX3ZhcmlhYmxlLm9uQ2hhbmdlKGFzeW5jICgpID0+IGF3YWl0IHRoaXMubW9kZWwucGx1Z2luLnVwZGF0ZUN1c3RvbVZhcmlhYmxlVmlld3MoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tX3ZhcmlhYmxlO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTZXR0aW5nfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtTQ19NYWluU2V0dGluZ3N9IGZyb20gXCIuLi8uLi9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtDdXN0b21WYXJpYWJsZUluc3RhbmNlfSBmcm9tIFwiLi9DdXN0b21WYXJpYWJsZUluc3RhbmNlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRJREdlbmVyYXRvcixcclxuICAgIE1vZGVsLFxyXG4gICAgUGFyZW50TW9kZWxPbmVUb01hbnlJZFJlbGF0aW9uLFxyXG59IGZyb20gXCIuLi8uLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi8uLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEN1c3RvbVZhcmlhYmxlTW9kZWwgZXh0ZW5kcyBNb2RlbCB7XHJcblxyXG4gICAgcHJpdmF0ZSBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2VzOiBDdXN0b21WYXJpYWJsZUluc3RhbmNlTWFwO1xyXG5cclxuICAgIHB1YmxpYyBnZXRTaW5ndWxhck5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCJDdXN0b20gdmFyaWFibGVcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZGVmaW5lUGFyZW50Q29uZmlndXJhdGlvblJlbGF0aW9uKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZTogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSk6IFBhcmVudE1vZGVsT25lVG9NYW55SWRSZWxhdGlvbiB7XHJcbiAgICAgICAgZGVidWdMb2coYEN1c3RvbVZhcmlhYmxlTW9kZWw6IERlZmluaW5nIHBhcmVudCBjb25maWd1cmF0aW9uIHJlbGF0aW9uIGZvciBDdXN0b21WYXJpYWJsZUluc3RhbmNlICR7Y3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmdldElEKCl9LmApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwib25lLXRvLW1hbnktaWRcIixcclxuICAgICAgICAgICAga2V5OiBcImN1c3RvbV92YXJpYWJsZXNcIixcclxuICAgICAgICAgICAgaWQ6IGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZS5nZXRJRCgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxvYWRJbnN0YW5jZXMocGFyZW50X2NvbmZpZ3VyYXRpb246IFNDX01haW5TZXR0aW5ncyk6IEN1c3RvbVZhcmlhYmxlSW5zdGFuY2VNYXAge1xyXG4gICAgICAgIGRlYnVnTG9nKGBDdXN0b21WYXJpYWJsZU1vZGVsOiBMb2FkaW5nIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2VzLmApO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlcyA9IG5ldyBDdXN0b21WYXJpYWJsZUluc3RhbmNlTWFwO1xyXG4gICAgICAgIHBhcmVudF9jb25maWd1cmF0aW9uLmN1c3RvbV92YXJpYWJsZXMuZm9yRWFjaCgoY3VzdG9tX3ZhcmlhYmxlX2NvbmZpZ3VyYXRpb246IEN1c3RvbVZhcmlhYmxlQ29uZmlndXJhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZXMuc2V0KFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tX3ZhcmlhYmxlX2NvbmZpZ3VyYXRpb24uaWQsXHJcbiAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSh0aGlzLCBjdXN0b21fdmFyaWFibGVfY29uZmlndXJhdGlvbiwgcGFyZW50X2NvbmZpZ3VyYXRpb24pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbmV3SW5zdGFuY2UocGFyZW50X2NvbmZpZ3VyYXRpb246IFNDX01haW5TZXR0aW5ncyk6IEN1c3RvbVZhcmlhYmxlSW5zdGFuY2Uge1xyXG4gICAgICAgIGRlYnVnTG9nKGBDdXN0b21WYXJpYWJsZU1vZGVsOiBDcmVhdGluZyBhIG5ldyBDdXN0b21WYXJpYWJsZUluc3RhbmNlLmApO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgICAgY29uc3QgY3VzdG9tX3ZhcmlhYmxlX2NvbmZpZ3VyYXRpb246IEN1c3RvbVZhcmlhYmxlQ29uZmlndXJhdGlvbiA9IHRoaXMuX2dldERlZmF1bHRDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgcGFyZW50X2NvbmZpZ3VyYXRpb24uY3VzdG9tX3ZhcmlhYmxlcy5wdXNoKGN1c3RvbV92YXJpYWJsZV9jb25maWd1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICBjb25zdCBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UgPSBuZXcgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSh0aGlzLCBjdXN0b21fdmFyaWFibGVfY29uZmlndXJhdGlvbiwgcGFyZW50X2NvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlcy5zZXQoY3VzdG9tX3ZhcmlhYmxlX2NvbmZpZ3VyYXRpb24uaWQsIGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhbiBvcGVyYXRpb25hbCB2YXJpYWJsZS5cclxuICAgICAgICB0aGlzLnBsdWdpbi5nZXRWYXJpYWJsZXMoKS5hZGQoY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmNyZWF0ZUN1c3RvbVZhcmlhYmxlKCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlO1xyXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBsb2dpYyB0byB0aGUgYmFzZSBNb2RlbCBjbGFzcy5cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NyZWF0ZVNldHRpbmdGaWVsZHMoaW5zdGFuY2U6IEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UsIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCk6IFNldHRpbmcge1xyXG4gICAgICAgIGRlYnVnTG9nKGBDdXN0b21WYXJpYWJsZU1vZGVsOiBDcmVhdGluZyBzZXR0aW5nIGZpZWxkcyBmb3IgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSAke2luc3RhbmNlLmdldElEKCl9LmApO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHRoZSBmaWVsZHMgYXBwZWFyIGNsb3NlciB0b2dldGhlci5cclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5hZGRDbGFzcyhcIlNDLXNldHRpbmctZ3JvdXBcIik7XHJcblxyXG4gICAgICAgIC8vIEhlYWRpbmcgc2V0dGluZ1xyXG4gICAgICAgIGNvbnN0IGhlYWRpbmdfc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShpbnN0YW5jZS5nZXRGdWxsTmFtZSgpKVxyXG4gICAgICAgICAgICAuc2V0SGVhZGluZygpXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBOYW1lIHNldHRpbmdcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJWYXJpYWJsZSBuYW1lXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiTXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuIEFsbG93ZWQgY2hhcmFjdGVycyBhcmUgbGV0dGVycyBhLXosIG51bWJlcnMgMC05IGFuZCBhbiB1bmRlcnNjb3JlIF9cIilcclxuICAgICAgICAgICAgLnNldENsYXNzKFwiU0MtY3VzdG9tLXZhcmlhYmxlLW5hbWUtc2V0dGluZ1wiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShpbnN0YW5jZS5jb25maWd1cmF0aW9uLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoKG5ld19uYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaW5kIGEgd2F5IHRvIGNyZWF0ZSB0aGlzIGtpbmQgb2YgdHJpdmlhbCBvbkNoYW5nZSgpIGZ1bmN0aW9ucyBpbiB0aGUgTW9kZWwgYmFzZSBjbGFzcy5cclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRJZlZhbGlkKFwibmFtZVwiLCBuZXdfbmFtZSkudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRpbmdfc2V0dGluZy5zZXROYW1lKGluc3RhbmNlLmdldEZ1bGxOYW1lKCkpIC8vIEFsc28gcmVtb3ZlcyBhIHBvc3NpYmxlIHdhcm5pbmcgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0Q3VzdG9tVmFyaWFibGUoKS51cGRhdGVQcm9wZXJ0aWVzKCk7IC8vIFVwZGF0ZSB0aGUgbmFtZSBhbHNvIHRvIHRoZSBvcGVyYXRpb25hbCB2YXJpYWJsZSwgbm90IG9ubHkgaW4gY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnVwZGF0ZUN1c3RvbVZhcmlhYmxlVmlld3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAocmVhc29uOiBzdHJpbmcgfCB1bmtub3duKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYXNvbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkaW5nX3NldHRpbmcuc2V0TmFtZShyZWFzb24gKyBcIiBUaGUgbmFtZSB3YXMgbm90IHNhdmVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgcnVudGltZSBlcnJvciBoYXMgb2NjdXJyZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBEZXNjcmlwdGlvbiBzZXR0aW5nXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiRGVzY3JpcHRpb25cIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJBcHBlYXJzIGluIGF1dG9jb21wbGV0ZSBsaXN0cyBhbG9uZyB3aXRoIHRoZSB2YXJpYWJsZSBuYW1lLCBhbmQgYWxzbyBpbiB0aGUgJ0N1c3RvbSB2YXJpYWJsZXMnIHBhbmUsIGlmIHlvdSB1c2UgaXQuXCIpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGluc3RhbmNlLmNvbmZpZ3VyYXRpb24uZGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld19kZXNjcmlwdGlvbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRmluZCBhIHdheSB0byBjcmVhdGUgdGhpcyBraW5kIG9mIHRyaXZpYWwgb25DaGFuZ2UoKSBmdW5jdGlvbnMgaW4gdGhlIE1vZGVsIGJhc2UgY2xhc3MuXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29uZmlndXJhdGlvbi5kZXNjcmlwdGlvbiA9IG5ld19kZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5nZXRDdXN0b21WYXJpYWJsZSgpLnVwZGF0ZVByb3BlcnRpZXMoKTsgLy8gVXBkYXRlIHRoZSBkZXNjcmlwdGlvbiBhbHNvIHRvIHRoZSBvcGVyYXRpb25hbCB2YXJpYWJsZSwgbm90IG9ubHkgaW4gY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi51cGRhdGVDdXN0b21WYXJpYWJsZVZpZXdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4gaGVhZGluZ19zZXR0aW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZVZhbHVlKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZTogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSwgZmllbGQ6IGtleW9mIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2VbXCJjb25maWd1cmF0aW9uXCJdLCBjdXN0b21fdmFyaWFibGVfbmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgZGVidWdMb2coYEN1c3RvbVZhcmlhYmxlTW9kZWw6IFZhbGlkYXRpbmcgJHtmaWVsZH0gdmFsdWUgJHtjdXN0b21fdmFyaWFibGVfbmFtZX0gZm9yIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UgJHtjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0SUQoKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBuYW1lIGNvbnRhaW5zIG9ubHkgY2hhcmFjdGVycyBhLXosIDAtOSBhbmQvb3IgdW5kZXJsaW5lIF9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1c3RvbV92YXJpYWJsZV9uYW1lLm1hdGNoKC9eW1xcd1xcZF0rJC91KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnJlY3QgZm9ybWF0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYFRoZSBuYW1lIHt7XyR7Y3VzdG9tX3ZhcmlhYmxlX25hbWV9fX0gZG9lcyBub3QgbWVldCB0aGUgbmFtaW5nIHJlcXVpcmVtZW50cy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5hbWUgaXMgYSBkdXBsaWNhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDdXN0b21WYXJpYWJsZU5hbWVEdXBsaWNhdGUoY3VzdG9tX3ZhcmlhYmxlX25hbWUsIGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIGR1cGxpY2F0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGBUaGUgbmFtZSB7e18ke2N1c3RvbV92YXJpYWJsZV9uYW1lfX19IGlzIGFscmVhZHkgcmVzZXJ2ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyB1bmlxdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBmaWVsZHMgZG8gbm90IG5lZWQgdmFsaWRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9nZXREZWZhdWx0Q29uZmlndXJhdGlvbigpOiBDdXN0b21WYXJpYWJsZUNvbmZpZ3VyYXRpb24ge1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIG5hbWUgZm9yIHRoZSB2YXJpYWJsZSBieSB1c2luZyBhIHNlcXVlbnRpYWwgbnVtYmVyLlxyXG4gICAgICAgIGxldCBzZXF1ZW50aWFsX251bWJlciA9IDE7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNDdXN0b21WYXJpYWJsZU5hbWVEdXBsaWNhdGUoU3RyaW5nKHNlcXVlbnRpYWxfbnVtYmVyKSkpIHtcclxuICAgICAgICAgICAgc2VxdWVudGlhbF9udW1iZXIrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBnZXRJREdlbmVyYXRvcigpLmdlbmVyYXRlSUQoKSxcclxuICAgICAgICAgICAgbmFtZTogU3RyaW5nKHNlcXVlbnRpYWxfbnVtYmVyKSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgX2RlbGV0ZUluc3RhbmNlKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZTogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGRlYnVnTG9nKGBDdXN0b21WYXJpYWJsZU1vZGVsOiBEZWxldGluZyBDdXN0b21WYXJpYWJsZUluc3RhbmNlICR7Y3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmdldElEKCl9LmApO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UgZnJvbSBhbGwgUHJvbXB0RmllbGRzIHRoYXQgdXNlIGl0LlxyXG4gICAgICAgIGZvciAoY29uc3QgcHJvbXB0IG9mIHRoaXMucGx1Z2luLmdldFByb21wdHMoKS52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21wdF9maWVsZCBvZiBwcm9tcHQucHJvbXB0X2ZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZS5nZXRJRCgpID09PSBwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi50YXJnZXRfdmFyaWFibGVfaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByb21wdCBmaWVsZCB1c2VzIHRoaXMgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHZhcmlhYmxlIGZyb20gdXNlLlxyXG4gICAgICAgICAgICAgICAgICAgIHByb21wdF9maWVsZC5jb25maWd1cmF0aW9uLnRhcmdldF92YXJpYWJsZV9pZCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2aW5nIGlzIGRvbmUgbGF0ZXIsIGFmdGVyIHRoZSBfZGVsZXRlSW5zdGFuY2UoKSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWxldGUgQ3VzdG9tVmFyaWFibGVcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5nZXRWYXJpYWJsZXMoKS5kZWxldGUoY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmdldEN1c3RvbVZhcmlhYmxlKCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZS5nZXRDdXN0b21WYXJpYWJsZSgpIGZhaWxlZCwgbm8gbmVlZCB0byBkbyBhbnl0aGluZy4gSXQganVzdCBtZWFucyB0aGVyZSBpcyBubyBDdXN0b21WYXJpYWJsZSwgc28gdGhlcmUncyBub3RoaW5nIHRvIGRlbGV0ZS5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlbGV0ZSBDdXN0b21WYXJpYWJsZUluc3RhbmNlXHJcbiAgICAgICAgdGhpcy5jdXN0b21fdmFyaWFibGVfaW5zdGFuY2VzLmRlbGV0ZShjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0SUQoKSk7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdmFyaWFibGUgZnJvbSBjdXN0b20gdmFyaWFibGUgc2lkZSBwYW5lcy5cclxuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi51cGRhdGVDdXN0b21WYXJpYWJsZVZpZXdzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gYmUgY2hhbmdlZCB0byBwdWJsaWMgaWYgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzQ3VzdG9tVmFyaWFibGVOYW1lRHVwbGljYXRlKGN1c3RvbV92YXJpYWJsZV9uYW1lOiBzdHJpbmcsIGlnbm9yZV9jdXN0b21fdmFyaWFibGVfaW5zdGFuY2U/OiBDdXN0b21WYXJpYWJsZUluc3RhbmNlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGlzX2R1cGxpY2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlcy5mb3JFYWNoKChjdXN0b21fdmFyaWFibGUyX2luc3RhbmNlOiBDdXN0b21WYXJpYWJsZUluc3RhbmNlLCBjdXN0b21fdmFyaWFibGVfaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBjYW4gdGhlIGN1cnJlbnQgY3VzdG9tIHZhcmlhYmxlIGF0dGVuZCB0byB0aGUgZHVwbGljYXRlIHRlc3QuXHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVfY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlICYmIGN1c3RvbV92YXJpYWJsZV9pZCA9PT0gaWdub3JlX2N1c3RvbV92YXJpYWJsZV9pbnN0YW5jZS5nZXRJRCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayB0aGlzIGluc3RhbmNlLiBUaGlzIHNraXBwaW5nIGlzIHVzZWQgZm9yIHRoZSBjdXJyZW50IG93bmVyIG9mIHRoZSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgZG8gdGhlIGFjdHVhbCBkdXBsaWNhdGUgdGVzdC5cclxuICAgICAgICAgICAgaWYgKGN1c3RvbV92YXJpYWJsZV9uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IGN1c3RvbV92YXJpYWJsZTJfaW5zdGFuY2UuY29uZmlndXJhdGlvbi5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGlzX2R1cGxpY2F0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXNfZHVwbGljYXRlO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVZhcmlhYmxlQ29uZmlndXJhdGlvbiB7XHJcbiAgICBpZDogc3RyaW5nLFxyXG4gICAgbmFtZTogc3RyaW5nLFxyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2VNYXAgZXh0ZW5kcyBNYXA8c3RyaW5nLCBDdXN0b21WYXJpYWJsZUluc3RhbmNlPiB7fSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfTW9kYWx9IGZyb20gXCIuLi8uLi9TQ19Nb2RhbFwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcbmltcG9ydCB7XHJcbiAgICBDdXN0b21WYXJpYWJsZUluc3RhbmNlLFxyXG4gICAgQ3VzdG9tVmFyaWFibGVNb2RlbCxcclxuICAgIGdldE1vZGVsLFxyXG59IGZyb20gXCIuLi8uLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7U2V0dGluZ30gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tVmFyaWFibGVTZXR0aW5nc01vZGFsIGV4dGVuZHMgU0NfTW9kYWwge1xyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlOiBDdXN0b21WYXJpYWJsZUluc3RhbmNlLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgb25fYWZ0ZXJfY3JlYXRpb246ICgpID0+IHZvaWQsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBvbl9hZnRlcl9jYW5jZWxsaW5nOiAoKSA9PiB2b2lkLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIocGx1Z2luKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLm9uT3BlbigpO1xyXG5cclxuICAgICAgICBjb25zdCBtb2RlbCA9IGdldE1vZGVsPEN1c3RvbVZhcmlhYmxlTW9kZWw+KEN1c3RvbVZhcmlhYmxlTW9kZWwubmFtZSk7XHJcbiAgICAgICAgbW9kZWwuY3JlYXRlU2V0dGluZ0ZpZWxkcyh0aGlzLmN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZSwgdGhpcy5tb2RhbEVsLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKHRoaXMubW9kYWxFbClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIkNyZWF0ZVwiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5hcHByb3ZlKCkpLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhcHByb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vbl9hZnRlcl9jcmVhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jcmVhdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25fYWZ0ZXJfY2FuY2VsbGluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgICBJdGVtVmlldyxcclxuICAgIFdvcmtzcGFjZUxlYWYsXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBDdXN0b21WYXJpYWJsZVZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBWaWV3VHlwZSA9IFwiU0MtY3VzdG9tLXZhcmlhYmxlcy12aWV3XCI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBsZWFmOiBXb3Jrc3BhY2VMZWFmXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihsZWFmKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RGlzcGxheVRleHQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCJDdXN0b20gdmFyaWFibGVzXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFZpZXdUeXBlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIEN1c3RvbVZhcmlhYmxlVmlldy5WaWV3VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SWNvbigpIHtcclxuICAgICAgICByZXR1cm4gXCJjb2RlLWdseXBoXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb250YWluZXJfZWxlbWVudDogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgb25PcGVuKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyX2VsZW1lbnQgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdLmNyZWF0ZURpdigpOyAvLyBJIGRvbid0IGtub3cgd2h5IEkgY2Fubm90IGNyZWF0ZSBlbGVtZW50cyBkaXJlY3RseSB1bmRlciB0aGlzLmNvbnRhaW5lckVsICh0aGV5IHdvdWxkbid0IHNob3cgdXApLiBJIGRpZCB0aGUgc2FtZSB0aGluZyBhcyB3YXMgZG9uZSBoZXJlOiBodHRwczovL21hcmN1cy5zZS5uZXQvb2JzaWRpYW4tcGx1Z2luLWRvY3MvZ3VpZGVzL2N1c3RvbS12aWV3cyAocmVmZXJlbmNlZCAyMDIyLTAzLTIzKS5cclxuICAgICAgICB0aGlzLmNvbnRhaW5lcl9lbGVtZW50LmFkZENsYXNzKFwiY29udGFpbmVyXCIpO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUNvbnRlbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlQ29udGVudCgpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lcl9lbGVtZW50LmVtcHR5KCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcImgzXCIsIHt0ZXh0OiBcIkN1c3RvbSB2YXJpYWJsZXNcIn0pO1xyXG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlIG9mIHRoaXMucGx1Z2luLmdldEN1c3RvbVZhcmlhYmxlSW5zdGFuY2VzKCkudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgbGV0IGN1c3RvbV92YXJpYWJsZV92YWx1ZSA9IChhd2FpdCBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0Q3VzdG9tVmFyaWFibGUoKS5nZXRWYWx1ZSgpKS52YWx1ZTtcclxuICAgICAgICAgICAgbGV0IGVtcGhhc2l6ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VzdG9tX3ZhcmlhYmxlX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21fdmFyaWFibGVfdmFsdWUgPSBcIk5vIHZhbHVlIHlldC5cIjtcclxuICAgICAgICAgICAgICAgIGVtcGhhc2l6ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJcIiA9PT0gY3VzdG9tX3ZhcmlhYmxlX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21fdmFyaWFibGVfdmFsdWUgPSBcIkFuIGVtcHR5IHRleHQuXCI7XHJcbiAgICAgICAgICAgICAgICBlbXBoYXNpemUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlX2xpc3RfZWxlbWVudDogSFRNTFVMaXN0RWxlbWVudCA9IHRoaXMuY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJ1bFwiKTtcclxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVfbGlzdF9pdGVtX2VsZW1lbnQgPSB2YXJpYWJsZV9saXN0X2VsZW1lbnQuY3JlYXRlRWwoXCJsaVwiLCB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0RnVsbE5hbWUoKSxcclxuICAgICAgICAgICAgICAgIGF0dHI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLmNvbmZpZ3VyYXRpb24uZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyaWFibGVfbGlzdF9pdGVtX2VsZW1lbnQuY3JlYXRlRWwoXCJiclwiKTtcclxuICAgICAgICAgICAgbGV0IHZhcmlhYmxlX2xpc3RfaXRlbV9lbGVtZW50X2NoaWxkOiBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKGVtcGhhc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVfbGlzdF9pdGVtX2VsZW1lbnRfY2hpbGQgPSB2YXJpYWJsZV9saXN0X2l0ZW1fZWxlbWVudC5jcmVhdGVFbChcImVtXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQm9sZCBub3JtYWwgdmFsdWVzIHRvIG1ha2UgdGhlbSBtb3JlIHByb21pbmVudCBpbiBjb250cmFzdCB0byB2YXJpYWJsZSBuYW1lcyBhbmQgXCJObyB2YWx1ZSB5ZXQuXCIvXCJBbiBlbXB0eSB0ZXh0LlwiIHRleHRzLlxyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVfbGlzdF9pdGVtX2VsZW1lbnRfY2hpbGQgPSB2YXJpYWJsZV9saXN0X2l0ZW1fZWxlbWVudC5jcmVhdGVFbChcInN0cm9uZ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXJpYWJsZV9saXN0X2l0ZW1fZWxlbWVudF9jaGlsZC5pbnNlcnRBZGphY2VudFRleHQoXCJiZWZvcmVlbmRcIiwgY3VzdG9tX3ZhcmlhYmxlX3ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzLCBUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7VmFyaWFibGVTZXR9IGZyb20gXCIuLi92YXJpYWJsZXMvbG9hZFZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgUHJlYWN0aW9uX1Byb21wdCxcclxuICAgIFByZWFjdGlvbl9Qcm9tcHRfQ29uZmlndXJhdGlvbixcclxufSBmcm9tIFwiLi4vaW1wb3J0c1wiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFByZWFjdGlvbiB7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlndXJhdGlvbjogUHJlYWN0aW9uQ29uZmlndXJhdGlvbixcclxuICAgICAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLFxyXG4gICAgKSB7fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwaXBlbGluZSBvZiBwcmVhY3Rpb25zIGNhbiBwcm9jZWVkIHRvIHRoZSBuZXh0IHByZWFjdGlvbi4gRmFsc2UgaW5kaWNhdGVzXHJcbiAgICAgKiB0byBjYW5jZWwgcnVubmluZyBhbnkgcG9zc2libGUgbGF0ZXIgcHJlYWN0aW9ucywgYW5kIGFsc28gY2FuY2VscyBleGVjdXRpb24gb2YgdGhlIHNoZWxsIGNvbW1hbmQuIElmIGFsbCBwcmVhY3Rpb25zJ1xyXG4gICAgICogcHJvbWlzZXMgcmV0dXJuIHRydWUsIHRoZSBzaGVsbCBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBkb1ByZWFjdGlvbihwYXJzaW5nX3Byb2Nlc3M6IFNoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzLCBzY19ldmVudDogU0NfRXZlbnQpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF5YmUgdGhpcyB3cmFwcGVyIG1ldGhvZCBpcyB1bm5lZWRlZCwgYnV0IGhhdmUgaXQgZm9yIGEgd2hpbGUgYXQgbGVhc3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwZXJmb3JtKHBhcnNpbmdfcHJvY2VzczogU2hlbGxDb21tYW5kUGFyc2luZ1Byb2Nlc3MsIHNjX2V2ZW50OiBTQ19FdmVudCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvUHJlYWN0aW9uKHBhcnNpbmdfcHJvY2Vzcywgc2NfZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZXREZWZhdWx0Q29uZmlndXJhdGlvbigpOiBQcmVhY3Rpb25Db25maWd1cmF0aW9uOyAvLyBUT0RPOiBSZW1vdmUgaWYgdGhpcyB3b24ndCBiZSB1c2VkLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB2YXJpYWJsZXMgdGhhdCBhcmUgZGVwZW5kZW50IG9mIHRoaXMgUHJlYWN0aW9uLCBpLmUuIHZhcmlhYmxlcyB3aG9zZSB2YWx1ZSBpcyBzZXQgYnkgdGhpcyBQcmVhY3Rpb24uXHJcbiAgICAgKiBJZiBhIHZhcmlhYmxlIGlzIFJFQUQgYnkgYSBQcmVhY3Rpb24sIGl0IGlzIE5PVCBjb25zaWRlcmVkIHRvIGJlIF9kZXBlbmRlbnRfIG9mIHRoZSBQcmVhY3Rpb24sIGFzIGxvbmcgYXMgdGhlIHZhcmlhYmxlJ3NcclxuICAgICAqIHZhbHVlIGlzIG5vdCBjaGFuZ2VkIGJ5IHRoZSBQcmVhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgaXQgcmV0dXJucyBhbiBlbXB0eSBWYXJpYWJsZVNldCwgYmVjYXVzZSBub3QgYWxsIFByZWFjdGlvbnMgd2lsbCB1c2UgdmFyaWFibGVzIGF0IGFsbC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERlcGVuZGVudFZhcmlhYmxlcygpOiBWYXJpYWJsZVNldCB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZVNldCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlYWN0aW9uKHBsdWdpbjogU0NfUGx1Z2luLCBwcmVhY3Rpb25fY29uZmlndXJhdGlvbjogUHJlYWN0aW9uQ29uZmlndXJhdGlvbiwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogUHJlYWN0aW9uIHtcclxuICAgIHN3aXRjaCAocHJlYWN0aW9uX2NvbmZpZ3VyYXRpb24udHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJwcm9tcHRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVhY3Rpb25fUHJvbXB0KHBsdWdpbiwgKHByZWFjdGlvbl9jb25maWd1cmF0aW9uIGFzIFByZWFjdGlvbl9Qcm9tcHRfQ29uZmlndXJhdGlvbiksIHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJlYWN0aW9uQ29uZmlndXJhdGlvbiB7XHJcbiAgICB0eXBlOiBcInByb21wdFwiO1xyXG4gICAgZW5hYmxlZDogYm9vbGVhbjtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuLi9ldmVudHMvU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtWYXJpYWJsZVNldH0gZnJvbSBcIi4uL3ZhcmlhYmxlcy9sb2FkVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBQcmVhY3Rpb24sXHJcbiAgICBQcmVhY3Rpb25Db25maWd1cmF0aW9uLFxyXG4gICAgUHJvbXB0LFxyXG59IGZyb20gXCIuLi9pbXBvcnRzXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcywgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcmVhY3Rpb25fUHJvbXB0IGV4dGVuZHMgUHJlYWN0aW9uIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlndXJhdGlvbjogUHJlYWN0aW9uX1Byb21wdF9Db25maWd1cmF0aW9uLFxyXG4gICAgICAgIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbiwgY29uZmlndXJhdGlvbiwgdF9zaGVsbF9jb21tYW5kKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZG9QcmVhY3Rpb24ocGFyc2luZ19wcm9jZXNzOiBTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2Vzcywgc2NfZXZlbnQ6IFNDX0V2ZW50KTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgLy8gVE9ETzogTm93IHRoYXQgZG9QcmVhY3Rpb24oKSByZXR1cm5zIGEgc2ltaWxhciBQcm9taXNlIGFzIGlzIHJlY2VpdmVkIGZyb20gb3BlblByb21wdCgpLCBjb25zaWRlciBqdXN0IHJldHVybmluZyB0aGUgc2FtZSBQcm9taXNlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdldFByb21wdCgpLm9wZW5Qcm9tcHQodGhpcy50X3NoZWxsX2NvbW1hbmQsIHBhcnNpbmdfcHJvY2Vzcywgc2NfZXZlbnQpLnRoZW4oKGV4ZWN1dGlvbl9jb25maXJtZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBQcm9tcHRNb2RhbCBoYXMgYmVlbiBjbG9zZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB1c2VyIHdhbnRlZCB0byBleGVjdXRlIHRoZSBzaGVsbCBjb21tYW5kIG9yIGNhbmNlbC5cclxuICAgICAgICAgICAgICAgIGlmIChleGVjdXRpb25fY29uZmlybWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlciB3YW50cyB0byBleGVjdXRlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgd2FudHMgdG8gY2FuY2VsLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIEN1c3RvbVZhcmlhYmxlcyB3aG9zZSB2YWx1ZXMgdGhpcyBQcmVhY3Rpb24ncyBQcm9tcHQgc2V0cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERlcGVuZGVudFZhcmlhYmxlcygpOiBWYXJpYWJsZVNldCB7XHJcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gbmV3IFZhcmlhYmxlU2V0KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9tcHRfZmllbGQgb2YgdGhpcy5nZXRQcm9tcHQoKS5wcm9tcHRfZmllbGRzKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIFByb21wdEZpZWxkIGhhcyBhIHRhcmdldCB2YXJpYWJsZSBkZWZpbmVkLiBPdGhlcndpc2UgZ2V0VGFyZ2V0VmFyaWFibGUoKSB3b3VsZCBjYXVzZSBhIGNyYXNoLlxyXG4gICAgICAgICAgICBpZiAoXCJcIiAhPT0gcHJvbXB0X2ZpZWxkLmNvbmZpZ3VyYXRpb24udGFyZ2V0X3ZhcmlhYmxlX2lkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMuYWRkKHByb21wdF9maWVsZC5nZXRUYXJnZXRWYXJpYWJsZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFyaWFibGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogUmVtb3ZlLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKTogUHJlYWN0aW9uX1Byb21wdF9Db25maWd1cmF0aW9uIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBcInByb21wdFwiLFxyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJvbXB0X2lkOiBcIlwiLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRQcm9tcHQoKTogUHJvbXB0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW4uZ2V0UHJvbXB0cygpLmdldCh0aGlzLmNvbmZpZ3VyYXRpb24ucHJvbXB0X2lkKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRQcmVhY3Rpb25fUHJvbXB0X0NvbmZpZ3VyYXRpb24oKTogUHJlYWN0aW9uX1Byb21wdF9Db25maWd1cmF0aW9uIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJwcm9tcHRcIixcclxuICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICBwcm9tcHRfaWQ6IFwiXCIsXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByZWFjdGlvbl9Qcm9tcHRfQ29uZmlndXJhdGlvbiBleHRlbmRzIFByZWFjdGlvbkNvbmZpZ3VyYXRpb24ge1xyXG4gICAgdHlwZTogXCJwcm9tcHRcIjtcclxuICAgIHByb21wdF9pZDogc3RyaW5nO1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTZXR0aW5nfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge3BhcnNlVmFyaWFibGVzfSBmcm9tIFwiLi4vLi4vLi4vdmFyaWFibGVzL3BhcnNlVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uLy4uLy4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtcclxuICAgIEN1c3RvbVZhcmlhYmxlLFxyXG4gICAgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSxcclxuICAgIEluc3RhbmNlLFxyXG4gICAgUHJvbXB0LFxyXG4gICAgUHJvbXB0Q29uZmlndXJhdGlvbixcclxuICAgIFByb21wdEZpZWxkTW9kZWwsXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2ltcG9ydHNcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcm9tcHRGaWVsZCBleHRlbmRzIEluc3RhbmNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5zIGEgdmFsdWUgcHJldmlldyBlbGVtZW50LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcHJldmlld19zZXR0aW5nOiBTZXR0aW5nO1xyXG5cclxuICAgIHByaXZhdGUgcGFyc2VkX3ZhbHVlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHBhcnNpbmdfZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyBtb2RlbDogUHJvbXB0RmllbGRNb2RlbCxcclxuICAgICAgICBwdWJsaWMgcHJvbXB0OiBQcm9tcHQsXHJcbiAgICAgICAgcHVibGljIGNvbmZpZ3VyYXRpb246IFByb21wdEZpZWxkQ29uZmlndXJhdGlvbixcclxuICAgICAgICBwdWJsaWMgcHJvbXB0X2ZpZWxkX2luZGV4OiBrZXlvZiBQcm9tcHRDb25maWd1cmF0aW9uW1wiZmllbGRzXCJdLCAvLyBUT0RPOiAna2V5b2YnIGlzIGtpbmQgb2YgaW5jb3JyZWN0IGhlcmUsICdrZXlvZicgaXMgZm9yIG9iamVjdHMsIGJ1dCAnU0NfTWFpblNldHRpbmdzW1wiY3VzdG9tX3ZhcmlhYmxlc1wiXScgaXMgYW4gYXJyYXkgd2l0aCBudW1lcmljIGluZGV4ZXMuXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihtb2RlbCwgY29uZmlndXJhdGlvbiwgcHJvbXB0LmNvbmZpZ3VyYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250YWluZXJfZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHRfc2hlbGxfY29tbWFuZFxyXG4gICAgICogQHBhcmFtIHNjX2V2ZW50IFVzZWQgd2hlbiBwYXJzaW5nIHZhcmlhYmxlcyBmb3IgZGVmYXVsdF92YWx1ZSBhbmQgdGhlIGlucHV0dGVkIHZhbHVlLiBOZWVkZWQgc28gdGhhdCBhbHNvIHt7ZXZlbnRfKn19IHZhcmlhYmxlcyBjYW4gYmUgdXNlZCBpbiBwcm9tcHRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlRmllbGQoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQgfCBudWxsLCBzY19ldmVudDogU0NfRXZlbnQgfCBudWxsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fY3JlYXRlRmllbGQoY29udGFpbmVyX2VsZW1lbnQsIHRfc2hlbGxfY29tbWFuZCwgc2NfZXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBwcmV2aWV3IHNldHRpbmcgZWxlbWVudC4gSXQgd2lsbCBub3QgY29udGFpbiBhbnkgYWN0dWFsIHNldHRpbmcgZWxlbWVudHMsIGp1c3QgdGV4dC5cclxuICAgICAgICB0aGlzLnByZXZpZXdfc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KTtcclxuXHJcbiAgICAgICAgLy8gUGFyc2UgdmFyaWFibGVzIGluIHRoZSBkZWZhdWx0IHZhbHVlIGFuZCBpbnNlcnQgaXQgdG8gdGhlIGZpZWxkLlxyXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGEgZGlmZmVyZW50IFwiZGVmYXVsdCB2YWx1ZVwiIHRoYW4gd2hhdCBUU2hlbGxDb21tYW5kIGNvbnNpZGVycyBhcyB2YXJpYWJsZXMnIGRlZmF1bHQgdmFsdWVzISBUaGlzIGlzIGFib3V0IGEgX2ZpZWxkJ3NfIGRlZmF1bHQgdmFsdWUsIG5vdCBhIHZhcmlhYmxlJ3MgZGVmYXVsdCB2YWx1ZS4gdF9zaGVsbF9jb21tYW5kIGlzIHBhc3NlZCBpbiBvcmRlciB0byBhbGxvdyBhbnkgcG9zc2libGUgdmFyaWFibGVzIGluIHRoZSBmaWVsZCdzIGRlZmF1bHQgdmFsdWUgdG8gYWNjZXNzIHRoZSB2YXJpYWJsZXMnIGRlZmF1bHQgdmFsdWVzICh3aGljaCBjb21lIGZyb20gVFNoZWxsQ29tbWFuZCkuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5hcHBseURlZmF1bHRWYWx1ZSh0X3NoZWxsX2NvbW1hbmQsIHNjX2V2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2NyZWF0ZUZpZWxkKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kIHwgbnVsbCwgc2NfZXZlbnQ6IFNDX0V2ZW50IHwgbnVsbCk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgcHVibGljIGdldFRpdGxlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5sYWJlbCA9PT0gXCJcIiA/IFwiVW5sYWJlbGxlZCBmaWVsZFwiIDogdGhpcy5jb25maWd1cmF0aW9uLmxhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHZhbHVlIGZyb20gdGhlIGZvcm0gZmllbGQuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZXRWYWx1ZSgpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgdmFsdWUgdG8gdGhlIGZvcm0gZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHNldFZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBkZWZhdWx0IHZhbHVlIGFuZCBzZXRzIGl0IHRvIHRoZSBmb3JtIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gdF9zaGVsbF9jb21tYW5kXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgYXBwbHlEZWZhdWx0VmFsdWUodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kIHwgbnVsbCwgc2NfZXZlbnQ6IFNDX0V2ZW50IHwgbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRfdmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF92YWx1ZTtcclxuICAgICAgICBjb25zdCBwYXJzaW5nX3Jlc3VsdCA9IGF3YWl0IHBhcnNlVmFyaWFibGVzKHRoaXMucHJvbXB0Lm1vZGVsLnBsdWdpbiwgZGVmYXVsdF92YWx1ZSwgbnVsbCwgdF9zaGVsbF9jb21tYW5kLCBzY19ldmVudCk7XHJcbiAgICAgICAgaWYgKCFwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQpIHtcclxuICAgICAgICAgICAgLy8gUGFyc2luZyBmYWlsZWQuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoZGVmYXVsdF92YWx1ZSk7IC8vIFVzZSB0aGUgdW5wYXJzZWQgdmFsdWUuIElmIGRlZmF1bHQgdmFsdWUgY29udGFpbnMgYSB2YXJpYWJsZSB0aGF0IGNhbm5vdCBiZSBwYXJzZWQsIGEgdXNlciBjYW4gc2VlIHRoZSB2YXJpYWJsZSBpbiB0aGUgcHJvbXB0IG1vZGFsIGFuZCBlaXRoZXIgZml4IGl0IG9yIGNoYW5nZSBpdCB0byBzb21ldGhpbmcgZWxzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBQYXJzaW5nIHN1Y2NlZWRlZC5cclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShwYXJzaW5nX3Jlc3VsdC5wYXJzZWRfY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMudmFsdWVIYXNDaGFuZ2VkKHRfc2hlbGxfY29tbWFuZCwgc2NfZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQYXJzZWRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBhcnNpbmdFcnJvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2luZ19lcnJvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoaXMucGFyc2VkX3ZhbHVlLCB0aGlzLnBhcnNpbmdfZXJyb3JzIGFuZCB0aGlzLnByZXZpZXdfc2V0dGluZyAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRfc2hlbGxfY29tbWFuZFxyXG4gICAgICogQHBhcmFtIHNjX2V2ZW50XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhc3luYyB2YWx1ZUhhc0NoYW5nZWQodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kIHwgbnVsbCwgc2NfZXZlbnQ6IFNDX0V2ZW50KSB7XHJcbiAgICAgICAgbGV0IHByZXZpZXc6IHN0cmluZztcclxuXHJcbiAgICAgICAgLy8gUGFyc2UgdmFyaWFibGVzIGluIHRoZSB2YWx1ZS5cclxuICAgICAgICBjb25zdCBwYXJzaW5nX3Jlc3VsdCA9IGF3YWl0IHBhcnNlVmFyaWFibGVzKHRoaXMucHJvbXB0Lm1vZGVsLnBsdWdpbiwgdGhpcy5nZXRWYWx1ZSgpLCBudWxsLCB0X3NoZWxsX2NvbW1hbmQsIHNjX2V2ZW50KTtcclxuICAgICAgICBpZiAoIXBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCkge1xyXG4gICAgICAgICAgICAvLyBQYXJzaW5nIGZhaWxlZC5cclxuICAgICAgICAgICAgdGhpcy5wYXJzZWRfdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAocGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZS4gSWYgdGhlcmUgYXJlIG1vcmUsIG90aGVycyBjYW4gYmUgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgIHByZXZpZXcgPSBwYXJzaW5nX3Jlc3VsdC5lcnJvcl9tZXNzYWdlc1swXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBlcnJvciBtZXNzYWdlcywgdGhlbiBlcnJvcnMgYXJlIHNpbGVudGx5IGlnbm9yZWQgYnkgdXNlcidzIHZhcmlhYmxlIGNvbmZpZ3VyYXRpb24sIGluIHdoaWNoIGNhc2UganVzdCBzaG93IHRoZSBvcmlnaW5hbCBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgcHJldmlldyA9IHBhcnNpbmdfcmVzdWx0Lm9yaWdpbmFsX2NvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJzaW5nX2Vycm9ycyA9IHBhcnNpbmdfcmVzdWx0LmVycm9yX21lc3NhZ2VzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFBhcnNpbmcgc3VjY2VlZGVkXHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VkX3ZhbHVlID0gcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQ7XHJcbiAgICAgICAgICAgIHByZXZpZXcgPSBwYXJzaW5nX3Jlc3VsdC5wYXJzZWRfY29udGVudDtcclxuICAgICAgICAgICAgdGhpcy5wYXJzaW5nX2Vycm9ycyA9IFtdOyAvLyBObyBlcnJvcnMuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHByZXZpZXcgZWxlbWVudC5cclxuICAgICAgICBpZiAoMCA9PT0gcGFyc2luZ19yZXN1bHQuY291bnRfcGFyc2VkX3ZhcmlhYmxlcykge1xyXG4gICAgICAgICAgICAgLy8gSWYgbm8gdmFyaWFibGVzIHdlcmUgdXNlZCwgaGlkZSB0aGUgZGVzY3JpcHRpb24gYXMgaXQncyBub3QgbmVlZGVkIHRvIHJlcGVhdCB0aGUgdmFsdWUgdGhhdCBhbHJlYWR5IHNob3dzIHVwIGluIHRoZSBmb3JtIGZpZWxkLlxyXG4gICAgICAgICAgICBwcmV2aWV3ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmV2aWV3X3NldHRpbmcuc2V0RGVzYyhwcmV2aWV3KTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBhIHBvc3NpYmxlIGV4dGVybmFsIGNhbGxiYWNrXHJcbiAgICAgICAgaWYgKHRoaXMub25fY2hhbmdlX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25fY2hhbmdlX2NhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9uX2NoYW5nZV9jYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGZpZWxkJ3MgdmFsdWUgaXMgY2hhbmdlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uQ2hhbmdlKG9uX2NoYW5nZV9jYWxsYmFjazogKCkgPT4gdm9pZCkge1xyXG4gICAgICAgIHRoaXMub25fY2hhbmdlX2NhbGxiYWNrID0gb25fY2hhbmdlX2NhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBvbl9jaGFuZ2VfY2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9uX2ZvY3VzX2NhbGxiYWNrIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgZmllbGQgaXMgZm9jdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uRm9jdXMob25fZm9jdXNfY2FsbGJhY2s6IChwcm9tcHRfZmllbGQ6IFByb21wdEZpZWxkKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgdGhpcy5vbl9mb2N1c19jYWxsYmFjayA9IG9uX2ZvY3VzX2NhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBvbl9mb2N1c19jYWxsYmFjaz86IChwcm9tcHRfZmllbGQ6IFByb21wdEZpZWxkKSA9PiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCBieSB0aGUgc3ViY2xhc3Mgd2hlbiB0aGUgZmllbGQgaGFzIGdvdHRlbiBmb2N1cy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhc0dvdHRlbkZvY3VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9uX2ZvY3VzX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25fZm9jdXNfY2FsbGJhY2sodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGZvY3VzIG9uIHRoZSBmaWVsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNldEZvY3VzKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGZpZWxkIGlzIGZpbGxlZCwgaWYgaXQncyBtYW5kYXRvcnkuIElmIHRoZSBmaWVsZCBpcyBub3QgbWFuZGF0b3J5LCBpdCdzIGFsd2F5cyB2YWxpZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRydWUgd2hlbiB2YWxpZCwgZmFsc2Ugd2hlbiBub3QgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB2YWxpZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29uZmlndXJhdGlvbi5yZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHZhbGlkYXRlLCBiZWNhdXNlIHRoZSBmaWVsZCBpcyBub3QgbWFuZGF0b3J5LlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZmllbGQgaXMgZmlsbGVkXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaWxsZWQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgaXNGaWxsZWQoKTogYm9vbGVhbjtcclxuXHJcbiAgICBwdWJsaWMgZ2V0VGFyZ2V0VmFyaWFibGVJbnN0YW5jZSgpOiBDdXN0b21WYXJpYWJsZUluc3RhbmNlIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRfdmFyaWFibGVfaWQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udGFyZ2V0X3ZhcmlhYmxlX2lkO1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZTogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSA9IHRoaXMucHJvbXB0Lm1vZGVsLnBsdWdpbi5nZXRDdXN0b21WYXJpYWJsZUluc3RhbmNlcygpLmdldCh0YXJnZXRfdmFyaWFibGVfaWQpO1xyXG4gICAgICAgIGlmICghY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5nZXRUYXJnZXRWYXJpYWJsZUluc3RhbmNlKCk6IEN1c3RvbVZhcmlhYmxlSW5zdGFuY2Ugd2l0aCBJRCAnXCIgKyB0YXJnZXRfdmFyaWFibGVfaWQgKyBcIicgd2FzIG5vdCBmb3VuZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VGFyZ2V0VmFyaWFibGUoKTogQ3VzdG9tVmFyaWFibGUge1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZSA9IHRoaXMuZ2V0VGFyZ2V0VmFyaWFibGVJbnN0YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0Q3VzdG9tVmFyaWFibGUoKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcm9tcHRGaWVsZENvbmZpZ3VyYXRpb24ge1xyXG4gICAgLy8gdHlwZTogXCJ0ZXh0XCI7IC8vIFRPRE86IFVuY29tbWVudCB3aGVuIGltcGxlbWVudGluZyBtb3JlIHZhbHVlcyB0aGFuIGp1c3QgXCJ0ZXh0XCIuIE5vIG5lZWQgdG8gZGVjaWRlIHRoZSB2YWx1ZSBcInRleHRcIiBub3csIGl0IGNhbiBiZSBjaGFuZ2VkIHRvIFwic2luZ2xlLWxpbmUtdGV4dFwiIG9yIHNvbWV0aGluZyBlbHNlLCB0b28uXHJcbiAgICBsYWJlbDogc3RyaW5nO1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIGRlZmF1bHRfdmFsdWU6IHN0cmluZztcclxuICAgIC8vICBUT0RPOiBBZGQgJ3BsYWNlaG9sZGVyJy5cclxuICAgIHRhcmdldF92YXJpYWJsZV9pZDogc3RyaW5nO1xyXG4gICAgcmVxdWlyZWQ6IGJvb2xlYW47XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gICAgU2V0dGluZyxcclxuICAgIFRleHRDb21wb25lbnQsXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7cmFuZG9tSW50ZWdlcn0gZnJvbSBcIi4uLy4uLy4uL0NvbW1vblwiO1xyXG5pbXBvcnQge2NyZWF0ZUF1dG9jb21wbGV0ZX0gZnJvbSBcIi4uLy4uLy4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBDdXN0b21WYXJpYWJsZUluc3RhbmNlLFxyXG4gICAgQ3VzdG9tVmFyaWFibGVNb2RlbCxcclxuICAgIEN1c3RvbVZhcmlhYmxlU2V0dGluZ3NNb2RhbCxcclxuICAgIGdldE1vZGVsLFxyXG4gICAgTW9kZWwsXHJcbiAgICBQYXJlbnRNb2RlbE9uZVRvTWFueUluZGV4UmVsYXRpb24sXHJcbiAgICBQcm9tcHQsXHJcbiAgICBQcm9tcHRGaWVsZCxcclxuICAgIFByb21wdEZpZWxkX1RleHQsXHJcbiAgICBQcm9tcHRGaWVsZENvbmZpZ3VyYXRpb24sXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2ltcG9ydHNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9tcHRGaWVsZE1vZGVsIGV4dGVuZHMgTW9kZWwge1xyXG5cclxuICAgIHB1YmxpYyBnZXRTaW5ndWxhck5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCJGaWVsZFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBkZWZpbmVQYXJlbnRDb25maWd1cmF0aW9uUmVsYXRpb24ocHJvbXB0X2ZpZWxkOiBQcm9tcHRGaWVsZCk6IFBhcmVudE1vZGVsT25lVG9NYW55SW5kZXhSZWxhdGlvbiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogXCJvbmUtdG8tbWFueS1pbmRleFwiLFxyXG4gICAgICAgICAgICBrZXk6IFwiZmllbGRzXCIsXHJcbiAgICAgICAgICAgIGluZGV4OiBwcm9tcHRfZmllbGQucHJvbXB0X2ZpZWxkX2luZGV4IGFzIG51bWJlcixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBsb2FkSW5zdGFuY2VzKHByb21wdDogUHJvbXB0KTogUHJvbXB0RmllbGRTZXQge1xyXG4gICAgICAgIGNvbnN0IHByb21wdF9maWVsZHMgPSBuZXcgUHJvbXB0RmllbGRTZXQ7XHJcbiAgICAgICAgcHJvbXB0LmNvbmZpZ3VyYXRpb24uZmllbGRzLmZvckVhY2goKGZpZWxkX2NvbmZpZ3VyYXRpb246IFByb21wdEZpZWxkQ29uZmlndXJhdGlvbiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgcHJvbXB0X2ZpZWxkcy5hZGQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUluc3RhbmNlKHByb21wdCwgZmllbGRfY29uZmlndXJhdGlvbiwgaW5kZXgpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21wdF9maWVsZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5ld0luc3RhbmNlKHByb21wdDogUHJvbXB0KTogUHJvbXB0RmllbGQge1xyXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBsb2dpYyB0byB0aGUgYmFzZSBNb2RlbCBjbGFzcy5cclxuXHJcbiAgICAgICAgLy8gU2V0dXAgYSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cclxuICAgICAgICBjb25zdCBwcm9tcHRfZmllbGRfY29uZmlndXJhdGlvbiA9IHRoaXMuX2dldERlZmF1bHRDb25maWd1cmF0aW9uKCk7XHJcblxyXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIGEgUHJvbXB0RmllbGRcclxuICAgICAgICBjb25zdCBwcm9tcHRfZmllbGQgPSB0aGlzLmNyZWF0ZUluc3RhbmNlKHByb21wdCwgcHJvbXB0X2ZpZWxkX2NvbmZpZ3VyYXRpb24sIHByb21wdC5jb25maWd1cmF0aW9uLmZpZWxkcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgY29uZmlndXJhdGlvbiBpbnRvIHRoZSBwcm9tcHQncyBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgcHJvbXB0LmNvbmZpZ3VyYXRpb24uZmllbGRzLnB1c2gocHJvbXB0X2ZpZWxkX2NvbmZpZ3VyYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgUHJvbXB0RmllbGQgaW5zdGFuY2UgaW50byBpdHMgcGFyZW50IFByb21wdCdzIGxpc3Qgb2YgZmllbGRzLlxyXG4gICAgICAgIHByb21wdC5wcm9tcHRfZmllbGRzLmFkZChwcm9tcHRfZmllbGQpO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIFByb21wdEZpZWxkXHJcbiAgICAgICAgcmV0dXJuIHByb21wdF9maWVsZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZUluc3RhbmNlKHByb21wdDogUHJvbXB0LCBwcm9tcHRfZmllbGRfY29uZmlndXJhdGlvbjogUHJvbXB0RmllbGRDb25maWd1cmF0aW9uLCBwcm9tcHRfZmllbGRfaW5kZXg6IG51bWJlcik6IFByb21wdEZpZWxkIHtcclxuICAgICAgICAvLyBUT0RPOiBXaGVuIHRoZSAndHlwZScgZmllbGQgZ2V0cyBpbXBsZW1lbnRlZCBvbiBQcm9tcHRGaWVsZENvbmZpZ3VyYXRpb24sIGltcGxlbWVudCBzb21lIGtpbmQgb2Ygc3dpdGNoIHN0cnVjdHVyZSBoZXJlIHRvIGNyZWF0ZSBkaWZmZXJlbnQgdHlwZXMgb2YgUHJvbXB0RmllbGRzLlxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbXB0RmllbGRfVGV4dCh0aGlzLCBwcm9tcHQsIHByb21wdF9maWVsZF9jb25maWd1cmF0aW9uLCBwcm9tcHRfZmllbGRfaW5kZXgpXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jcmVhdGVTZXR0aW5nRmllbGRzKHByb21wdF9maWVsZDogUHJvbXB0RmllbGQsIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCk6IFNldHRpbmcge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsX3BsYWNlaG9sZGVycyA9IFtcclxuICAgICAgICAgICAgXCJXaGF0IGlzIHlvdXIgbmFtZT9cIixcclxuICAgICAgICAgICAgXCJIb3cgYmlnIGlzIHRoZSB1bml2ZXJzZT9cIixcclxuICAgICAgICAgICAgXCJIb3cgbG9uZyBpcyBldGVybml0eT9cIixcclxuICAgICAgICAgICAgXCJXaGF0IGlzIHlvdXIgbHVja3kgbnVtYmVyP1wiLFxyXG4gICAgICAgICAgICBcIldoYXQgaXMgeW91ciBmYXZvcml0ZSBzb25nP1wiLFxyXG4gICAgICAgICAgICBcIldoYXQgaXMgeW91ciBmYXZvcml0ZSBjb2xvcj9cIixcclxuICAgICAgICAgICAgXCJIb3cgbWFueSBib29rcyBoYXZlIHlvdSByZWFkP1wiLFxyXG4gICAgICAgICAgICBcIldoYXQgaXMgdGhlIHB1cnBvc2Ugb2YgbGlmZT9cIixcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRfdmFsdWVfcGxhY2Vob2xkZXJzID0gW1xyXG4gICAgICAgICAgICBbXCJCb25kLCBKYW1lcyBCb25kXCIsIFwiSm9obiBEb2VcIiwgXCJKYW5lIERvZVwiLCBcIk1yLiBCZWFuXCJdLFxyXG4gICAgICAgICAgICBbXCJWZXJ5IGJpZywgYW5kIHN0aWxsIGV4cGFuZGluZ1wiLCBcIjkzIGJpbGxpb24gbGlnaHQteWVhcnNcIl0sXHJcbiAgICAgICAgICAgIFtcIkluZmluaXRlXCIsIFwiVG9vIGxvbmcgdG8gd2FpdCBmb3JcIl0sXHJcbiAgICAgICAgICAgIFtTdHJpbmcocmFuZG9tSW50ZWdlcigwLCA5KSksIFwiSSBkb24ndCBoYXZlIG9uZVwiXSxcclxuICAgICAgICAgICAgW1wiV2UgYXJlIHRoZSB3b3JsZCAoVVNBIGZvciBBZnJpY2EpXCIsIFwiSGVhbCB0aGUgd29ybGQgKE1pY2hhZWwgSmFja3NvbilcIiwgXCJJbWFnaW5lIChKb2huIExlbm5vbilcIiwgXCJDaXJjbGUgb2YgbGlmZSAoRWx0b24gSm9obilcIl0sXHJcbiAgICAgICAgICAgIFtcIkJsdWUgYXMgZGVlcCBhcyBhbiBvY2VhblwiLCBcIlJlZCBhcyBsb3ZlXCIsIFwiR3Jhc3MtZ3JlZW5cIiwgXCJTbm93LXdoaXRlXCJdLFxyXG4gICAgICAgICAgICBbXCJUaG91c2FuZHNcIiwgXCJNYW55XCIsIFwiQ291bnRsZXNzXCIsIFwiTm9uZVwiXSxcclxuICAgICAgICAgICAgW1wiVGhpbmtpbmdcIiwgXCJCZWluZyBhIGJlaW5nXCIsIFwiNDJcIl0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBsYWJlbF9wbGFjZWhvbGRlcl9pbmRleDogbnVtYmVyID0gcmFuZG9tSW50ZWdlcigwLCBsYWJlbF9wbGFjZWhvbGRlcnMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdF92YWx1ZV9wbGFjZWhvbGRlcnNfc3Vic2V0OiBzdHJpbmdbXSA9IGRlZmF1bHRfdmFsdWVfcGxhY2Vob2xkZXJzW2xhYmVsX3BsYWNlaG9sZGVyX2luZGV4XTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBjdXN0b20gdmFyaWFibGVzXHJcbiAgICAgICAgY29uc3QgY3VzdG9tX3ZhcmlhYmxlX29wdGlvbnM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge307XHJcbiAgICAgICAgdGhpcy5wbHVnaW4uZ2V0Q3VzdG9tVmFyaWFibGVJbnN0YW5jZXMoKS5mb3JFYWNoKChjdXN0b21fdmFyaWFibGVfaW5zdGFuY2U6IEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UsIGN1c3RvbV92YXJpYWJsZV9pZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGN1c3RvbV92YXJpYWJsZV9vcHRpb25zW2N1c3RvbV92YXJpYWJsZV9pZF0gPSBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0RnVsbE5hbWUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25fZGVmYXVsdF92YWx1ZV9zZXR0aW5nX2NoYW5nZSA9IGFzeW5jIChuZXdfZGVmYXVsdF92YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHByb21wdF9maWVsZC5jb25maWd1cmF0aW9uLmRlZmF1bHRfdmFsdWUgPSBuZXdfZGVmYXVsdF92YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5nIGZpZWxkc1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdfZ3JvdXBfZWxlbWVudCA9IGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZURpdih7YXR0cjoge2NsYXNzOiBcIlNDLXNldHRpbmctZ3JvdXBcIn19KTtcclxuICAgICAgICBsZXQgbGFiZWxfc2V0dGluZ19jb21wb25lbnQ6IFRleHRDb21wb25lbnQ7XHJcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uX3NldHRpbmdfY29tcG9uZW50OiBUZXh0Q29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdfZ3JvdXA6IFByb21wdEZpZWxkU2V0dGluZ0dyb3VwID0ge1xyXG4gICAgICAgICAgICBoZWFkaW5nX3NldHRpbmc6IG5ldyBTZXR0aW5nKHNldHRpbmdfZ3JvdXBfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKFwiXCIpIC8vIFRoaXMgd2lsbCBiZSBzZXQgZG93biBiZWxvdy5cclxuICAgICAgICAgICAgICAgIC5zZXRIZWFkaW5nKClcclxuICAgICAgICAgICAgLFxyXG4gICAgICAgICAgICBsYWJlbF9zZXR0aW5nOiBuZXcgU2V0dGluZyhzZXR0aW5nX2dyb3VwX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShcIkZpZWxkIGxhYmVsXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IGxhYmVsX3NldHRpbmdfY29tcG9uZW50ID0gdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi5sYWJlbClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIobGFiZWxfcGxhY2Vob2xkZXJzW2xhYmVsX3BsYWNlaG9sZGVyX2luZGV4XSlcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld19sYWJlbDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdF9maWVsZC5jb25maWd1cmF0aW9uLmxhYmVsID0gbmV3X2xhYmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlX2hlYWRpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAsXHJcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWVfc2V0dGluZzogbmV3IFNldHRpbmcoc2V0dGluZ19ncm91cF9lbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoXCJEZWZhdWx0IHZhbHVlXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvbXB0X2ZpZWxkLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF92YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdF9maWVsZC5jb25maWd1cmF0aW9uLmxhYmVsID8gXCJcIiAvLyBJZiB0aGUgbGFiZWwgaXMgZGVmaW5lZCwgZG8gbm90IGFkZCBhIHBsYWNlaG9sZGVyIGhlcmUsIGFzIHRoZSBsYWJlbCdzIHBsYWNlaG9sZGVyIGlzIG5vdCB2aXNpYmxlLCBzbyB0aGlzIHBsYWNlaG9sZGVyIHdvdWxkIG5vdCBtYWtlIHNlbnNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0X3ZhbHVlX3BsYWNlaG9sZGVyc19zdWJzZXRbcmFuZG9tSW50ZWdlcigwLCBkZWZhdWx0X3ZhbHVlX3BsYWNlaG9sZGVyc19zdWJzZXQubGVuZ3RoIC0gMSldXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShvbl9kZWZhdWx0X3ZhbHVlX3NldHRpbmdfY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uX3NldHRpbmc6IG5ldyBTZXR0aW5nKHNldHRpbmdfZ3JvdXBfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKFwiRGVzY3JpcHRpb25cIilcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gZGVzY3JpcHRpb25fc2V0dGluZ19jb21wb25lbnQgPSB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHByb21wdF9maWVsZC5jb25maWd1cmF0aW9uLmRlc2NyaXB0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X2Rlc2NyaXB0aW9uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0X2ZpZWxkLmNvbmZpZ3VyYXRpb24uZGVzY3JpcHRpb24gPSBuZXdfZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAsXHJcbiAgICAgICAgICAgIHRhcmdldF92YXJpYWJsZV9zZXR0aW5nOiBuZXcgU2V0dGluZyhzZXR0aW5nX2dyb3VwX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShcIlRhcmdldCB2YXJpYWJsZVwiKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoXCJXaGVyZSB0aGUgaW5wdXR0ZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQgaW4uIFlvdSBjYW4gdXNlIHRoZSB2YXJpYWJsZSBpbiBhIHNoZWxsIGNvbW1hbmQuXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiXCIsIFwiXCIpIC8vIEFuIG9wdGlvbiBmb3IgYSBzaXR1YXRpb24gd2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKGN1c3RvbV92YXJpYWJsZV9vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJuZXdcIiwgXCJDcmVhdGUgYSBuZXcgY3VzdG9tIHZhcmlhYmxlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHByb21wdF9maWVsZC5jb25maWd1cmF0aW9uLnRhcmdldF92YXJpYWJsZV9pZClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoKG5ld190YXJnZXRfdmFyaWFibGVfaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJuZXdcIiA9PT0gbmV3X3RhcmdldF92YXJpYWJsZV9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGN1c3RvbSB2YXJpYWJsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0TW9kZWw8Q3VzdG9tVmFyaWFibGVNb2RlbD4oQ3VzdG9tVmFyaWFibGVNb2RlbC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlID0gbW9kZWwubmV3SW5zdGFuY2UodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgQ3VzdG9tVmFyaWFibGVTZXR0aW5nc01vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZSBpcyBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZS5nZXRJRCgpLCBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0VGl0bGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZShjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0SUQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi50YXJnZXRfdmFyaWFibGVfaWQgPSBjdXN0b21fdmFyaWFibGVfaW5zdGFuY2UuZ2V0SUQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZShwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi50YXJnZXRfdmFyaWFibGVfaWQpOyAvLyBSZXNldCB0aGUgZHJvcGRvd24gc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGUgY3JlYXRpb24gd2FzIGNhbmNlbGxlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRlbGV0ZUluc3RhbmNlKGN1c3RvbV92YXJpYWJsZV9pbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGFuIGV4aXN0aW5nIHRhcmdldCB2YXJpYWJsZSAob3IgYW4gZW1wdHkgaWQgXCJcIikuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgdGFyZ2V0IHZhcmlhYmxlIGlzIG5vdCByZXNlcnZlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdF9maWVsZC5zZXRJZlZhbGlkKFwidGFyZ2V0X3ZhcmlhYmxlX2lkXCIsIG5ld190YXJnZXRfdmFyaWFibGVfaWQpLnRoZW4oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IGNhbiBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yX21lc3NhZ2U6IHN0cmluZyB8IHVua25vd24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yX21lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCB2YXJpYWJsZSBpcyByZXNlcnZlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUocHJvbXB0X2ZpZWxkLmNvbmZpZ3VyYXRpb24udGFyZ2V0X3ZhcmlhYmxlX2lkKTsgLy8gUmVzZXQgdGhlIGRyb3Bkb3duIHNlbGVjdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3Tm90aWZpY2F0aW9uKGVycm9yX21lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgcnVudGltZSBlcnJvciBoYXMgb2NjdXJyZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yX21lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkX3NldHRpbmc6IG5ldyBTZXR0aW5nKHNldHRpbmdfZ3JvdXBfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKFwiSXMgcmVxdWlyZWRcIilcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKFwiSWYgb24sIHRoZSBmaWVsZCBuZWVkcyB0byBiZSBmaWxsZWQgYmVmb3JlIHRoZSBwcm9tcHQgY2FuIGJlIHN1Ym1pdHRlZC5cIilcclxuICAgICAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi5yZXF1aXJlZClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld19yZXF1aXJlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi5yZXF1aXJlZCA9IG5ld19yZXF1aXJlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3VwZGF0ZV9oZWFkaW5nKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF91cGRhdGVfaGVhZGluZygpIHtcclxuICAgICAgICAgICAgc2V0dGluZ19ncm91cC5oZWFkaW5nX3NldHRpbmcuc2V0TmFtZShwcm9tcHRfZmllbGQuZ2V0VGl0bGUoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvY29tcGxldGUgbWVudVxyXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KSB7XHJcbiAgICAgICAgICAgIC8vIFNob3cgYXV0b2NvbXBsZXRlIG1lbnUgKD0gYSBsaXN0IG9mIGF2YWlsYWJsZSB2YXJpYWJsZXMpLlxyXG4gICAgICAgICAgICBjb25zdCBsYWJlbF9pbnB1dF9lbGVtZW50ID0gc2V0dGluZ19ncm91cC5sYWJlbF9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwiaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHRoaXMucGx1Z2luLCBsYWJlbF9pbnB1dF9lbGVtZW50LCAoKSA9PiBsYWJlbF9zZXR0aW5nX2NvbXBvbmVudC5vbkNoYW5nZWQoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRfdmFsdWVfaW5wdXRfZWxlbWVudCA9IHNldHRpbmdfZ3JvdXAuZGVmYXVsdF92YWx1ZV9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwiaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHRoaXMucGx1Z2luLCBkZWZhdWx0X3ZhbHVlX2lucHV0X2VsZW1lbnQsIG9uX2RlZmF1bHRfdmFsdWVfc2V0dGluZ19jaGFuZ2UpO1xyXG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbl9pbnB1dF9lbGVtZW50ID0gc2V0dGluZ19ncm91cC5kZXNjcmlwdGlvbl9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwiaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHRoaXMucGx1Z2luLCBkZXNjcmlwdGlvbl9pbnB1dF9lbGVtZW50LCAoKSA9PiBkZXNjcmlwdGlvbl9zZXR0aW5nX2NvbXBvbmVudC5vbkNoYW5nZWQoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2V0dGluZ19ncm91cC5oZWFkaW5nX3NldHRpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlVmFsdWUocHJvbXB0X2ZpZWxkOiBQcm9tcHRGaWVsZCwgZmllbGQ6IGtleW9mIFByb21wdEZpZWxkQ29uZmlndXJhdGlvbiwgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBzd2l0Y2ggKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0YXJnZXRfdmFyaWFibGVfaWRcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3X3RhcmdldF92YXJpYWJsZV9pZDogc3RyaW5nID0gdmFsdWUgYXMgc3RyaW5nOyAvLyBBIG1vcmUgZGVzY3JpcHRpdmUgbmFtZSBmb3IgJ3ZhbHVlJy5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgYWxsb3cgYW4gZW1wdHkgdGFyZ2V0X3ZhcmlhYmxlX2lkLiBBIFByb21wdCBjYW5ub3QgYmUgb3BlbmVkIGlmIGEgZmllbGQgbGFja3MgYSB0YXJnZXRfdmFyaWFibGVfaWQsIGJ1dCBpdCdzIGFsbG93ZWQgdG8gYmUgc3RvcmVkIGluIHRoZSBjb25maWd1cmF0aW9uLCBiZWNhdXNlIG5ldyBQcm9tcHRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCBzZWxlY3RlZCB0YXJnZXQgdmFyaWFibGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoXCJcIiA9PT0gbmV3X3RhcmdldF92YXJpYWJsZV9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0YXJnZXQgdmFyaWFibGUgaXMgbm90IHVzZWQgYnkgb3RoZXIgZmllbGRzIG9mIHRoZSBzYW1lIFByb21wdC5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3RoZXJfcHJvbXB0X2ZpZWxkIG9mIHByb21wdF9maWVsZC5wcm9tcHQucHJvbXB0X2ZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9tcHRfZmllbGQgIT09IG90aGVyX3Byb21wdF9maWVsZCkgeyAvLyBEbyBub3QgY2hlY2sgdGhlIHNhbWUgZmllbGQuIE9ubHkgY2hlY2sgb3RoZXIgZmllbGRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIG90aGVyIGZpZWxkIGhhcyB0aGUgc2FtZSB0YXJnZXQgdmFyaWFibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdfdGFyZ2V0X3ZhcmlhYmxlX2lkID09PSBvdGhlcl9wcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi50YXJnZXRfdmFyaWFibGVfaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgaGF2ZSB0aGUgc2FtZSB0YXJnZXRfdmFyaWFibGVfaWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldF92YXJpYWJsZV9uYW1lID0gdGhpcy5wbHVnaW4uZ2V0Q3VzdG9tVmFyaWFibGVJbnN0YW5jZXMoKS5nZXQobmV3X3RhcmdldF92YXJpYWJsZV9pZCkuZ2V0RnVsbE5hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgVGFyZ2V0IHZhcmlhYmxlICR7dGFyZ2V0X3ZhcmlhYmxlX25hbWV9IGlzIGFscmVhZHkgdXNlZCBieSBhbm90aGVyIGZpZWxkIGluIHRoZSBzYW1lIHByb21wdC4gU2VsZWN0IGFub3RoZXIgdmFyaWFibGUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgZmllbGRzIGhhdmUgYmVlbiBjaGVja2VkIGFuZCBubyBjb2xsaXNpb25zIHdlcmUgZm91bmQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gdmFsaWRhdGlvbiBmb3Igb3RoZXIgZmllbGRzLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiLnZhbGlkYXRlVmFsdWUoKTogTm8gdmFsaWRhdGlvbiBpcyBpbXBsZW1lbnRlZCBmb3Igb3RoZXIgZmllbGRzLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXREZWZhdWx0Q29uZmlndXJhdGlvbigpOiBQcm9tcHRGaWVsZENvbmZpZ3VyYXRpb24ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIHR5cGU6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJcIixcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWU6IFwiXCIsXHJcbiAgICAgICAgICAgIC8vICBUT0RPOiBBZGQgJ3BsYWNlaG9sZGVyJy5cclxuICAgICAgICAgICAgdGFyZ2V0X3ZhcmlhYmxlX2lkOiBcIlwiLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZWxldGVJbnN0YW5jZShwcm9tcHRfZmllbGQ6IFByb21wdEZpZWxkKTogdm9pZCB7XHJcbiAgICAgICAgcHJvbXB0X2ZpZWxkLnByb21wdC5wcm9tcHRfZmllbGRzLmRlbGV0ZShwcm9tcHRfZmllbGQpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvbXB0RmllbGRTZXQgZXh0ZW5kcyBTZXQ8UHJvbXB0RmllbGQ+IHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb21wdEZpZWxkU2V0dGluZ0dyb3VwIHtcclxuICAgIGhlYWRpbmdfc2V0dGluZzogU2V0dGluZztcclxuICAgIGxhYmVsX3NldHRpbmc6IFNldHRpbmc7XHJcbiAgICBkZWZhdWx0X3ZhbHVlX3NldHRpbmc6IFNldHRpbmc7XHJcbiAgICBkZXNjcmlwdGlvbl9zZXR0aW5nOiBTZXR0aW5nO1xyXG4gICAgdGFyZ2V0X3ZhcmlhYmxlX3NldHRpbmc6IFNldHRpbmdcclxuICAgIHJlcXVpcmVkX3NldHRpbmc6IFNldHRpbmc7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gICAgU2V0dGluZyxcclxuICAgIFRleHRDb21wb25lbnQsXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7Y3JlYXRlQXV0b2NvbXBsZXRlfSBmcm9tIFwiLi4vLi4vLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vLi4vLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7cGFyc2VWYXJpYWJsZXN9IGZyb20gXCIuLi8uLi8uLi92YXJpYWJsZXMvcGFyc2VWYXJpYWJsZXNcIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vLi4vLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgUHJvbXB0RmllbGQsXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2ltcG9ydHNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9tcHRGaWVsZF9UZXh0IGV4dGVuZHMgUHJvbXB0RmllbGQge1xyXG5cclxuICAgIHByaXZhdGUgdGV4dF9jb21wb25lbnQ6IFRleHRDb21wb25lbnQ7XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIF9jcmVhdGVGaWVsZChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCB8IG51bGwsIHNjX2V2ZW50OiBTQ19FdmVudCB8IG51bGwpIHtcclxuICAgICAgICBjb25zdCBwbHVnaW46IFNDX1BsdWdpbiA9IHRoaXMucHJvbXB0Lm1vZGVsLnBsdWdpbjtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaWVsZFxyXG4gICAgICAgIGNvbnN0IG9uX2NoYW5nZSA9ICgpID0+IHRoaXMudmFsdWVIYXNDaGFuZ2VkKHRfc2hlbGxfY29tbWFuZCwgc2NfZXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsX3BhcnNpbmdfcmVzdWx0ID0gYXdhaXQgcGFyc2VWYXJpYWJsZXModGhpcy5wcm9tcHQubW9kZWwucGx1Z2luLCB0aGlzLmNvbmZpZ3VyYXRpb24ubGFiZWwsIG51bGwsIHRfc2hlbGxfY29tbWFuZCwgc2NfZXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uX3BhcnNpbmdfcmVzdWx0ID0gYXdhaXQgcGFyc2VWYXJpYWJsZXModGhpcy5wcm9tcHQubW9kZWwucGx1Z2luLCB0aGlzLmNvbmZpZ3VyYXRpb24uZGVzY3JpcHRpb24sIG51bGwsIHRfc2hlbGxfY29tbWFuZCwgc2NfZXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUobGFiZWxfcGFyc2luZ19yZXN1bHQuc3VjY2VlZGVkID8gbGFiZWxfcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQgOiBsYWJlbF9wYXJzaW5nX3Jlc3VsdC5vcmlnaW5hbF9jb250ZW50KVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhkZXNjcmlwdGlvbl9wYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQgPyBkZXNjcmlwdGlvbl9wYXJzaW5nX3Jlc3VsdC5wYXJzZWRfY29udGVudCA6IGRlc2NyaXB0aW9uX3BhcnNpbmdfcmVzdWx0Lm9yaWdpbmFsX2NvbnRlbnQpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0X2NvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0X2NvbXBvbmVudCA9IHRleHRfY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgdGV4dF9jb21wb25lbnQub25DaGFuZ2Uob25fY2hhbmdlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCBvbkZvY3VzIGhvb2suXHJcbiAgICAgICAgdGhpcy50ZXh0X2NvbXBvbmVudC5pbnB1dEVsLm9uZm9jdXMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR290dGVuRm9jdXMoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTaG93IGF1dG9jb21wbGV0ZSBtZW51IChpZiBlbmFibGVkKVxyXG4gICAgICAgIGlmIChwbHVnaW4uc2V0dGluZ3Muc2hvd19hdXRvY29tcGxldGVfbWVudSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dF9lbGVtZW50ID0gc2V0dGluZy5jb250cm9sRWwuZmluZChcImlucHV0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNyZWF0ZUF1dG9jb21wbGV0ZShwbHVnaW4sIGlucHV0X2VsZW1lbnQsIG9uX2NoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzZXRWYWx1ZSh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50ZXh0X2NvbXBvbmVudC5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dF9jb21wb25lbnQuZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0Rm9jdXMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50ZXh0X2NvbXBvbmVudC5pbnB1dEVsLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGlzRmlsbGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCkubGVuZ3RoID4gMDtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcywgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uLy4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtTQ19NYWluU2V0dGluZ3N9IGZyb20gXCIuLi8uLi9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0TW9kZWwsXHJcbiAgICBJbnN0YW5jZSxcclxuICAgIFByb21wdEZpZWxkLFxyXG4gICAgUHJvbXB0RmllbGRDb25maWd1cmF0aW9uLFxyXG4gICAgUHJvbXB0RmllbGRTZXQsXHJcbiAgICBQcm9tcHRGaWVsZE1vZGVsLFxyXG4gICAgUHJvbXB0TW9kYWwsXHJcbiAgICBQcm9tcHRNb2RlbCxcclxuICAgIGdldElER2VuZXJhdG9yLFxyXG59IGZyb20gXCIuLi8uLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi8uLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFByb21wdCBleHRlbmRzIEluc3RhbmNlIHtcclxuXHJcbiAgICBwdWJsaWMgcHJvbXB0X2ZpZWxkczogUHJvbXB0RmllbGRTZXQgPSBuZXcgUHJvbXB0RmllbGRTZXQoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwdWJsaWMgbW9kZWw6IFByb21wdE1vZGVsLFxyXG4gICAgICAgIHByb3RlY3RlZCBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBwdWJsaWMgY29uZmlndXJhdGlvbjogUHJvbXB0Q29uZmlndXJhdGlvbixcclxuICAgICAgICBwdWJsaWMgcGFyZW50X2NvbmZpZ3VyYXRpb246IFNDX01haW5TZXR0aW5ncyxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKG1vZGVsLCBjb25maWd1cmF0aW9uLCBwYXJlbnRfY29uZmlndXJhdGlvbik7XHJcblxyXG4gICAgICAgIC8vIEludHJvZHVjZSB0aGUgSUQgdG8gYW4gSUQgZ2VuZXJhdG9yIHNvIHRoYXQgaXQgd29uJ3QgYWNjaWRlbnRhbGx5IGdlbmVyYXRlIHRoZSBzYW1lIElEIGFnYWluIHdoZW4gY3JlYXRpbmcgbmV3IFByb21wdHMuXHJcbiAgICAgICAgZ2V0SURHZW5lcmF0b3IoKS5hZGRSZXNlcnZlZElEKGNvbmZpZ3VyYXRpb24uaWQpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZUZpZWxkcygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZ2V0SUQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5pZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VGl0bGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi50aXRsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29uZmlndXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDU1NDbGFzcygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBQcm9tcHQuZ2V0Q1NTQmFzZUNsYXNzKCkgKyBcIi1cIiArIHRoaXMuZ2V0SUQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENTU0Jhc2VDbGFzcygpIHtcclxuICAgICAgICByZXR1cm4gXCJTQy1wcm9tcHQtbW9kYWxcIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q1NTQ2xhc3NlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBQcm9tcHQuZ2V0Q1NTQmFzZUNsYXNzKCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0Q1NTQ2xhc3MoKSxcclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdF9zaGVsbF9jb21tYW5kIENhbiBiZSBudWxsLCBpZiB3YW50ZWQgdG8ganVzdCBwcmV2aWV3IHRoZSBQcm9tcHQgbW9kYWwgd2l0aG91dCByZWFsbHkgZXhlY3V0aW5nIGEgc2hlbGwgY29tbWFuZC4gSW5wdXR0ZWQgdmFsdWVzIHdpbGwgc3RpbGwgYmUgYXNzaWduZWQgdG8gdGFyZ2V0IHZhcmlhYmxlcy5cclxuICAgICAqIEBwYXJhbSBwYXJzaW5nX3Byb2Nlc3NcclxuICAgICAqIEBwYXJhbSBzY19ldmVudFxyXG4gICAgICogQHJldHVybiBQcm9taXNlIFRoZSBib29sZWFuIHZhbHVlIHRlbGxzIHdoZXRoZXIgdGhlIHVzZXIgd2FudHMgdG8gZXhlY3V0ZSBhIHNoZWxsIGNvbW1hbmQgKHRydWUpIG9yIGNhbmNlbCAoZmFsc2UpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3BlblByb21wdCh0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQgfCBudWxsLCBwYXJzaW5nX3Byb2Nlc3M6IFNoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzIHwgbnVsbCwgc2NfZXZlbnQ6IFNDX0V2ZW50IHwgbnVsbCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGNvbnN0IGNhbl9vcGVuX3Byb21wdF9yZXN1bHQgPSB0aGlzLmNhbk9wZW5Qcm9tcHQoKTtcclxuICAgICAgICBpZiAodHJ1ZSAhPT0gY2FuX29wZW5fcHJvbXB0X3Jlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBTb21lIGVycm9yIGlzIHByZXZlbnRpbmcgb3BlbmluZyB0aGUgcHJvbXB0LlxyXG4gICAgICAgICAgICAvLyBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UgaXMgY29udGFpbmVkIGluIGNhbl9vcGVuX3Byb21wdF9yZXN1bHQuXHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwiQ291bGQgbm90IG9wZW4gUHJvbXB0IFwiICsgdGhpcy5nZXRJRCgpICsgXCIgYmVjYXVzZSBvZiBlcnJvcjogXCIgKyBjYW5fb3Blbl9wcm9tcHRfcmVzdWx0KTtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoY2FuX29wZW5fcHJvbXB0X3Jlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpOyAvLyBmYWxzZTogQ2FuY2VsIGV4ZWN1dGlvbiAocHJldGVuZHMgdGhhdCBhIHVzZXIgY2FuY2VsbGVkIGl0LCBidXQgaXQncyBvaykuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWJ1Z0xvZyhcIk9wZW5pbmcgUHJvbXB0IFwiICsgdGhpcy5nZXRJRCgpKTtcclxuXHJcbiAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgUHJvbXB0TW9kYWwoXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLFxyXG4gICAgICAgICAgICB0aGlzLnByb21wdF9maWVsZHMsXHJcbiAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgcGFyc2luZ19wcm9jZXNzLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICBzY19ldmVudCxcclxuICAgICAgICAgICAgKCkgPT4ge3JldHVybiB0aGlzLnZhbGlkYXRlRmllbGRzKCk7fVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgIHJldHVybiBtb2RhbC5wcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2FuT3BlblByb21wdCgpOiB0cnVlIHwgc3RyaW5nIHtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBhbGwgUHJvbXB0RmllbGRzIGhhdmUgYSB0YXJnZXQgdmFyaWFibGUgZGVmaW5lZC5cclxuICAgICAgICBmb3IgKGNvbnN0IHByb21wdF9maWVsZCBvZiB0aGlzLnByb21wdF9maWVsZHMpIHtcclxuICAgICAgICAgICAgaWYgKCFwcm9tcHRfZmllbGQuY29uZmlndXJhdGlvbi50YXJnZXRfdmFyaWFibGVfaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQ2Fubm90IG9wZW4gcHJvbXB0ICcke3RoaXMuZ2V0VGl0bGUoKX0nOiBGaWVsZCAnJHtwcm9tcHRfZmllbGQuZ2V0VGl0bGUoKX0nIGRvZXMgbm90IGhhdmUgYSB0YXJnZXQgdmFyaWFibGUuYDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0X2ZpZWxkLmdldFRhcmdldFZhcmlhYmxlSW5zdGFuY2UoKTsgLy8gSnVzdCB0cnkgdG8gZ2V0IGEgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZS4gTm8gbmVlZCB0byB1c2UgaXQgaGVyZSwgYnV0IGlmIHRoaXMgZmFpbHMsIHdlIGtub3cgdGhlIHZhcmlhYmxlIGlzIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgQ2Fubm90IG9wZW4gcHJvbXB0ICcke3RoaXMuZ2V0VGl0bGUoKX0nOiBGaWVsZCAnJHtwcm9tcHRfZmllbGQuZ2V0VGl0bGUoKX0nIHVzZXMgYSB0YXJnZXQgdmFyaWFibGUgd2hpY2ggZG9lcyBub3QgZXhpc3QgYW55bW9yZS5gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGwgb2suXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIFByb21wdEZpZWxkIGluc3RhbmNlcywgTk9UIHNldHRpbmcgZmllbGRzIVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZUZpZWxkcygpIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkNyZWF0aW5nIGZpZWxkcyBmb3IgUHJvbXB0IFwiICsgdGhpcy5nZXRJRCgpKTtcclxuICAgICAgICBjb25zdCBwcm9tcHRfZmllbGRfbW9kZWwgPSBnZXRNb2RlbDxQcm9tcHRGaWVsZE1vZGVsPihQcm9tcHRGaWVsZE1vZGVsLm5hbWUpO1xyXG4gICAgICAgIHRoaXMucHJvbXB0X2ZpZWxkcyA9IHByb21wdF9maWVsZF9tb2RlbC5sb2FkSW5zdGFuY2VzKHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgdmFsdWVzIGluIFByb21wdEZpZWxkIGluc3RhbmNlcywgTk9UIHNldHRpbmcgZmllbGRzIVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlRmllbGRzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwiVmFsaWRhdGluZyBmaWVsZHMgZm9yIFByb21wdCBcIiArIHRoaXMuZ2V0SUQoKSk7XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGUgYWxsIGZpZWxkcyBhbmQgY2hlY2sgdGhlaXIgdmFsaWRpdHkuXHJcbiAgICAgICAgY29uc3QgZXJyb3JfbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgdGhpcy5wcm9tcHRfZmllbGRzLmZvckVhY2goKHByb21wdF9maWVsZDogUHJvbXB0RmllbGQpID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaWVsZCBoYXMgcGFyc2luZyBlcnJvcnMuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNpbmdfZXJyb3JzOiBzdHJpbmdbXSA9IHByb21wdF9maWVsZC5nZXRQYXJzaW5nRXJyb3JzKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyc2luZ19lcnJvciBvZiBwYXJzaW5nX2Vycm9ycykge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmaWVsZCBoYXMgcGFyc2luZyBlcnJvcihzKS5cclxuICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzLnB1c2goYCcke3Byb21wdF9maWVsZC5nZXRUaXRsZSgpfSc6IGAgKyBwYXJzaW5nX2Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgb3RoZXIgdmFsaWRpdHkuXHJcbiAgICAgICAgICAgIGlmICghcHJvbXB0X2ZpZWxkLnZhbGlkYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmllbGQgZmFpbGVkIHRvIHZhbGlkYXRlLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgc28gdGhhdCB0aGUgbWVzc2FnZSB3aWxsIGNvbWUgZnJvbSBwcm9tcHRfZmllbGQudmFsaWRhdGUoKS5cclxuICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzLnB1c2goYCcke3Byb21wdF9maWVsZC5nZXRUaXRsZSgpfScgbmVlZHMgdG8gYmUgZmlsbGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0LlxyXG4gICAgICAgIGlmICgwID09PSBlcnJvcl9tZXNzYWdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl9tZXNzYWdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBwcmV2aWV3aW5nIGEgUHJvbXB0TW9kYWwsIHRoZXJlIGlzIG5vIHJlYWwgc2hlbGwgY29tbWFuZCBhdmFpbGFibGUgKGJlY2F1c2Ugbm8gc2hlbGwgY29tbWFuZCBoYXMgdHJpZ2dlcmVkIHRoZVxyXG4gICAgICogUHJvbXB0TW9kYWwpLiBUaGlzIG1ldGhvZCBjcmVhdGVzIGp1c3QgYSBkdW1teSBzaGVsbCBjb21tYW5kIHN0cmluZyB0aGF0IGltaXRhdGVzIGEgY29tbWFuZCB0aGF0IHdvdWxkIGVjaG8gdmFyaWFibGUgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXhhbXBsZVNoZWxsQ29tbWFuZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlX25hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvbXB0X2ZpZWxkIG9mIHRoaXMucHJvbXB0X2ZpZWxkcykge1xyXG4gICAgICAgICAgICB2YXJpYWJsZV9uYW1lcy5wdXNoKHByb21wdF9maWVsZC5nZXRUYXJnZXRWYXJpYWJsZUluc3RhbmNlKCkuZ2V0RnVsbE5hbWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcImVjaG8gXCIrdmFyaWFibGVfbmFtZXMuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvbXB0Q29uZmlndXJhdGlvbiB7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgICBwcmV2aWV3X3NoZWxsX2NvbW1hbmQ6IGJvb2xlYW47XHJcbiAgICBmaWVsZHM6IFByb21wdEZpZWxkQ29uZmlndXJhdGlvbltdO1xyXG4gICAgZXhlY3V0ZV9idXR0b25fdGV4dDogc3RyaW5nO1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19Nb2RhbH0gZnJvbSBcIi4uLy4uL1NDX01vZGFsXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kUGFyc2luZ1Byb2Nlc3MsIFRTaGVsbENvbW1hbmR9IGZyb20gXCIuLi8uLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtTZXR0aW5nfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge2NyZWF0ZU11bHRpbGluZVRleHRFbGVtZW50fSBmcm9tIFwiLi4vLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7VmFyaWFibGUsIFZhcmlhYmxlVmFsdWVSZXN1bHR9IGZyb20gXCIuLi8uLi92YXJpYWJsZXMvVmFyaWFibGVcIjtcclxuaW1wb3J0IHtcclxuICAgIFByb21wdCxcclxuICAgIFByb21wdEZpZWxkLFxyXG4gICAgUHJvbXB0RmllbGRTZXQsXHJcbn0gZnJvbSBcIi4uLy4uL2ltcG9ydHNcIjtcclxuaW1wb3J0IHtcclxuICAgIHBhcnNlVmFyaWFibGVzLFxyXG4gICAgUGFyc2luZ1Jlc3VsdCxcclxufSBmcm9tIFwiLi4vLi4vdmFyaWFibGVzL3BhcnNlVmFyaWFibGVzXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvbXB0TW9kYWwgZXh0ZW5kcyBTQ19Nb2RhbCB7XHJcblxyXG4gICAgcHVibGljIHByb21pc2U6IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgICBwcml2YXRlIHVzZXJfY29uZmlybWVkX29rID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIHJlc29sdmVfcHJvbWlzZTogKHZhbHVlOiAoYm9vbGVhbiB8IFByb21pc2VMaWtlPGJvb2xlYW4+KSkgPT4gdm9pZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHByb21wdF9maWVsZHM6IFByb21wdEZpZWxkU2V0LFxyXG4gICAgICAgIC8qKiBDYW4gYmUgbnVsbCwgaWYgd2FudGVkIHRvIGp1c3QgcHJldmlldyB0aGUgUHJvbXB0IG1vZGFsIHdpdGhvdXQgcmVhbGx5IGV4ZWN1dGluZyBhIHNoZWxsIGNvbW1hbmQuIElucHV0dGVkIHZhbHVlcyB3aWxsIHN0aWxsIGJlIGFzc2lnbmVkIHRvIHRhcmdldCB2YXJpYWJsZXMuICovXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQgfCBudWxsLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgcGFyc2luZ19wcm9jZXNzOiBTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcyB8IG51bGwsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBwcm9tcHQ6IFByb21wdCxcclxuICAgICAgICBwcml2YXRlIHNjX2V2ZW50OiBTQ19FdmVudCB8IG51bGwsXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIGNsaWNrcyB0aGUgZXhlY3V0aW9uIGJ1dHRvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgY2hlY2sgdGhlIGZvcm0gZWxlbWVudHMnIHZhbGlkaXR5IGFuZCByZXR1cm4gZmFsc2UgaWYgdGhlcmUgYXJlIHVuZmlsbGVkIGZpZWxkcy4gKi9cclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHZhbGlkYXRvcjogKCkgPT4gUHJvbWlzZTx2b2lkPixcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlX3Byb21pc2UgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKCk7XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIGFuZCBkaXNwbGF5IHRpdGxlXHJcbiAgICAgICAgY29uc3QgdGl0bGVfcGFyc2luZ19yZXN1bHQgPSBhd2FpdCBwYXJzZVZhcmlhYmxlcyh0aGlzLnBsdWdpbiwgdGhpcy5wcm9tcHQuZ2V0VGl0bGUoKSwgbnVsbCwgdGhpcy50X3NoZWxsX2NvbW1hbmQsIHRoaXMuc2NfZXZlbnQpO1xyXG4gICAgICAgIHRoaXMuc2V0VGl0bGUoXHJcbiAgICAgICAgICAgIHRpdGxlX3BhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZFxyXG4gICAgICAgICAgICA/IHRpdGxlX3BhcnNpbmdfcmVzdWx0LnBhcnNlZF9jb250ZW50XHJcbiAgICAgICAgICAgIDogdGl0bGVfcGFyc2luZ19yZXN1bHQub3JpZ2luYWxfY29udGVudFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIGFuZCBkaXNwbGF5IGRlc2NyaXB0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMucHJvbXB0LmNvbmZpZ3VyYXRpb24uZGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb25fcGFyc2luZ19yZXN1bHQ6IFBhcnNpbmdSZXN1bHQgPSBhd2FpdCBwYXJzZVZhcmlhYmxlcyh0aGlzLnBsdWdpbiwgdGhpcy5wcm9tcHQuY29uZmlndXJhdGlvbi5kZXNjcmlwdGlvbiwgbnVsbCwgdGhpcy50X3NoZWxsX2NvbW1hbmQsIHRoaXMuc2NfZXZlbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9XHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbl9wYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWRcclxuICAgICAgICAgICAgICAgID8gZGVzY3JpcHRpb25fcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnRcclxuICAgICAgICAgICAgICAgIDogZGVzY3JpcHRpb25fcGFyc2luZ19yZXN1bHQub3JpZ2luYWxfY29udGVudFxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uX2VsZW1lbnQgPSBjcmVhdGVNdWx0aWxpbmVUZXh0RWxlbWVudChcInBcIiwgZGVzY3JpcHRpb24sIHRoaXMubW9kYWxFbCk7XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uX2VsZW1lbnQuYWRkQ2xhc3MoXCJzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb25cIik7IC8vIEEgQ1NTIGNsYXNzIGRlZmluZWQgYnkgT2JzaWRpYW4uXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2aWV3IHRoZSBzaGVsbCBjb21tYW5kIChpZiB3YW50ZWQpXHJcbiAgICAgICAgLy8gVE9ETzogRXh0cmFjdCB0byBhIHNlcGFyYXRlIG1ldGhvZCwgYXMgdGhpcyBpcyBhIGJpZyBibG9jayBvZiBjb2RlLlxyXG4gICAgICAgIGxldCB1cGRhdGVfc2hlbGxfY29tbWFuZF9wcmV2aWV3OiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDsgLy8gU3RheXMgbnVsbCBpZiAucHJldmlld19zaGVsbF9jb21tYW5kIGlzIGZhbHNlLlxyXG4gICAgICAgIGxldCBmb2N1c2VkX3Byb21wdF9maWVsZDogUHJvbXB0RmllbGQgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvbXB0LmdldENvbmZpZ3VyYXRpb24oKS5wcmV2aWV3X3NoZWxsX2NvbW1hbmQpIHtcclxuICAgICAgICAgICAgbGV0IHNoZWxsX2NvbW1hbmRfcHJldmlld190ZXh0OiBzdHJpbmc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZD8uZ2V0QWxpYXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSwgYXR0cjoge2NsYXNzOiBcIlNDLW5vLW1hcmdpblwifX0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgXCJTaG93IHZhcmlhYmxlIHZhbHVlc1wiIHRvZ2dsZVxyXG4gICAgICAgICAgICBsZXQgcHJldmlld192YXJpYWJsZV92YWx1ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZV9uYW1lc192aXNpYmxlX2ljb24gPSBcImNvZGUtZ2x5cGhcIjtcclxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVfdmFsdWVzX3Zpc2libGVfZ2x5cGggPSBcInByaWNlLXRhZy1nbHlwaFwiO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aWV3X3ZhcmlhYmxlX3ZhbHVlc19zZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbih2YXJpYWJsZV92YWx1ZXNfdmlzaWJsZV9nbHlwaClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIlRvZ2dsZSBzaG93aW5nIHZhcmlhYmxlIG5hbWVzIG9yIHZhbHVlcy5cIilcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdfdmFyaWFibGVfdmFsdWVzID0gIXByZXZpZXdfdmFyaWFibGVfdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0SWNvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdfdmFyaWFibGVfdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhcmlhYmxlX3ZhbHVlc192aXNpYmxlX2dseXBoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhcmlhYmxlX25hbWVzX3Zpc2libGVfaWNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZV9zaGVsbF9jb21tYW5kX3ByZXZpZXcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVjaWRlIHdoYXQgdGV4dCB0byB1c2UgaW4gdGhlIHByZXZpZXdcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2luZ19wcm9jZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG93IGEgcmVhbCBzaGVsbCBjb21tYW5kLiBVc2UgcHJlcGFyc2VkIGNvbnRlbnQgKD0gY29udGVudCB0aGF0IG1pZ2h0IGhhdmUgc29tZSB2YXJpYWJsZXMgYWxyZWFkeSBwYXJzZWQpLlxyXG4gICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wcmV2aWV3X3RleHQgPSB0aGlzLnBhcnNpbmdfcHJvY2Vzcy5nZXRQYXJzaW5nUmVzdWx0cygpLnNoZWxsX2NvbW1hbmQucGFyc2VkX2NvbnRlbnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3cgYSByZWFsIHNoZWxsIGNvbW1hbmQuIE5vIHByZXBhcnNlZCBjb250ZW50IGlzIGF2YWlsYWJsZS4gVGhpcyBjb250ZW50IGRvZXMgbm90IGhhdmUgYW55IHZhcmlhYmxlcyBwYXJzZWQgeWV0LlxyXG4gICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wcmV2aWV3X3RleHQgPSB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRTaGVsbENvbW1hbmQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdXAgYSBmYWtlIFwic2hlbGwgY29tbWFuZFwiIGZvciBwcmV2aWV3aW5nLlxyXG4gICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wcmV2aWV3X3RleHQgPSB0aGlzLnByb21wdC5nZXRFeGFtcGxlU2hlbGxDb21tYW5kKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIihUaGlzIGlzIG5vdCBhIHJlYWwgc2hlbGwgY29tbWFuZCwgaXQncyBqdXN0IGFuIGV4YW1wbGUgZm9yIHRoaXMgcHJldmlldyB3aGVuIG5vIHJlYWwgc2hlbGwgY29tbWFuZCBpcyBhdmFpbGFibGUuKVwiLCBhdHRyOiB7Y2xhc3M6IFwiU0Mtbm8tbWFyZ2luIFNDLXNtYWxsLWZvbnRcIn19KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJoclwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHByZXZpZXcgdGV4dCB1cGRhdGVzLlxyXG4gICAgICAgICAgICB1cGRhdGVfc2hlbGxfY29tbWFuZF9wcmV2aWV3ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNoZWxsX2NvbW1hbmRfcHJldmlld190ZXh0X2ZpbmFsID0gc2hlbGxfY29tbWFuZF9wcmV2aWV3X3RleHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlld192YXJpYWJsZV92YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJldmlldyBzaG91bGQgc2hvdyB0aGUgVkFMVUVTLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZvcm0gZmllbGRzIGRvIG5vdCBjb250YWluIGFueSBwYXJzaW5nIGVycm9ycy4gKElmIHRoZXJlIGFyZSBlcnJvcnMsIGFuIHVucGFyc2VkIHByZXZpZXcgdGV4dCB3aWxsIGJlIHNob3duKS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQcm9tcHRGaWVsZHNQYXJzaW5nRXJyb3JzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBmaWVsZHMgYXJlIHBhcnNlZCBvayAoPSBpbmRpdmlkdWFsIHBhcnNpbmcpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIGZpZWxkIHZhbHVlcyBpbnRvIHRoZSBzaGVsbCBjb21tYW5kIHByZXZpZXcgYnkgcGFyc2luZyB0aGUgcHJldmlldyB0ZXh0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgdmFsdWVzIGZyb20gdGhlIHByb21wdCBmaWVsZHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyZXNoX3ZhbHVlcyA9IHRoaXMuZ2V0UHJvbXB0RmllbGRzVmFsdWVzKCk7IC8vIFRoZXNlIFByb21wdEZpZWxkIHZhbHVlcyBhcmUgZnJlc2gsIHNvIG5vdCB5ZXQgc3RvcmVkIGluIHRoZSBhY3R1YWwgdmFyaWFibGVzLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHZhcmlhYmxlcyBpbiB0aGUgc2hlbGwgY29tbWFuZCBwcmV2aWV3IHRleHQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNpbmdfcmVzdWx0ID0gYXdhaXQgcGFyc2VWYXJpYWJsZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfcHJldmlld190ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTaGVsbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjX2V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCAvLyBVc2UgYWxsIHZhcmlhYmxlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YXJpYWJsZTogVmFyaWFibGUsIHJhd192YWx1ZTogVmFyaWFibGVWYWx1ZVJlc3VsdCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmVzaF92YWx1ZXMuaGFzKHZhcmlhYmxlLnZhcmlhYmxlX25hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgdmFsdWUgdG8gdGhlIG9uZSBpbiB0aGUgcHJvbXB0IGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdfdmFsdWUuZXJyb3JfbWVzc2FnZXMgPSBbXTsgLy8gUmVtb3ZlIGFueSBwb3NzaWJsZSBlcnJvciBtZXNzYWdlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3X3ZhbHVlLnN1Y2NlZWRlZCA9IHRydWU7IC8vIFRoaXMgbmVlZHMgdG8gcmVmbGVjdCB0aGF0IHRoZXJlIGFyZSBubyBlcnJvciBtZXNzYWdlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3X3ZhbHVlLnZhbHVlID0gZnJlc2hfdmFsdWVzLmdldCh2YXJpYWJsZS52YXJpYWJsZV9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gbW9kaWZpY2F0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFyaWFibGU6IFZhcmlhYmxlLCBlc2NhcGVkX3ZhbHVlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtcGhhc2l6ZSB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIGN1cnJlbnRseSBmb2N1c2VkIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkX3Byb21wdF9maWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUudmFyaWFibGVfbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBmb2N1c2VkX3Byb21wdF9maWVsZC5nZXRUYXJnZXRWYXJpYWJsZUluc3RhbmNlKCkuZ2V0UHJlZml4ZWROYW1lKCkudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgdmFsdWUgYm9sZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPHN0cm9uZz4ke2VzY2FwZWRfdmFsdWV9PC9zdHJvbmc+YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBtb2RpZmljYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVkX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wcmV2aWV3X3RleHRfZmluYWwgPSBwYXJzaW5nX3Jlc3VsdC5wYXJzZWRfY29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZXZpZXcgc2hvdWxkIHNob3cgdGhlIFZBUklBQkxFIE5BTUVTLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkX3Byb21wdF9maWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChmb2N1c2VkX3Byb21wdF9maWVsZC5nZXRUYXJnZXRWYXJpYWJsZSgpLmdldFBhdHRlcm4oKSwgXCJpZ3VcIik7IC8vIGk6IGNhc2UtaW5zZW5zaXRpdmU7IGc6IG1hdGNoIGFsbCBvY2N1cnJlbmNlcyBpbnN0ZWFkIG9mIGp1c3QgdGhlIGZpcnN0IG9uZS4gdTogc3VwcG9ydCA0LWJ5dGUgdW5pY29kZSBjaGFyYWN0ZXJzIHRvby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wcmV2aWV3X3RleHRfZmluYWwgPSBzaGVsbF9jb21tYW5kX3ByZXZpZXdfdGV4dF9maW5hbC5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXBsYWNlYWJsZV92YXJpYWJsZV9uYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz5cIiArIHJlcGxhY2VhYmxlX3ZhcmlhYmxlX25hbWUgKyBcIjwvc3Ryb25nPlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2aWV3X3ZhcmlhYmxlX3ZhbHVlc19zZXR0aW5nLmRlc2NFbC5pbm5lckhUTUwgPSBzaGVsbF9jb21tYW5kX3ByZXZpZXdfdGV4dF9maW5hbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBmaWVsZHNcclxuICAgICAgICBsZXQgaXNfZmlyc3RfZmllbGQgPSB0cnVlO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvbXB0X2ZpZWxkIG9mIHRoaXMucHJvbXB0X2ZpZWxkcykge1xyXG4gICAgICAgICAgICBhd2FpdCBwcm9tcHRfZmllbGQuY3JlYXRlRmllbGQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRGl2KHthdHRyOiB7Y2xhc3M6IFwiU0Mtc2V0dGluZy1ncm91cFwifX0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjX2V2ZW50XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGVfc2hlbGxfY29tbWFuZF9wcmV2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9tcHRfZmllbGQub25DaGFuZ2UodXBkYXRlX3NoZWxsX2NvbW1hbmRfcHJldmlldyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvbXB0X2ZpZWxkLm9uRm9jdXMoKHByb21wdF9maWVsZDogUHJvbXB0RmllbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGZvY3VzZWRfcHJvbXB0X2ZpZWxkID0gcHJvbXB0X2ZpZWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZV9zaGVsbF9jb21tYW5kX3ByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVfc2hlbGxfY29tbWFuZF9wcmV2aWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNfZmlyc3RfZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZvY3VzIG9uIHRoZSBmaXJzdCBmaWVsZC5cclxuICAgICAgICAgICAgICAgIGlzX2ZpcnN0X2ZpZWxkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBwcm9tcHRfZmllbGQuc2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXBkYXRlX3NoZWxsX2NvbW1hbmRfcHJldmlldykge1xyXG4gICAgICAgICAgICAvLyBTZXQgYSBwcmV2aWV3IHRleHQuIE11c3QgYmUgZG9uZSBhZnRlciBmaWVsZHMgYXJlIGNyZWF0ZWQsIGJlY2F1c2UgdGhlaXIgdmFsdWVzIGFyZSBhY2Nlc3NlZC5cclxuICAgICAgICAgICAgdXBkYXRlX3NoZWxsX2NvbW1hbmRfcHJldmlldygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGlwIGFib3V0IHZhcmlhYmxlc1xyXG4gICAgICAgIGxldCB0aXAgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLnByb21wdF9maWVsZHMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogV2hlbiBpbXBsZW1lbnRpbmcgZGlmZmVyZW50IGZpZWxkIHR5cGVzLCBhZGQgYSBjaGVjayB0aGF0IHRoZSB0aXAgaXMgb25seSBzaG93biB3aGVuIHRoZXJlIGFyZSB0ZXh0L251bWVyaWMgZmllbGRzIHByZXNlbnQuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgdGlwIGlmIHRoaXMgbW9kYWwgYWN0dWFsbHkgY29udGFpbnMgZmllbGRzLiBQcm9tcHRzIGNhbiBhbHNvIGJlIHVzZWQgYXMgY3VzdG9tICdjb25maXJtYXRpb24gcHJvbXB0cycgd2l0aG91dCBhbnkgZmllbGRzLlxyXG4gICAgICAgICAgICB0aXAgPSBcIlRpcCEgWW91IGNhbiB1c2Uge3t2YXJpYWJsZXN9fSBpbiB0ZXh0IGZpZWxkcy5cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGUgYnV0dG9uXHJcbiAgICAgICAgY29uc3QgZXhlY3V0ZV9idXR0b25fdGV4dF9wYXJzaW5nX3Jlc3VsdCA9IGF3YWl0IHBhcnNlVmFyaWFibGVzKHRoaXMucGx1Z2luLCB0aGlzLnByb21wdC5jb25maWd1cmF0aW9uLmV4ZWN1dGVfYnV0dG9uX3RleHQsIG51bGwsIHRoaXMudF9zaGVsbF9jb21tYW5kLCB0aGlzLnNjX2V2ZW50KTtcclxuICAgICAgICBjb25zdCBleGVjdXRlX2J1dHRvbl90ZXh0ID1cclxuICAgICAgICAgICAgZXhlY3V0ZV9idXR0b25fdGV4dF9wYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWRcclxuICAgICAgICAgICAgPyBleGVjdXRlX2J1dHRvbl90ZXh0X3BhcnNpbmdfcmVzdWx0LnBhcnNlZF9jb250ZW50XHJcbiAgICAgICAgICAgIDogZXhlY3V0ZV9idXR0b25fdGV4dF9wYXJzaW5nX3Jlc3VsdC5vcmlnaW5hbF9jb250ZW50XHJcbiAgICAgICAgO1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKHRoaXMubW9kYWxFbClcclxuICAgICAgICAgICAgLnNldERlc2ModGlwKVxyXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KGV4ZWN1dGVfYnV0dG9uX3RleHQpXHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB0aGlzLmFwcHJvdmUoKSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRfc2hlbGxfY29tbWFuZCkge1xyXG4gICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGlzIGlzIGEgcHJldmlldyBvbmx5IFByb21wdC5cclxuICAgICAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogYFRoaXMgaXMgYSBwcmV2aWV3IHByb21wdC4gTm8gc2hlbGwgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkLCBidXQgY2xpY2tpbmcgdGhlICcke3RoaXMucHJvbXB0LmNvbmZpZ3VyYXRpb24uZXhlY3V0ZV9idXR0b25fdGV4dH0nIGJ1dHRvbiB3aWxsIHN0aWxsIHN0b3JlIHRoZSBpbnB1dHRlZCB2YWx1ZShzKSB0byB2YXJpYWJsZShzKS5gfSkuYWRkQ2xhc3MoXCJTQy1wcm9tcHQtZHJ5LXJ1bi1ub3RpY2VcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgQ1NTIGNsYXNzZXMgc28gdGhhdCBjdXN0b20gc3R5bGluZyBjYW4gYmUgZG9uZSBvbiBhIHBlci1wcm9tcHQgbW9kYWwgYmFzaXMgKG9yIGZvciBhbGwgcHJvbXB0IG1vZGFscyB2aWEgYSBjb21tb24gY2xhc3MpLlxyXG4gICAgICAgIHRoaXMubW9kYWxFbC5hZGRDbGFzc2VzKHRoaXMucHJvbXB0LmdldENTU0NsYXNzZXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFwcHJvdmUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IoKS50aGVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gVGhlIGZvcm0gZmllbGRzIGFyZSBmaWxsZWQgb2tcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NpZ25WYWx1ZXNUb1ZhcmlhYmxlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVfcHJvbWlzZSh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy51c2VyX2NvbmZpcm1lZF9vayA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9LCAoZXJyb3JfbWVzc2FnZXM6IHN0cmluZ1tdIHwgdW5rbm93bikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcl9tZXNzYWdlcykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgc29tZSBwcm9ibGVtcyB3aXRoIHRoZSBmaWVsZHMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcnMoZXJyb3JfbWVzc2FnZXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZSBvdGhlciBydW50aW1lIGVycm9yIGhhcyBvY2N1cnJlZC5cclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yX21lc3NhZ2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZSgpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudXNlcl9jb25maXJtZWRfb2spIHsgLy8gVE9ETzogRmluZCBvdXQgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbm90IHVzZSB0aGlzIGtpbmQgb2YgZmxhZyBwcm9wZXJ0eS4gQ2FuIHRoZSBzdGF0dXMgYmUgY2hlY2tlZCBmcm9tIHRoZSBwcm9taXNlIGl0c2VsZj9cclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlX3Byb21pc2UoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGFzc2lnblZhbHVlc1RvVmFyaWFibGVzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvbXB0X2ZpZWxkIG9mIHRoaXMucHJvbXB0X2ZpZWxkcykge1xyXG4gICAgICAgICAgICBhd2FpdCBwcm9tcHRfZmllbGQuZ2V0VGFyZ2V0VmFyaWFibGUoKS5zZXRWYWx1ZShwcm9tcHRfZmllbGQuZ2V0UGFyc2VkVmFsdWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2F0aGVycyBhIE1hcCBvZiB2YXJpYWJsZSB2YWx1ZXMgdHlwZWQgaW4gdGhlIGZvcm0sIGJ1dCBkb2VzIG5vdCBzdG9yZSB0aGUgdmFsdWVzIGludG8gdGhlIHZhcmlhYmxlcy4gQ2FsbGVkIHdoZW5cclxuICAgICAqIGdlbmVyYXRpbmcgYSBwcmV2aWV3IHRleHQsIHNvIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2Qgd2lsbCBub3QgcGVyc2lzdCBpbiBhbnkgd2F5LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9tcHRGaWVsZHNWYWx1ZXMoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb21wdF9maWVsZCBvZiB0aGlzLnByb21wdF9maWVsZHMpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnNldChwcm9tcHRfZmllbGQuZ2V0VGFyZ2V0VmFyaWFibGUoKS52YXJpYWJsZV9uYW1lLCBwcm9tcHRfZmllbGQuZ2V0UGFyc2VkVmFsdWUoKSA/PyBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFByb21wdEZpZWxkc1BhcnNpbmdFcnJvcnMoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2luZ19lcnJvcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9tcHRfZmllbGQgb2YgdGhpcy5wcm9tcHRfZmllbGRzKSB7XHJcbiAgICAgICAgICAgIHBhcnNpbmdfZXJyb3JzLnB1c2goLi4ucHJvbXB0X2ZpZWxkLmdldFBhcnNpbmdFcnJvcnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzaW5nX2Vycm9ycztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFNoZWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVhbCB1c2FnZSBvZiB0aGUgUHJvbXB0TW9kYWwsIHNvIGEgVFNoZWxsQ29tbWFuZCBpcyBhdmFpbGFibGUuIExvb2sgdXAgdGhlIHNoZWxsIGZyb20gdGhhdC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldFNoZWxsKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSnVzdCB0cnlpbmcgdGhlIFByb21wdE1vZGFsLiBKdXN0IHVzZSBzb21lIHNoZWxsIGZvciB2YXJpYWJsZSBlc2NhcGluZyBpbiBhbiBleGFtcGxlIHByZXZpZXcuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5nZXREZWZhdWx0U2hlbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gICAgZ2V0SURHZW5lcmF0b3IsXHJcbiAgICBNb2RlbCxcclxuICAgIFBhcmVudE1vZGVsT25lVG9NYW55SWRSZWxhdGlvbixcclxuICAgIFByZWFjdGlvbl9Qcm9tcHRfQ29uZmlndXJhdGlvbixcclxuICAgIFByb21wdCxcclxuICAgIFByb21wdENvbmZpZ3VyYXRpb24sXHJcbiAgICBQcm9tcHRTZXR0aW5nc01vZGFsLFxyXG59IGZyb20gXCIuLi8uLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7U2V0dGluZ30gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7U0NfTWFpblNldHRpbmdzfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3MvU0NfTWFpblNldHRpbmdzXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi8uLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFByb21wdE1vZGVsIGV4dGVuZHMgTW9kZWwge1xyXG5cclxuICAgIHByaXZhdGUgcHJvbXB0cyA9IG5ldyBQcm9tcHRNYXAoKTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0U2luZ3VsYXJOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiUHJvbXB0XCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGRlZmluZVBhcmVudENvbmZpZ3VyYXRpb25SZWxhdGlvbihwcm9tcHQ6IFByb21wdCk6IFBhcmVudE1vZGVsT25lVG9NYW55SWRSZWxhdGlvbiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogXCJvbmUtdG8tbWFueS1pZFwiLFxyXG4gICAgICAgICAgICBrZXk6IFwicHJvbXB0c1wiLFxyXG4gICAgICAgICAgICBpZDogcHJvbXB0LmdldElEKCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbG9hZEluc3RhbmNlcyhwYXJlbnRfY29uZmlndXJhdGlvbjogU0NfTWFpblNldHRpbmdzKTogUHJvbXB0TWFwIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkxvYWRpbmcgUHJvbXB0IGluc3RhbmNlcy5cIik7XHJcbiAgICAgICAgdGhpcy5wcm9tcHRzID0gbmV3IFByb21wdE1hcCgpO1xyXG4gICAgICAgIHBhcmVudF9jb25maWd1cmF0aW9uLnByb21wdHMuZm9yRWFjaCgocHJvbXB0X2NvbmZpZ3VyYXRpb246IFByb21wdENvbmZpZ3VyYXRpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbXB0OiBQcm9tcHQgPSBuZXcgUHJvbXB0KHRoaXMsIHRoaXMucGx1Z2luLCBwcm9tcHRfY29uZmlndXJhdGlvbiwgcGFyZW50X2NvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnByb21wdHMuc2V0KHByb21wdF9jb25maWd1cmF0aW9uLmlkLCBwcm9tcHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb21wdHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5ld0luc3RhbmNlKHBhcmVudF9jb25maWd1cmF0aW9uOiBTQ19NYWluU2V0dGluZ3MpOiBQcm9tcHQge1xyXG4gICAgICAgIGRlYnVnTG9nKFwiQ3JlYXRpbmcgYSBuZXcgUHJvbXB0IGluc3RhbmNlLlwiKTtcclxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgbG9naWMgdG8gdGhlIGJhc2UgTW9kZWwgY2xhc3MuXHJcblxyXG4gICAgICAgIC8vIFNldHVwIGEgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFuZCBnZW5lcmF0ZSBhbiBJRFxyXG4gICAgICAgIGNvbnN0IHByb21wdF9jb25maWd1cmF0aW9uID0gdGhpcy5fZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKTtcclxuXHJcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgYSBQcm9tcHRcclxuICAgICAgICBjb25zdCBwcm9tcHQgPSBuZXcgUHJvbXB0KHRoaXMsIHRoaXMucGx1Z2luLCBwcm9tcHRfY29uZmlndXJhdGlvbiwgdGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMucHJvbXB0cy5zZXQocHJvbXB0LmdldElEKCksIHByb21wdCk7XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBjb25maWd1cmF0aW9uIGludG8gcGx1Z2luJ3Mgc2V0dGluZ3NcclxuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9tcHRzLnB1c2gocHJvbXB0X2NvbmZpZ3VyYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIFByb21wdFxyXG4gICAgICAgIHJldHVybiBwcm9tcHQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfY3JlYXRlU2V0dGluZ0ZpZWxkcyhwcm9tcHQ6IFByb21wdCwgY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KTogU2V0dGluZyB7XHJcbiAgICAgICAgZGVidWdMb2coXCJDcmVhdGluZyBzZXR0aW5nIGZpZWxkcyBmb3IgYSBQcm9tcHQgaW5zdGFuY2UuXCIpO1xyXG4gICAgICAgIGNvbnN0IHByb21wdF9uYW1lX3NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBidXR0b25cclxuICAgICAgICAgICAgLnNldE5hbWUocHJvbXB0LmdldFRpdGxlKCkpXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkRlZmluZSBwcm9tcHQgZmllbGRzXCIpXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImdlYXJcIilcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5TZXR0aW5nc01vZGFsKHByb21wdCwgcHJvbXB0X25hbWVfc2V0dGluZyk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4gcHJvbXB0X25hbWVfc2V0dGluZztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGVWYWx1ZShwcm9tcHQ6IFByb21wdCwgZmllbGQ6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBub3QgdXNlZCwgc28gaXQgY2FuIGp1c3QgcmVzb2x2ZSBhbGwgdGhlIHRpbWUuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVuU2V0dGluZ3NNb2RhbChwcm9tcHQ6IFByb21wdCwgcHJvbXB0X25hbWVfc2V0dGluZzogU2V0dGluZykge1xyXG4gICAgICAgIGRlYnVnTG9nKFwiT3BlbmluZyBzZXR0aW5ncyBtb2RhbCBmb3IgYSBQcm9tcHQgaW5zdGFuY2UuXCIpO1xyXG4gICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IFByb21wdFNldHRpbmdzTW9kYWwodGhpcy5wbHVnaW4sIHByb21wdCwgcHJvbXB0X25hbWVfc2V0dGluZyk7XHJcbiAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldERlZmF1bHRDb25maWd1cmF0aW9uKCk6IFByb21wdENvbmZpZ3VyYXRpb24ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBnZXRJREdlbmVyYXRvcigpLmdlbmVyYXRlSUQoKSxcclxuICAgICAgICAgICAgdGl0bGU6IFwiXCIsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICBwcmV2aWV3X3NoZWxsX2NvbW1hbmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBmaWVsZHM6IFtdLFxyXG4gICAgICAgICAgICBleGVjdXRlX2J1dHRvbl90ZXh0OiBcIkV4ZWN1dGVcIixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZGVsZXRlSW5zdGFuY2UocHJvbXB0OiBQcm9tcHQpOiB2b2lkIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkRlbGV0aW5nIGEgUHJvbXB0IGluc3RhbmNlLlwiKTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBQcm9tcHQgZnJvbSBhbGwgVFNoZWxsQ29tbWFuZHMgdGhhdCB1c2UgaXQuXHJcbiAgICAgICAgY29uc3Qgc2hlbGxfY29tbWFuZHMgPSB0aGlzLnBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9pZCBpbiBzaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgICAgICBjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVhY3Rpb25fY29uZmlndXJhdGlvbiBvZiB0X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLnByZWFjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcInByb21wdFwiID09PSBwcmVhY3Rpb25fY29uZmlndXJhdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlYWN0aW9uX3Byb21wdF9jb25maWd1cmF0aW9uID0gcHJlYWN0aW9uX2NvbmZpZ3VyYXRpb24gYXMgUHJlYWN0aW9uX1Byb21wdF9Db25maWd1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9tcHQuZ2V0SUQoKSA9PT0gcHJlYWN0aW9uX3Byb21wdF9jb25maWd1cmF0aW9uLnByb21wdF9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIFRTaGVsbENvbW1hbmQgdXNlcyB0aGlzIFByb21wdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBQcm9tcHQgZnJvbSB1c2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWFjdGlvbl9wcm9tcHRfY29uZmlndXJhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWFjdGlvbl9wcm9tcHRfY29uZmlndXJhdGlvbi5wcm9tcHRfaWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZC5yZXNldFByZWFjdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2aW5nIGlzIGRvbmUgbGF0ZXIsIGFmdGVyIHRoZSBfZGVsZXRlSW5zdGFuY2UoKSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wcm9tcHRzLmRlbGV0ZShwcm9tcHQuZ2V0SUQoKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9tcHRNYXAgZXh0ZW5kcyBNYXA8c3RyaW5nLCBQcm9tcHQ+IHt9IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldE1vZGVsLFxyXG4gICAgSW5zdGFuY2UsXHJcbiAgICBNb2RlbCxcclxufSBmcm9tIFwiLi4vaW1wb3J0c1wiO1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm4gUHJvbWlzZTxJbnN0YW5jZUNsYXNzPiBBIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIGlmIGEgdXNlciBjbGlja3MgdGhlIGJ1dHRvbi4gVGhlIHByb21pc2UgaXMgc3VwcGxpZWQgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9uPFxyXG4gICAgICAgIE1vZGVsQ2xhc3MgZXh0ZW5kcyBNb2RlbCxcclxuICAgICAgICBJbnN0YW5jZUNsYXNzIGV4dGVuZHMgSW5zdGFuY2UsXHJcbiAgICA+KFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIG1vZGVsX2NsYXNzX25hbWU6IHN0cmluZyxcclxuICAgICAgICBidXR0b25fY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LFxyXG4gICAgICAgIGluc3RhbmNlX2NvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCxcclxuICAgICAgICBwYXJlbnRfaW5zdGFuY2Vfb3JfY29uZmlndXJhdGlvbjogSW5zdGFuY2VDbGFzc1tcInBhcmVudF9jb25maWd1cmF0aW9uXCJdIHwgSW5zdGFuY2VDbGFzc1tcInBhcmVudF9pbnN0YW5jZVwiXVxyXG4gICAgKTogUHJvbWlzZTx7aW5zdGFuY2U6IEluc3RhbmNlQ2xhc3MsIG1haW5fc2V0dGluZzogU2V0dGluZ30+IHtcclxuXHJcbiAgICBkZWJ1Z0xvZyhcIkNyZWF0aW5nIGEgYnV0dG9uIGZvciBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZSBmb3IgbW9kZWwgXCIgKyBtb2RlbF9jbGFzc19uYW1lICsgXCIuXCIpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlX3Byb21pc2UpID0+IHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IGdldE1vZGVsPE1vZGVsQ2xhc3M+KG1vZGVsX2NsYXNzX25hbWUpO1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGJ1dHRvbl9jb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIk5ldyBcIiArIG1vZGVsLmdldFNpbmd1bGFyTmFtZSgpLnRvTG9jYWxlTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBtb2RlbC5uZXdJbnN0YW5jZShwYXJlbnRfaW5zdGFuY2Vfb3JfY29uZmlndXJhdGlvbikgYXMgSW5zdGFuY2VDbGFzcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYWluX3NldHRpbmcgPSBtb2RlbC5jcmVhdGVTZXR0aW5nRmllbGRzKGluc3RhbmNlLCBpbnN0YW5jZV9jb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZV9wcm9taXNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnN0YW5jZVwiOiBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYWluX3NldHRpbmdcIjogbWFpbl9zZXR0aW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfSk7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX01vZGFsfSBmcm9tIFwiLi4vLi4vU0NfTW9kYWxcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQge1xyXG4gICAgU2V0dGluZyxcclxuICAgIFRleHRBcmVhQ29tcG9uZW50LFxyXG4gICAgVGV4dENvbXBvbmVudCxcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtjcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9ufSBmcm9tIFwiLi4vY3JlYXRlTmV3TW9kZWxJbnN0YW5jZUJ1dHRvblwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0TW9kZWwsXHJcbiAgICBQcm9tcHQsXHJcbiAgICBQcm9tcHRGaWVsZCxcclxuICAgIFByb21wdEZpZWxkTW9kZWwsXHJcbn0gZnJvbSBcIi4uLy4uL2ltcG9ydHNcIjtcclxuaW1wb3J0IHtjcmVhdGVBdXRvY29tcGxldGV9IGZyb20gXCIuLi8uLi9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFByb21wdFNldHRpbmdzTW9kYWwgZXh0ZW5kcyBTQ19Nb2RhbCB7XHJcblxyXG4gICAgcHJpdmF0ZSBhcHByb3ZlZCA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvbXB0OiBQcm9tcHQsXHJcblxyXG4gICAgICAgIC8qKiBDYW4gYmUgdW5kZWZpbmVkIGlmIHRoZSBtb2RhbCBpcyBjcmVhdGVkIGZyb20gYSBwbGFjZSB3aGVyZSB0aGVyZSBpcyBubyBuYW1lIGVsZW1lbnQuICovXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBwcm9tcHRfbmFtZV9zZXR0aW5nPzogU2V0dGluZyxcclxuXHJcbiAgICAgICAgLyoqIElmIGRlZmluZWQsIGEgYnV0dG9uIHdpbGwgYmUgYWRkZWQgYW5kIG9uX2FmdGVyX2FwcHJvdmFsKCkgLyBvbl9hZnRlcl9jYW5jZWxsaW5nKCkgd2lsbCBiZSBjYWxsZWQgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGJ1dHRvbiB3YXMgY2xpY2tlZCBvciBub3QuICovXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBva19idXR0b25fdGV4dD86IHN0cmluZyxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IG9uX2FmdGVyX2FwcHJvdmFsPzogKCkgPT4gdm9pZCxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IG9uX2FmdGVyX2NhbmNlbGxpbmc/OiAoKSA9PiB2b2lkLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIocGx1Z2luKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLm9uT3BlbigpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcl9lbGVtZW50ID0gdGhpcy5tb2RhbEVsO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlX2FuZF9kZXNjcmlwdGlvbl9ncm91cF9lbGVtZW50ID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRGl2KHthdHRyOiB7Y2xhc3M6IFwiU0Mtc2V0dGluZy1ncm91cFwifX0pO1xyXG5cclxuICAgICAgICAvLyBUaXRsZVxyXG4gICAgICAgIGNvbnN0IHRpdGxlX3NldHRpbmcgPSBuZXcgU2V0dGluZyh0aXRsZV9hbmRfZGVzY3JpcHRpb25fZ3JvdXBfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJQcm9tcHQgdGl0bGVcIilcclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGljb24gPT4gaWNvblxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJUcnkgdGhlIHByb21wdCB3aXRob3V0IGV4ZWN1dGluZyBhbnkgc2hlbGwgY29tbWFuZC5cIilcclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKFwicnVuLWNvbW1hbmRcIilcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIkRyeSBydW5cIiB0aGUgUHJvbXB0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9tcHQub3BlblByb21wdChudWxsLCBudWxsLCBudWxsKS50aGVuKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucHJvbXB0LmdldFRpdGxlKCkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld190aXRsZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9tcHQuZ2V0Q29uZmlndXJhdGlvbigpLnRpdGxlID0gbmV3X3RpdGxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRpdGxlIGluIGEgbmFtZSBzZXR0aW5nLiAoT25seSBpZiB0aGUgbW9kYWwgd2FzIGNyZWF0ZWQgZnJvbSBhIHBsYWNlIHdoZXJlIGEgUHJvbXB0IG5hbWUgZWxlbWVudCBleGlzdHMpLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbXB0X25hbWVfc2V0dGluZz8uc2V0TmFtZShuZXdfdGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKCh0aXRsZV9zZXR0aW5nX2NvbXBvbmVudDogVGV4dENvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF1dG9jb21wbGV0ZSBmb3IgVGl0bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLnNob3dfYXV0b2NvbXBsZXRlX21lbnUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHRoaXMucGx1Z2luLCB0aXRsZV9zZXR0aW5nX2NvbXBvbmVudC5pbnB1dEVsLCAoKSA9PiB0aXRsZV9zZXR0aW5nX2NvbXBvbmVudC5vbkNoYW5nZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICAgICAgY29uc3QgdGl0bGVfaW5wdXRfZWxlbWVudDogSFRNTElucHV0RWxlbWVudCA9IHRpdGxlX3NldHRpbmcuY29udHJvbEVsLmZpbmQoXCJpbnB1dFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZvY3VzIG9uIHRoZSB0aXRsZSBmaWVsZC5cclxuICAgICAgICB0aXRsZV9pbnB1dF9lbGVtZW50LmZvY3VzKCk7XHJcblxyXG4gICAgICAgIC8vIERlc2NyaXB0aW9uXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGl0bGVfYW5kX2Rlc2NyaXB0aW9uX2dyb3VwX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiRGVzY3JpcHRpb25cIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJEaXNwbGF5ZWQgYmV0d2VlbiB0aGUgcHJvbXB0IHRpdGxlIGFuZCBmaWVsZHMuIEJvdGggRGVzY3JpcHRpb24gYW5kIFRpdGxlIHN1cHBvcnQge3t2YXJpYWJsZXN9fS5cIilcclxuICAgICAgICAgICAgLmFkZFRleHRBcmVhKHRleHRhcmVhID0+IHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wcm9tcHQuY29uZmlndXJhdGlvbi5kZXNjcmlwdGlvbilcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X2Rlc2NyaXB0aW9uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21wdC5nZXRDb25maWd1cmF0aW9uKCkuZGVzY3JpcHRpb24gPSBuZXdfZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRlc2NyaXB0aW9uX2NvbXBvbmVudDogVGV4dEFyZWFDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvY29tcGxldGUgZm9yIERlc2NyaXB0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUF1dG9jb21wbGV0ZSh0aGlzLnBsdWdpbiwgZGVzY3JpcHRpb25fY29tcG9uZW50LmlucHV0RWwsICgpID0+IGRlc2NyaXB0aW9uX2NvbXBvbmVudC5vbkNoYW5nZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFByZXZpZXcgc2hlbGwgY29tbWFuZFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIlByZXZpZXcgc2hlbGwgY29tbWFuZCBpbiBwcm9tcHRcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJJZiB0aGlzIGlzIG9uLCB0aGUgcHJvbXB0IHdpbGwgZGlzcGxheSB0aGUgZXhlY3V0YWJsZSBzaGVsbCBjb21tYW5kIHdpdGggdmFyaWFibGUgbmFtZXMgaW4gaXQsIGFuZCBoaWdobGlnaHQgdGhlIHZhcmlhYmxlKHMpIHRoYXQgd2lsbCBiZSBhZmZlY3RlZCBieSB0aGUgdmFsdWVzIGlucHV0dGVkIGluIHRoZSBwcm9tcHQuXCIpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucHJvbXB0LmdldENvbmZpZ3VyYXRpb24oKS5wcmV2aWV3X3NoZWxsX2NvbW1hbmQpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld192YWx1ZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbXB0LmdldENvbmZpZ3VyYXRpb24oKS5wcmV2aWV3X3NoZWxsX2NvbW1hbmQgPSBuZXdfdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gRmllbGRzXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiRmllbGRzXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVGlwISBZb3UgY2FuIHVzZSB7e3ZhcmlhYmxlc319IGluICdGaWVsZCBsYWJlbCcsICdEZWZhdWx0IHZhbHVlJyBhbmQgJ0Rlc2NyaXB0aW9uJy5cIilcclxuICAgICAgICA7XHJcbiAgICAgICAgY29uc3QgcHJvbXB0X2ZpZWxkX21vZGVsID0gZ2V0TW9kZWw8UHJvbXB0RmllbGRNb2RlbD4oUHJvbXB0RmllbGRNb2RlbC5uYW1lKTtcclxuICAgICAgICBjb25zdCBmaWVsZHNfY29udGFpbmVyID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRGl2KCk7XHJcbiAgICAgICAgdGhpcy5wcm9tcHQucHJvbXB0X2ZpZWxkcy5mb3JFYWNoKChwcm9tcHRfZmllbGQ6IFByb21wdEZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgIHByb21wdF9maWVsZF9tb2RlbC5jcmVhdGVTZXR0aW5nRmllbGRzKHByb21wdF9maWVsZCwgZmllbGRzX2NvbnRhaW5lcik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIE5ldyBmaWVsZCBidXR0b25cclxuICAgICAgICBjcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9uPFByb21wdEZpZWxkTW9kZWwsIFByb21wdEZpZWxkPih0aGlzLnBsdWdpbiwgUHJvbXB0RmllbGRNb2RlbC5uYW1lLCBjb250YWluZXJfZWxlbWVudCwgZmllbGRzX2NvbnRhaW5lciwgdGhpcy5wcm9tcHQpLnRoZW4oKTtcclxuXHJcbiAgICAgICAgLy8gRXhlY3V0ZSBidXR0b24gdGV4dFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZURpdih7YXR0cjoge2NsYXNzOiBcIlNDLXNldHRpbmctZ3JvdXBcIn19KSlcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJFeGVjdXRlIGJ1dHRvbiB0ZXh0XCIpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucHJvbXB0LmNvbmZpZ3VyYXRpb24uZXhlY3V0ZV9idXR0b25fdGV4dClcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X2V4ZWN1dGVfYnV0dG9uX3RleHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21wdC5jb25maWd1cmF0aW9uLmV4ZWN1dGVfYnV0dG9uX3RleHQgPSBuZXdfZXhlY3V0ZV9idXR0b25fdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoZXhlY3V0ZV9idXR0b25fdGV4dF9jb21wb25lbnQ6IFRleHRDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvY29tcGxldGUgZm9yIHRoZSBFeGVjdXRlIGJ1dHRvbiB0ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUF1dG9jb21wbGV0ZSh0aGlzLnBsdWdpbiwgZXhlY3V0ZV9idXR0b25fdGV4dF9jb21wb25lbnQuaW5wdXRFbCwgKCkgPT4gZXhlY3V0ZV9idXR0b25fdGV4dF9jb21wb25lbnQub25DaGFuZ2VkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuXHJcbiAgICAgICAgLy8gT2sgYnV0dG9uXHJcbiAgICAgICAgaWYgKHRoaXMub2tfYnV0dG9uX3RleHQpIHtcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCh0aGlzLm9rX2J1dHRvbl90ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHRoaXMuYXBwcm92ZSgpKSxcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQSB0aXAgYWJvdXQgQ1NTIHN0eWxpbmcuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVGlwISBZb3UgY2FuIGN1c3RvbWlzZSB0aGUgc3R5bGUgb2YgdGhlIHByb21wdCBtb2RhbCB3aXRoIENTUyBieSB1c2luZyB0aGUgY2xhc3MgLlwiICsgdGhpcy5wcm9tcHQuZ2V0Q1NTQ2xhc3MoKSArIFwiIG9yIC5cIiArIFByb21wdC5nZXRDU1NCYXNlQ2xhc3MoKStcIiAoZm9yIGFsbCBwcm9tcHQgbW9kYWxzKS5cIilcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFwcHJvdmUoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMub25fYWZ0ZXJfYXBwcm92YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHByb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMub25fYWZ0ZXJfYXBwcm92YWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBhIGNhbmNlbGxpbmcgaG9vayBpZiBvbmUgaXMgZGVmaW5lZCAoYW5kIGlmIHRoZSBjbG9zaW5nIGhhcHBlbnMgZHVlIHRvIGNhbmNlbGxpbmcsIGkuZS4gdGhlIG9rIGJ1dHRvbiBpcyBOT1QgY2xpY2tlZCkuXHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcHJvdmVkICYmIHRoaXMub25fYWZ0ZXJfY2FuY2VsbGluZykge1xyXG4gICAgICAgICAgICB0aGlzLm9uX2FmdGVyX2NhbmNlbGxpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMy4wIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgICBTZXR0aW5nLFxyXG4gICAgVGV4dEFyZWFDb21wb25lbnQsXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtcclxuICAgIElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nLFxyXG4gICAgUGxhdGZvcm1JZCxcclxuICAgIFBsYXRmb3JtTmFtZXMsXHJcbn0gZnJvbSBcIi4uL1NDX01haW5TZXR0aW5nc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0T3BlcmF0aW5nU3lzdGVtLFxyXG4gICAgZ290b1VSTCxcclxufSBmcm9tIFwiLi4vLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7Q29uZmlybWF0aW9uTW9kYWx9IGZyb20gXCIuLi8uLi9Db25maXJtYXRpb25Nb2RhbFwiO1xyXG5pbXBvcnQge2NyZWF0ZUF1dG9jb21wbGV0ZX0gZnJvbSBcIi4vQXV0b2NvbXBsZXRlXCI7XHJcbmltcG9ydCB7RG9jdW1lbnRhdGlvblBBVEhBdWdtZW50YXRpb25zTGlua30gZnJvbSBcIi4uLy4uL0RvY3VtZW50YXRpb25cIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQQVRIQXVnbWVudGF0aW9uRmllbGRzKHBsdWdpbjogU0NfUGx1Z2luLCBjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHBhdGhfYXVnbWVudGF0aW9uczogSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmcpIHtcclxuXHJcbiAgICBjb25zdCBwYXRoX3ZhcmlhYmxlX25hbWUgPSBnZXRQQVRIRW52aXJvbm1lbnRWYXJpYWJsZU5hbWUoKTtcclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgIC5zZXROYW1lKGBBZGQgZGlyZWN0b3JpZXMgdG8gdGhlICR7cGF0aF92YXJpYWJsZV9uYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZWApXHJcbiAgICAgICAgLnNldEhlYWRpbmcoKVxyXG4gICAgICAgIC5zZXREZXNjKGBUaGlzIGlzIHNvbWV0aW1lcyBuZWVkZWQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBjYWxsIHNvbWUgdXNlciBpbnN0YWxsZWQgYXBwbGljYXRpb25zLiBUaGUgZGlyZWN0b3JpZXMgd2lsbCBiZSBhcHBlbmRlZCBBRlRFUiB0aGUgZGVmYXVsdCBkaXJlY3RvcmllcyBpbiAke3BhdGhfdmFyaWFibGVfbmFtZX0sIHVubGVzcyB7eyFlbnZpcm9ubWVudDoke3BhdGhfdmFyaWFibGVfbmFtZX19fSBpcyBpbmNsdWRlZC4gT3RoZXIge3t2YXJpYWJsZXN9fSBjYW4gYmUgdXNlZCwgdG9vLCBidXQgdGhleSBkb24ndCBhZmZlY3QgdGhlIGFwcGVuZGluZyBvcmRlci5gKVxyXG5cclxuICAgICAgICAvLyBBbiBpY29uIGZvciBzaG93aW5nIHRoZSBjdXJyZW50IFBBVEggY29udGVudC5cclxuICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0SWNvbihcImJ1bGxldC1saXN0XCIpXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKGBTaG93IHRoZSBjdXJyZW50ICR7cGF0aF92YXJpYWJsZV9uYW1lfSBjb250ZW50ICh3aXRob3V0IGFueSBhZGRpdGlvbnMpLmApXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IENvbmZpcm1hdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICBgQ3VycmVudCAke3BhdGhfdmFyaWFibGVfbmFtZX0gY29udGVudGAsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuUEFUSCxcclxuICAgICAgICAgICAgICAgICAgICBcIkNsb3NlXCIsXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICBtb2RhbC5vcGVuKCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIClcclxuXHJcbiAgICAgICAgLy8gSGVscCBsaW5rXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldEljb24oXCJoZWxwXCIpXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKGBEb2N1bWVudGF0aW9uOiBBZGRpdGlvbnMgdG8gdGhlICR7cGF0aF92YXJpYWJsZV9uYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZWApXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IGdvdG9VUkwoRG9jdW1lbnRhdGlvblBBVEhBdWdtZW50YXRpb25zTGluaykpXHJcbiAgICAgICAgKVxyXG4gICAgO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGZpZWxkIGZvciBlYWNoIG9wZXJhdGluZyBzeXN0ZW0uXHJcbiAgICBjb25zdCBzdWJfY29udGFpbmVyX2VsZW1lbnQgPSBjb250YWluZXJfZWxlbWVudC5jcmVhdGVEaXYoKTtcclxuICAgIHN1Yl9jb250YWluZXJfZWxlbWVudC5hZGRDbGFzcyhcIlNDLXNldHRpbmctZ3JvdXBcIik7XHJcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhQbGF0Zm9ybU5hbWVzKS5mb3JFYWNoKChwbGF0Zm9ybV9pZDogUGxhdGZvcm1JZCkgPT4geyAvLyBVc2UgLmZvckVhY2goKSBhbmQgY2FsbGJhY2tzIGluc3RlYWQgb2YgYSBzaW1wbGUgZm9yIGxvb3AsIGJlY2F1c2UgJ3BsYXRmb3JtX2lkJyBuZWVkcyB0byByZXRhaW4gdGhlIHNhbWUgdmFsdWUgbGF0ZXIgaW4gdGhlIC5vbkNoYW5nZSgpIGNhbGxiYWNrLiBPdGhlcndpc2UsIGBwbGF0Zm9ybV9pZGAgd291bGQgc2hvdyB1cCBhcyBcIndpbjMyXCIgaW4gYWxsIC5vbkNoYW5nZSgpIGNhbGxzLlxyXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtX25hbWUgPSBQbGF0Zm9ybU5hbWVzW3BsYXRmb3JtX2lkXTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoc3ViX2NvbnRhaW5lcl9lbGVtZW50KS5zZXROYW1lKHBsYXRmb3JtX25hbWUgKyBcIiBcIiArIGdldFBBVEhFbnZpcm9ubWVudFZhcmlhYmxlTmFtZShwbGF0Zm9ybV9pZCkgKyBcIiBhZGRpdGlvbnNcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJEZWZpbmUgZWFjaCBkaXJlY3Rvcnkgb24gYSBzZXBhcmF0ZSBsaW5lLCBvciBtdWx0aXBsZSBkaXJlY3RvcmllcyBvbiBvbmUgbGluZSwgc2VwYXJhdGVkIGJ5IFwiICsgZ2V0UEFUSFNlcGFyYXRvcihwbGF0Zm9ybV9pZCwgdHJ1ZSkpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0YXJlYSA9PiB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHBhdGhfYXVnbWVudGF0aW9uc1twbGF0Zm9ybV9pZF0gPz8gXCJcIilcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X3BhdGhfYXVnbWVudGF0aW9uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQQVRIIGF1Z21lbnRhdGlvbiBoYXMgYmVlbiBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3X3BhdGhfYXVnbWVudGF0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF1Z21lbnRhdGlvbiBoYXMgY29udGVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aF9hdWdtZW50YXRpb25zW3BsYXRmb3JtX2lkXSA9IG5ld19wYXRoX2F1Z21lbnRhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXVnbWVudGF0aW9uIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXRoX2F1Z21lbnRhdGlvbnNbcGxhdGZvcm1faWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHRleHRhcmVhX2NvbXBvbmVudDogVGV4dEFyZWFDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW4gYXV0b2NvbXBsZXRlIG1lbnUuXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHBsdWdpbiwgdGV4dGFyZWFfY29tcG9uZW50LmlucHV0RWwgYXMgdW5rbm93biBhcyBIVE1MSW5wdXRFbGVtZW50LCAoKSA9PiB0ZXh0YXJlYV9jb21wb25lbnQub25DaGFuZ2VkKCkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBBVEhTZXBhcmF0b3IocGxhdGZvcm1faWQ6IFBsYXRmb3JtSWQsIHZlcmJvc2UgPSBmYWxzZSkge1xyXG4gICAgc3dpdGNoIChwbGF0Zm9ybV9pZCkge1xyXG4gICAgICAgIGNhc2UgXCJsaW51eFwiOlxyXG4gICAgICAgIGNhc2UgXCJkYXJ3aW5cIjogLy8gVGhpcyBpcyBtYWNPUy5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcmJvc2UgPyBcImEgY29sb24gOlwiIDogXCI6XCI7XHJcbiAgICAgICAgY2FzZSBcIndpbjMyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJib3NlID8gXCJhIHNlbWljb2xvbiA7XCIgOiBcIjtcIjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnROZXdsaW5lc1RvUEFUSFNlcGFyYXRvcnMocGF0aDogc3RyaW5nLCBwbGF0Zm9ybV9pZDogUGxhdGZvcm1JZCkge1xyXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gZ2V0UEFUSFNlcGFyYXRvcihwbGF0Zm9ybV9pZCk7XHJcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKFxyXG4gICAgICAgIC8oXFxyXFxufFxccnxcXG4pKy9ndSwgLy8gKyBtZWFucyB0aGF0IG11bHRpcGxlIGFkamFjZW50IG5ld2xpbmVzIGNhbiBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIHNlcGFyYXRvciBjaGFyYWN0ZXIuXHJcbiAgICAgICAgKCkgPT4gc2VwYXJhdG9yLCAvLyBUaGUgcmVwbGFjZW1lbnQgaXMgYSBjYWxsYmFjayBpbiBvcmRlciB0byBhdm9pZCBwcm9ibGVtcyB3aXRoICQgY2hhcmFjdGVycywgYWx0aG91Z2ggdGhhdCBwcm9ibGVtIHdvdWxkIG9ubHkgb2NjdXIgaWYgdGhlIHNlcGFyYXRvciB3b3VsZCBjb250YWluIGEgJCBjaGFyYWN0ZXIsIHdoaWNoIGlzIGRvZXMgbm90LCBidXQgZml4IGl0IGFueXdheS5cclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIGF1Z21lbnRhdGlvbiBzdHJpbmcgKHNwZWNpZmljIHRvIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0pIGZyb20gdGhlIHBsdWdpbidzXHJcbiAqIGNvbmZpZ3VyYXRpb24uIFJldHVybnMgaXQgV0lUSE9VVCBwYXJzaW5nIHBvc3NpYmxlIHZhcmlhYmxlcyBpbiB0aGUgc3RyaW5nLiBJZiB0aGUgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtIGRvZXMgbm90XHJcbiAqIGhhdmUgYSBkZWRpY2F0ZWQgUEFUSCBhdWdtZW50YXRpb24gc3RyaW5nIGluIHRoZSBjb25maWd1cmF0aW9uLCByZXR1cm5zIG51bGwuXHJcbiAqXHJcbiAqIEBwYXJhbSBwbHVnaW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQQVRIQXVnbWVudGF0aW9uKHBsdWdpbjogU0NfUGx1Z2luKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gcGx1Z2luLnNldHRpbmdzLmVudmlyb25tZW50X3ZhcmlhYmxlX3BhdGhfYXVnbWVudGF0aW9uc1tnZXRPcGVyYXRpbmdTeXN0ZW0oKV0gPz8gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgT1Mgc3BlY2lmaWMgbmFtZSBmb3IgdGhlIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUuIEZvciBXaW5kb3dzIGl0cyBQYXRoLCBidXQgZm9yIG1hY09TIGFuZCBMaW51eCBpdHMgUEFUSCwgc29cclxuICogdGhlIG9ubHkgZGlmZmVyZW5jZSBpcyBjYXNpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UEFUSEVudmlyb25tZW50VmFyaWFibGVOYW1lKHBsYXRmb3JtX2lkOiBQbGF0Zm9ybUlkID0gZ2V0T3BlcmF0aW5nU3lzdGVtKCkpIHtcclxuICAgIHN3aXRjaCAocGxhdGZvcm1faWQpIHtcclxuICAgICAgICBjYXNlIFwiZGFyd2luXCI6XHJcbiAgICAgICAgY2FzZSBcImxpbnV4XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcIlBBVEhcIjtcclxuICAgICAgICBjYXNlIFwid2luMzJcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUGF0aFwiO1xyXG4gICAgfVxyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICAgIHBhcnNlVmFyaWFibGVzLFxyXG4gICAgUGFyc2luZ1Jlc3VsdCxcclxufSBmcm9tIFwiLi9wYXJzZVZhcmlhYmxlc1wiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuLi9ldmVudHMvU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtWYXJpYWJsZVNldH0gZnJvbSBcIi4vbG9hZFZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgY2xvbmVPYmplY3QsXHJcbiAgICB1bmlxdWVBcnJheSxcclxufSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uL0RlYnVnXCI7XHJcblxyXG4vKipcclxuICogUGFyc2luZ1Byb2Nlc3MgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyB1bmNlcnRhaW4gY2FuIGFsbCB2YXJpYWJsZXMgYmUgcGFyc2VkIGF0IHRoZSB0aW1lIGJlaW5nLFxyXG4gKiBpLmUuIHdoZW4gcGFyc2luZyBzaGVsbCBjb21tYW5kcyAoYW5kIGFsaWFzZXMpLCBhcyB0aGV5IGNhbiBoYXZlIHByZWFjdGlvbnMgd2hpY2ggcmVxdWlyZSBwYXJzaW5nIHRvIGJlIGRvbmUgaW4gdHdvIHBoYXNlcy5cclxuICpcclxuICogQWxzbywgc2hlbGwgY29tbWFuZHMgYXJlIG9mdGVuIHBhcnNlZCBpbiBhZHZhbmNlIGZvciBjb21tYW5kIHBhbGV0dGUgYW5kIGNvbnRleHQgbWVudXMuIFRoZW4gaXQncyBnb29kIHRvIHN0b3JlIHRoZSBwYXJzaW5nXHJcbiAqIHJlc3VsdCBieSB1c2luZyBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy5cclxuICpcclxuICogVGhlbiBhZ2FpbiwgaWYgdGhlIHBhcnNpbmcgdXNlLWNhc2UgaXMgc2ltcGxlciwgZS5nLiBQcm9tcHQgZGVzY3JpcHRpb24gb3IgcHJvbXB0IGZpZWxkIHZhbHVlcywgaXQncyBtb3JlIHN0cmFpZ2h0Zm9yd2FyZFxyXG4gKiB0byBqdXN0IGNhbGwgcGFyc2VWYXJpYWJsZXMoKSB3aXRob3V0IHV0aWxpc2luZyB0aGlzIGNsYXNzLiBBZnRlciBhbGwsIHRoaXMgY2xhc3MgaXMgYSB3cmFwcGVyIGZvciBwYXJzZVZhcmlhYmxlcygpLlxyXG4gKlxyXG4gKiA8UGFyc2luZ01hcD4gaXMgYSBnZW5lcmFsaXphdGlvbiBmb3IgZGVmaW5pbmcga2V5cyBmb3IgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzdWJtaXR0aW5nIHRoZSBvcmlnaW5hbCBwYXJzZWFibGVcclxuICogY29udGVudC4gVGhlIHNhbWUga2V5cyB3aWxsIHRoZW4gYmUgdXNlZCB0byBmb3JtIGFub3RoZXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNpbmcgcmVzdWx0cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJzaW5nUHJvY2VzczxQYXJzaW5nTWFwIGV4dGVuZHMge1trZXk6IHN0cmluZ106IHN0cmluZ30+IHtcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcnNpbmdfcmVzdWx0czogUGFyc2luZ1Jlc3VsdENvbnRhaW5lcjxQYXJzaW5nTWFwPiA9IHt9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBTQ19QbHVnaW4sXHJcbiAgICAgICAgcHJpdmF0ZSBvcmlnaW5hbF9jb250ZW50czogUGFyc2luZ01hcCxcclxuXHJcbiAgICAgICAgLyoqIFVzZWQgdG8gZ2V0IGEgc2hlbGwgKGdldFNoZWxsKCkpIGFuZCBkZWZhdWx0IHZhbHVlcyBmb3IgdmFyaWFibGVzLiAqL1xyXG4gICAgICAgIHByaXZhdGUgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLFxyXG4gICAgICAgIHByaXZhdGUgc2NfZXZlbnQ6IFNDX0V2ZW50IHwgbnVsbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiAucHJvY2VzcygpIGlzIGNhbGxlZCwgaXQgd2lsbCBzaGlmdCBhbmQgcHJvY2VzcyB0aGUgZmlyc3QgVmFyaWFibGVTZXQgcHJlc2VudCBpbiB0aGlzIGFycmF5LiBTbywgdGhlIG5leHQgY2FsbFxyXG4gICAgICAgICAqIHdpbGwgc2hpZnQgYW5kIHByb2Nlc3MgdGhlIG5leHQgc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgdmFyaWFibGVfc2V0czogVmFyaWFibGVTZXRbXSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBtYXJrIGNlcnRhaW4gY29udGVudHMgdG8gYWx3YXlzIGF2b2lkIGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGVpciB2YXJpYWJsZSB2YWx1ZXMuXHJcbiAgICAgICAgICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjb250ZW50IHRoYXQgaXMgbmV2ZXIgc3VibWl0dGVkIHRvIGEgc2hlbGwsIGkuZS4gb3V0cHV0IHdyYXBwZXJzIGF0IHRoZSBtb21lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgbGlzdCBvZiAnY29udGVudCBrZXlzJy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIGF2b2lkX2VzY2FwaW5nOiAoa2V5b2YgUGFyc2luZ01hcClbXSA9IFtdLFxyXG4gICAgKSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJQYXJzaW5nIHByb2Nlc3M6IENvdW50IHZhcmlhYmxlIHNldHM6IFwiICsgdGhpcy52YXJpYWJsZV9zZXRzLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc19maXJzdF9jYWxsID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgdGhlIG5leHQgc3RlcCBpbiB0aGUgcGFyc2luZyBwcm9jZXNzLiBUaGUgc3RlcCBjYW4gYmUgdGhlIGZpcnN0IG9uZSwgb3IgYSBzdWJzZXF1ZW50IHN0ZXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUcnVlIGlmIHBhcnNpbmcgc3VjY2VlZGVkLCBmYWxzZSBvdGhlcndpc2UuIFJlYWQgdGhlIHJlc3VsdHMgYnkgY2FsbGluZyAuZ2V0UGFyc2luZ1Jlc3VsdCgpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJvY2VzcygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50X3ZhcmlhYmxlcyA9IHRoaXMudmFyaWFibGVfc2V0cy5zaGlmdCgpO1xyXG4gICAgICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZGVidWdMb2coXCJQYXJzaW5nIHByb2Nlc3M6IENvdW50IHZhcmlhYmxlcyBpbiBjdXJyZW50IHNldDogXCIgKyBjdXJyZW50X3ZhcmlhYmxlcy5zaXplKTtcclxuXHJcbiAgICAgICAgLy8gTXVsdGlwbGUgY29udGVudHMgY2FuIGJlIHBhcnNlZCBpbiB0aGUgc2FtZSBjYWxsLiBUU2hlbGxDb21tYW5kIGluc3RhbmNlcyBoYXZlICdzaGVsbF9jb21tYW5kJyBhbmQgJ2FsaWFzJ1xyXG4gICAgICAgIC8vIGNvbnRlbnRzIHdoaWNoIGFyZSBwYXJzZWQgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBtdWx0aS1jb250ZW50IHN1cHBvcnQgY2FuIGJlIHVzZWQgZm9yIGV2ZW4gbW9yZSBzaXR1YXRpb25zIGlmXHJcbiAgICAgICAgLy8gbmVlZGVkIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50X2tleSBvZiB0aGlzLmdldENvbnRlbnRLZXlzKCkpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYXJzZV9jb250ZW50OiBzdHJpbmc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX2ZpcnN0X2NhbGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBvcmlnaW5hbCBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgcGFyc2VfY29udGVudCA9IHRoaXMub3JpZ2luYWxfY29udGVudHNbY29udGVudF9rZXldO1xyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJTdGFydGluZyB0byBwYXJzZSAnXCIgKyBjb250ZW50X2tleSArIFwiJzogXCIgKyBwYXJzZV9jb250ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHBhcnNpbmcgY29udGVudCBmcm9tIHByZXZpb3VzIHBhcnNpbmcgcmVzdWx0LiBUaGlzIHRpbWUgcGFyc2UgdmFyaWFibGVzIHRoYXQgd2VyZSBub3QgcGFyc2UgYmFjayB0aGVuLlxyXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFByb2JsZW06IHZhcmlhYmxlIHZhbHVlcyB0aGF0IGNhbWUgZnJvbSBhbiBlYXJsaWVyIHBoYXNlIGFyZSBleHBvc2VkIHRvIHJlcGV0aXRpdmUgcGFyc2luZy4gRmluZCBhIHdheSB0byBsaW1pdCB0aGUgcGFyc2luZyB0byBvbmx5IG9yaWdpbmFsIHBhcnRzIG9mIHRoZSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICAgICAgICAgICAgcGFyc2VfY29udGVudCA9IHRoaXMucGFyc2luZ19yZXN1bHRzW2NvbnRlbnRfa2V5XS5wYXJzZWRfY29udGVudDtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ29udGludWluZyBwYXJzaW5nICdcIiArIGNvbnRlbnRfa2V5ICsgXCInOiBcIiArIHBhcnNlX2NvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNpbmdfcmVzdWx0ID0gYXdhaXQgcGFyc2VWYXJpYWJsZXMoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgICAgIHBhcnNlX2NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF2b2lkRXNjYXBpbmcoY29udGVudF9rZXkpID8gbnVsbCA6IHRoaXMudF9zaGVsbF9jb21tYW5kLmdldFNoZWxsKCksIC8vIElmIG5vIGVzY2FwaW5nIGlzIG5lZWRlZCwgcGFzcyBudWxsLlxyXG4gICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjX2V2ZW50LFxyXG4gICAgICAgICAgICAgICAgY3VycmVudF92YXJpYWJsZXMsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGFyc2luZyBzdWNjZWVkZWQgb3IgZmFpbGVkLlxyXG4gICAgICAgICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiBwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQ7IC8vIEZsYWcgYXMgZmFpbGVkIGFsc28gaWYgYSBwcmV2aW91cyBwaGFzZSBoYXMgZmFpbGVkLlxyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHBhcnNpbmcgcmVzdWx0XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VUb1BhcnNpbmdSZXN1bHRzKGNvbnRlbnRfa2V5LCBwYXJzaW5nX3Jlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5pc2hcclxuICAgICAgICB0aGlzLmlzX2ZpcnN0X2NhbGwgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gc3VjY2VzcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgd3JhcHBlciBmb3IgLnByb2Nlc3MoKSB0aGF0IHByb2Nlc3NlcyBhbGwgdGhlIFZhcmlhYmxlU2V0cyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHVucHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiBwYXJzaW5nIGFsbCBzZXRzIHN1Y2NlZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc1Jlc3QoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgLy8gMS4gQ2hlY2sgYSBwcmV2aW91cyBwYXJzaW5nIHJlc3VsdCAoaWYgZXhpc3RzKS5cclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnRfa2V5IG9mIHRoaXMuZ2V0Q29udGVudEtleXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzaW5nX3Jlc3VsdHNbY29udGVudF9rZXldKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBIHByZXZpb3VzIHBhcnNpbmcgcmVzdWx0IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBpdCBoYXMgbm90IGZhaWxlZC5cclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiUHJldmlvdXMgcGFyc2luZyBzdWNjZWVkZWQ/IFwiICsgdGhpcy5wYXJzaW5nX3Jlc3VsdHNbY29udGVudF9rZXldLnN1Y2NlZWRlZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2luZ19yZXN1bHRzW2NvbnRlbnRfa2V5XS5zdWNjZWVkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJldmlvdXMgcGFyc2luZyByZXN1bHQgaGFzIGZhaWxlZC5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIuIFByb2Nlc3MgdGhlIHJlc3Qgb2YgdGhlIFZhcmlhYmxlU2V0cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFyaWFibGVfc2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWF3YWl0IHRoaXMucHJvY2VzcygpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBhcnNpbmdSZXN1bHRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNpbmdfcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIFNDX1BsdWdpbi5uZXdFcnJvcnMoKSB0byBjcmVhdGUgdmlzaWJsZSBlcnJvciBiYWxsb29ucyBmb3IgYWxsIHRoZSBpc3N1ZXMgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwbGF5RXJyb3JNZXNzYWdlcygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcnModGhpcy5nZXRFcnJvck1lc3NhZ2VzKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGUgQ2FuIGJlIG1hZGUgcHVibGljIGlmIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRFcnJvck1lc3NhZ2VzKCkge1xyXG4gICAgICAgIGxldCBlcnJvcl9tZXNzYWdlczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnRfa2V5IG9mIHRoaXMuZ2V0Q29udGVudEtleXMoKSkge1xyXG4gICAgICAgICAgICBlcnJvcl9tZXNzYWdlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5wYXJzaW5nX3Jlc3VsdHNbY29udGVudF9rZXldLmVycm9yX21lc3NhZ2VzLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBlcnJvciBtZXNzYWdlcy4gV2hlbiBwYXJzaW5nICdzaGVsbF9jb21tYW5kJyBhbmQgJ2FsaWFzJywgdGhleSBjYW4gY29udGFpbiBzYW1lIHZhcmlhYmxlcyBhbmRcclxuICAgICAgICAvLyB0aGVyZWZvcmUgZ2VuZXJhdGUgc2FtZSBlcnJvciBtZXNzYWdlcy5cclxuICAgICAgICBlcnJvcl9tZXNzYWdlcyA9IHVuaXF1ZUFycmF5KGVycm9yX21lc3NhZ2VzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVycm9yX21lc3NhZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0Q29udGVudEtleXMoKTogKGtleW9mIFBhcnNpbmdNYXApW10ge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm9yaWdpbmFsX2NvbnRlbnRzKSBhcyAoa2V5b2YgUGFyc2luZ01hcClbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyBjb25zZWN1dGl2ZSBwYXJzaW5nIHJlc3VsdHMgdG9nZXRoZXIgc28gdGhhdCBpbmZvcm1hdGlvbiBmcm9tIGJvdGggdGhlIG9sZCBhbmQgbmV3IHBhcnNpbmcgcmVzdWx0cyBjYW4gYmUgcHJlc2VydmVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG1lcmdlVG9QYXJzaW5nUmVzdWx0cyhjb250ZW50X2tleToga2V5b2YgUGFyc2luZ01hcCwgcGFyc2luZ19yZXN1bHQ6IFBhcnNpbmdSZXN1bHQpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGFyc2luZ19yZXN1bHRzW2NvbnRlbnRfa2V5XSkge1xyXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIG1lcmdlLiBCdXQgY2xvbmUgdGhlIG9iamVjdCBzbyB0aGF0IHBvc3NpYmxlIGZ1dHVyZSBtZXJnZXMgd2lsbCBub3QgbWVzcyB1cCB0aGUgb3JpZ2luYWwgb2JqZWN0IGluIGNhc2UgaXQncyB1c2VkIHNvbWV3aGVyZSBlbHNlLlxyXG4gICAgICAgICAgICB0aGlzLnBhcnNpbmdfcmVzdWx0c1tjb250ZW50X2tleV0gPSBjbG9uZU9iamVjdChwYXJzaW5nX3Jlc3VsdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWVyZ2VcclxuICAgICAgICAgICAgLy8gTk9URTogdGhpcy5wYXJzaW5nX3Jlc3VsdHNbY29udGVudF9rZXldLm9yaWdpbmFsX2NvbnRlbnQgSVMgS0VQVCBVTkNIQU5HRUQhIFRoZSBuZXdlciBcIm9yaWdpbmFsXCIgY29udGVudCBpcyBub3QgYWN0dWFsbHkgb3JpZ2luYWwsIGJlY2F1c2UgaXQncyBwYXJ0bHkgcGFyc2VkLiBUaGF0J3Mgd2h5IHRoZSBvbGQgb25lIGlzIHByZXNlcnZlZC5cclxuICAgICAgICAgICAgdGhpcy5wYXJzaW5nX3Jlc3VsdHNbY29udGVudF9rZXldLnBhcnNlZF9jb250ZW50ID0gcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQ7IC8vIE5ldyBwYXJzZWQgY29udGVudCBvdmVycmlkZXMgdGhlIG9sZCBvbmUuXHJcbiAgICAgICAgICAgIHRoaXMucGFyc2luZ19yZXN1bHRzW2NvbnRlbnRfa2V5XS5zdWNjZWVkZWQgJiY9IHBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZDsgLy8gQm90aCB0aGUgb2xkIGFuZCBuZXcgcGFyc2luZyBtdXN0IGhhdmUgc3VjY2VlZGVkIGluIG9yZGVyIHRvIGNvbnNpZGVyIHRoZSB3aG9sZSBwcm9jZXNzIHN1Y2NlZWRlZC5cclxuICAgICAgICAgICAgdGhpcy5wYXJzaW5nX3Jlc3VsdHNbY29udGVudF9rZXldLmVycm9yX21lc3NhZ2VzLnB1c2goLi4ucGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMpOyAvLyBJbmNsdWRlIGJvdGggb2xkIGFuZCBuZXcgZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgIHRoaXMucGFyc2luZ19yZXN1bHRzW2NvbnRlbnRfa2V5XS5jb3VudF9wYXJzZWRfdmFyaWFibGVzICs9IHBhcnNpbmdfcmVzdWx0LmNvdW50X3BhcnNlZF92YXJpYWJsZXM7IC8vIFN1bSB1cCB0aGUgdmFyaWFibGUgdXNhZ2UgY291bnRzLiBBdCB0aGUgdGltZSBvZiB3cml0aW5nLCB0aGUgc3VtIGlzIG9ubHkgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgd2VyZSBhbnkgdmFyaWFibGVzIHBhcnNlZCBvciBub3QsIHNvIGFuIGFjY3VyYXRlIHN1bSBpcyBub3QgdXNlZCBhdG0uXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciB0aGUgZ2l2ZW4gY29udGVudF9rZXkgaGFzIGEgbWFyayB0aGF0IHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgY29udGVudCdzIHZhcmlhYmxlIHZhbHVlcyBzaG91bGQgbm90IGJlIGVzY2FwZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnRfa2V5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGF2b2lkRXNjYXBpbmcoY29udGVudF9rZXk6IGtleW9mIFBhcnNpbmdNYXApOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdm9pZF9lc2NhcGluZy5jb250YWlucyhjb250ZW50X2tleSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnR5cGUgUGFyc2luZ1Jlc3VsdENvbnRhaW5lcjxQYXJzaW5nTWFwPiA9IHtcclxuICAgIFtrZXkgaW4ga2V5b2YgUGFyc2luZ01hcF0/OiBQYXJzaW5nUmVzdWx0O1xyXG59OyIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgICBPdXRwdXRDaGFubmVsQ29kZXMsXHJcbiAgICBPdXRwdXRDaGFubmVsT3JkZXIsXHJcbiAgICBPdXRwdXRIYW5kbGluZ01vZGUsXHJcbn0gZnJvbSBcIi4uL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsQ29kZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgSUNvbW1hbmRQYWxldHRlT3B0aW9ucyxcclxuICAgIElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nLFxyXG4gICAgSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmdXaXRoRGVmYXVsdCxcclxufSBmcm9tIFwiLi9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtTQ19FdmVudENvbmZpZ3VyYXRpb25zfSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50Q29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlRGVmYXVsdFZhbHVlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4uL3ZhcmlhYmxlcy9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgUHJlYWN0aW9uQ29uZmlndXJhdGlvblxyXG59IGZyb20gXCIuLi9pbXBvcnRzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24ge1xyXG4gICAgaWQ6IHN0cmluZyxcclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbnMgb3BlcmF0aW5nIHN5c3RlbSBzcGVjaWZpYyBzaGVsbCBjb21tYW5kcy5cclxuICAgICAqICAtIGtleTogcGxhdGZvcm0gKD0gT1MpIG5hbWVcclxuICAgICAqICAtIHZhbHVlOiBzaGVsbCBjb21tYW5kXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtX3NwZWNpZmljX2NvbW1hbmRzOiBJUGxhdGZvcm1TcGVjaWZpY1N0cmluZ1dpdGhEZWZhdWx0O1xyXG4gICAgc2hlbGxzOiBJUGxhdGZvcm1TcGVjaWZpY1N0cmluZztcclxuICAgIGFsaWFzOiBzdHJpbmc7XHJcbiAgICBpY29uOiBzdHJpbmcgfCBudWxsO1xyXG4gICAgY29uZmlybV9leGVjdXRpb246IGJvb2xlYW47XHJcbiAgICBpZ25vcmVfZXJyb3JfY29kZXM6IG51bWJlcltdO1xyXG4gICAgb3V0cHV0X2NoYW5uZWxzOiBPdXRwdXRDaGFubmVsQ29kZXMsXHJcbiAgICBvdXRwdXRfd3JhcHBlcnM6IHtcclxuICAgICAgICBzdGRvdXQ6IHN0cmluZyB8IG51bGwsXHJcbiAgICAgICAgc3RkZXJyOiBzdHJpbmcgfCBudWxsLFxyXG4gICAgfTtcclxuICAgIG91dHB1dF9jaGFubmVsX29yZGVyOiBPdXRwdXRDaGFubmVsT3JkZXI7XHJcbiAgICBvdXRwdXRfaGFuZGxpbmdfbW9kZTogT3V0cHV0SGFuZGxpbmdNb2RlO1xyXG4gICAgZXZlbnRzOiBTQ19FdmVudENvbmZpZ3VyYXRpb25zO1xyXG4gICAgY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eToga2V5b2YgSUNvbW1hbmRQYWxldHRlT3B0aW9ucztcclxuICAgIHByZWFjdGlvbnM6IFByZWFjdGlvbkNvbmZpZ3VyYXRpb25bXTtcclxuICAgIHZhcmlhYmxlX2RlZmF1bHRfdmFsdWVzOiB7XHJcbiAgICAgICAgW3ZhcmlhYmxlX2lkX29yX25hbWU6IHN0cmluZ106IFZhcmlhYmxlRGVmYXVsdFZhbHVlQ29uZmlndXJhdGlvbixcclxuICAgIH07XHJcblxyXG4gICAgLy8gTEVHQUNZXHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgQ2FuIG9ubHkgYmUgdXNlZCBmb3IgbWlncmF0aW9uLiAqL1xyXG4gICAgc2hlbGxfY29tbWFuZD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5ld1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24oc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nLCBzaGVsbF9jb21tYW5kID0gXCJcIik6IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogc2hlbGxfY29tbWFuZF9pZCxcclxuICAgICAgICBwbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kczoge1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBzaGVsbF9jb21tYW5kLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hlbGxzOiB7fSxcclxuICAgICAgICBhbGlhczogXCJcIixcclxuICAgICAgICBpY29uOiBudWxsLFxyXG4gICAgICAgIGNvbmZpcm1fZXhlY3V0aW9uOiBmYWxzZSxcclxuICAgICAgICBpZ25vcmVfZXJyb3JfY29kZXM6IFtdLFxyXG4gICAgICAgIG91dHB1dF9jaGFubmVsczoge1xyXG4gICAgICAgICAgICBzdGRvdXQ6IFwiaWdub3JlXCIsXHJcbiAgICAgICAgICAgIHN0ZGVycjogXCJub3RpZmljYXRpb25cIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIG91dHB1dF93cmFwcGVyczoge1xyXG4gICAgICAgICAgICBzdGRvdXQ6IG51bGwsXHJcbiAgICAgICAgICAgIHN0ZGVycjogbnVsbCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG91dHB1dF9jaGFubmVsX29yZGVyOiBcInN0ZG91dC1maXJzdFwiLFxyXG4gICAgICAgIG91dHB1dF9oYW5kbGluZ19tb2RlOiBcImJ1ZmZlcmVkXCIsXHJcbiAgICAgICAgZXZlbnRzOiB7fSxcclxuICAgICAgICBjb21tYW5kX3BhbGV0dGVfYXZhaWxhYmlsaXR5OiBcImVuYWJsZWRcIixcclxuICAgICAgICBwcmVhY3Rpb25zOiBbXSxcclxuICAgICAgICB2YXJpYWJsZV9kZWZhdWx0X3ZhbHVlczoge30sXHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IHtuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uLCBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuL0RlYnVnXCI7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xyXG5pbXBvcnQge2NvbWJpbmVPYmplY3RzLCBnZXRQbHVnaW5BYnNvbHV0ZVBhdGh9IGZyb20gXCIuL0NvbW1vblwiO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7Z2V0RGVmYXVsdFNldHRpbmdzfSBmcm9tIFwiLi9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NcIjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBSdW5NaWdyYXRpb25zKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBjb25zdCBzaG91bGRfc2F2ZSA9IFsgLy8gSWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgaXMgdHJ1ZSwgc2F2aW5nIHdpbGwgYmUgdHJpZ2dlcmVkLlxyXG4gICAgICAgIEVuc3VyZU1haW5GaWVsZHNFeGlzdChwbHVnaW4pLCAvLyBEbyB0aGlzIGVhcmx5LlxyXG4gICAgICAgIE1pZ3JhdGVDb21tYW5kc1RvU2hlbGxDb21tYW5kcyhwbHVnaW4pLFxyXG4gICAgICAgIE1pZ3JhdGVTaGVsbENvbW1hbmRzT2JqZWN0VG9BcnJheShwbHVnaW4pLFxyXG4gICAgICAgIE1pZ3JhdGVTaGVsbENvbW1hbmRUb1BsYXRmb3JtcyhwbHVnaW4pLFxyXG4gICAgICAgIEVuc3VyZVNoZWxsQ29tbWFuZHNIYXZlQWxsRmllbGRzKHBsdWdpbiksXHJcbiAgICAgICAgRGVsZXRlRW1wdHlDb21tYW5kc0ZpZWxkKHBsdWdpbiksXHJcbiAgICBdO1xyXG4gICAgaWYgKHNob3VsZF9zYXZlLmluY2x1ZGVzKHRydWUpKSB7XHJcbiAgICAgICAgLy8gT25seSBzYXZlIGlmIHRoZXJlIHdlcmUgY2hhbmdlcyB0byBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgIGRlYnVnTG9nKFwiU2F2aW5nIG1pZ3JhdGlvbnMuLi5cIilcclxuICAgICAgICBiYWNrdXBTZXR0aW5nc0ZpbGUocGx1Z2luKTsgLy8gTWFrZSBhIGJhY2t1cCBjb3B5IG9mIHRoZSBvbGQgZmlsZSBCRUZPUkUgd3JpdGluZyB0aGUgbmV3LCBtaWdyYXRlZCBzZXR0aW5ncyBmaWxlLlxyXG4gICAgICAgIGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICBkZWJ1Z0xvZyhcIk1pZ3JhdGlvbnMgc2F2ZWQuLi5cIilcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbiBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUsIGJ1dCBJIGhhdmVuJ3QgeWV0IGRlY2lkZWQgd2lsbCBpdCBiZSBkb25lIGluIDEuMCBvciBsYXRlci5cclxuICovXHJcbmZ1bmN0aW9uIE1pZ3JhdGVTaGVsbENvbW1hbmRzT2JqZWN0VG9BcnJheShwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNoZWxsIGNvbW1hbmRzJyBjb250YWluZXIgaXMgYW4gb2JqZWN0LlxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcykpIHtcclxuICAgICAgICAvLyBJdCBpcyBhbiBvYmplY3QuIEl0IG5lZWRzIHRvIGJlIGNoYW5nZWQgdG8gYW4gYXJyYXkgaW4gb3JkZXIgdG8gYWxsb3cgY3VzdG9tIG9yZGVyaW5nLlxyXG4gICAgICAgIGNvbnN0IHNoZWxsX2NvbW1hbmRzX2FycmF5OiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uW10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWxsX2NvbW1hbmRfaWQgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGx1Z2luLnNldHRpbmdzLnNoZWxsX2NvbW1hbmRzKSkgeyAvLyBSZW1lbWJlciB0aGF0IHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcyBpcyBhbiBvYmplY3QgaGVyZSEgTm90IGFuIGFycmF5ICh5ZXQpLlxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIEkgZG9uJ3Qga25vdyB3aHkgVHlwZVNjcmlwdCB0aGlua3MgdGhlIGluZGV4IGlzIGluY29ycmVjdC5cclxuICAgICAgICAgICAgY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uID0gcGx1Z2luLnNldHRpbmdzLnNoZWxsX2NvbW1hbmRzW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG5cclxuICAgICAgICAgICAgLy8gQXNzaWduICdpZCcgdG8gU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbiBiZWNhdXNlIGl0IGRpZCBub3QgY29udGFpbiBpdCBiZWZvcmUgdGhpcyBtaWdyYXRpb24uXHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZCA9IHNoZWxsX2NvbW1hbmRfaWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24gdG8gdGhlIG5ldyBhcnJheSBjb250YWluZXIuXHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRzX2FycmF5LnB1c2goc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIG9sZCBvYmplY3QgY29udGFpbmVyIHdpdGggdGhlIG5ldyBhcnJheSBjb250YWluZXIuXHJcbiAgICAgICAgcGx1Z2luLnNldHRpbmdzLnNoZWxsX2NvbW1hbmRzID0gc2hlbGxfY29tbWFuZHNfYXJyYXk7IC8vIE5vdyBwbHVnaW4uc2V0dGluZ3Muc2hlbGxfY29tbWFuZHMgY2hhbmdlcyB0byBiZSBhbiBhcnJheSBpbnN0ZWFkIG9mIGFuIG9iamVjdC5cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNhdmUgdGhlIGNoYW5nZXMuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBjb250YWluZXIgaXMgYWxyZWFkeSBtaWdyYXRlZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG5lZWQgdG8gc2F2ZSBhbnl0aGluZy5cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbiBiZSByZW1vdmVkIGluIDEuMC4wLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTWlncmF0ZUNvbW1hbmRzVG9TaGVsbENvbW1hbmRzKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBpZiAodW5kZWZpbmVkID09PSBwbHVnaW4uc2V0dGluZ3MuY29tbWFuZHMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb3VudF9zaGVsbF9jb21tYW5kcyA9IHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcy5sZW5ndGg7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgaWYgKDAgPCBjb3VudF9zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgIGxldCBjb3VudF9lbXB0eV9jb21tYW5kcyA9IDA7IC8vIEEgY291bnRlciBmb3IgZW1wdHkgb3IgbnVsbCBjb21tYW5kc1xyXG4gICAgICAgIGRlYnVnTG9nKFwic2V0dGluZ3MuY29tbWFuZHMgaXMgbm90IGVtcHR5LCB3aWxsIG1pZ3JhdGUgXCIgKyBjb3VudF9zaGVsbF9jb21tYW5kcyArIFwiIGNvbW1hbmRzIHRvIHNldHRpbmdzLnNoZWxsX2NvbW1hbmRzLlwiKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWxsX2NvbW1hbmRfaWQgaW4gcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoZWxsX2NvbW1hbmQgPSBwbHVnaW4uc2V0dGluZ3MuY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF07XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjb21tYW5kIGlzIG5vdCBlbXB0eS4gSnVzdCBpbiBjYXNlLlxyXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gc2hlbGxfY29tbWFuZCB8fCAwID09PSBzaGVsbF9jb21tYW5kLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbW1hbmQgaXMgZW1wdHlcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiTWlncmF0aW9uIGZhaWx1cmUgZm9yIHNoZWxsIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiOiBUaGUgb3JpZ2luYWwgc2hlbGwgY29tbWFuZCBzdHJpbmcgaXMgZW1wdHksIHNvIGl0IGNhbm5vdCBiZSBtaWdyYXRlZC5cIik7XHJcbiAgICAgICAgICAgICAgICBjb3VudF9lbXB0eV9jb21tYW5kcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVuZGVmaW5lZCAhPT0gcGx1Z2luLmdldFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25JbmRleChzaGVsbF9jb21tYW5kX2lkKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQSBjb21tYW5kIHdpdGggdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiTWlncmF0aW9uIGZhaWx1cmUgZm9yIHNoZWxsIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiOiBBIHNoZWxsIGNvbW1hbmQgd2l0aCBzYW1lIElEIGFscmVhZHkgZXhpc3RzIGluIHNldHRpbmdzLnNoZWxsX2NvbW1hbmRzLlwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsbCBPSywgbWlncmF0ZS5cclxuICAgICAgICAgICAgICAgIHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcy5wdXNoKG5ld1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24oc2hlbGxfY29tbWFuZF9pZCwgc2hlbGxfY29tbWFuZCkpOyAvLyBDcmVhdGVzIGEgc2hlbGwgY29tbWFuZCB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCBkZWZpbmVzIHRoZSBjb21tYW5kIGZvciBpdC5cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW4uc2V0dGluZ3MuY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF07IC8vIExlYXZlcyBhIG51bGwgaW4gcGxhY2UsIGJ1dCB3ZSBjYW4gZGVhbCB3aXRoIGl0IGJ5IGRlbGV0aW5nIHRoZSB3aG9sZSBhcnJheSBpZiBpdCBnZXRzIGVtcHR5LlxyXG4gICAgICAgICAgICAgICAgY291bnRfZW1wdHlfY29tbWFuZHMrKzsgLy8gQWNjb3VudCB0aGUgbnVsbCBnZW5lcmF0ZWQgb24gdGhlIHByZXZpb3VzIGxpbmUuXHJcbiAgICAgICAgICAgICAgICBzYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiTWlncmF0ZWQgc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IFwiICsgc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50X2VtcHR5X2NvbW1hbmRzID09PSBjb3VudF9zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgY29tbWFuZHMgYXJyYXkgbm93IGNvbnRhaW5zIG9ubHkgZW1wdHkvbnVsbCBjb21tYW5kcy5cclxuICAgICAgICAgICAgLy8gRGVsZXRlIGl0LlxyXG4gICAgICAgICAgICBkZWxldGUgcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJzZXR0aW5ncy5jb21tYW5kcyBpcyBlbXB0eSwgc28gbm8gbmVlZCB0byBtaWdyYXRlIGNvbW1hbmRzLiBHb29kIHRoaW5nISA6KVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzYXZlO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGdlbmVyYWwgbWlncmF0b3IgdGhhdCBhZGRzIG5ldywgbWlzc2luZyBwcm9wZXJ0aWVzIHRvIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24gb2JqZWN0cy4gVGhpcyBpcyBub3QgdGllZCB0byBhbnkgc3BlY2lmaWMgdmVyc2lvbiB1cGRhdGUsIHVubGlrZSBNaWdyYXRlQ29tbWFuZHNUb1NoZWxsQ29tbWFuZHMoKS5cclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEVuc3VyZVNoZWxsQ29tbWFuZHNIYXZlQWxsRmllbGRzKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgY29uc3Qgc2hlbGxfY29tbWFuZF9kZWZhdWx0X2NvbmZpZ3VyYXRpb24gPSBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKFwibm8taWRcIik7IC8vIFVzZSBhIGR1bW15IGlkIGhlcmUsIGJlY2F1c2Ugc29tZXRoaW5nIG5lZWRzIHRvIGJlIHVzZWQuIFRoaXMgaWQgc2hvdWxkIG5ldmVyIGVuZCB1cCBiZWluZyB1c2VkIGluIHByYWN0aWNlLlxyXG4gICAgY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9ucyA9IHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcztcclxuICAgIGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uIG9mIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5X25hbWUgaW4gc2hlbGxfY29tbWFuZF9kZWZhdWx0X2NvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlIGNhbiBoYXZlIChhbG1vc3QpIHdoYXRldmVyIGRhdGF0eXBlXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5X2RlZmF1bHRfdmFsdWUgPSBzaGVsbF9jb21tYW5kX2RlZmF1bHRfY29uZmlndXJhdGlvbltwcm9wZXJ0eV9uYW1lXTtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25bcHJvcGVydHlfbmFtZV0gJiYgcHJvcGVydHlfbmFtZSAhPT0gXCJpZFwiKSB7IC8vIFRoZSBcImlkXCIgY2hlY2sgaXMganVzdCBpbiBjYXNlIHRoYXQgTWlncmF0ZVNoZWxsQ29tbWFuZHNPYmplY3RUb0FycmF5KCkgd291bGQgbm90IGhhdmUgYWRkZWQgdGhlIFwiaWRcIiBwcm9wZXJ0eSwgaW4gd2hpY2ggY2FzZSB0aGUgZHVtbXkgXCJuby1pZFwiIGlkIHNob3VsZCBub3QgYmUgYWNjaWRlbnRhbGx5IGFzc2lnbmVkIHRvIHRoZSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaGVsbCBjb21tYW5kIGRvZXMgbm90IGhhdmUgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcHJvcGVydHkgdG8gdGhlIHNoZWxsIGNvbW1hbmQgYW5kIHVzZSBhIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkVuc3VyZVNoZWxsQ29tbWFuZHNIYXZlQWxsRmllbGRzKCk6IFNoZWxsIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmlkICsgXCIgZG9lcyBub3QgaGF2ZSBhIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicuIFdpbGwgY3JlYXRlIHRoZSBwcm9wZXJ0eSBhbmQgYXNzaWduIGEgZGVmYXVsdCB2YWx1ZSAnXCIgKyBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbltwcm9wZXJ0eV9uYW1lXSA9IHByb3BlcnR5X2RlZmF1bHRfdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzYXZlO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGdlbmVyYWwgbWlncmF0b3IgdGhhdCBhZGRzIG5ldywgbWlzc2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBtYWluIHNldHRpbmdzIG9iamVjdC4gVGhpcyBpcyBub3QgdGllZCB0byBhbnkgc3BlY2lmaWMgdmVyc2lvbiB1cGRhdGUsIHVubGlrZSBNaWdyYXRlQ29tbWFuZHNUb1NoZWxsQ29tbWFuZHMoKS5cclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEVuc3VyZU1haW5GaWVsZHNFeGlzdChwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgbGV0IGhhc19taXNzaW5nX2ZpZWxkcyA9IGZhbHNlO1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBwbHVnaW4uc2V0dGluZ3M7XHJcbiAgICBjb25zdCBkZWZhdWx0X3NldHRpbmdzID0gZ2V0RGVmYXVsdFNldHRpbmdzKGZhbHNlKTtcclxuICAgIGZvciAoY29uc3QgcHJvcGVydHlfbmFtZSBpbiBkZWZhdWx0X3NldHRpbmdzKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNldHRpbmdzW3Byb3BlcnR5X25hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBvYmplY3QgZG9lcyBub3QgaGF2ZSB0aGlzIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHByb3BlcnR5X2RlZmF1bHRfdmFsdWUgY2FuIGhhdmUgKGFsbW9zdCkgd2hhdGV2ZXIgZGF0YXR5cGVcclxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlfZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfc2V0dGluZ3NbcHJvcGVydHlfbmFtZV07XHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwiRW5zdXJlTWFpbkZpZWxkc0V4aXN0KCk6IE1haW4gc2V0dGluZ3MgZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eV9uYW1lICsgXCInLiBXaWxsIGxhdGVyIGNyZWF0ZSB0aGUgcHJvcGVydHkgYW5kIGFzc2lnbiBhIGRlZmF1bHQgdmFsdWUgJ1wiICsgcHJvcGVydHlfZGVmYXVsdF92YWx1ZSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgIGhhc19taXNzaW5nX2ZpZWxkcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNfbWlzc2luZ19maWVsZHMpIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkVuc3VyZU1haW5GaWVsZHNFeGlzdCgpOiBEb2luZyB0aGUgYWJvdmUtbWVudGlvbmVkIG5ldyBmaWVsZCBjcmVhdGlvbnMuLi5cIik7XHJcbiAgICAgICAgcGx1Z2luLnNldHRpbmdzID0gY29tYmluZU9iamVjdHMoZGVmYXVsdF9zZXR0aW5ncywgcGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkVuc3VyZU1haW5GaWVsZHNFeGlzdCgpOiBEb25lLlwiKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU2F2ZSB0aGUgY2hhbmdlc1xyXG4gICAgfVxyXG5cclxuICAgIGRlYnVnTG9nKFwiRW5zdXJlTWFpbkZpZWxkc0V4aXN0KCk6IE5vIG5ldyBmaWVsZHMgdG8gY3JlYXRlLCBhbGwgb2suXCIpO1xyXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBOb3RoaW5nIHRvIHNhdmUuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYW4gYmUgcmVtb3ZlZCBpbiAxLjAuMC5cclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE1pZ3JhdGVTaGVsbENvbW1hbmRUb1BsYXRmb3JtcyhwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgbGV0IHNhdmUgPSBmYWxzZTtcclxuICAgIGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uIG9mIHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaGVsbCBjb21tYW5kIHNob3VsZCBiZSBtaWdyYXRlZC5cclxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnBsYXRmb3JtX3NwZWNpZmljX2NvbW1hbmRzIHx8IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5wbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kcy5kZWZhdWx0ID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIk1pZ3JhdGluZyBzaGVsbCBjb21tYW5kICNcIiArIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZCArIFwiOiBzaGVsbF9jb21tYW5kIHN0cmluZyB3aWxsIGJlIG1vdmVkIHRvIHBsYXRmb3Jtcy5kZWZhdWx0OiBcIiArIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5wbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQ7XHJcbiAgICAgICAgICAgICAgICBzYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiTWlncmF0aW9uIGZhaWx1cmUgZm9yIHNoZWxsIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmlkICsgXCI6IHBsYXRmb3JtcyBleGlzdHMgYWxyZWFkeS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2F2ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbiBiZSByZW1vdmVkIGluIDEuMC4wLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRGVsZXRlRW1wdHlDb21tYW5kc0ZpZWxkKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgaWYgKHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZGVsZXRlIHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcztcclxuICAgICAgICAgICAgc2F2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNhdmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJtYW5lbnQsIGRvIG5vdCByZW1vdmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwbHVnaW5cclxuICovXHJcbmZ1bmN0aW9uIGJhY2t1cFNldHRpbmdzRmlsZShwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgLy8gcGx1Z2luLmFwcC5maWxlTWFuYWdlci5cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IGN1cnJlbnRfc2V0dGluZ3NfdmVyc2lvbiA9IChwbHVnaW4uc2V0dGluZ3Muc2V0dGluZ3NfdmVyc2lvbiA9PT0gXCJwcmlvci10by0wLjcuMFwiKSA/IFwiMC54XCIgOiBwbHVnaW4uc2V0dGluZ3Muc2V0dGluZ3NfdmVyc2lvbjtcclxuICAgIGNvbnN0IHBsdWdpbl9wYXRoID0gZ2V0UGx1Z2luQWJzb2x1dGVQYXRoKHBsdWdpbik7XHJcbiAgICBjb25zdCBzZXR0aW5nc19maWxlX3BhdGggPSBwYXRoLmpvaW4ocGx1Z2luX3BhdGgsIFwiZGF0YS5qc29uXCIpO1xyXG4gICAgY29uc3QgYmFja3VwX2ZpbGVfcGF0aF93aXRob3V0X2V4dGVuc2lvbiA9IHBhdGguam9pbihwbHVnaW5fcGF0aCwgXCJkYXRhLWJhY2t1cC12ZXJzaW9uLVwiICsgY3VycmVudF9zZXR0aW5nc192ZXJzaW9uICsgXCItYmVmb3JlLXVwZ3JhZGluZy10by1cIiArIFNDX1BsdWdpbi5TZXR0aW5nc1ZlcnNpb24pO1xyXG5cclxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGN1cnJlbnQgc2V0dGluZ3MgZmlsZSBjYW4gYmUgZm91bmQuXHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc2V0dGluZ3NfZmlsZV9wYXRoKSkge1xyXG4gICAgICAgIC8vIE5vdCBmb3VuZC4gUHJvYmFibHkgdGhlIHZhdWx0IHVzZXMgYSBkaWZmZXJlbnQgY29uZmlnIGZvbGRlciB0aGFuIC5vYnNpZGlhbi5cclxuICAgICAgICBkZWJ1Z0xvZyhcImJhY2t1cFNldHRpbmdzRmlsZSgpOiBDYW5ub3QgZmluZCBkYXRhLmpzb25cIik7XHJcbiAgICAgICAgcGx1Z2luLm5ld0Vycm9yKFwiU2hlbGwgY29tbWFuZHM6IENhbm5vdCBjcmVhdGUgYSBiYWNrdXAgb2YgY3VycmVudCBzZXR0aW5ncyBmaWxlLCBiZWNhdXNlIGRhdGEuanNvbiBpcyBub3QgZm91bmQuXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYmFja3VwX2ZpbGVfcGF0aCA9IGJhY2t1cF9maWxlX3BhdGhfd2l0aG91dF9leHRlbnNpb24gKyBcIi5qc29uXCI7XHJcbiAgICBsZXQgcnVubmluZ19udW1iZXIgPSAxO1xyXG4gICAgd2hpbGUgKGZzLmV4aXN0c1N5bmMoYmFja3VwX2ZpbGVfcGF0aCkpIHtcclxuICAgICAgICBydW5uaW5nX251bWJlcisrOyAvLyBUaGUgZmlyc3QgbnVtYmVyIHdpbGwgYmUgMi5cclxuICAgICAgICBiYWNrdXBfZmlsZV9wYXRoID0gYmFja3VwX2ZpbGVfcGF0aF93aXRob3V0X2V4dGVuc2lvbiArIFwiLVwiICsgcnVubmluZ19udW1iZXIgKyBcIi5qc29uXCI7XHJcbiAgICAgICAgaWYgKHJ1bm5pbmdfbnVtYmVyID49IDEwMDApIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgc29tZSBwcm9ibGVtIHdpdGggZGV0ZWN0aW5nIGV4aXN0aW5nL2luZXhpc3RpbmcgZmlsZXMuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgaGFuZ2luZyB0aGUgcHJvZ3JhbSBpbiBhbiBldGVybmFsIGxvb3AuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhY2t1cFNldHRpbmdzRmlsZSgpOiBFdGVybmFsIGxvb3AgZGV0ZWN0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZzLmNvcHlGaWxlU3luYyhzZXR0aW5nc19maWxlX3BhdGgsIGJhY2t1cF9maWxlX3BhdGgpO1xyXG59IiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtJUGxhdGZvcm1TcGVjaWZpY1N0cmluZywgUGxhdGZvcm1JZCwgUGxhdGZvcm1OYW1lc30gZnJvbSBcIi4uL1NDX01haW5TZXR0aW5nc1wiO1xyXG5pbXBvcnQge2V4dHJhY3RGaWxlTmFtZSwgZ2V0T3BlcmF0aW5nU3lzdGVtfSBmcm9tIFwiLi4vLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7Z2V0VXNlcnNEZWZhdWx0U2hlbGwsIFBsYXRmb3JtU2hlbGxzfSBmcm9tIFwiLi4vLi4vU2hlbGxcIjtcclxuaW1wb3J0IHtTZXR0aW5nfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNoZWxsU2VsZWN0aW9uRmllbGQocGx1Z2luOiBTQ19QbHVnaW4sIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgc2hlbGxzOiBJUGxhdGZvcm1TcGVjaWZpY1N0cmluZywgaXNfZ2xvYmFsX3NldHRpbmdzOiBib29sZWFuKSB7XHJcbiAgICBsZXQgcGxhdGZvcm1faWQ6IFBsYXRmb3JtSWQ7XHJcbiAgICBmb3IgKHBsYXRmb3JtX2lkIGluIFBsYXRmb3JtTmFtZXMpIHtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybV9uYW1lID0gUGxhdGZvcm1OYW1lc1twbGF0Zm9ybV9pZF07XHJcbiAgICAgICAgbGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICAgICAgaWYgKGlzX2dsb2JhbF9zZXR0aW5ncykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50X3N5c3RlbV9kZWZhdWx0ID0gKGdldE9wZXJhdGluZ1N5c3RlbSgpID09PSBwbGF0Zm9ybV9pZCkgPyBcIiAoXCIgKyBleHRyYWN0RmlsZU5hbWUoZ2V0VXNlcnNEZWZhdWx0U2hlbGwoKSkgKyBcIilcIiA6IFwiXCI7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XCJkZWZhdWx0XCI6IFwiVXNlIHN5c3RlbSBkZWZhdWx0XCIgKyBjdXJyZW50X3N5c3RlbV9kZWZhdWx0fTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1wiZGVmYXVsdFwiOiBcIlVzZSBkZWZhdWx0XCJ9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWxsX3BhdGggaW4gUGxhdGZvcm1TaGVsbHNbcGxhdGZvcm1faWRdKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLy8gVE9ETzogR2V0IHJpZCBvZiB0aGVzZSB0d28gdHMtaWdub3Jlcy5cclxuICAgICAgICAgICAgY29uc3Qgc2hlbGxfbmFtZSA9IFBsYXRmb3JtU2hlbGxzW3BsYXRmb3JtX2lkXVtzaGVsbF9wYXRoXTtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBvcHRpb25zW3NoZWxsX3BhdGhdID0gc2hlbGxfbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKHBsYXRmb3JtX25hbWUgKyAoaXNfZ2xvYmFsX3NldHRpbmdzID8gXCIgZGVmYXVsdCBzaGVsbFwiIDogXCIgc2hlbGxcIikpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKChpc19nbG9iYWxfc2V0dGluZ3MgPyBcIkNhbiBiZSBvdmVycmlkZGVuIGJ5IGVhY2ggc2hlbGwgY29tbWFuZC4gXCIgOiBcIlwiKSArIChcIndpbjMyXCIgPT09IHBsYXRmb3JtX2lkID8gXCJQb3dlcnNoZWxsIGlzIHJlY29tbWVuZGVkIG92ZXIgY21kLmV4ZSwgYmVjYXVzZSB0aGlzIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IGVzY2FwaW5nIHZhcmlhYmxlcyBpbiBDTUQuXCIgOiBcIlwiKSlcclxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHNoZWxsc1twbGF0Zm9ybV9pZF0gPz8gXCJkZWZhdWx0XCIpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoKChfcGxhdGZvcm1faWQ6IFBsYXRmb3JtSWQpID0+IHsgcmV0dXJuIGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiB7IC8vIE5lZWQgdG8gdXNlIGEgbmVzdGVkIGZ1bmN0aW9uIHNvIHRoYXQgcGxhdGZvcm1faWQgY2FuIGJlIHN0b3JlZCBzdGF0aWNhbGx5LCBvdGhlcndpc2UgaXQgd291bGQgYWx3YXlzIGJlIFwid2luMzJcIiAodGhlIGxhc3QgdmFsdWUgb2YgUGxhdGZvcm1OYW1lcykuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZGVmYXVsdFwiID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGRlZmF1bHQgc2hlbGwsIHRoZSB2YWx1ZSBzaG91bGQgYmUgdW5zZXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzaGVsbHNbX3BsYXRmb3JtX2lkXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgY2FzZTogYXNzaWduIHRoZSBzaGVsbCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxzW19wbGF0Zm9ybV9pZF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfX0pKHBsYXRmb3JtX2lkKSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtTZXR0aW5nRmllbGRHcm91cH0gZnJvbSBcIi4uL1NDX01haW5TZXR0aW5nc1RhYlwiO1xyXG5pbXBvcnQge1NldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge3BhcnNlVmFyaWFibGVzfSBmcm9tIFwiLi4vLi4vdmFyaWFibGVzL3BhcnNlVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7Y3JlYXRlQXV0b2NvbXBsZXRlfSBmcm9tIFwiLi9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi8uLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7Y3JlYXRlTXVsdGlsaW5lVGV4dEVsZW1lbnR9IGZyb20gXCIuLi8uLi9Db21tb25cIjtcclxuaW1wb3J0IHtFT0x9IGZyb20gXCJvc1wiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZShcclxuICAgIHBsdWdpbjogU0NfUGx1Z2luLFxyXG4gICAgY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LFxyXG4gICAgc2V0dGluZ19pY29uX2FuZF9uYW1lOiBzdHJpbmcsXHJcbiAgICBzaGVsbF9jb21tYW5kOiBzdHJpbmcsXHJcbiAgICBzaGVsbDogc3RyaW5nLFxyXG4gICAgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLFxyXG4gICAgc2hvd19hdXRvY29tcGxldGVfbWVudTogYm9vbGVhbixcclxuICAgIGV4dHJhX29uX2NoYW5nZTogKHNoZWxsX2NvbW1hbmQ6IHN0cmluZykgPT4gdm9pZCxcclxuICAgIHNoZWxsX2NvbW1hbmRfcGxhY2Vob2xkZXIgPSBcIkVudGVyIHlvdXIgY29tbWFuZFwiXHJcbiAgICApIHtcclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBvbl9jaGFuZ2Uoc2hlbGxfY29tbWFuZDogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHByZXZpZXdcclxuICAgICAgICBzZXR0aW5nX2dyb3VwLnByZXZpZXdfc2V0dGluZy5kZXNjRWwuaW5uZXJIVE1MID0gXCJcIjsgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnQuXHJcbiAgICAgICAgY3JlYXRlTXVsdGlsaW5lVGV4dEVsZW1lbnQoXHJcbiAgICAgICAgICAgIFwic3BhblwiLCAvLyBUT0RPOiBNYXliZSBjbGVhbmVyIHdvdWxkIGJlIG5vdCB0byBjcmVhdGUgYSA8c3Bhbj4sIGJ1dCB0byBpbnNlcnQgdGhlIGNvbnRlbnQgZGlyZWN0bHkgaW50byBkZXNjRWwuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFNoZWxsQ29tbWFuZFByZXZpZXcocGx1Z2luLCBzaGVsbF9jb21tYW5kLCBzaGVsbCwgdF9zaGVsbF9jb21tYW5kLCBudWxsIC8qIE5vIGV2ZW50IGlzIGF2YWlsYWJsZSBkdXJpbmcgcHJldmlldy4gKi8pLFxyXG4gICAgICAgICAgICBzZXR0aW5nX2dyb3VwLnByZXZpZXdfc2V0dGluZy5kZXNjRWwsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gTGV0IHRoZSBjYWxsZXIgZXh0ZW5kIHRoaXMgb25DaGFuZ2UsIHRvIHByZWZvcm0gc2F2aW5nIHRoZSBzZXR0aW5nczpcclxuICAgICAgICBleHRyYV9vbl9jaGFuZ2Uoc2hlbGxfY29tbWFuZCk7XHJcblxyXG4gICAgICAgIC8vIFJlc2l6ZSB0aGUgc2hlbGwgY29tbWFuZCB0ZXh0YXJlYSB0byBtYXRjaCB0aGUgYW1vdW50IG9mIGxpbmVzIGluIGl0LlxyXG4gICAgICAgIHVwZGF0ZV90ZXh0YXJlYV9oZWlnaHQoc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9wbGFjZWhvbGRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlX3RleHRhcmVhX2hlaWdodChzaGVsbF9jb21tYW5kOiBzdHJpbmcsIHNoZWxsX2NvbW1hbmRfcGxhY2Vob2xkZXI6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IG5ld2xpbmVzX3BhdHRlcm4gPSAvXFxyXFxufFxccnxcXG4vO1xyXG4gICAgICAgIGNvbnN0IGNvdW50X2xpbmVzX2luX3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kLnNwbGl0KG5ld2xpbmVzX3BhdHRlcm4pLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb3VudF9saW5lc19pbl9zaGVsbF9jb21tYW5kX3BsYWNlaG9sZGVyID0gc2hlbGxfY29tbWFuZF9wbGFjZWhvbGRlci5zcGxpdChuZXdsaW5lc19wYXR0ZXJuKS5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGNvdW50X2xpbmVzX2ZpbmFsID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIGNvdW50X2xpbmVzX2luX3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgICAgIGNvdW50X2xpbmVzX2luX3NoZWxsX2NvbW1hbmRfcGxhY2Vob2xkZXIsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzLm1heF92aXNpYmxlX2xpbmVzX2luX3NoZWxsX2NvbW1hbmRfZmllbGRzKSB7XHJcbiAgICAgICAgICAgIC8vIExpbWl0IHRoZSBoZWlnaHQgc28gdGhhdCB0aGUgZmllbGQgd2lsbCBub3QgdGFrZSB1cCB0b28gbXVjaCBzcGFjZS5cclxuICAgICAgICAgICAgY291bnRfbGluZXNfZmluYWwgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5zZXR0aW5ncy5tYXhfdmlzaWJsZV9saW5lc19pbl9zaGVsbF9jb21tYW5kX2ZpZWxkcyxcclxuICAgICAgICAgICAgICAgIGNvdW50X2xpbmVzX2ZpbmFsLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoc2V0dGluZ19ncm91cC5zaGVsbF9jb21tYW5kX3NldHRpbmcuc2V0dGluZ0VsLmZpbmQoXCJ0ZXh0YXJlYVwiKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50KS5yb3dzID0gY291bnRfbGluZXNfZmluYWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ19ncm91cDogU2V0dGluZ0ZpZWxkR3JvdXAgPSB7XHJcbiAgICAgICAgbmFtZV9zZXR0aW5nOlxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5zZXRDbGFzcyhcIlNDLW5hbWUtc2V0dGluZ1wiKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKG5hbWVfc2V0dGluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVfc2V0dGluZy5uYW1lRWwuaW5uZXJIVE1MID0gc2V0dGluZ19pY29uX2FuZF9uYW1lO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAsXHJcbiAgICAgICAgc2hlbGxfY29tbWFuZF9zZXR0aW5nOlxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoc2hlbGxfY29tbWFuZF9wbGFjZWhvbGRlcilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2hlbGxfY29tbWFuZClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2Uob25fY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnNldENsYXNzKFwiU0Mtc2hlbGwtY29tbWFuZC1zZXR0aW5nXCIpXHJcbiAgICAgICAgLFxyXG4gICAgICAgIHByZXZpZXdfc2V0dGluZzpcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3MoXCJTQy1wcmV2aWV3LXNldHRpbmdcIilcclxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIChzZXR0aW5nOiBTZXR0aW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5kZXNjRWwuaW5uZXJIVE1MID0gXCJcIjsgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnQuIE5vdCBhY3R1YWxseSBuZWVkZWQgaGVyZSBiZWNhdXNlIGl0J3MgZW1wdHkgYWxyZWFkeSwgYnV0IGRvIGl0IGp1c3QgaW4gY2FzZS5cclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVNdWx0aWxpbmVUZXh0RWxlbWVudChcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsIC8vIFRPRE86IE1heWJlIGNsZWFuZXIgd291bGQgYmUgbm90IHRvIGNyZWF0ZSBhIDxzcGFuPiwgYnV0IHRvIGluc2VydCB0aGUgY29udGVudCBkaXJlY3RseSBpbnRvIGRlc2NFbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZ2V0U2hlbGxDb21tYW5kUHJldmlldyhwbHVnaW4sIHNoZWxsX2NvbW1hbmQsIHNoZWxsLCB0X3NoZWxsX2NvbW1hbmQsIG51bGwgLyogTm8gZXZlbnQgaXMgYXZhaWxhYmxlIGR1cmluZyBwcmV2aWV3LiAqLyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcuZGVzY0VsLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICxcclxuICAgIH07XHJcbiAgICB1cGRhdGVfdGV4dGFyZWFfaGVpZ2h0KHNoZWxsX2NvbW1hbmQsIHNoZWxsX2NvbW1hbmRfcGxhY2Vob2xkZXIpO1xyXG5cclxuICAgIC8vIEF1dG9jb21wbGV0ZSBtZW51XHJcbiAgICBpZiAoc2hvd19hdXRvY29tcGxldGVfbWVudSkge1xyXG4gICAgICAgIGNyZWF0ZUF1dG9jb21wbGV0ZShwbHVnaW4sIHNldHRpbmdfZ3JvdXAuc2hlbGxfY29tbWFuZF9zZXR0aW5nLnNldHRpbmdFbC5maW5kKFwidGV4dGFyZWFcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudCwgb25fY2hhbmdlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2V0dGluZ19ncm91cDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBwbHVnaW5cclxuICogQHBhcmFtIHNoZWxsX2NvbW1hbmRcclxuICogQHBhcmFtIHNoZWxsXHJcbiAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmRcclxuICogQHBhcmFtIHNjX2V2ZW50XHJcbiAqIEBwdWJsaWMgRXhwb3J0ZWQgYmVjYXVzZSBjcmVhdGVTaGVsbENvbW1hbmRGaWVsZCB1c2VzIHRoaXMuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2hlbGxDb21tYW5kUHJldmlldyhwbHVnaW46IFNDX1BsdWdpbiwgc2hlbGxfY29tbWFuZDogc3RyaW5nLCBzaGVsbDogc3RyaW5nLCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQsIHNjX2V2ZW50OiBTQ19FdmVudCB8IG51bGwpIHtcclxuICAgIGNvbnN0IHBhcnNpbmdfcmVzdWx0ID0gYXdhaXQgcGFyc2VWYXJpYWJsZXMocGx1Z2luLCBzaGVsbF9jb21tYW5kLCBzaGVsbCwgdF9zaGVsbF9jb21tYW5kLCBzY19ldmVudCk7XHJcbiAgICBpZiAoIXBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCkge1xyXG4gICAgICAgIC8vIFZhcmlhYmxlIHBhcnNpbmcgZmFpbGVkLlxyXG4gICAgICAgIGlmIChwYXJzaW5nX3Jlc3VsdC5lcnJvcl9tZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBhbGwgZXJyb3IgbWVzc2FnZXMsIGVhY2ggaW4gaXRzIG93biBsaW5lLiAoVXN1YWxseSB0aGVyZSdzIGp1c3Qgb25lIG1lc3NhZ2UpLlxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMuam9pbihFT0wpOyAvLyBOZXdsaW5lcyBhcmUgY29udmVydGVkIHRvIDxicj4ncyBieSB0aGUgY29uc3VtZXJzIG9mIHRoaXMgZnVuY3Rpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVycm9yIG1lc3NhZ2VzLCB0aGVuIGVycm9ycyBhcmUgc2lsZW50bHkgaWdub3JlZCBieSB1c2VyJ3MgdmFyaWFibGUgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgLy8gVGhlIHByZXZpZXcgY2FuIHRoZW4gc2hvdyB0aGUgb3JpZ2luYWwsIHVucGFyc2VkIHNoZWxsIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIHJldHVybiBzaGVsbF9jb21tYW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFZhcmlhYmxlIHBhcnNpbmcgc3VjY2VlZGVkXHJcbiAgICByZXR1cm4gcGFyc2luZ19yZXN1bHQucGFyc2VkX2NvbnRlbnQ7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0NyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZX0gZnJvbSBcIi4vQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRDb3JlXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge1BsYXRmb3JtSWQsIFBsYXRmb3JtTmFtZXN9IGZyb20gXCIuLi9TQ19NYWluU2V0dGluZ3NcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kRmllbGQocGx1Z2luOiBTQ19QbHVnaW4sIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLCBwbGF0Zm9ybV9pZDogUGxhdGZvcm1JZCwgc2hvd19hdXRvY29tcGxldGVfbWVudTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgcGxhdGZvcm1fbmFtZSA9IFBsYXRmb3JtTmFtZXNbcGxhdGZvcm1faWRdO1xyXG4gICAgY29uc3Qgc2V0dGluZ19ncm91cCA9IENyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZShcclxuICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQsXHJcbiAgICAgICAgXCJTaGVsbCBjb21tYW5kIG9uIFwiICsgcGxhdGZvcm1fbmFtZSxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0UGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZHMoKVtwbGF0Zm9ybV9pZF0gPz8gXCJcIixcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGwoKSxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgc2hvd19hdXRvY29tcGxldGVfbWVudSxcclxuICAgICAgICBhc3luYyAoc2hlbGxfY29tbWFuZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaGVsbF9jb21tYW5kLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2hlbGxfY29tbWFuZCBpcyBub3QgZW1wdHksIHNvIGl0J3MgYSBub3JtYWwgY29tbWFuZC5cclxuICAgICAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZC5nZXRQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kcygpW3BsYXRmb3JtX2lkXSA9IHNoZWxsX2NvbW1hbmQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaGVsbF9jb21tYW5kIGlzIGVtcHR5LCBzbyB0aGUgZGVmYXVsdCBjb21tYW5kIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRfc2hlbGxfY29tbWFuZC5nZXRQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kcygpW3BsYXRmb3JtX2lkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0RGVmYXVsdFNoZWxsQ29tbWFuZCgpLFxyXG4gICAgKTtcclxuICAgIHNldHRpbmdfZ3JvdXAubmFtZV9zZXR0aW5nLnNldERlc2MoXCJJZiBlbXB0eSwgdGhlIGRlZmF1bHQgc2hlbGwgY29tbWFuZCB3aWxsIGJlIHVzZWQgb24gXCIgKyBwbGF0Zm9ybV9uYW1lICsgXCIuXCIpO1xyXG4gICAgcmV0dXJuIHNldHRpbmdfZ3JvdXA7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge3NldEljb259IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWIge1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIGljb246IHN0cmluZztcclxuICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYlN0cnVjdHVyZSB7XHJcbiAgICBoZWFkZXI6IEhUTUxFbGVtZW50LFxyXG4gICAgYWN0aXZlX3RhYl9pZDogc3RyaW5nLFxyXG4gICAgYnV0dG9uczoge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IEhUTUxFbGVtZW50LFxyXG4gICAgfVxyXG4gICAgY29udGVudENvbnRhaW5lcnM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCxcclxuICAgIH0sXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFicyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBUYWI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUYWJDb250ZW50Q29udGFpbmVycyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCxcclxufVxyXG5cclxuaW50ZXJmYWNlIFRhYkJ1dHRvbnMge1xyXG4gICAgW2tleTogc3RyaW5nXTogSFRNTEVsZW1lbnQsXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWJzKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgdGFiczogVGFicyk6IFRhYlN0cnVjdHVyZSB7XHJcbiAgICBjb25zdCB0YWJfaGVhZGVyID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJkaXZcIiwge2F0dHI6IHtjbGFzczogXCJTQy10YWItaGVhZGVyXCJ9fSk7XHJcbiAgICBjb25zdCB0YWJfY29udGVudF9jb250YWluZXJzOiBUYWJDb250ZW50Q29udGFpbmVycyA9IHt9O1xyXG4gICAgY29uc3QgdGFiX2J1dHRvbnM6IFRhYkJ1dHRvbnMgPSB7fTtcclxuICAgIGNvbnN0IHRhYl9zdHJ1Y3R1cmUgPSB7XHJcbiAgICAgICAgaGVhZGVyOiB0YWJfaGVhZGVyLFxyXG4gICAgICAgIGFjdGl2ZV90YWJfaWQ6IE9iamVjdC5rZXlzKHRhYnMpWzBdIGFzIHN0cmluZywgLy8gSW5kaWNhdGUgdGhhdCB0aGUgZmlyc3QgdGFiIGlzIGFjdGl2ZS4gVGhpcyBkb2VzIG5vdCBhZmZlY3Qgd2hhdCB0YWIgaXMgYWN0aXZlIGluIHByYWN0aXNlLCBpdCBqdXN0IHJlcG9ydHMgdGhlIGFjdGl2ZSB0YWIuXHJcbiAgICAgICAgYnV0dG9uczogdGFiX2J1dHRvbnMsXHJcbiAgICAgICAgY29udGVudENvbnRhaW5lcnM6IHRhYl9jb250ZW50X2NvbnRhaW5lcnMsXHJcbiAgICB9O1xyXG4gICAgbGV0IGZpcnN0X2J1dHRvbjogSFRNTEVsZW1lbnQ7XHJcbiAgICBmb3IgKGNvbnN0IHRhYl9pZCBpbiB0YWJzKSB7XHJcbiAgICAgICAgY29uc3QgdGFiID0gdGFic1t0YWJfaWRdO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYnV0dG9uXHJcbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGFiX2hlYWRlci5jcmVhdGVFbChcImJ1dHRvblwiLCB7XHJcbiAgICAgICAgICAgIGF0dHI6IHtcclxuICAgICAgICAgICAgICAgIGNsYXNzOiBcIlNDLXRhYi1oZWFkZXItYnV0dG9uXCIsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZVRhYjogXCJTQy10YWItXCIgKyB0YWJfaWQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFiX2J1dHRvbiA9IHRoaXMgYXMgSFRNTEVsZW1lbnQ7IC8vIFVzZSAndGhpcycgaW5zdGVhZCBvZiBldmVudC50YXJnZXQgYmVjYXVzZSB0aGlzIHdheSB3ZSdsbCBhbHdheXMgZ2V0IGEgYnV0dG9uIGVsZW1lbnQsIG5vdCBhbiBlbGVtZW50IGluc2lkZSB0aGUgIGJ1dHRvbiAoaS5lLiBhbiBpY29uKS5cclxuXHJcbiAgICAgICAgICAgIC8vIEhpZGUgYWxsIHRhYiBjb250ZW50cyBhbmQgZ2V0IHRoZSBtYXggZGltZW5zaW9uc1xyXG4gICAgICAgICAgICBsZXQgbWF4X3dpZHRoID0gMDtcclxuICAgICAgICAgICAgbGV0IG1heF9oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB0YWJfaGVhZGVyID0gdGFiX2J1dHRvbi5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJfZWxlbWVudCA9IHRhYl9oZWFkZXIucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgY29uc3QgdGFiX2NvbnRlbnRzID0gY29udGFpbmVyX2VsZW1lbnQuZmluZEFsbChcImRpdi5TQy10YWItY29udGVudFwiKTsgLy8gRG8gbm90IGdldCBhbGwgdGFiIGNvbnRlbnRzIHRoYXQgZXhpc3QsIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgdGFiIHN5c3RlbXMgb3BlbiBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgICAgICBjb25zdCBpc19tYWluX3NldHRpbmdzX21vZGFsID0gY29udGFpbmVyX2VsZW1lbnQuaGFzQ2xhc3MoXCJ2ZXJ0aWNhbC10YWItY29udGVudFwiKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiB0YWJfY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYl9jb250ZW50ID0gdGFiX2NvbnRlbnRzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG1heGltdW0gdGFiIGRpbWVuc2lvbnMgc28gdGhhdCBhbGwgdGFicyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICAgICAgLy8gQnV0IGRvbid0IGRvIGl0IGlmIHRoaXMgaXMgdGhlIG1haW4gc2V0dGluZ3MgbW9kYWxcclxuICAgICAgICAgICAgICAgIGlmICghaXNfbWFpbl9zZXR0aW5nc19tb2RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhYl9jb250ZW50LmFkZENsYXNzKFwiU0MtdGFiLWFjdGl2ZVwiKTsgLy8gTmVlZCB0byBtYWtlIHRoZSB0YWIgdmlzaWJsZSB0ZW1wb3JhcmlseSBpbiBvcmRlciB0byBnZXQgdGhlIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYl9jb250ZW50Lm9mZnNldEhlaWdodCA+IG1heF9oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4X2hlaWdodCA9IHRhYl9jb250ZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYl9jb250ZW50Lm9mZnNldFdpZHRoID4gbWF4X3dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF93aWR0aCA9IHRhYl9jb250ZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5IGhpZGUgdGhlIHRhYlxyXG4gICAgICAgICAgICAgICAgdGFiX2NvbnRlbnQucmVtb3ZlQ2xhc3MoXCJTQy10YWItYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWN0aXZlIHN0YXR1cyBmcm9tIGFsbCBidXR0b25zXHJcbiAgICAgICAgICAgIGNvbnN0IGFkamFjZW50X3RhYl9idXR0b25zID0gdGFiX2hlYWRlci5maW5kQWxsKFwiLlNDLXRhYi1oZWFkZXItYnV0dG9uXCIpOyAvLyBEbyBub3QgZ2V0IGFsbCB0YWIgYnV0dG9ucyB0aGF0IGV4aXN0LCBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIHRhYiBzeXN0ZW1zIG9wZW4gYXQgdGhlIHNhbWUgdGltZS5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiBhZGphY2VudF90YWJfYnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFiX2J1dHRvbiA9IGFkamFjZW50X3RhYl9idXR0b25zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHRhYl9idXR0b24ucmVtb3ZlQ2xhc3MoXCJTQy10YWItYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgY2xpY2tlZCB0YWJcclxuICAgICAgICAgICAgdGFiX2J1dHRvbi5hZGRDbGFzcyhcIlNDLXRhYi1hY3RpdmVcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2YXRlX3RhYl9pZCA9IHRhYl9idXR0b24uYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oXCJhY3RpdmF0ZVRhYlwiKS52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgdGFiX2NvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhY3RpdmF0ZV90YWJfaWQpO1xyXG4gICAgICAgICAgICB0YWJfY29udGVudC5hZGRDbGFzcyhcIlNDLXRhYi1hY3RpdmVcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIHRoZSBjbGlja2VkIHRhYiBhcyBhY3RpdmUgaW4gVGFiU3RydWN0dXJlIChqdXN0IHRvIHJlcG9ydCB3aGljaCB0YWIgaXMgY3VycmVudGx5IGFjdGl2ZSlcclxuICAgICAgICAgICAgdGFiX3N0cnVjdHVyZS5hY3RpdmVfdGFiX2lkID0gYWN0aXZhdGVfdGFiX2lkLnJlcGxhY2UoL15TQy10YWItLywgXCJcIik7IC8vIFJlbW92ZSBcIlNDLXRhYlwiIHByZWZpeC5cclxuXHJcbiAgICAgICAgICAgIC8vIEZvY3VzIGFuIGVsZW1lbnQgKGlmIGEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgcHJlc2VudClcclxuICAgICAgICAgICAgdGFiX2NvbnRlbnQuZmluZChcIi5TQy1mb2N1cy1lbGVtZW50LW9uLXRhYi1vcGVuaW5nXCIpPy5mb2N1cygpIC8vID8gPSBJZiBub3QgZm91bmQsIGRvIG5vdGhpbmcuXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgbWF4IGRpbWVuc2lvbnMgdG8gdGhpcyB0YWJcclxuICAgICAgICAgICAgLy8gQnV0IGRvbid0IGRvIGl0IGlmIHRoaXMgaXMgdGhlIG1haW4gc2V0dGluZ3MgbW9kYWxcclxuICAgICAgICAgICAgaWYgKCFpc19tYWluX3NldHRpbmdzX21vZGFsKSB7XHJcbiAgICAgICAgICAgICAgICB0YWJfY29udGVudC5zdHlsZS53aWR0aCA9IG1heF93aWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRhYl9jb250ZW50LnN0eWxlLmhlaWdodCA9IG1heF9oZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgZWxzZSAoSSBkb24ndCBrbm93IGlmIHRoaXMgaXMgbmVlZGVkIG9yIG5vdClcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNldEljb24oYnV0dG9uLCB0YWIuaWNvbik7XHJcbiAgICAgICAgYnV0dG9uLmluc2VydEFkamFjZW50VGV4dChcImJlZm9yZWVuZFwiLCBcIiBcIiArIHRhYi50aXRsZSk7XHJcbiAgICAgICAgdGFiX2J1dHRvbnNbdGFiX2lkXSA9IGJ1dHRvbjtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRlbnQgY29udGFpbmVyXHJcbiAgICAgICAgdGFiX2NvbnRlbnRfY29udGFpbmVyc1t0YWJfaWRdID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJkaXZcIiwge2F0dHI6IHtjbGFzczogXCJTQy10YWItY29udGVudFwiLCBpZDogXCJTQy10YWItXCIgKyB0YWJfaWR9fSk7XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIGNvbnRlbnRcclxuICAgICAgICB0YWIuY29udGVudF9nZW5lcmF0b3IodGFiX2NvbnRlbnRfY29udGFpbmVyc1t0YWJfaWRdKTtcclxuXHJcbiAgICAgICAgLy8gTWVtb3JpemUgdGhlIGZpcnN0IHRhYidzIGJ1dHRvblxyXG4gICAgICAgIGlmICghZmlyc3RfYnV0dG9uKSB7XHJcbiAgICAgICAgICAgIGZpcnN0X2J1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWN0aXZhdGUgdGhlIGZpcnN0IHRhYlxyXG4gICAgaWYgKGZpcnN0X2J1dHRvbikge1xyXG4gICAgICAgIGZpcnN0X2J1dHRvbi5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiB0aGUgVGFiU3RydWN0dXJlXHJcbiAgICByZXR1cm4gdGFiX3N0cnVjdHVyZTtcclxufVxyXG5cclxuIiwiLypcclxuICogJ1NoZWxsIGNvbW1hbmRzJyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjEgLSAyMDIyIEphcmtrbyBMaW5uYW52aXJ0YVxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4vU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X29uTGF5b3V0UmVhZHkgZXh0ZW5kcyBTQ19FdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcIm9uLWxheW91dC1yZWFkeVwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiT2JzaWRpYW4gc3RhcnRzXCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVnaXN0ZXJfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3MgPSBmYWxzZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3JlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KGFzeW5jICgpID0+IGF3YWl0IHRoaXMudHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQpKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBiYXNlIGNsYXNzIGRvZXMgbm90IG5lZWQgdG8gcmVnaXN0ZXIgYW55dGhpbmcuXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF91bnJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCk6IHZvaWQge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gdW5yZWdpc3RlciwgYmVjYXVzZSB0aGlzIGV2ZW50IGhhcHBlbnMgb25seSBvbmNlIHdoZW4gT2JzaWRpYW4gc3RhcnRzLiBJZiB0aGUgZXZlbnQgaXMgbm90IGVuYWJsZWQgZm9yIGEgc2hlbGwgY29tbWFuZCwgbmV4dCB0aW1lIE9ic2lkaWFuIHN0YXJ0cywgdGhpcyBldmVudCB3b24ndCBnZXQgcmVnaXN0ZXJlZC5cclxuICAgIH1cclxuXHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX1dvcmtzcGFjZUV2ZW50fSBmcm9tIFwiLi9TQ19Xb3Jrc3BhY2VFdmVudFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X29uUXVpdCBleHRlbmRzIFNDX1dvcmtzcGFjZUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwib24tcXVpdFwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiT2JzaWRpYW4gcXVpdHNcIjtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB3b3Jrc3BhY2VfZXZlbnQgPSBcInF1aXRcIjtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U0NfV29ya3NwYWNlRXZlbnR9IGZyb20gXCIuL1NDX1dvcmtzcGFjZUV2ZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU0NfRXZlbnRfb25BY3RpdmVMZWFmQ2hhbmdlZCBleHRlbmRzIFNDX1dvcmtzcGFjZUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwib24tYWN0aXZlLWxlYWYtY2hhbmdlZFwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiU3dpdGNoaW5nIHRoZSBhY3RpdmUgcGFuZVwiO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtzcGFjZV9ldmVudCA9IFwiYWN0aXZlLWxlYWYtY2hhbmdlXCI7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi9TQ19FdmVudFwiO1xyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9TQ19FdmVudENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHtOb3RpY2UsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9FdmVyeU5TZWNvbmRzIGV4dGVuZHMgU0NfRXZlbnQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF9jb2RlID0gXCJldmVyeS1uLXNlY29uZHNcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkV2ZXJ5IG4gc2Vjb25kc1wiO1xyXG4gICAgcHJvdGVjdGVkIGRlZmF1bHRfY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICBzZWNvbmRzOiA2MCxcclxuICAgIH07XHJcbiAgICBwcml2YXRlIGludGVydmFsc19pZHM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBudW1iZXI7IC8vIGtleTogVFNoZWxsQ29tbWFuZCBpZCwgdmFsdWU6IHNldEludGVydmFsKCkgaWQuXHJcbiAgICB9ID0ge307XHJcblxyXG4gICAgcHJvdGVjdGVkIF9yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICBjb25zdCBtaWxsaXNlY29uZHM6IG51bWJlciA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQpLnNlY29uZHMgKiAxMDAwO1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsX2lkOiBudW1iZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoXHJcbiAgICAgICAgICAgIGFzeW5jICgpID0+IGF3YWl0IHRoaXMudHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQpLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMsXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckludGVydmFsKGludGVydmFsX2lkKTtcclxuICAgICAgICB0aGlzLmludGVydmFsc19pZHNbdF9zaGVsbF9jb21tYW5kLmdldElkKCldID0gaW50ZXJ2YWxfaWQ7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUaGUgYmFzZSBjbGFzcyBkb2VzIG5vdCBuZWVkIHRvIHJlZ2lzdGVyIGFueXRoaW5nLlxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdW5yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiB2b2lkIHtcclxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsc19pZHNbdF9zaGVsbF9jb21tYW5kLmdldElkKCldKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gb25seSB0byBjaGFuZ2UgdGhlIHJldHVybiB0eXBlLlxyXG4gICAgICogQHBhcmFtIHRfc2hlbGxfY29tbWFuZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiBDb25maWd1cmF0aW9uIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQpIGFzIENvbmZpZ3VyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUV4dHJhU2V0dGluZ3NGaWVsZHMoZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbiA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgIGxldCBhcHBseV9zZWNvbmRzOiBudW1iZXI7XHJcbiAgICAgICAgbmV3IFNldHRpbmcoZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIlNlY29uZHNcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJOZWVkcyB0byBiZSBhdCBsZWFzdCAxLiBDdXJyZW50bHkgc3VwcG9ydHMgb25seSBpbnRlZ2Vycy5cIilcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY29uZmlndXJhdGlvbi5zZWNvbmRzLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoKHJhd192YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfc2Vjb25kcyA9IHBhcnNlSW50KHJhd192YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2F2ZSBoZXJlLCBiZWNhdXNlIHRoZSB1c2VyIG1pZ2h0IHN0aWxsIGJlIGVkaXRpbmcgdGhlIG51bWJlci5cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJBcHBseVwiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT0gYXBwbHlfc2Vjb25kcyB8fCBhcHBseV9zZWNvbmRzID09PSB0aGlzLmdldENvbmZpZ3VyYXRpb24odF9zaGVsbF9jb21tYW5kKS5zZWNvbmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJZb3UgZGlkbid0IGNoYW5nZSB0aGUgc2Vjb25kcyFcIilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGFwcGx5X3NlY29uZHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUaGUgc2Vjb25kcyBuZWVkIHRvIGJlIGFuIGludGVnZXIhXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcHBseV9zZWNvbmRzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlRoZSBzZWNvbmRzIG5lZWQgdG8gYmUgYXQgbGVhc3QgMSFcIilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgb2ssIHNhdmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQpLnNlY29uZHMgPSBhcHBseV9zZWNvbmRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlZ2lzdGVyIHRvIGFwcGx5IHRoZSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpY2VBYm91dEVuYWJsaW5nKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkFmdGVyRW5hYmxpbmcodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5ub3RpY2VBYm91dEVuYWJsaW5nKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBub3RpY2VBYm91dEVuYWJsaW5nKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIG5ldyBOb3RpY2UoXCJUaGUgc2hlbGwgY29tbWFuZCB3aWxsIHJ1biBldmVyeSBcIiArIHRoaXMuZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQpLnNlY29uZHMgKyBcIiBzZWNvbmRzXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29uZmlndXJhdGlvbiBleHRlbmRzIFNDX0V2ZW50Q29uZmlndXJhdGlvbiB7XHJcbiAgICBzZWNvbmRzOiBudW1iZXIsXHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7RWRpdG9yLCBNYXJrZG93blZpZXcsIE1lbnV9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge1NDX01lbnVFdmVudH0gZnJvbSBcIi4vU0NfTWVudUV2ZW50XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU0NfRXZlbnRfRWRpdG9yTWVudSBleHRlbmRzIFNDX01lbnVFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcImVkaXRvci1tZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJFZGl0b3IgbWVudVwiO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtzcGFjZV9ldmVudCA9IFwiZWRpdG9yLW1lbnVcIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0VHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICByZXR1cm4gYXN5bmMgKG1lbnU6IE1lbnUsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRUU2hlbGxDb21tYW5kVG9NZW51KHRfc2hlbGxfY29tbWFuZCwgbWVudSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfb25MYXlvdXRSZWFkeX0gZnJvbSBcIi4vU0NfRXZlbnRfb25MYXlvdXRSZWFkeVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X29uUXVpdH0gZnJvbSBcIi4vU0NfRXZlbnRfb25RdWl0XCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfb25BY3RpdmVMZWFmQ2hhbmdlZH0gZnJvbSBcIi4vU0NfRXZlbnRfb25BY3RpdmVMZWFmQ2hhbmdlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0V2ZXJ5TlNlY29uZHN9IGZyb20gXCIuL1NDX0V2ZW50X0V2ZXJ5TlNlY29uZHNcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4vU0NfRXZlbnRfRmlsZU1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJNZW51fSBmcm9tIFwiLi9TQ19FdmVudF9Gb2xkZXJNZW51XCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRWRpdG9yTWVudX0gZnJvbSBcIi4vU0NfRXZlbnRfRWRpdG9yTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDcmVhdGVkfSBmcm9tIFwiLi9TQ19FdmVudF9GaWxlQ3JlYXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVEZWxldGVkfSBmcm9tIFwiLi9TQ19FdmVudF9GaWxlRGVsZXRlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWR9IGZyb20gXCIuL1NDX0V2ZW50X0ZpbGVDb250ZW50TW9kaWZpZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTW92ZWR9IGZyb20gXCIuL1NDX0V2ZW50X0ZpbGVNb3ZlZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVSZW5hbWVkfSBmcm9tIFwiLi9TQ19FdmVudF9GaWxlUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlckNyZWF0ZWR9IGZyb20gXCIuL1NDX0V2ZW50X0ZvbGRlckNyZWF0ZWRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9Gb2xkZXJEZWxldGVkfSBmcm9tIFwiLi9TQ19FdmVudF9Gb2xkZXJEZWxldGVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRm9sZGVyTW92ZWR9IGZyb20gXCIuL1NDX0V2ZW50X0ZvbGRlck1vdmVkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRm9sZGVyUmVuYW1lZH0gZnJvbSBcIi4vU0NfRXZlbnRfRm9sZGVyUmVuYW1lZFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi9TQ19FdmVudFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNDX0V2ZW50cyhwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZ2V0U0NfRXZlbnRzLmV2ZW50cykge1xyXG4gICAgICAgIC8vIENhY2hlIHRoZSBsaXN0IG9mIFNDX0V2ZW50IG9iamVjdHNcclxuICAgICAgICBnZXRTQ19FdmVudHMuZXZlbnRzID0gW1xyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfb25MYXlvdXRSZWFkeShwbHVnaW4pLFxyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfb25RdWl0KHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9vbkFjdGl2ZUxlYWZDaGFuZ2VkKHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9FdmVyeU5TZWNvbmRzKHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9GaWxlTWVudShwbHVnaW4pLFxyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfRm9sZGVyTWVudShwbHVnaW4pLFxyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfRWRpdG9yTWVudShwbHVnaW4pLFxyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfRmlsZUNvbnRlbnRNb2RpZmllZChwbHVnaW4pLFxyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfRmlsZUNyZWF0ZWQocGx1Z2luKSxcclxuICAgICAgICAgICAgbmV3IFNDX0V2ZW50X0ZpbGVEZWxldGVkKHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9GaWxlTW92ZWQocGx1Z2luKSxcclxuICAgICAgICAgICAgbmV3IFNDX0V2ZW50X0ZpbGVSZW5hbWVkKHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9Gb2xkZXJDcmVhdGVkKHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9Gb2xkZXJEZWxldGVkKHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9Gb2xkZXJNb3ZlZChwbHVnaW4pLFxyXG4gICAgICAgICAgICBuZXcgU0NfRXZlbnRfRm9sZGVyUmVuYW1lZChwbHVnaW4pLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0U0NfRXZlbnRzLmV2ZW50cztcclxufVxyXG5nZXRTQ19FdmVudHMuZXZlbnRzID0gdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNDX0V2ZW50KHBsdWdpbjogU0NfUGx1Z2luLCBzY19ldmVudF9jbGFzczogdHlwZW9mIFNDX0V2ZW50KSB7XHJcbiAgICBsZXQgZm91bmRfc2NfZXZlbnQ6IFNDX0V2ZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgZ2V0U0NfRXZlbnRzKHBsdWdpbikuZm9yRWFjaCgoc2NfZXZlbnQ6IFNDX0V2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHNjX2V2ZW50IGluc3RhbmNlb2Ygc2NfZXZlbnRfY2xhc3MpIHtcclxuICAgICAgICAgICAgZm91bmRfc2NfZXZlbnQgPSBzY19ldmVudDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmb3VuZF9zY19ldmVudDtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzLjAgb2YgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxyXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxyXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGVcclxuICogR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXHJcbiAqXHJcbiAqIENvbnRhY3QgdGhlIGF1dGhvciAoSmFya2tvIExpbm5hbnZpcnRhKTogaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtzZXRJY29ufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4vRGVidWdcIjtcclxuaW1wb3J0IHt1bmlxdWVBcnJheX0gZnJvbSBcIi4vQ29tbW9uXCI7XHJcblxyXG4vKipcclxuICogQSB3cmFwcGVyIGZvciBPYnNpZGlhbidzIHNldEljb24oKSwgYnV0IHdpdGggdGhlIGRpZmZlcmVuY2UgdGhhdCB0aGlzIG9uZSBkb2VzIG5vdCBuZWVkIGEgY29udGFpbmVyIGFzIGEgcGFyYW1ldGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEljb25IVE1MKGljb25faWQ6IHN0cmluZykge1xyXG4gICAgaWYgKCFpY29uX2lkKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpY29uX2NvbnRhaW5lciA9IGRvY3VtZW50LmJvZHkuY3JlYXRlRWwoXCJkaXZcIik7IC8vIEEgdGVtcG9yYXJ5IGVsZW1lbnQsIHdpbGwgYmUgZGVsZXRlZCBzb29uLiBOb3QgbmljZSB0byBjcmVhdGUgYSB0ZW1wb3JhcnkgZWxlbWVudCBpbiB0aGUgYm9keSwgYnV0IEkgZG9uJ3Qga25vdyBhbnkgYmV0dGVyIHdheS5cclxuICAgIGRlYnVnTG9nKGljb25faWQpOyAvLyBUT0RPOiBEbyBub3QgY29tbWl0LlxyXG4gICAgc2V0SWNvbihpY29uX2NvbnRhaW5lciwgaWNvbl9pZCk7XHJcbiAgICBjb25zdCBpY29uX2h0bWwgPSBpY29uX2NvbnRhaW5lci5pbm5lckhUTUw7XHJcbiAgICBpY29uX2NvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgIHJldHVybiBpY29uX2h0bWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFRoZSBsaXN0IGlzIHByb3ZpZGVkIGJ5IHBoaWJyMC5cclxuICogQGxpbmsgaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82ODYwNTM3MDgyNjEyMjg1NzcvODQwMjg2MjY0OTY0MDIyMzAyLzk2ODI0ODU4ODY0MTY2NTA3NVxyXG4gKiBAZGVzY3JpcHRpb24gcGhpYnIwOiBcIlVwZGF0ZWQgSWNvbiBMaXN0IGZvciBPYnNpZGlhbiB2MC4xNC43KyAobHVjaWRlIGljb25zIHYwLjMwLjAgKyBvYnNpZGlhbnMgb3duKVwiXHJcbiAqIEBjb3B5cmlnaHQgVGhlIGNvcHlyaWdodCBzdGF0ZW1lbnQgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUgZG9lcyBub3QgYWZmZWN0IHRoaXMgbGlzdCBvZiBpY29ucy5cclxuICogVE9ETzogVGhlIGxpc3Qgc2VlbXMgdG8gbWlzcyBzb21lIGljb25zLCBhdCBsZWFzdCAnZ2VhcicuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSUNPTl9MSVNUID0gW1wiYWN0aXZpdHlcIixcImFpcnBsYXlcIixcImFsYXJtLWNoZWNrXCIsXCJhbGFybS1jbG9jay1vZmZcIixcImFsYXJtLWNsb2NrXCIsXCJhbGFybS1taW51c1wiLFwiYWxhcm0tcGx1c1wiLFwiYWxidW1cIixcImFsZXJ0LWNpcmNsZVwiLFwiYWxlcnQtb2N0YWdvblwiLFwiYWxlcnQtdHJpYW5nbGVcIixcImFsaWduLWNlbnRlci1ob3Jpem9udGFsXCIsXCJhbGlnbi1jZW50ZXItdmVydGljYWxcIixcImFsaWduLWNlbnRlclwiLFwiYWxpZ24tZW5kLWhvcml6b250YWxcIixcImFsaWduLWVuZC12ZXJ0aWNhbFwiLFwiYWxpZ24taG9yaXpvbnRhbC1kaXN0cmlidXRlLWNlbnRlclwiLFwiYWxpZ24taG9yaXpvbnRhbC1kaXN0cmlidXRlLWVuZFwiLFwiYWxpZ24taG9yaXpvbnRhbC1kaXN0cmlidXRlLXN0YXJ0XCIsXCJhbGlnbi1ob3Jpem9udGFsLWp1c3RpZnktY2VudGVyXCIsXCJhbGlnbi1ob3Jpem9udGFsLWp1c3RpZnktZW5kXCIsXCJhbGlnbi1ob3Jpem9udGFsLWp1c3RpZnktc3RhcnRcIixcImFsaWduLWhvcml6b250YWwtc3BhY2UtYXJvdW5kXCIsXCJhbGlnbi1ob3Jpem9udGFsLXNwYWNlLWJldHdlZW5cIixcImFsaWduLWp1c3RpZnlcIixcImFsaWduLWxlZnRcIixcImFsaWduLXJpZ2h0XCIsXCJhbGlnbi1zdGFydC1ob3Jpem9udGFsXCIsXCJhbGlnbi1zdGFydC12ZXJ0aWNhbFwiLFwiYWxpZ24tdmVydGljYWwtZGlzdHJpYnV0ZS1jZW50ZXJcIixcImFsaWduLXZlcnRpY2FsLWRpc3RyaWJ1dGUtZW5kXCIsXCJhbGlnbi12ZXJ0aWNhbC1kaXN0cmlidXRlLXN0YXJ0XCIsXCJhbGlnbi12ZXJ0aWNhbC1qdXN0aWZ5LWNlbnRlclwiLFwiYWxpZ24tdmVydGljYWwtanVzdGlmeS1lbmRcIixcImFsaWduLXZlcnRpY2FsLWp1c3RpZnktc3RhcnRcIixcImFsaWduLXZlcnRpY2FsLXNwYWNlLWFyb3VuZFwiLFwiYWxpZ24tdmVydGljYWwtc3BhY2UtYmV0d2VlblwiLFwiYW5jaG9yXCIsXCJhcGVydHVyZVwiLFwiYXJjaGl2ZVwiLFwiYXJyb3ctYmlnLWRvd25cIixcImFycm93LWJpZy1sZWZ0XCIsXCJhcnJvdy1iaWctcmlnaHRcIixcImFycm93LWJpZy11cFwiLFwiYXJyb3ctZG93bi1jaXJjbGVcIixcImFycm93LWRvd24tbGVmdFwiLFwiYXJyb3ctZG93bi1yaWdodFwiLFwiYXJyb3ctZG93blwiLFwiYXJyb3ctbGVmdC1jaXJjbGVcIixcImFycm93LWxlZnQtcmlnaHRcIixcImFycm93LWxlZnRcIixcImFycm93LXJpZ2h0LWNpcmNsZVwiLFwiYXJyb3ctcmlnaHRcIixcImFycm93LXVwLWNpcmNsZVwiLFwiYXJyb3ctdXAtbGVmdFwiLFwiYXJyb3ctdXAtcmlnaHRcIixcImFycm93LXVwXCIsXCJhc3Rlcmlza1wiLFwiYXQtc2lnblwiLFwiYXdhcmRcIixcImF4ZVwiLFwiYmFua25vdGVcIixcImJhci1jaGFydC0yXCIsXCJiYXItY2hhcnRcIixcImJhc2VsaW5lXCIsXCJiYXR0ZXJ5LWNoYXJnaW5nXCIsXCJiYXR0ZXJ5LWZ1bGxcIixcImJhdHRlcnktbG93XCIsXCJiYXR0ZXJ5LW1lZGl1bVwiLFwiYmF0dGVyeVwiLFwiYmVha2VyXCIsXCJiZWxsLW1pbnVzXCIsXCJiZWxsLW9mZlwiLFwiYmVsbC1wbHVzXCIsXCJiZWxsLXJpbmdcIixcImJlbGxcIixcImJpa2VcIixcImJpbmFyeVwiLFwiYml0Y29pblwiLFwiYmx1ZXRvb3RoLWNvbm5lY3RlZFwiLFwiYmx1ZXRvb3RoLW9mZlwiLFwiYmx1ZXRvb3RoLXNlYXJjaGluZ1wiLFwiYmx1ZXRvb3RoXCIsXCJib2xkXCIsXCJib29rLW9wZW5cIixcImJvb2tcIixcImJvb2ttYXJrLW1pbnVzXCIsXCJib29rbWFyay1wbHVzXCIsXCJib29rbWFya1wiLFwiYm90XCIsXCJib3gtc2VsZWN0XCIsXCJib3hcIixcImJyaWVmY2FzZVwiLFwiYnJ1c2hcIixcImJ1Z1wiLFwiYnVpbGRpbmctMlwiLFwiYnVpbGRpbmdcIixcImJ1c1wiLFwiY2FsY3VsYXRvclwiLFwiY2FsZW5kYXJcIixcImNhbWVyYS1vZmZcIixcImNhbWVyYVwiLFwiY2FyXCIsXCJjYXJyb3RcIixcImNhc3RcIixcImNoZWNrLWNpcmNsZS0yXCIsXCJjaGVjay1jaXJjbGVcIixcImNoZWNrLXNxdWFyZVwiLFwiY2hlY2tcIixcImNoZXZyb24tZG93blwiLFwiY2hldnJvbi1maXJzdFwiLFwiY2hldnJvbi1sYXN0XCIsXCJjaGV2cm9uLWxlZnRcIixcImNoZXZyb24tcmlnaHRcIixcImNoZXZyb24tdXBcIixcImNoZXZyb25zLWRvd24tdXBcIixcImNoZXZyb25zLWRvd25cIixcImNoZXZyb25zLWxlZnRcIixcImNoZXZyb25zLXJpZ2h0XCIsXCJjaGV2cm9ucy11cC1kb3duXCIsXCJjaGV2cm9ucy11cFwiLFwiY2hyb21lXCIsXCJjaXJjbGUtc2xhc2hlZFwiLFwiY2lyY2xlXCIsXCJjbGlwYm9hcmQtY2hlY2tcIixcImNsaXBib2FyZC1jb3B5XCIsXCJjbGlwYm9hcmQtbGlzdFwiLFwiY2xpcGJvYXJkLXhcIixcImNsaXBib2FyZFwiLFwiY2xvY2stMVwiLFwiY2xvY2stMTBcIixcImNsb2NrLTExXCIsXCJjbG9jay0xMlwiLFwiY2xvY2stMlwiLFwiY2xvY2stM1wiLFwiY2xvY2stNFwiLFwiY2xvY2stNVwiLFwiY2xvY2stNlwiLFwiY2xvY2stN1wiLFwiY2xvY2stOFwiLFwiY2xvY2stOVwiLFwiY2xvY2tcIixcImNsb3VkLWRyaXp6bGVcIixcImNsb3VkLWZvZ1wiLFwiY2xvdWQtaGFpbFwiLFwiY2xvdWQtbGlnaHRuaW5nXCIsXCJjbG91ZC1tb29uXCIsXCJjbG91ZC1vZmZcIixcImNsb3VkLXJhaW4td2luZFwiLFwiY2xvdWQtcmFpblwiLFwiY2xvdWQtc25vd1wiLFwiY2xvdWQtc3VuXCIsXCJjbG91ZFwiLFwiY2xvdWR5XCIsXCJjbG92ZXJcIixcImNvZGUtMlwiLFwiY29kZVwiLFwiY29kZXBlblwiLFwiY29kZXNhbmRib3hcIixcImNvZmZlZVwiLFwiY29pbnNcIixcImNvbHVtbnNcIixcImNvbW1hbmRcIixcImNvbXBhc3NcIixcImNvbnRhY3RcIixcImNvbnRyYXN0XCIsXCJjb29raWVcIixcImNvcHlcIixcImNvcHlsZWZ0XCIsXCJjb3B5cmlnaHRcIixcImNvcm5lci1kb3duLWxlZnRcIixcImNvcm5lci1kb3duLXJpZ2h0XCIsXCJjb3JuZXItbGVmdC1kb3duXCIsXCJjb3JuZXItbGVmdC11cFwiLFwiY29ybmVyLXJpZ2h0LWRvd25cIixcImNvcm5lci1yaWdodC11cFwiLFwiY29ybmVyLXVwLWxlZnRcIixcImNvcm5lci11cC1yaWdodFwiLFwiY3B1XCIsXCJjcmVkaXQtY2FyZFwiLFwiY3JvcFwiLFwiY3Jvc3NcIixcImNyb3NzaGFpclwiLFwiY3Jvd25cIixcImN1cnJlbmN5XCIsXCJkYXRhYmFzZVwiLFwiZGVsZXRlXCIsXCJkaWNlLTFcIixcImRpY2UtMlwiLFwiZGljZS0zXCIsXCJkaWNlLTRcIixcImRpY2UtNVwiLFwiZGljZS02XCIsXCJkaXNjXCIsXCJkaXZpZGUtY2lyY2xlXCIsXCJkaXZpZGUtc3F1YXJlXCIsXCJkaXZpZGVcIixcImRvbGxhci1zaWduXCIsXCJkb3dubG9hZC1jbG91ZFwiLFwiZG93bmxvYWRcIixcImRyaWJiYmxlXCIsXCJkcm9wbGV0XCIsXCJkcm9wbGV0c1wiLFwiZHJ1bXN0aWNrXCIsXCJlZGl0LTJcIixcImVkaXQtM1wiLFwiZWRpdFwiLFwiZWdnXCIsXCJlcXVhbC1ub3RcIixcImVxdWFsXCIsXCJlcmFzZXJcIixcImV1cm9cIixcImV4cGFuZFwiLFwiZXh0ZXJuYWwtbGlua1wiLFwiZXllLW9mZlwiLFwiZXllXCIsXCJmYWNlYm9va1wiLFwiZmFzdC1mb3J3YXJkXCIsXCJmZWF0aGVyXCIsXCJmaWdtYVwiLFwiZmlsZS1jaGVjay0yXCIsXCJmaWxlLWNoZWNrXCIsXCJmaWxlLWNvZGVcIixcImZpbGUtZGlnaXRcIixcImZpbGUtaW5wdXRcIixcImZpbGUtbWludXMtMlwiLFwiZmlsZS1taW51c1wiLFwiZmlsZS1vdXRwdXRcIixcImZpbGUtcGx1cy0yXCIsXCJmaWxlLXBsdXNcIixcImZpbGUtc2VhcmNoXCIsXCJmaWxlLXRleHRcIixcImZpbGUteC0yXCIsXCJmaWxlLXhcIixcImZpbGVcIixcImZpbGVzXCIsXCJmaWxtXCIsXCJmaWx0ZXJcIixcImZsYWctb2ZmXCIsXCJmbGFnLXRyaWFuZ2xlLWxlZnRcIixcImZsYWctdHJpYW5nbGUtcmlnaHRcIixcImZsYWdcIixcImZsYW1lXCIsXCJmbGFzaGxpZ2h0LW9mZlwiLFwiZmxhc2hsaWdodFwiLFwiZmxhc2stY29uaWNhbFwiLFwiZmxhc2stcm91bmRcIixcImZvbGRlci1taW51c1wiLFwiZm9sZGVyLW9wZW5cIixcImZvbGRlci1wbHVzXCIsXCJmb2xkZXJcIixcImZvcm0taW5wdXRcIixcImZvcndhcmRcIixcImZyYW1lXCIsXCJmcmFtZXJcIixcImZyb3duXCIsXCJmdW5jdGlvbi1zcXVhcmVcIixcImdhbWVwYWQtMlwiLFwiZ2FtZXBhZFwiLFwiZ2F1Z2VcIixcImdhdmVsXCIsXCJnZW1cIixcImdob3N0XCIsXCJnaWZ0XCIsXCJnaXQtYnJhbmNoLXBsdXNcIixcImdpdC1icmFuY2hcIixcImdpdC1jb21taXRcIixcImdpdC1mb3JrXCIsXCJnaXQtbWVyZ2VcIixcImdpdC1wdWxsLXJlcXVlc3RcIixcImdpdGh1YlwiLFwiZ2l0bGFiXCIsXCJnbGFzc2VzXCIsXCJnbG9iZS0yXCIsXCJnbG9iZVwiLFwiZ3JhYlwiLFwiZ3JhZHVhdGlvbi1jYXBcIixcImdyaWRcIixcImdyaXAtaG9yaXpvbnRhbFwiLFwiZ3JpcC12ZXJ0aWNhbFwiLFwiaGFtbWVyXCIsXCJoYW5kLW1ldGFsXCIsXCJoYW5kXCIsXCJoYXJkLWRyaXZlXCIsXCJoYXJkLWhhdFwiLFwiaGFzaFwiLFwiaGF6ZVwiLFwiaGVhZHBob25lc1wiLFwiaGVhcnRcIixcImhlbHAtY2lyY2xlXCIsXCJoZXhhZ29uXCIsXCJoaWdobGlnaHRlclwiLFwiaGlzdG9yeVwiLFwiaG9tZVwiLFwiaW1hZ2UtbWludXNcIixcImltYWdlLW9mZlwiLFwiaW1hZ2UtcGx1c1wiLFwiaW1hZ2VcIixcImltcG9ydFwiLFwiaW5ib3hcIixcImluZGVudFwiLFwiaW5kaWFuLXJ1cGVlXCIsXCJpbmZpbml0eVwiLFwiaW5mb1wiLFwiaW5zcGVjdFwiLFwiaW5zdGFncmFtXCIsXCJpdGFsaWNcIixcImphcGFuZXNlLXllblwiLFwia2V5XCIsXCJrZXlib2FyZFwiLFwibGFuZG1hcmtcIixcImxhbmd1YWdlc1wiLFwibGFwdG9wLTJcIixcImxhcHRvcFwiLFwibGFzc28tc2VsZWN0XCIsXCJsYXNzb1wiLFwibGF5ZXJzXCIsXCJsYXlvdXQtZGFzaGJvYXJkXCIsXCJsYXlvdXQtZ3JpZFwiLFwibGF5b3V0LWxpc3RcIixcImxheW91dC10ZW1wbGF0ZVwiLFwibGF5b3V0XCIsXCJsaWJyYXJ5XCIsXCJsaWZlLWJ1b3lcIixcImxpZ2h0YnVsYi1vZmZcIixcImxpZ2h0YnVsYlwiLFwibGluay0yLW9mZlwiLFwibGluay0yXCIsXCJsaW5rXCIsXCJsaW5rZWRpblwiLFwibGlzdC1jaGVja3NcIixcImxpc3QtbWludXNcIixcImxpc3Qtb3JkZXJlZFwiLFwibGlzdC1wbHVzXCIsXCJsaXN0LXhcIixcImxpc3RcIixcImxvYWRlci0yXCIsXCJsb2FkZXJcIixcImxvY2F0ZS1maXhlZFwiLFwibG9jYXRlLW9mZlwiLFwibG9jYXRlXCIsXCJsb2NrXCIsXCJsb2ctaW5cIixcImxvZy1vdXRcIixcIm1haWxcIixcIm1hcC1waW5cIixcIm1hcFwiLFwibWF4aW1pemUtMlwiLFwibWF4aW1pemVcIixcIm1lZ2FwaG9uZVwiLFwibWVoXCIsXCJtZW51XCIsXCJtZXNzYWdlLWNpcmNsZVwiLFwibWVzc2FnZS1zcXVhcmVcIixcIm1pYy1vZmZcIixcIm1pY1wiLFwibWluaW1pemUtMlwiLFwibWluaW1pemVcIixcIm1pbnVzLWNpcmNsZVwiLFwibWludXMtc3F1YXJlXCIsXCJtaW51c1wiLFwibW9uaXRvci1vZmZcIixcIm1vbml0b3Itc3BlYWtlclwiLFwibW9uaXRvclwiLFwibW9vblwiLFwibW9yZS1ob3Jpem9udGFsXCIsXCJtb3JlLXZlcnRpY2FsXCIsXCJtb3VudGFpbi1zbm93XCIsXCJtb3VudGFpblwiLFwibW91c2UtcG9pbnRlci0yXCIsXCJtb3VzZS1wb2ludGVyLWNsaWNrXCIsXCJtb3VzZS1wb2ludGVyXCIsXCJtb3VzZVwiLFwibW92ZS1kaWFnb25hbC0yXCIsXCJtb3ZlLWRpYWdvbmFsXCIsXCJtb3ZlLWhvcml6b250YWxcIixcIm1vdmUtdmVydGljYWxcIixcIm1vdmVcIixcIm11c2ljXCIsXCJuYXZpZ2F0aW9uLTJcIixcIm5hdmlnYXRpb25cIixcIm5ldHdvcmtcIixcIm9jdGFnb25cIixcIm9wdGlvblwiLFwib3V0ZGVudFwiLFwicGFja2FnZS1jaGVja1wiLFwicGFja2FnZS1taW51c1wiLFwicGFja2FnZS1wbHVzXCIsXCJwYWNrYWdlLXNlYXJjaFwiLFwicGFja2FnZS14XCIsXCJwYWNrYWdlXCIsXCJwYWxldHRlXCIsXCJwYWxtdHJlZVwiLFwicGFwZXJjbGlwXCIsXCJwYXVzZS1jaXJjbGVcIixcInBhdXNlLW9jdGFnb25cIixcInBhdXNlXCIsXCJwZW4tdG9vbFwiLFwicGVuY2lsXCIsXCJwZXJjZW50XCIsXCJwZXJzb24tc3RhbmRpbmdcIixcInBob25lLWNhbGxcIixcInBob25lLWZvcndhcmRlZFwiLFwicGhvbmUtaW5jb21pbmdcIixcInBob25lLW1pc3NlZFwiLFwicGhvbmUtb2ZmXCIsXCJwaG9uZS1vdXRnb2luZ1wiLFwicGhvbmVcIixcInBpZS1jaGFydFwiLFwicGlnZ3ktYmFua1wiLFwicGluXCIsXCJwaXBldHRlXCIsXCJwbGFuZVwiLFwicGxheS1jaXJjbGVcIixcInBsYXlcIixcInBsdWctemFwXCIsXCJwbHVzLWNpcmNsZVwiLFwicGx1cy1zcXVhcmVcIixcInBsdXNcIixcInBvY2tldFwiLFwicG9kY2FzdFwiLFwicG9pbnRlclwiLFwicG91bmQtc3RlcmxpbmdcIixcInBvd2VyLW9mZlwiLFwicG93ZXJcIixcInByaW50ZXJcIixcInFyLWNvZGVcIixcInF1b3RlXCIsXCJyYWRpby1yZWNlaXZlclwiLFwicmFkaW9cIixcInJlZG9cIixcInJlZnJlc2gtY2N3XCIsXCJyZWZyZXNoLWN3XCIsXCJyZWdleFwiLFwicmVwZWF0LTFcIixcInJlcGVhdFwiLFwicmVwbHktYWxsXCIsXCJyZXBseVwiLFwicmV3aW5kXCIsXCJyb2NrZXRcIixcInJvY2tpbmctY2hhaXJcIixcInJvdGF0ZS1jY3dcIixcInJvdGF0ZS1jd1wiLFwicnNzXCIsXCJydWxlclwiLFwicnVzc2lhbi1ydWJsZVwiLFwic2F2ZVwiLFwic2NhbGVcIixcInNjYW4tbGluZVwiLFwic2NhblwiLFwic2Npc3NvcnNcIixcInNjcmVlbi1zaGFyZS1vZmZcIixcInNjcmVlbi1zaGFyZVwiLFwic2VhcmNoXCIsXCJzZW5kXCIsXCJzZXBhcmF0b3ItaG9yaXpvbnRhbFwiLFwic2VwYXJhdG9yLXZlcnRpY2FsXCIsXCJzZXJ2ZXItY3Jhc2hcIixcInNlcnZlci1vZmZcIixcInNlcnZlclwiLFwic2V0dGluZ3MtMlwiLFwic2V0dGluZ3NcIixcInNoYXJlLTJcIixcInNoYXJlXCIsXCJzaGVldFwiLFwic2hpZWxkLWFsZXJ0XCIsXCJzaGllbGQtY2hlY2tcIixcInNoaWVsZC1jbG9zZVwiLFwic2hpZWxkLW9mZlwiLFwic2hpZWxkXCIsXCJzaGlydFwiLFwic2hvcHBpbmctYmFnXCIsXCJzaG9wcGluZy1jYXJ0XCIsXCJzaG92ZWxcIixcInNocmlua1wiLFwic2h1ZmZsZVwiLFwic2lkZWJhci1jbG9zZVwiLFwic2lkZWJhci1vcGVuXCIsXCJzaWRlYmFyXCIsXCJzaWdtYVwiLFwic2lnbmFsLWhpZ2hcIixcInNpZ25hbC1sb3dcIixcInNpZ25hbC1tZWRpdW1cIixcInNpZ25hbC16ZXJvXCIsXCJzaWduYWxcIixcInNraXAtYmFja1wiLFwic2tpcC1mb3J3YXJkXCIsXCJza3VsbFwiLFwic2xhY2tcIixcInNsYXNoXCIsXCJzbGlkZXJzXCIsXCJzbWFydHBob25lLWNoYXJnaW5nXCIsXCJzbWFydHBob25lXCIsXCJzbWlsZVwiLFwic25vd2ZsYWtlXCIsXCJzb3J0LWFzY1wiLFwic29ydC1kZXNjXCIsXCJzcGVha2VyXCIsXCJzcHJvdXRcIixcInNxdWFyZVwiLFwic3Rhci1oYWxmXCIsXCJzdGFyXCIsXCJzdG9wLWNpcmNsZVwiLFwic3RyZXRjaC1ob3Jpem9udGFsXCIsXCJzdHJldGNoLXZlcnRpY2FsXCIsXCJzdHJpa2V0aHJvdWdoXCIsXCJzdWJzY3JpcHRcIixcInN1blwiLFwic3VucmlzZVwiLFwic3Vuc2V0XCIsXCJzdXBlcnNjcmlwdFwiLFwic3dpc3MtZnJhbmNcIixcInN3aXRjaC1jYW1lcmFcIixcInRhYmxlXCIsXCJ0YWJsZXRcIixcInRhZ1wiLFwidGFyZ2V0XCIsXCJ0ZW50XCIsXCJ0ZXJtaW5hbC1zcXVhcmVcIixcInRlcm1pbmFsXCIsXCJ0ZXh0LWN1cnNvci1pbnB1dFwiLFwidGV4dC1jdXJzb3JcIixcInRoZXJtb21ldGVyLXNub3dmbGFrZVwiLFwidGhlcm1vbWV0ZXItc3VuXCIsXCJ0aGVybW9tZXRlclwiLFwidGh1bWJzLWRvd25cIixcInRodW1icy11cFwiLFwidGlja2V0XCIsXCJ0aW1lci1vZmZcIixcInRpbWVyLXJlc2V0XCIsXCJ0aW1lclwiLFwidG9nZ2xlLWxlZnRcIixcInRvZ2dsZS1yaWdodFwiLFwidG9ybmFkb1wiLFwidHJhc2gtMlwiLFwidHJhc2hcIixcInRyZWxsb1wiLFwidHJlbmRpbmctZG93blwiLFwidHJlbmRpbmctdXBcIixcInRyaWFuZ2xlXCIsXCJ0cnVja1wiLFwidHYtMlwiLFwidHZcIixcInR3aXRjaFwiLFwidHdpdHRlclwiLFwidHlwZVwiLFwidW1icmVsbGFcIixcInVuZGVybGluZVwiLFwidW5kb1wiLFwidW5saW5rLTJcIixcInVubGlua1wiLFwidW5sb2NrXCIsXCJ1cGxvYWQtY2xvdWRcIixcInVwbG9hZFwiLFwidXNlci1jaGVja1wiLFwidXNlci1taW51c1wiLFwidXNlci1wbHVzXCIsXCJ1c2VyLXhcIixcInVzZXJcIixcInVzZXJzXCIsXCJ2ZXJpZmllZFwiLFwidmlicmF0ZVwiLFwidmlkZW8tb2ZmXCIsXCJ2aWRlb1wiLFwidmlld1wiLFwidm9pY2VtYWlsXCIsXCJ2b2x1bWUtMVwiLFwidm9sdW1lLTJcIixcInZvbHVtZS14XCIsXCJ2b2x1bWVcIixcIndhbGxldFwiLFwid2FuZFwiLFwid2F0Y2hcIixcIndhdmVzXCIsXCJ3ZWJjYW1cIixcIndpZmktb2ZmXCIsXCJ3aWZpXCIsXCJ3aW5kXCIsXCJ3cmFwLXRleHRcIixcIndyZW5jaFwiLFwieC1jaXJjbGVcIixcIngtb2N0YWdvblwiLFwieC1zcXVhcmVcIixcInhcIixcInlvdXR1YmVcIixcInphcC1vZmZcIixcInphcFwiLFwiem9vbS1pblwiLFwiem9vbS1vdXRcIixcInNlYXJjaC1sYXJnZVwiLFwic2VhcmNoXCIsXCJhY3Rpdml0eVwiLFwiYWlycGxheVwiLFwiYWxhcm0tY2hlY2tcIixcImFsYXJtLWNsb2NrLW9mZlwiLFwiYWxhcm0tY2xvY2tcIixcImFsYXJtLW1pbnVzXCIsXCJhbGFybS1wbHVzXCIsXCJhbGJ1bVwiLFwiYWxlcnQtY2lyY2xlXCIsXCJhbGVydC1vY3RhZ29uXCIsXCJhbGVydC10cmlhbmdsZVwiLFwiYWxpZ24tY2VudGVyLWhvcml6b250YWxcIixcImFsaWduLWNlbnRlci12ZXJ0aWNhbFwiLFwiYWxpZ24tY2VudGVyXCIsXCJhbGlnbi1lbmQtaG9yaXpvbnRhbFwiLFwiYWxpZ24tZW5kLXZlcnRpY2FsXCIsXCJhbGlnbi1ob3Jpem9udGFsLWRpc3RyaWJ1dGUtY2VudGVyXCIsXCJhbGlnbi1ob3Jpem9udGFsLWRpc3RyaWJ1dGUtZW5kXCIsXCJhbGlnbi1ob3Jpem9udGFsLWRpc3RyaWJ1dGUtc3RhcnRcIixcImFsaWduLWhvcml6b250YWwtanVzdGlmeS1jZW50ZXJcIixcImFsaWduLWhvcml6b250YWwtanVzdGlmeS1lbmRcIixcImFsaWduLWhvcml6b250YWwtanVzdGlmeS1zdGFydFwiLFwiYWxpZ24taG9yaXpvbnRhbC1zcGFjZS1hcm91bmRcIixcImFsaWduLWhvcml6b250YWwtc3BhY2UtYmV0d2VlblwiLFwiYWxpZ24tanVzdGlmeVwiLFwiYWxpZ24tbGVmdFwiLFwiYWxpZ24tcmlnaHRcIixcImFsaWduLXN0YXJ0LWhvcml6b250YWxcIixcImFsaWduLXN0YXJ0LXZlcnRpY2FsXCIsXCJhbGlnbi12ZXJ0aWNhbC1kaXN0cmlidXRlLWNlbnRlclwiLFwiYWxpZ24tdmVydGljYWwtZGlzdHJpYnV0ZS1lbmRcIixcImFsaWduLXZlcnRpY2FsLWRpc3RyaWJ1dGUtc3RhcnRcIixcImFsaWduLXZlcnRpY2FsLWp1c3RpZnktY2VudGVyXCIsXCJhbGlnbi12ZXJ0aWNhbC1qdXN0aWZ5LWVuZFwiLFwiYWxpZ24tdmVydGljYWwtanVzdGlmeS1zdGFydFwiLFwiYWxpZ24tdmVydGljYWwtc3BhY2UtYXJvdW5kXCIsXCJhbGlnbi12ZXJ0aWNhbC1zcGFjZS1iZXR3ZWVuXCIsXCJhbmNob3JcIixcImFwZXJ0dXJlXCIsXCJhcmNoaXZlXCIsXCJhcnJvdy1iaWctZG93blwiLFwiYXJyb3ctYmlnLWxlZnRcIixcImFycm93LWJpZy1yaWdodFwiLFwiYXJyb3ctYmlnLXVwXCIsXCJhcnJvdy1kb3duLWNpcmNsZVwiLFwiYXJyb3ctZG93bi1sZWZ0XCIsXCJhcnJvdy1kb3duLXJpZ2h0XCIsXCJhcnJvdy1kb3duXCIsXCJhcnJvdy1sZWZ0LWNpcmNsZVwiLFwiYXJyb3ctbGVmdC1yaWdodFwiLFwiYXJyb3ctbGVmdFwiLFwiYXJyb3ctcmlnaHQtY2lyY2xlXCIsXCJhcnJvdy1yaWdodFwiLFwiYXJyb3ctdXAtY2lyY2xlXCIsXCJhcnJvdy11cC1sZWZ0XCIsXCJhcnJvdy11cC1yaWdodFwiLFwiYXJyb3ctdXBcIixcImFzdGVyaXNrXCIsXCJhdC1zaWduXCIsXCJhd2FyZFwiLFwiYXhlXCIsXCJiYW5rbm90ZVwiLFwiYmFyLWNoYXJ0LTJcIixcImJhci1jaGFydFwiLFwiYmFzZWxpbmVcIixcImJhdHRlcnktY2hhcmdpbmdcIixcImJhdHRlcnktZnVsbFwiLFwiYmF0dGVyeS1sb3dcIixcImJhdHRlcnktbWVkaXVtXCIsXCJiYXR0ZXJ5XCIsXCJiZWFrZXJcIixcImJlbGwtbWludXNcIixcImJlbGwtb2ZmXCIsXCJiZWxsLXBsdXNcIixcImJlbGwtcmluZ1wiLFwiYmVsbFwiLFwiYmlrZVwiLFwiYmluYXJ5XCIsXCJiaXRjb2luXCIsXCJibHVldG9vdGgtY29ubmVjdGVkXCIsXCJibHVldG9vdGgtb2ZmXCIsXCJibHVldG9vdGgtc2VhcmNoaW5nXCIsXCJibHVldG9vdGhcIixcImJvbGRcIixcImJvb2stb3BlblwiLFwiYm9va1wiLFwiYm9va21hcmstbWludXNcIixcImJvb2ttYXJrLXBsdXNcIixcImJvb2ttYXJrXCIsXCJib3RcIixcImJveC1zZWxlY3RcIixcImJveFwiLFwiYnJpZWZjYXNlXCIsXCJicnVzaFwiLFwiYnVnXCIsXCJidWlsZGluZy0yXCIsXCJidWlsZGluZ1wiLFwiYnVzXCIsXCJjYWxjdWxhdG9yXCIsXCJjYWxlbmRhclwiLFwiY2FtZXJhLW9mZlwiLFwiY2FtZXJhXCIsXCJjYXJcIixcImNhcnJvdFwiLFwiY2FzdFwiLFwiY2hlY2stY2lyY2xlLTJcIixcImNoZWNrLWNpcmNsZVwiLFwiY2hlY2stc3F1YXJlXCIsXCJjaGVja1wiLFwiY2hldnJvbi1kb3duXCIsXCJjaGV2cm9uLWZpcnN0XCIsXCJjaGV2cm9uLWxhc3RcIixcImNoZXZyb24tbGVmdFwiLFwiY2hldnJvbi1yaWdodFwiLFwiY2hldnJvbi11cFwiLFwiY2hldnJvbnMtZG93bi11cFwiLFwiY2hldnJvbnMtZG93blwiLFwiY2hldnJvbnMtbGVmdFwiLFwiY2hldnJvbnMtcmlnaHRcIixcImNoZXZyb25zLXVwLWRvd25cIixcImNoZXZyb25zLXVwXCIsXCJjaHJvbWVcIixcImNpcmNsZS1zbGFzaGVkXCIsXCJjaXJjbGVcIixcImNsaXBib2FyZC1jaGVja1wiLFwiY2xpcGJvYXJkLWNvcHlcIixcImNsaXBib2FyZC1saXN0XCIsXCJjbGlwYm9hcmQteFwiLFwiY2xpcGJvYXJkXCIsXCJjbG9jay0xXCIsXCJjbG9jay0xMFwiLFwiY2xvY2stMTFcIixcImNsb2NrLTEyXCIsXCJjbG9jay0yXCIsXCJjbG9jay0zXCIsXCJjbG9jay00XCIsXCJjbG9jay01XCIsXCJjbG9jay02XCIsXCJjbG9jay03XCIsXCJjbG9jay04XCIsXCJjbG9jay05XCIsXCJsdWNpZGUtY2xvY2tcIixcImNsb3VkLWRyaXp6bGVcIixcImNsb3VkLWZvZ1wiLFwiY2xvdWQtaGFpbFwiLFwiY2xvdWQtbGlnaHRuaW5nXCIsXCJjbG91ZC1tb29uXCIsXCJjbG91ZC1vZmZcIixcImNsb3VkLXJhaW4td2luZFwiLFwiY2xvdWQtcmFpblwiLFwiY2xvdWQtc25vd1wiLFwiY2xvdWQtc3VuXCIsXCJsdWNpZGUtY2xvdWRcIixcImNsb3VkeVwiLFwiY2xvdmVyXCIsXCJjb2RlLTJcIixcImNvZGVcIixcImNvZGVwZW5cIixcImNvZGVzYW5kYm94XCIsXCJjb2ZmZWVcIixcImNvaW5zXCIsXCJjb2x1bW5zXCIsXCJjb21tYW5kXCIsXCJjb21wYXNzXCIsXCJjb250YWN0XCIsXCJjb250cmFzdFwiLFwiY29va2llXCIsXCJjb3B5XCIsXCJjb3B5bGVmdFwiLFwiY29weXJpZ2h0XCIsXCJjb3JuZXItZG93bi1sZWZ0XCIsXCJjb3JuZXItZG93bi1yaWdodFwiLFwiY29ybmVyLWxlZnQtZG93blwiLFwiY29ybmVyLWxlZnQtdXBcIixcImNvcm5lci1yaWdodC1kb3duXCIsXCJjb3JuZXItcmlnaHQtdXBcIixcImNvcm5lci11cC1sZWZ0XCIsXCJjb3JuZXItdXAtcmlnaHRcIixcImNwdVwiLFwiY3JlZGl0LWNhcmRcIixcImNyb3BcIixcImx1Y2lkZS1jcm9zc1wiLFwiY3Jvc3NoYWlyXCIsXCJjcm93blwiLFwiY3VycmVuY3lcIixcImRhdGFiYXNlXCIsXCJkZWxldGVcIixcImRpY2UtMVwiLFwiZGljZS0yXCIsXCJkaWNlLTNcIixcImRpY2UtNFwiLFwiZGljZS01XCIsXCJkaWNlLTZcIixcImRpc2NcIixcImRpdmlkZS1jaXJjbGVcIixcImRpdmlkZS1zcXVhcmVcIixcImRpdmlkZVwiLFwiZG9sbGFyLXNpZ25cIixcImRvd25sb2FkLWNsb3VkXCIsXCJkb3dubG9hZFwiLFwiZHJpYmJibGVcIixcImRyb3BsZXRcIixcImRyb3BsZXRzXCIsXCJkcnVtc3RpY2tcIixcImVkaXQtMlwiLFwiZWRpdC0zXCIsXCJlZGl0XCIsXCJlZ2dcIixcImVxdWFsLW5vdFwiLFwiZXF1YWxcIixcImVyYXNlclwiLFwiZXVyb1wiLFwiZXhwYW5kXCIsXCJleHRlcm5hbC1saW5rXCIsXCJleWUtb2ZmXCIsXCJleWVcIixcImZhY2Vib29rXCIsXCJmYXN0LWZvcndhcmRcIixcImZlYXRoZXJcIixcImZpZ21hXCIsXCJmaWxlLWNoZWNrLTJcIixcImZpbGUtY2hlY2tcIixcImZpbGUtY29kZVwiLFwiZmlsZS1kaWdpdFwiLFwiZmlsZS1pbnB1dFwiLFwiZmlsZS1taW51cy0yXCIsXCJmaWxlLW1pbnVzXCIsXCJmaWxlLW91dHB1dFwiLFwiZmlsZS1wbHVzLTJcIixcImZpbGUtcGx1c1wiLFwiZmlsZS1zZWFyY2hcIixcImZpbGUtdGV4dFwiLFwiZmlsZS14LTJcIixcImZpbGUteFwiLFwiZmlsZVwiLFwiZmlsZXNcIixcImZpbG1cIixcImZpbHRlclwiLFwiZmxhZy1vZmZcIixcImZsYWctdHJpYW5nbGUtbGVmdFwiLFwiZmxhZy10cmlhbmdsZS1yaWdodFwiLFwiZmxhZ1wiLFwiZmxhbWVcIixcImZsYXNobGlnaHQtb2ZmXCIsXCJmbGFzaGxpZ2h0XCIsXCJmbGFzay1jb25pY2FsXCIsXCJmbGFzay1yb3VuZFwiLFwiZm9sZGVyLW1pbnVzXCIsXCJmb2xkZXItb3BlblwiLFwiZm9sZGVyLXBsdXNcIixcImx1Y2lkZS1mb2xkZXJcIixcImZvcm0taW5wdXRcIixcImZvcndhcmRcIixcImZyYW1lXCIsXCJmcmFtZXJcIixcImZyb3duXCIsXCJmdW5jdGlvbi1zcXVhcmVcIixcImdhbWVwYWQtMlwiLFwiZ2FtZXBhZFwiLFwiZ2F1Z2VcIixcImdhdmVsXCIsXCJnZW1cIixcImdob3N0XCIsXCJnaWZ0XCIsXCJnaXQtYnJhbmNoLXBsdXNcIixcImdpdC1icmFuY2hcIixcImdpdC1jb21taXRcIixcImdpdC1mb3JrXCIsXCJnaXQtbWVyZ2VcIixcImdpdC1wdWxsLXJlcXVlc3RcIixcImdpdGh1YlwiLFwiZ2l0bGFiXCIsXCJnbGFzc2VzXCIsXCJnbG9iZS0yXCIsXCJnbG9iZVwiLFwiZ3JhYlwiLFwiZ3JhZHVhdGlvbi1jYXBcIixcImdyaWRcIixcImdyaXAtaG9yaXpvbnRhbFwiLFwiZ3JpcC12ZXJ0aWNhbFwiLFwiaGFtbWVyXCIsXCJoYW5kLW1ldGFsXCIsXCJoYW5kXCIsXCJoYXJkLWRyaXZlXCIsXCJoYXJkLWhhdFwiLFwiaGFzaFwiLFwiaGF6ZVwiLFwiaGVhZHBob25lc1wiLFwiaGVhcnRcIixcImhlbHAtY2lyY2xlXCIsXCJoZXhhZ29uXCIsXCJoaWdobGlnaHRlclwiLFwiaGlzdG9yeVwiLFwiaG9tZVwiLFwiaW1hZ2UtbWludXNcIixcImltYWdlLW9mZlwiLFwiaW1hZ2UtcGx1c1wiLFwiaW1hZ2VcIixcImltcG9ydFwiLFwiaW5ib3hcIixcImluZGVudFwiLFwiaW5kaWFuLXJ1cGVlXCIsXCJpbmZpbml0eVwiLFwibHVjaWRlLWluZm9cIixcImluc3BlY3RcIixcImluc3RhZ3JhbVwiLFwiaXRhbGljXCIsXCJqYXBhbmVzZS15ZW5cIixcImtleVwiLFwia2V5Ym9hcmRcIixcImxhbmRtYXJrXCIsXCJsdWNpZGUtbGFuZ3VhZ2VzXCIsXCJsYXB0b3AtMlwiLFwibGFwdG9wXCIsXCJsYXNzby1zZWxlY3RcIixcImxhc3NvXCIsXCJsYXllcnNcIixcImxheW91dC1kYXNoYm9hcmRcIixcImxheW91dC1ncmlkXCIsXCJsYXlvdXQtbGlzdFwiLFwibGF5b3V0LXRlbXBsYXRlXCIsXCJsYXlvdXRcIixcImxpYnJhcnlcIixcImxpZmUtYnVveVwiLFwibGlnaHRidWxiLW9mZlwiLFwibGlnaHRidWxiXCIsXCJsaW5rLTItb2ZmXCIsXCJsaW5rLTJcIixcImx1Y2lkZS1saW5rXCIsXCJsaW5rZWRpblwiLFwibGlzdC1jaGVja3NcIixcImxpc3QtbWludXNcIixcImxpc3Qtb3JkZXJlZFwiLFwibGlzdC1wbHVzXCIsXCJsaXN0LXhcIixcImxpc3RcIixcImxvYWRlci0yXCIsXCJsb2FkZXJcIixcImxvY2F0ZS1maXhlZFwiLFwibG9jYXRlLW9mZlwiLFwibG9jYXRlXCIsXCJsb2NrXCIsXCJsb2ctaW5cIixcImxvZy1vdXRcIixcIm1haWxcIixcIm1hcC1waW5cIixcIm1hcFwiLFwibWF4aW1pemUtMlwiLFwibWF4aW1pemVcIixcIm1lZ2FwaG9uZVwiLFwibWVoXCIsXCJtZW51XCIsXCJtZXNzYWdlLWNpcmNsZVwiLFwibWVzc2FnZS1zcXVhcmVcIixcIm1pYy1vZmZcIixcIm1pY1wiLFwibWluaW1pemUtMlwiLFwibWluaW1pemVcIixcIm1pbnVzLWNpcmNsZVwiLFwibWludXMtc3F1YXJlXCIsXCJtaW51c1wiLFwibW9uaXRvci1vZmZcIixcIm1vbml0b3Itc3BlYWtlclwiLFwibW9uaXRvclwiLFwibW9vblwiLFwibW9yZS1ob3Jpem9udGFsXCIsXCJtb3JlLXZlcnRpY2FsXCIsXCJtb3VudGFpbi1zbm93XCIsXCJtb3VudGFpblwiLFwibW91c2UtcG9pbnRlci0yXCIsXCJtb3VzZS1wb2ludGVyLWNsaWNrXCIsXCJtb3VzZS1wb2ludGVyXCIsXCJtb3VzZVwiLFwibW92ZS1kaWFnb25hbC0yXCIsXCJtb3ZlLWRpYWdvbmFsXCIsXCJtb3ZlLWhvcml6b250YWxcIixcIm1vdmUtdmVydGljYWxcIixcIm1vdmVcIixcIm11c2ljXCIsXCJuYXZpZ2F0aW9uLTJcIixcIm5hdmlnYXRpb25cIixcIm5ldHdvcmtcIixcIm9jdGFnb25cIixcIm9wdGlvblwiLFwib3V0ZGVudFwiLFwicGFja2FnZS1jaGVja1wiLFwicGFja2FnZS1taW51c1wiLFwicGFja2FnZS1wbHVzXCIsXCJwYWNrYWdlLXNlYXJjaFwiLFwicGFja2FnZS14XCIsXCJwYWNrYWdlXCIsXCJwYWxldHRlXCIsXCJwYWxtdHJlZVwiLFwicGFwZXJjbGlwXCIsXCJwYXVzZS1jaXJjbGVcIixcInBhdXNlLW9jdGFnb25cIixcInBhdXNlXCIsXCJwZW4tdG9vbFwiLFwibHVjaWRlLXBlbmNpbFwiLFwicGVyY2VudFwiLFwicGVyc29uLXN0YW5kaW5nXCIsXCJwaG9uZS1jYWxsXCIsXCJwaG9uZS1mb3J3YXJkZWRcIixcInBob25lLWluY29taW5nXCIsXCJwaG9uZS1taXNzZWRcIixcInBob25lLW9mZlwiLFwicGhvbmUtb3V0Z29pbmdcIixcInBob25lXCIsXCJwaWUtY2hhcnRcIixcInBpZ2d5LWJhbmtcIixcImx1Y2lkZS1waW5cIixcInBpcGV0dGVcIixcInBsYW5lXCIsXCJwbGF5LWNpcmNsZVwiLFwicGxheVwiLFwicGx1Zy16YXBcIixcInBsdXMtY2lyY2xlXCIsXCJwbHVzLXNxdWFyZVwiLFwicGx1c1wiLFwicG9ja2V0XCIsXCJwb2RjYXN0XCIsXCJwb2ludGVyXCIsXCJwb3VuZC1zdGVybGluZ1wiLFwicG93ZXItb2ZmXCIsXCJwb3dlclwiLFwicHJpbnRlclwiLFwicXItY29kZVwiLFwicXVvdGVcIixcInJhZGlvLXJlY2VpdmVyXCIsXCJyYWRpb1wiLFwicmVkb1wiLFwicmVmcmVzaC1jY3dcIixcInJlZnJlc2gtY3dcIixcInJlZ2V4XCIsXCJyZXBlYXQtMVwiLFwicmVwZWF0XCIsXCJyZXBseS1hbGxcIixcInJlcGx5XCIsXCJyZXdpbmRcIixcInJvY2tldFwiLFwicm9ja2luZy1jaGFpclwiLFwicm90YXRlLWNjd1wiLFwicm90YXRlLWN3XCIsXCJyc3NcIixcInJ1bGVyXCIsXCJydXNzaWFuLXJ1YmxlXCIsXCJzYXZlXCIsXCJzY2FsZVwiLFwic2Nhbi1saW5lXCIsXCJzY2FuXCIsXCJzY2lzc29yc1wiLFwic2NyZWVuLXNoYXJlLW9mZlwiLFwic2NyZWVuLXNoYXJlXCIsXCJsdWNpZGUtc2VhcmNoXCIsXCJzZW5kXCIsXCJzZXBhcmF0b3ItaG9yaXpvbnRhbFwiLFwic2VwYXJhdG9yLXZlcnRpY2FsXCIsXCJzZXJ2ZXItY3Jhc2hcIixcInNlcnZlci1vZmZcIixcInNlcnZlclwiLFwic2V0dGluZ3MtMlwiLFwic2V0dGluZ3NcIixcInNoYXJlLTJcIixcInNoYXJlXCIsXCJzaGVldFwiLFwic2hpZWxkLWFsZXJ0XCIsXCJzaGllbGQtY2hlY2tcIixcInNoaWVsZC1jbG9zZVwiLFwic2hpZWxkLW9mZlwiLFwic2hpZWxkXCIsXCJzaGlydFwiLFwic2hvcHBpbmctYmFnXCIsXCJzaG9wcGluZy1jYXJ0XCIsXCJzaG92ZWxcIixcInNocmlua1wiLFwic2h1ZmZsZVwiLFwic2lkZWJhci1jbG9zZVwiLFwic2lkZWJhci1vcGVuXCIsXCJzaWRlYmFyXCIsXCJzaWdtYVwiLFwic2lnbmFsLWhpZ2hcIixcInNpZ25hbC1sb3dcIixcInNpZ25hbC1tZWRpdW1cIixcInNpZ25hbC16ZXJvXCIsXCJzaWduYWxcIixcInNraXAtYmFja1wiLFwic2tpcC1mb3J3YXJkXCIsXCJza3VsbFwiLFwic2xhY2tcIixcInNsYXNoXCIsXCJzbGlkZXJzXCIsXCJzbWFydHBob25lLWNoYXJnaW5nXCIsXCJzbWFydHBob25lXCIsXCJzbWlsZVwiLFwic25vd2ZsYWtlXCIsXCJzb3J0LWFzY1wiLFwic29ydC1kZXNjXCIsXCJzcGVha2VyXCIsXCJzcHJvdXRcIixcInNxdWFyZVwiLFwic3Rhci1oYWxmXCIsXCJsdWNpZGUtc3RhclwiLFwic3RvcC1jaXJjbGVcIixcInN0cmV0Y2gtaG9yaXpvbnRhbFwiLFwic3RyZXRjaC12ZXJ0aWNhbFwiLFwic3RyaWtldGhyb3VnaFwiLFwic3Vic2NyaXB0XCIsXCJzdW5cIixcInN1bnJpc2VcIixcInN1bnNldFwiLFwic3VwZXJzY3JpcHRcIixcInN3aXNzLWZyYW5jXCIsXCJzd2l0Y2gtY2FtZXJhXCIsXCJ0YWJsZVwiLFwidGFibGV0XCIsXCJ0YWdcIixcInRhcmdldFwiLFwidGVudFwiLFwidGVybWluYWwtc3F1YXJlXCIsXCJ0ZXJtaW5hbFwiLFwidGV4dC1jdXJzb3ItaW5wdXRcIixcInRleHQtY3Vyc29yXCIsXCJ0aGVybW9tZXRlci1zbm93Zmxha2VcIixcInRoZXJtb21ldGVyLXN1blwiLFwidGhlcm1vbWV0ZXJcIixcInRodW1icy1kb3duXCIsXCJ0aHVtYnMtdXBcIixcInRpY2tldFwiLFwidGltZXItb2ZmXCIsXCJ0aW1lci1yZXNldFwiLFwidGltZXJcIixcInRvZ2dsZS1sZWZ0XCIsXCJ0b2dnbGUtcmlnaHRcIixcInRvcm5hZG9cIixcInRyYXNoLTJcIixcImx1Y2lkZS10cmFzaFwiLFwidHJlbGxvXCIsXCJ0cmVuZGluZy1kb3duXCIsXCJ0cmVuZGluZy11cFwiLFwidHJpYW5nbGVcIixcInRydWNrXCIsXCJ0di0yXCIsXCJ0dlwiLFwidHdpdGNoXCIsXCJ0d2l0dGVyXCIsXCJ0eXBlXCIsXCJ1bWJyZWxsYVwiLFwidW5kZXJsaW5lXCIsXCJ1bmRvXCIsXCJ1bmxpbmstMlwiLFwidW5saW5rXCIsXCJ1bmxvY2tcIixcInVwbG9hZC1jbG91ZFwiLFwidXBsb2FkXCIsXCJ1c2VyLWNoZWNrXCIsXCJ1c2VyLW1pbnVzXCIsXCJ1c2VyLXBsdXNcIixcInVzZXIteFwiLFwidXNlclwiLFwidXNlcnNcIixcInZlcmlmaWVkXCIsXCJ2aWJyYXRlXCIsXCJ2aWRlby1vZmZcIixcInZpZGVvXCIsXCJ2aWV3XCIsXCJ2b2ljZW1haWxcIixcInZvbHVtZS0xXCIsXCJ2b2x1bWUtMlwiLFwidm9sdW1lLXhcIixcInZvbHVtZVwiLFwid2FsbGV0XCIsXCJ3YW5kXCIsXCJ3YXRjaFwiLFwid2F2ZXNcIixcIndlYmNhbVwiLFwid2lmaS1vZmZcIixcIndpZmlcIixcIndpbmRcIixcIndyYXAtdGV4dFwiLFwid3JlbmNoXCIsXCJ4LWNpcmNsZVwiLFwieC1vY3RhZ29uXCIsXCJ4LXNxdWFyZVwiLFwieFwiLFwieW91dHViZVwiLFwiemFwLW9mZlwiLFwiemFwXCIsXCJ6b29tLWluXCIsXCJ6b29tLW91dFwiLFwic2VhcmNoLWxhcmdlXCIsXCJsdWNpZGUtc2VhcmNoXCJdO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBvcmlnaW5hbCBJQ09OX0xJU1QgY29udGFpbnMgZHVwbGljYXRlIGVudHJpZXMgKGUuZy4gdHdvIFwiYWN0aXZpdHlcIiBpdGVtcykgYW5kIGlzIG5vdCBpbiBhbHBoYWJldGljYWwgb3JkZXIuIFRoaXMgbGlzdCBpbXByb3ZlcyBpdC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBJQ09OX0xJU1RfU09SVEVEX1VOSVFVRSA9IHVuaXF1ZUFycmF5KElDT05fTElTVCkuc29ydCgpOyIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbi8vIEB0cy1pZ25vcmVcclxuaW1wb3J0IHtTZXR0aW5nLCBUZXh0QXJlYUNvbXBvbmVudH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtTQ19NYWluU2V0dGluZ3NUYWJ9IGZyb20gXCIuL1NDX01haW5TZXR0aW5nc1RhYlwiO1xyXG5pbXBvcnQge2dldE91dHB1dENoYW5uZWxzT3B0aW9uTGlzdH0gZnJvbSBcIi4uL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7XHJcbiAgICBPdXRwdXRDaGFubmVsQ29kZSxcclxuICAgIE91dHB1dENoYW5uZWxPcmRlcixcclxuICAgIE91dHB1dEhhbmRsaW5nTW9kZSxcclxuICAgIE91dHB1dFN0cmVhbSxcclxufSBmcm9tIFwiLi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxDb2RlXCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtDb21tYW5kUGFsZXR0ZU9wdGlvbnMsIElDb21tYW5kUGFsZXR0ZU9wdGlvbnMsIFBsYXRmb3JtSWQsIFBsYXRmb3JtTmFtZXN9IGZyb20gXCIuL1NDX01haW5TZXR0aW5nc1wiO1xyXG5pbXBvcnQge2NyZWF0ZVNoZWxsU2VsZWN0aW9uRmllbGR9IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlU2hlbGxTZWxlY3Rpb25GaWVsZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZSxcclxuICAgIGdlbmVyYXRlU2hlbGxDb21tYW5kRmllbGRJY29uQW5kTmFtZVxyXG59IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRcIjtcclxuaW1wb3J0IHtjcmVhdGVQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kRmllbGR9IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlUGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZEZpZWxkXCI7XHJcbmltcG9ydCB7Y3JlYXRlVGFicywgVGFiU3RydWN0dXJlfSBmcm9tIFwiLi9zZXR0aW5nX2VsZW1lbnRzL1RhYnNcIjtcclxuaW1wb3J0IHtjcmVhdGVBdXRvY29tcGxldGV9IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcbmltcG9ydCB7Z2V0U0NfRXZlbnRzfSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50TGlzdFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7XHJcbiAgICBjb3B5VG9DbGlwYm9hcmQsXHJcbiAgICBnb3RvVVJMLFxyXG59IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtTQ19Nb2RhbH0gZnJvbSBcIi4uL1NDX01vZGFsXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXREZWZhdWx0UHJlYWN0aW9uX1Byb21wdF9Db25maWd1cmF0aW9uLFxyXG4gICAgZ2V0TW9kZWwsXHJcbiAgICBQcmVhY3Rpb25fUHJvbXB0X0NvbmZpZ3VyYXRpb24sXHJcbiAgICBQcmVhY3Rpb25Db25maWd1cmF0aW9uLFxyXG4gICAgUHJvbXB0LFxyXG4gICAgUHJvbXB0TW9kZWwsXHJcbiAgICBQcm9tcHRTZXR0aW5nc01vZGFsLFxyXG59IGZyb20gXCIuLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7VmFyaWFibGVEZWZhdWx0VmFsdWVDb25maWd1cmF0aW9ufSBmcm9tIFwiLi4vdmFyaWFibGVzL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Q21kT3JDdHJsfSBmcm9tIFwiLi4vSG90a2V5c1wiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0SWNvbkhUTUwsXHJcbiAgICBJQ09OX0xJU1RfU09SVEVEX1VOSVFVRSxcclxufSBmcm9tIFwiLi4vSWNvbnNcIjtcclxuaW1wb3J0IHtPdXRwdXRXcmFwcGVyfSBmcm9tIFwiLi4vbW9kZWxzL291dHB1dF93cmFwcGVyL091dHB1dFdyYXBwZXJcIjtcclxuaW1wb3J0IHtPdXRwdXRXcmFwcGVyTW9kZWx9IGZyb20gXCIuLi9tb2RlbHMvb3V0cHV0X3dyYXBwZXIvT3V0cHV0V3JhcHBlck1vZGVsXCI7XHJcbmltcG9ydCB7T3V0cHV0V3JhcHBlclNldHRpbmdzTW9kYWx9IGZyb20gXCIuLi9tb2RlbHMvb3V0cHV0X3dyYXBwZXIvT3V0cHV0V3JhcHBlclNldHRpbmdzTW9kYWxcIjtcclxuaW1wb3J0IHtEb2N1bWVudGF0aW9uT3V0cHV0SGFuZGxpbmdNb2RlTGlua30gZnJvbSBcIi4uL0RvY3VtZW50YXRpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBSZW5hbWUgdG8gU2hlbGxDb21tYW5kU2V0dGluZ3NNb2RhbFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV4dHJhT3B0aW9uc01vZGFsIGV4dGVuZHMgU0NfTW9kYWwge1xyXG4gICAgcHVibGljIHN0YXRpYyBHRU5FUkFMX09QVElPTlNfU1VNTUFSWSA9IFwiQWxpYXMsIEljb24sIENvbmZpcm1hdGlvblwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBQUkVBQ1RJT05TX09QVElPTlNfU1VNTUFSWSA9IFwiUHJlYWN0aW9uczogUHJvbXB0IGZvciBhc2tpbmcgdmFsdWVzIGZyb20gdXNlclwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBPVVRQVVRfT1BUSU9OU19TVU1NQVJZID0gXCJTdGRvdXQvc3RkZXJyIGhhbmRsaW5nLCBJZ25vcmUgZXJyb3JzXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIEVOVklST05NRU5UU19PUFRJT05TX1NVTU1BUlkgPSBcIlNoZWxsIHNlbGVjdGlvbiwgT3BlcmF0aW5nIHN5c3RlbSBzcGVjaWZpYyBzaGVsbCBjb21tYW5kc1wiO1xyXG4gICAgcHVibGljIHN0YXRpYyBFVkVOVFNfU1VNTUFSWSA9IFwiRXZlbnRzXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFZBUklBQkxFU19TVU1NQVJZID0gXCJEZWZhdWx0IHZhbHVlcyBmb3IgdmFyaWFibGVzXCI7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZDtcclxuICAgIHByaXZhdGUgbmFtZV9zZXR0aW5nOiBTZXR0aW5nO1xyXG4gICAgcHJpdmF0ZSBzZXR0aW5nX3RhYjogU0NfTWFpblNldHRpbmdzVGFiO1xyXG4gICAgcHJpdmF0ZSB0YWJfc3RydWN0dXJlOiBUYWJTdHJ1Y3R1cmU7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBTQ19QbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZywgc2V0dGluZ190YWI6IFNDX01haW5TZXR0aW5nc1RhYikge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX2lkID0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCA9IHBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG4gICAgICAgIHRoaXMubmFtZV9zZXR0aW5nID0gc2V0dGluZ190YWIuc2V0dGluZ19ncm91cHNbc2hlbGxfY29tbWFuZF9pZF0ubmFtZV9zZXR0aW5nO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ190YWIgPSBzZXR0aW5nX3RhYjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKCkge1xyXG4gICAgICAgIHN1cGVyLm9uT3BlbigpO1xyXG5cclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJoMlwiLCB7dGV4dDogdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0RGVmYXVsdFNoZWxsQ29tbWFuZCgpfSk7ICAvLyBUT0RPOiBVc2UgdGhpcy5zZXRUaXRsZSgpIGluc3RlYWQuXHJcblxyXG4gICAgICAgIC8vIFRhYnNcclxuICAgICAgICB0aGlzLnRhYl9zdHJ1Y3R1cmUgPSBjcmVhdGVUYWJzKHRoaXMubW9kYWxFbCwge1xyXG4gICAgICAgICAgICBcImV4dHJhLW9wdGlvbnMtZ2VuZXJhbFwiOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJHZW5lcmFsXCIsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBcImdlYXJcIixcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJHZW5lcmFsKGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZXh0cmEtb3B0aW9ucy1wcmVhY3Rpb25zXCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByZWFjdGlvbnNcIixcclxuICAgICAgICAgICAgICAgIGljb246IFwibm90ZS1nbHlwaFwiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudF9nZW5lcmF0b3I6IChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYlByZWFjdGlvbnMoY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJleHRyYS1vcHRpb25zLW91dHB1dFwiOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJPdXRwdXRcIixcclxuICAgICAgICAgICAgICAgIGljb246IFwibGluZXMtb2YtdGV4dFwiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudF9nZW5lcmF0b3I6IChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYk91dHB1dChjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImV4dHJhLW9wdGlvbnMtZW52aXJvbm1lbnRzXCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkVudmlyb25tZW50c1wiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJzdGFja2VkLWxldmVsc1wiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudF9nZW5lcmF0b3I6IChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYkVudmlyb25tZW50cyhjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImV4dHJhLW9wdGlvbnMtZXZlbnRzXCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkV2ZW50c1wiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJkaWNlXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiRXZlbnRzKGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZXh0cmEtb3B0aW9ucy12YXJpYWJsZXNcIjoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBcImNvZGUtZ2x5cGhcIixcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJWYXJpYWJsZXMoY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gSG90a2V5cyBmb3IgbW92aW5nIHRvIG5leHQvcHJldmlvdXMgc2hlbGwgY29tbWFuZFxyXG4gICAgICAgIGNvbnN0IHN3aXRjaF90b190X3NoZWxsX2NvbW1hbmQgPSAodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld19tb2RhbCA9IG5ldyBFeHRyYU9wdGlvbnNNb2RhbCh0aGlzLnBsdWdpbiwgdF9zaGVsbF9jb21tYW5kLmdldElkKCksIHRoaXMuc2V0dGluZ190YWIpO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7IC8vIE5lZWRzIHRvIGJlIGNsb3NlZCBiZWZvcmUgdGhlIG5ldyBvbmUgaXMgb3BlbmVkLCBvdGhlcndpc2UgdGhlIG5ldyBvbmUncyB0YWIgY29udGVudCB3b24ndCBiZSBzaG93bi5cclxuICAgICAgICAgICAgbmV3X21vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgbmV3X21vZGFsLmFjdGl2YXRlVGFiKHRoaXMudGFiX3N0cnVjdHVyZS5hY3RpdmVfdGFiX2lkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2NvcGUucmVnaXN0ZXIoW1wiTW9kXCJdLCBcIkFycm93VXBcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQucHJldmlvdXNUU2hlbGxDb21tYW5kKCkpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaF90b190X3NoZWxsX2NvbW1hbmQodGhpcy50X3NoZWxsX2NvbW1hbmQucHJldmlvdXNUU2hlbGxDb21tYW5kKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXCJNb2RcIl0sIFwiQXJyb3dEb3duXCIsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudF9zaGVsbF9jb21tYW5kLm5leHRUU2hlbGxDb21tYW5kKCkpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaF90b190X3NoZWxsX2NvbW1hbmQodGhpcy50X3NoZWxsX2NvbW1hbmQubmV4dFRTaGVsbENvbW1hbmQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLm1vZGFsRWwpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVGlwISBIaXQgXCIgKyBDbWRPckN0cmwoKSArIFwiICsgdXAvZG93biB0byBzd2l0Y2ggdG8gcHJldmlvdXMvbmV4dCBzaGVsbCBjb21tYW5kLlwiKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYkdlbmVyYWwoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgLy8gQWxpYXMgZmllbGRcclxuICAgICAgICBjb25zdCBhbGlhc19jb250YWluZXIgPSBjb250YWluZXJfZWxlbWVudC5jcmVhdGVEaXYoe2F0dHI6IHtjbGFzczogXCJTQy1zZXR0aW5nLWdyb3VwXCJ9fSlcclxuICAgICAgICBuZXcgU2V0dGluZyhhbGlhc19jb250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQWxpYXNcIilcclxuICAgICAgICA7XHJcbiAgICAgICAgY29uc3Qgb25fYWxpYXNfY2hhbmdlID0gYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBhY3R1YWwgYWxpYXMgdmFsdWVcclxuICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmFsaWFzID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgT2JzaWRpYW4gY29tbWFuZCBwYWxldHRlXHJcbiAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLnJlbmFtZU9ic2lkaWFuQ29tbWFuZCh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRTaGVsbENvbW1hbmQoKSwgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGVTaGVsbCBjb21tYW5kcyBzZXR0aW5ncyBwYW5lbFxyXG4gICAgICAgICAgICB0aGlzLm5hbWVfc2V0dGluZy5uYW1lRWwuaW5uZXJIVE1MID0gZ2VuZXJhdGVTaGVsbENvbW1hbmRGaWVsZEljb25BbmROYW1lKHRoaXMudF9zaGVsbF9jb21tYW5kKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmVcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhbGlhc19zZXR0aW5nID0gbmV3IFNldHRpbmcoYWxpYXNfY29udGFpbmVyKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKG9uX2FsaWFzX2NoYW5nZSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuc2V0Q2xhc3MoXCJTQy1uby1kZXNjcmlwdGlvblwiKVxyXG4gICAgICAgIDtcclxuICAgICAgICBjb25zdCBhbGlhc19pbnB1dF9lbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50ID0gYWxpYXNfc2V0dGluZy5jb250cm9sRWwuZmluZChcImlucHV0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgYWxpYXNfaW5wdXRfZWxlbWVudC5hZGRDbGFzcyhcIlNDLWZvY3VzLWVsZW1lbnQtb24tdGFiLW9wZW5pbmdcIik7IC8vIEZvY3VzIHdpdGhvdXQgYSBuZWVkIHRvIGNsaWNrIHRoZSBmaWVsZC5cclxuICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd19hdXRvY29tcGxldGVfbWVudSkge1xyXG4gICAgICAgICAgICAvLyBTaG93IGF1dG9jb21wbGV0ZSBtZW51ICg9IGEgbGlzdCBvZiBhdmFpbGFibGUgdmFyaWFibGVzKS5cclxuICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHRoaXMucGx1Z2luLCBhbGlhc19pbnB1dF9lbGVtZW50LCBvbl9hbGlhc19jaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxpYXNfY29udGFpbmVyLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJJZiBub3QgZW1wdHksIHRoZSBhbGlhcyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgY29tbWFuZCBwYWxldHRlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCBjb21tYW5kLiBBbiBhbGlhcyBpcyBuZXZlciBleGVjdXRlZCBhcyBhIGNvbW1hbmQuXCJ9KTtcclxuICAgICAgICBhbGlhc19jb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIllvdSBjYW4gYWxzbyB1c2UgdGhlIHNhbWUge3t9fSBzdHlsZSB2YXJpYWJsZXMgaW4gYWxpYXNlcyB0aGF0IGFyZSB1c2VkIGluIHNoZWxsIGNvbW1hbmRzLiBXaGVuIHZhcmlhYmxlcyBhcmUgdXNlZCBpbiBhbGlhc2VzLCB0aGV5IGRvIG5vdCBhZmZlY3QgdGhlIGNvbW1hbmQgZXhlY3V0aW9uIGluIGFueSB3YXksIGJ1dCBpdCdzIGEgbmljZSB3YXkgdG8gcmV2ZWFsIHdoYXQgdmFsdWVzIHlvdXIgY29tbWFuZCB3aWxsIHVzZSwgZXZlbiB3aGVuIGFuIGFsaWFzIGhpZGVzIG1vc3Qgb2YgdGhlIG90aGVyIHRlY2huaWNhbCBkZXRhaWxzLiBTdGFydGluZyBhIHZhcmlhYmxlIHdpdGgge3shIHdpbGwgcHJldmVudCBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gY29tbWFuZCBwYWxldHRlLlwifSk7XHJcblxyXG4gICAgICAgIC8vIEljb24gZmllbGRcclxuICAgICAgICBjb25zdCBjdXJyZW50X2ljb24gPSB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRDb25maWd1cmF0aW9uKCkuaWNvbjtcclxuICAgICAgICBjb25zdCBpY29uX3NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldERlc2MoXCJJZiBkZWZpbmVkLCB0aGUgaWNvbiB3aWxsIGJlIHNob3duIGluIGZpbGUgbWVudSwgZm9sZGVyIG1lbnUsIGFuZCBlZGl0b3IgbWVudSBpbiBmcm9udCBvZiB0aGUgYWxpYXMgdGV4dC4gSXQncyBhbHNvIHNob3duIGluIHRoZSBzZXR0aW5ncy4gSXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRpc3Rpbmd1aXNoIGRpZmZlcmVudCBzaGVsbCBjb21tYW5kcyB2aXN1YWxseSBmcm9tIGVhY2ggb3RoZXIuXCIpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcIm5vLWljb25cIiwgXCJObyBpY29uXCIpIC8vIE5lZWQgdG8gdXNlIGEgbm9uLWVtcHR5IHN0cmluZyBsaWtlIFwibm8taWNvblwiLCBiZWNhdXNlIGlmICd2YWx1ZScgd291bGQgYmUgXCJcIiB0aGVuIGl0IGJlY29tZXMgdGhlIHNhbWUgYXMgJ2Rpc3BsYXknIGZyb20gc29tZSByZWFzb24sIGkuZS4gXCJObyBpY29uXCIuXHJcbiAgICAgICAgICAgICAgICAudGhlbigoZHJvcGRvd24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIGFsbCBhdmFpbGFibGUgaWNvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpY29uX2lkIG9mIElDT05fTElTVF9TT1JURURfVU5JUVVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBvcHRpb24gZm9yIHRoZSBpY29uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oaWNvbl9pZCwgaWNvbl9pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKGN1cnJlbnRfaWNvbiA/PyBcIlwiKTsgLy8gXCJcIiA9PSB0aGUgJ05vIGljb24nIG9wdGlvbi5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld19pY29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwibm8taWNvblwiID09PSBuZXdfaWNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIGljb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmljb24gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpY29uIGZyb20gdGhlIG1vZGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25fc2V0dGluZy5uYW1lRWwuaW5uZXJIVE1MID0gXCJJY29uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IG9yIGNoYW5nZSB0aGUgaWNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRDb25maWd1cmF0aW9uKCkuaWNvbiA9IG5ld19pY29uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpY29uIGluIHRoZSBtb2RhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uX3NldHRpbmcubmFtZUVsLmlubmVySFRNTCA9IFwiSWNvbiBcIiArIGdldEljb25IVE1MKG5ld19pY29uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSAob3IgcmVtb3ZlKSB0aGUgaWNvbiBpbiB0aGUgbWFpbiBzZXR0aW5ncyBwYW5lbFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZV9zZXR0aW5nLm5hbWVFbC5pbm5lckhUTUwgPSBnZW5lcmF0ZVNoZWxsQ29tbWFuZEZpZWxkSWNvbkFuZE5hbWUodGhpcy50X3NoZWxsX2NvbW1hbmQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgICAgICBpY29uX3NldHRpbmcubmFtZUVsLmlubmVySFRNTCA9IFwiSWNvbiBcIiArIGdldEljb25IVE1MKGN1cnJlbnRfaWNvbilcclxuXHJcbiAgICAgICAgLy8gQ29uZmlybSBleGVjdXRpb24gZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJBc2sgY29uZmlybWF0aW9uIGJlZm9yZSBleGVjdXRpb25cIilcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlybUV4ZWN1dGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5jb25maXJtX2V4ZWN1dGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGljb25fY29udGFpbmVyID0gdGhpcy5uYW1lX3NldHRpbmcubmFtZUVsLmZpbmQoXCJzcGFuLnNoZWxsLWNvbW1hbmRzLWNvbmZpcm0tZXhlY3V0aW9uLWljb24tY29udGFpbmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRDb25maXJtRXhlY3V0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25fY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGljb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbl9jb250YWluZXIuYWRkQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFNoZWxsIGNvbW1hbmQgaWRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldERlc2MoYFNoZWxsIGNvbW1hbmQgaWQ6ICR7dGhpcy5zaGVsbF9jb21tYW5kX2lkfWApXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImRvY3VtZW50c1wiKVxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoYENvcHkgJHt0aGlzLnNoZWxsX2NvbW1hbmRfaWR9IHRvIHRoZSBjbGlwYm9hcmQuYClcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5VG9DbGlwYm9hcmQodGhpcy5zaGVsbF9jb21tYW5kX2lkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24oYCR7dGhpcy5zaGVsbF9jb21tYW5kX2lkfSB3YXMgY29waWVkIHRvIHRoZSBjbGlwYm9hcmQuYClcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5jYW5BZGRUb0NvbW1hbmRQYWxldHRlKCkpIHtcclxuICAgICAgICAgICAgLy8gT25seSBzaG93IE9ic2lkaWFuIGNvbW1hbmQgcGFsZXR0ZSBpZCBpZiB0aGUgc2hlbGwgY29tbWFuZCBpcyBhdmFpbGFibGUgaW4gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuICAgICAgICAgICAgY29uc3Qgb2JzaWRpYW5fY29tbWFuZF9pZCA9IHRoaXMudF9zaGVsbF9jb21tYW5kLmdldE9ic2lkaWFuQ29tbWFuZCgpLmlkO1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKGBPYnNpZGlhbiBjb21tYW5kIHBhbGV0dGUgaWQ6ICR7b2JzaWRpYW5fY29tbWFuZF9pZH1gKVxyXG4gICAgICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcImRvY3VtZW50c1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKGBDb3B5ICR7b2JzaWRpYW5fY29tbWFuZF9pZH0gdG8gdGhlIGNsaXBib2FyZC5gKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weVRvQ2xpcGJvYXJkKG9ic2lkaWFuX2NvbW1hbmRfaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24oYCR7b2JzaWRpYW5fY29tbWFuZF9pZH0gd2FzIGNvcGllZCB0byB0aGUgY2xpcGJvYXJkLmApXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuc2V0dGluZ0VsLmFkZENsYXNzKFwiU0Mtbm8tdG9wLWJvcmRlclwiKSAvLyBObyBob3Jpem9udGFsIHJ1bGVyIGJldHdlZW4gdGhlIHR3byBpZCBlbGVtZW50cy5cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYlByZWFjdGlvbnMoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIlByZWFjdGlvbnMgYXJlIHBlcmZvcm1lZCBiZWZvcmUgdGhlIGFjdHVhbCBzaGVsbCBjb21tYW5kIGdldHMgZXhlY3V0ZWQsIHRvIGRvIGNlcnRhaW4gcHJlcGFyYXRpb25zIGZvciB0aGUgc2hlbGwgY29tbWFuZC5cIn0pO1xyXG4gICAgICAgIGNvbnN0IHByZWFjdGlvbnNfY29uZmlndXJhdGlvbiA9IHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5wcmVhY3Rpb25zO1xyXG5cclxuICAgICAgICAvLyBMb2FkIGNvbmZpZyB2YWx1ZXNcclxuICAgICAgICBsZXQgcHJlYWN0aW9uX3Byb21wdF9jb25maWd1cmF0aW9uOiBQcmVhY3Rpb25fUHJvbXB0X0NvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHByZWFjdGlvbnNfY29uZmlndXJhdGlvbi5mb3JFYWNoKChwcmVhY3Rpb25fY29uZmlndXJhdGlvbjogUHJlYWN0aW9uQ29uZmlndXJhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHByZWFjdGlvbl9jb25maWd1cmF0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJwcm9tcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24gPSBwcmVhY3Rpb25fY29uZmlndXJhdGlvbiBhcyBQcmVhY3Rpb25fUHJvbXB0X0NvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUHJlYWN0aW9uOiBQcm9tcHRcclxuICAgICAgICBjb25zdCBwcm9tcHRfb3B0aW9uczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcclxuICAgICAgICB0aGlzLnBsdWdpbi5nZXRQcm9tcHRzKCkuZm9yRWFjaCgocHJvbXB0OiBQcm9tcHQpID0+IHtcclxuICAgICAgICAgICAgcHJvbXB0X29wdGlvbnNbcHJvbXB0LmdldElEKCldID0gcHJvbXB0LmdldFRpdGxlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IG9sZF9zZWxlY3RlZF9wcm9tcHRfb3B0aW9uOiBzdHJpbmcgPSAocHJlYWN0aW9uX3Byb21wdF9jb25maWd1cmF0aW9uPy5lbmFibGVkKSA/IHByZWFjdGlvbl9wcm9tcHRfY29uZmlndXJhdGlvbi5wcm9tcHRfaWQgOiBcIm5vLXByb21wdFwiO1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIlByb21wdFwiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIlByb21wdHMgYXJlIHVzZWQgdG8gYXNrIHZhbHVlcyBmcm9tIHRoZSB1c2VyIHJpZ2h0IGJlZm9yZSBzaGVsbCBjb21tYW5kIGV4ZWN1dGlvbi4gVGhlIHZhbHVlcyBjYW4gYmUgYWNjZXNzZWQgaW4gdGhlIHNoZWxsIGNvbW1hbmQgdmlhIGN1c3RvbSB2YXJpYWJsZXMuIFlvdSBjYW4gbWFuYWdlIGFsbCBwcm9tcHRzIGluIHRoZSBwbHVnaW4ncyBtYWluIHNldHRpbmdzIHZpZXcsIHVuZGVyIHRoZSAnUHJlYWN0aW9ucycgdGFiLlwiKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJuby1wcm9tcHRcIiwgXCJObyBwcm9tcHRcIilcclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKHByb21wdF9vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcIm5ld1wiLCBcIkNyZWF0ZSBhIG5ldyBwcm9tcHRcIilcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShvbGRfc2VsZWN0ZWRfcHJvbXB0X29wdGlvbilcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X3Byb21wdF9pZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgUHJlYWN0aW9uUHJvbXB0Q29uZmlndXJhdGlvbiBpZiBpdCBkb2VzIG5vdCBleGlzdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZWFjdGlvbl9wcm9tcHRfY29uZmlndXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24gPSBnZXREZWZhdWx0UHJlYWN0aW9uX1Byb21wdF9Db25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWFjdGlvbnNfY29uZmlndXJhdGlvbi5wdXNoKHByZWFjdGlvbl9wcm9tcHRfY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLnJlc2V0UHJlYWN0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJwcmV0IHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5ld19wcm9tcHRfaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5ld1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgUHJvbXB0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRNb2RlbDxQcm9tcHRNb2RlbD4oUHJvbXB0TW9kZWwubmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld19wcm9tcHQgPSBtb2RlbC5uZXdJbnN0YW5jZSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBQcm9tcHRTZXR0aW5nc01vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3Byb21wdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDcmVhdGUgcHJvbXB0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb21wdCBpcyBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKG5ld19wcm9tcHQuZ2V0SUQoKSwgbmV3X3Byb21wdC5nZXRUaXRsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKG5ld19wcm9tcHQuZ2V0SUQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24uZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24ucHJvbXB0X2lkID0gbmV3X3Byb21wdC5nZXRJRCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRfc2VsZWN0ZWRfcHJvbXB0X29wdGlvbiA9IGRyb3Bkb3duLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb21wdCBjcmVhdGlvbiB3YXMgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUob2xkX3NlbGVjdGVkX3Byb21wdF9vcHRpb24pOyAvLyBSZXNldCB0aGUgZHJvcGRvd24gc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGVsZXRlSW5zdGFuY2UobmV3X3Byb21wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2FzZSBcIm5vLXByb21wdFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBwcm9tcHQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQucmVzZXRQcmVhY3Rpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZF9zZWxlY3RlZF9wcm9tcHRfb3B0aW9uID0gZHJvcGRvd24uZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhbiBleGlzdGluZyBwcm9tcHQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24uZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVhY3Rpb25fcHJvbXB0X2NvbmZpZ3VyYXRpb24ucHJvbXB0X2lkID0gbmV3X3Byb21wdF9pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkX3NlbGVjdGVkX3Byb21wdF9vcHRpb24gPSBkcm9wZG93bi5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYk91dHB1dChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBPdXRwdXQgY2hhbm5lbGluZ1xyXG4gICAgICAgIGNvbnN0IHN0ZG91dF9jaGFubmVsX3NldHRpbmcgPSB0aGlzLm5ld091dHB1dENoYW5uZWxTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50LCBcIk91dHB1dCBjaGFubmVsIGZvciBzdGRvdXRcIiwgXCJzdGRvdXRcIik7XHJcbiAgICAgICAgdGhpcy5uZXdPdXRwdXRDaGFubmVsU2V0dGluZyhjb250YWluZXJfZWxlbWVudCwgXCJPdXRwdXQgY2hhbm5lbCBmb3Igc3RkZXJyXCIsIFwic3RkZXJyXCIsIFwiSWYgYm90aCBzdGRvdXQgYW5kIHN0ZGVyciB1c2UgdGhlIHNhbWUgY2hhbm5lbCwgc3RkZXJyIHdpbGwgYmUgY29tYmluZWQgdG8gc2FtZSBtZXNzYWdlIHdpdGggc3Rkb3V0LlwiKTtcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0IHdyYXBwZXJzXHJcbiAgICAgICAgdGhpcy5uZXdPdXRwdXRXcmFwcGVyU2V0dGluZyhjb250YWluZXJfZWxlbWVudCwgXCJPdXRwdXQgd3JhcHBlciBmb3Igc3Rkb3V0XCIsIFwic3Rkb3V0XCIsIFwiT3V0cHV0IHdyYXBwZXJzIGNhbiBiZSB1c2VkIHRvIHN1cnJvdW5kIG91dHB1dCB3aXRoIHByZWRlZmluZWQgdGV4dCwgZS5nLiB0byBwdXQgb3V0cHV0IGludG8gYSBjb2RlIGJsb2NrLiBOb3RlOiBJZiAnT3V0cHV0IG1vZGUnIGlzICdSZWFsdGltZScsIHdyYXBwZXJzIHdpbGwgcHJvYmFibHkgYXBwZWFyIG11bHRpcGxlIHRpbWVzIGluIG91dHB1dCFcIik7XHJcbiAgICAgICAgdGhpcy5uZXdPdXRwdXRXcmFwcGVyU2V0dGluZyhjb250YWluZXJfZWxlbWVudCwgXCJPdXRwdXQgd3JhcHBlciBmb3Igc3RkZXJyXCIsIFwic3RkZXJyXCIpO1xyXG5cclxuICAgICAgICAvLyBPdXRwdXQgaGFuZGxpbmcgbW9kZVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIk91dHB1dCBoYW5kbGluZyBtb2RlXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiU2V0IHRvICdSZWFsdGltZScgaWYgeW91ciBzaGVsbCBjb21tYW5kIHJ1bnMgZm9yIGEgbG9uZyB0aW1lIEFORCB5b3Ugd2FudCBvdXRwdXQgaGFuZGxpbmcgdG8gc3RhcnQgYXMgc29vbiBhcyBhbnkgb3V0cHV0dGVkIGNvbnRlbnQgaXMgYXZhaWxhYmxlLiBPdXRwdXQgY2hhbm5lbHMgbWlnaHQgYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBzaW5nbGUgcHJvY2Vzcy4gJ1dhaXQgdW50aWwgZmluaXNoZWQnIHBvc3Rwb25lcyBvdXRwdXQgaGFuZGxpbmcgdW50aWwgYWxsIG91dHB1dCBpcyByZWNlaXZlZCwgYW5kIGhhbmRsZXMgaXQgYXMgYSBzaW5nbGUgYnVuY2guIElmIHVuY2VydGFpbiwgdXNlIHRoZSB0cmFkaXRpb25hbCAnV2FpdCB1bnRpbCBmaW5pc2hlZCcuXCIpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYnVmZmVyZWRcIjogXCJXYWl0IHVudGlsIGZpbmlzaGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZWFsdGltZVwiOiBcIlJlYWx0aW1lIChleHBlcmltZW50YWwpXCIsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5vdXRwdXRfaGFuZGxpbmdfbW9kZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3TW9kZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLm91dHB1dF9oYW5kbGluZ19tb2RlID0gbmV3TW9kZSBhcyBPdXRwdXRIYW5kbGluZ01vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAgICAgLy8gRG9jdW1lbnRhdGlvbiBsaW5rXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihpY29uID0+IGljb25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKFwiaGVscFwiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gZ290b1VSTChEb2N1bWVudGF0aW9uT3V0cHV0SGFuZGxpbmdNb2RlTGluaykpXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkRvY3VtZW50YXRpb246IE91dHB1dCBoYW5kbGluZyBtb2RlXCIpLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBPcmRlciBvZiBvdXRwdXQgY2hhbm5lbHNcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJPcmRlciBvZiBzdGRvdXQvc3RkZXJyIG91dHB1dFwiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIldoZW4gb3V0cHV0IGNvbnRhaW5zIGJvdGggZXJyb3JzIGFuZCBub3JtYWwgb3V0cHV0LCB3aGljaCBvbmUgc2hvdWxkIGJlIHByZXNlbnRlZCBmaXJzdD8gKE9ubHkgbWF0dGVycyBpZiAnT3V0cHV0IGhhbmRsaW5nJyBpcyAnV2FpdCB1bnRpbCBmaW5pc2hlZCcpLlwiKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICBcInN0ZG91dC1maXJzdFwiOiBcIlN0ZG91dCBmaXJzdCwgdGhlbiBzdGRlcnIuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdGRlcnItZmlyc3RcIjogXCJTdGRlcnIgZmlyc3QsIHRoZW4gc3Rkb3V0LlwiLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRPdXRwdXRDaGFubmVsT3JkZXIoKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IE91dHB1dENoYW5uZWxPcmRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5vdXRwdXRfY2hhbm5lbF9vcmRlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gRm9jdXMgb24gdGhlIHN0ZG91dCBjaGFubmVsIGRyb3Bkb3duIGZpZWxkXHJcbiAgICAgICAgc3Rkb3V0X2NoYW5uZWxfc2V0dGluZy5jb250cm9sRWwuZmluZChcInNlbGVjdFwiKS5hZGRDbGFzcyhcIlNDLWZvY3VzLWVsZW1lbnQtb24tdGFiLW9wZW5pbmdcIik7XHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBlcnJvcnMgZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJJZ25vcmUgZXJyb3IgY29kZXNcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJBIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIG51bWJlcnMuIElmIGV4ZWN1dGluZyBhIHNoZWxsIGNvbW1hbmQgZmFpbHMgd2l0aCBvbmUgb2YgdGhlc2UgZXhpdCBjb2Rlcywgbm8gZXJyb3IgbWVzc2FnZSB3aWxsIGJlIGRpc3BsYXllZCwgYW5kIHRoZSBhYm92ZSBzdGRlcnIgY2hhbm5lbCB3aWxsIGJlIGlnbm9yZWQuIFN0ZG91dCBjaGFubmVsIHdpbGwgc3RpbGwgYmUgdXNlZCBmb3Igc3Rkb3V0LiBFcnJvciBjb2RlcyBtdXN0IGJlIGludGVnZXJzIGFuZCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMC4gQW55dGhpbmcgZWxzZSB3aWxsIGJlIHJlbW92ZWQuIE5vdGU6IElmICdPdXRwdXQgaGFuZGxpbmcnIGlzICdSZWFsdGltZScsIG5vIGV4aXQgY29kZSBiYXNlZCBpZ25vcmluZyBjYW4gYmUgZG9uZSwgYXMgYW4gZXJyb3IgY29kZSBpcyBvbmx5IHJlY2VpdmVkIHdoZW4gYSBzaGVsbCBjb21tYW5kIHByb2Nlc3MgZmluaXNoZXMuXCIpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldElnbm9yZUVycm9yQ29kZXMoKS5qb2luKFwiLFwiKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWdub3JlX2Vycm9yX2NvZGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd19lcnJvcl9jb2RlcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gcmF3X2Vycm9yX2NvZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd19lcnJvcl9jb2RlID0gcmF3X2Vycm9yX2NvZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcl9jb2RlX2NhbmRpZGF0ZSA9IHBhcnNlSW50KHJhd19lcnJvcl9jb2RlLnRyaW0oKSk7IC8vIEUuZy4gYW4gZW1wdHkgc3RyaW5nIGNvbnZlcnRzIHRvIE5hTiAoPSBOb3QgYSBOdW1iZXIpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZXJyb3IgY29kZSBpcyBub3QgTmFOLCAwIG9yIGEgbmVnYXRpdmUgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGVycm9yX2NvZGVfY2FuZGlkYXRlKSAmJiBlcnJvcl9jb2RlX2NhbmRpZGF0ZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FuZGlkYXRlIGlzIGxlZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlX2Vycm9yX2NvZGVzLnB1c2goZXJyb3JfY29kZV9jYW5kaWRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSB2YWxpZGF0ZWQgZXJyb3IgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5pZ25vcmVfZXJyb3JfY29kZXMgPSBpZ25vcmVfZXJyb3JfY29kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvbl9jb250YWluZXIgPSB0aGlzLm5hbWVfc2V0dGluZy5uYW1lRWwuZmluZChcInNwYW4uc2hlbGwtY29tbWFuZHMtaWdub3JlZC1lcnJvci1jb2Rlcy1pY29uLWNvbnRhaW5lclwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0SWdub3JlRXJyb3JDb2RlcygpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGljb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbl9jb250YWluZXIuc2V0QXR0cihcImFyaWEtbGFiZWxcIiwgZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZSh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRJZ25vcmVFcnJvckNvZGVzKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbl9jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgaWNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uX2NvbnRhaW5lci5hZGRDbGFzcyhcIlNDLWhpZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYkVudmlyb25tZW50cyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBQbGF0Zm9ybSBzcGVjaWZpYyBzaGVsbCBjb21tYW5kc1xyXG4gICAgICAgIGxldCBwbGF0Zm9ybV9pZDogUGxhdGZvcm1JZDtcclxuICAgICAgICBsZXQgaXNfZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgIGZvciAocGxhdGZvcm1faWQgaW4gUGxhdGZvcm1OYW1lcykge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nX2dyb3VwID0gY3JlYXRlUGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZEZpZWxkKHRoaXMucGx1Z2luLCBjb250YWluZXJfZWxlbWVudCwgdGhpcy50X3NoZWxsX2NvbW1hbmQsIHBsYXRmb3JtX2lkLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KTtcclxuICAgICAgICAgICAgaWYgKGlzX2ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBvbiB0aGUgZmlyc3QgT1Mgc3BlY2lmaWMgc2hlbGwgY29tbWFuZCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ19ncm91cC5zaGVsbF9jb21tYW5kX3NldHRpbmcuY29udHJvbEVsLmZpbmQoXCJ0ZXh0YXJlYVwiKS5hZGRDbGFzcyhcIlNDLWZvY3VzLWVsZW1lbnQtb24tdGFiLW9wZW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICBpc19maXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQbGF0Zm9ybSBzcGVjaWZpYyBzaGVsbCBzZWxlY3Rpb25cclxuICAgICAgICBjcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkKHRoaXMucGx1Z2luLCBjb250YWluZXJfZWxlbWVudCwgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGxzKCksIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYkV2ZW50cyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBDb21tYW5kIHBhbGV0dGVcclxuICAgICAgICBjb25zdCBjb21tYW5kX3BhbGV0dGVfYXZhaWxhYmlsaXR5X3NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJBdmFpbGFiaWxpdHkgaW4gT2JzaWRpYW4ncyBjb21tYW5kIHBhbGV0dGVcIilcclxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhDb21tYW5kUGFsZXR0ZU9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBrZXlvZiBJQ29tbWFuZFBhbGV0dGVPcHRpb25zKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbW1hbmQgcGFsZXR0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5jYW5BZGRUb0NvbW1hbmRQYWxldHRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdG8gY29tbWFuZCBwYWxldHRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLnJlZ2lzdGVyVG9Db21tYW5kUGFsZXR0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVucmVnaXN0ZXIgZnJvbSBjb21tYW5kIHBhbGV0dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQudW5yZWdpc3RlckZyb21Db21tYW5kUGFsZXR0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIEZvY3VzIG9uIHRoZSBjb21tYW5kIHBhbGV0dGUgYXZhaWxhYmlsaXR5IGZpZWxkXHJcbiAgICAgICAgY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eV9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwic2VsZWN0XCIpLmFkZENsYXNzKFwiU0MtZm9jdXMtZWxlbWVudC1vbi10YWItb3BlbmluZ1wiKTtcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiRXhlY3V0ZSB0aGlzIHNoZWxsIGNvbW1hbmQgYXV0b21hdGljYWxseSB3aGVuOlwiKVxyXG4gICAgICAgICAgICAuc2V0SGVhZGluZygpIC8vIE1ha2UgdGhlIG5hbWUgYm9sZFxyXG4gICAgICAgIDtcclxuICAgICAgICBnZXRTQ19FdmVudHModGhpcy5wbHVnaW4pLmZvckVhY2goKHNjX2V2ZW50OiBTQ19FdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc19ldmVudF9lbmFibGVkOiBib29sZWFuID0gdGhpcy50X3NoZWxsX2NvbW1hbmQuaXNTQ19FdmVudEVuYWJsZWQoc2NfZXZlbnQuc3RhdGljKCkuZ2V0Q29kZSgpKTtcclxuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeV9vZl9leHRyYV92YXJpYWJsZXMgPSBzY19ldmVudC5nZXRTdW1tYXJ5T2ZFdmVudFZhcmlhYmxlcygpO1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKHNjX2V2ZW50LnN0YXRpYygpLmdldFRpdGxlKCkpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhzdW1tYXJ5X29mX2V4dHJhX3ZhcmlhYmxlcyA/IFwiQWRkaXRpb25hbCB2YXJpYWJsZXM6IFwiICsgc3VtbWFyeV9vZl9leHRyYV92YXJpYWJsZXMgOiBcIlwiKVxyXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGlzX2V2ZW50X2VuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIChlbmFibGU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIHRoZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZW5hYmxlU0NfRXZlbnQoc2NfZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7IC8vIFNob3cgZXh0cmEgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZC5kaXNhYmxlU0NfRXZlbnQoc2NfZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgLy8gSGlkZSBleHRyYSBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9jdW1lbnRhdGlvbiBpY29uXHJcbiAgICAgICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oaWNvbiA9PiBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEljb24oXCJoZWxwXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gZ290b1VSTChzY19ldmVudC5zdGF0aWMoKS5nZXREb2N1bWVudGF0aW9uTGluaygpKSlcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkRvY3VtZW50YXRpb246IFwiICsgc2NfZXZlbnQuc3RhdGljKCkuZ2V0VGl0bGUoKSArIFwiIGV2ZW50XCIpLFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRyYSBzZXR0aW5nc1xyXG4gICAgICAgICAgICBjb25zdCBleHRyYV9zZXR0aW5nc19jb250YWluZXIgPSBjb250YWluZXJfZWxlbWVudC5jcmVhdGVEaXYoKTtcclxuICAgICAgICAgICAgZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBpc19ldmVudF9lbmFibGVkID8gXCJibG9ja1wiIDogXCJub25lXCI7XHJcbiAgICAgICAgICAgIHNjX2V2ZW50LmNyZWF0ZUV4dHJhU2V0dGluZ3NGaWVsZHMoZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyLCB0aGlzLnRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJWYXJpYWJsZXMoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciB2YXJpYWJsZXNcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJEZWZhdWx0IHZhbHVlcyBmb3IgdmFyaWFibGVzXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQ2VydGFpbiB2YXJpYWJsZXMgY2FuIGJlIGluYWNjZXNzaWJsZSBkdXJpbmcgY2VydGFpbiBzaXR1YXRpb25zLCBlLmcuIHt7ZmlsZV9uYW1lfX0gaXMgbm90IGF2YWlsYWJsZSB3aGVuIG5vIGZpbGUgcGFuZSBpcyBmb2N1c2VkLiBZb3UgY2FuIGRlZmluZSBkZWZhdWx0IHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGEgdmFyaWFibGUgaXMgb3RoZXJ3aXNlIHVuYXZhaWxhYmxlLlwiKVxyXG4gICAgICAgICAgICAuc2V0SGVhZGluZygpXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBBZGQgZGVmYXVsdCB2YWx1ZSBmaWVsZHMgZm9yIGVhY2ggdmFyaWFibGUgdGhhdCBjYW4gaGF2ZSBhIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB0aGlzLnBsdWdpbi5nZXRWYXJpYWJsZXMoKSkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGFkZCBmaWVsZHMgZm9yIHZhcmlhYmxlcyB0aGF0IGFyZSBub3QgYWx3YXlzIGFjY2Vzc2libGUuXHJcbiAgICAgICAgICAgIGlmICghdmFyaWFibGUuaXNBbHdheXNBdmFpbGFibGUoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBhbiBpZGVudGlmaWVyIGZvciBhIHZhcmlhYmxlIChhbiBpZCwgaWYgaXQncyBhIEN1c3RvbVZhcmlhYmxlLCBvdGhlcndpc2UgdGhlIHZhcmlhYmxlJ3MgbmFtZSkuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZV9pZGVudGlmaWVyID0gdmFyaWFibGUuZ2V0SWRlbnRpZmllcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGEgZGVmYXVsdCB2YWx1ZSBoYXMgZGVmaW5lZCBmb3IgdGhpcyB2YXJpYWJsZSAoYW5kIHRoaXMgVFNoZWxsQ29tbWFuZCksIHJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRfdmFsdWVfY29uZmlndXJhdGlvbjogVmFyaWFibGVEZWZhdWx0VmFsdWVDb25maWd1cmF0aW9uIHwgdW5kZWZpbmVkID0gdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0RGVmYXVsdFZhbHVlQ29uZmlndXJhdGlvbkZvclZhcmlhYmxlKHZhcmlhYmxlKTsgLy8gTk9URSB0aGF0IHRoaXMgY2FuIGJlIFVOREVGSU5FRCFcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBjb25maWd1cmF0aW9uIGluIG9uQ2hhbmdlKCkgY2FsbGJhY2tzIGlmIHRoZSB2YXJpYWJsZSBkb2VzIG5vdCB5ZXQgaGF2ZSBvbmUgZm9yIHRoaXMgVFNoZWxsQ29tbWFuZC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZV9kZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbjogVmFyaWFibGVEZWZhdWx0VmFsdWVDb25maWd1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNob3ctZXJyb3JzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLnZhcmlhYmxlX2RlZmF1bHRfdmFsdWVzW3ZhcmlhYmxlX2lkZW50aWZpZXJdID0gY29uZmlndXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdGV4dGFyZWFfY29tcG9uZW50OiBUZXh0QXJlYUNvbXBvbmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGZvciB1cGRhdGluZyB0ZXh0YXJlYV9jb21wb25lbnQgdmlzaWJpbGl0eS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZV90ZXh0YXJlYV9jb21wb25lbnRfdmlzaWJpbGl0eSA9ICh0eXBlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhX2NvbXBvbmVudC5pbnB1dEVsLnJlbW92ZUNsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYV9jb21wb25lbnQuaW5wdXRFbC5hZGRDbGFzcyhcIlNDLWhpZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgdmFsdWUgc2V0dGluZ1xyXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUodmFyaWFibGUuZ2V0RnVsbE5hbWUoKSlcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYyhcIklmIG5vdCBhdmFpbGFibGUsIHRoZW46XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAodmFyaWFibGUuZ2V0QXZhaWxhYmlsaXR5VGV4dFBsYWluKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hvdy1lcnJvcnNcIjogXCJDYW5jZWwgZXhlY3V0aW9uIGFuZCBzaG93IGVycm9yc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjYW5jZWwtc2lsZW50bHlcIjogXCJDYW5jZWwgZXhlY3V0aW9uIHNpbGVudGx5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiRXhlY3V0ZSB3aXRoIHZhbHVlOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uID8gZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uLnR5cGUgOiBcInNob3ctZXJyb3JzXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAobmV3X3R5cGU6IHR5cGVvZiBkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24udHlwZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24gPSBjcmVhdGVfZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uLnR5cGUgPSBuZXdfdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInNob3ctZXJyb3JzXCIgPT09IG5ld190eXBlICYmIGRlZmF1bHRfdmFsdWVfY29uZmlndXJhdGlvbi52YWx1ZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIFwic2hvdy1lcnJvcnNcIiBpcyBzZWxlY3RlZCBhbmQgbm8gdGV4dCB2YWx1ZSBpcyB0eXBlZCwgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZSBjYW4gYmUgY2xlYW5lZCB1cCBieSByZW1vdmluZyB0aGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbXBsZXRlbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWxldGluZywgaWYgYSB0ZXh0IHZhbHVlIGlzIHByZXNlbnQsIGJlY2F1c2UgdGhlIHVzZXIgbWlnaHQgd2FudCB0byBrZWVwIGl0IGlmIHRoZXkgd2lsbCBsYXRlciBjaGFuZ2UgJ3R5cGUnIHRvICd2YWx1ZScuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS52YXJpYWJsZV9kZWZhdWx0X3ZhbHVlc1t2YXJpYWJsZV9pZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93L2hpZGUgdGhlIHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVfdGV4dGFyZWFfY29tcG9uZW50X3Zpc2liaWxpdHkobmV3X3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0YXJlYSA9PiB0ZXh0YXJlYV9jb21wb25lbnQgPSB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uID8gZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uLnZhbHVlIDogXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIChuZXdfdmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X3ZhbHVlX2NvbmZpZ3VyYXRpb24gPSBjcmVhdGVfZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgdGV4dCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdF92YWx1ZV9jb25maWd1cmF0aW9uLnZhbHVlID0gbmV3X3ZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigodGV4dGFyZWFfY29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdXRvY29tcGxldGUgZm9yIHRoZSB0ZXh0YXJlYS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlQXV0b2NvbXBsZXRlKHRoaXMucGx1Z2luLCB0ZXh0YXJlYV9jb21wb25lbnQuaW5wdXRFbCwgKCkgPT4gdGV4dGFyZWFfY29tcG9uZW50Lm9uQ2hhbmdlZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlX3RleHRhcmVhX2NvbXBvbmVudF92aXNpYmlsaXR5KGRlZmF1bHRfdmFsdWVfY29uZmlndXJhdGlvbiA/IGRlZmF1bHRfdmFsdWVfY29uZmlndXJhdGlvbi50eXBlIDogXCJzaG93LWVycm9yc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVUYWIodGFiX2lkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLnRhYl9zdHJ1Y3R1cmUuYnV0dG9uc1t0YWJfaWRdKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCB0YWIgaWQ6IFwiICsgdGFiX2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50YWJfc3RydWN0dXJlLmJ1dHRvbnNbdGFiX2lkXS5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbmV3T3V0cHV0Q2hhbm5lbFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LCB0aXRsZTogc3RyaW5nLCBvdXRwdXRfc3RyZWFtX25hbWU6IE91dHB1dFN0cmVhbSwgZGVzY3JpcHRpb24gPSBcIlwiKSB7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X2NoYW5uZWxfb3B0aW9ucyA9IGdldE91dHB1dENoYW5uZWxzT3B0aW9uTGlzdChvdXRwdXRfc3RyZWFtX25hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUodGl0bGUpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKGRlc2NyaXB0aW9uKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKG91dHB1dF9jaGFubmVsX29wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0T3V0cHV0Q2hhbm5lbHMoKVtvdXRwdXRfc3RyZWFtX25hbWVdKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogT3V0cHV0Q2hhbm5lbENvZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRDb25maWd1cmF0aW9uKCkub3V0cHV0X2NoYW5uZWxzW291dHB1dF9zdHJlYW1fbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBuZXdPdXRwdXRXcmFwcGVyU2V0dGluZyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHRpdGxlOiBzdHJpbmcsIG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtLCBkZXNjcmlwdGlvbiA9IFwiXCIpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXRfd3JhcHBlcl9vcHRpb25zOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xyXG4gICAgICAgIHRoaXMucGx1Z2luLmdldE91dHB1dFdyYXBwZXJzKCkuZm9yRWFjaCgob3V0cHV0X3dyYXBwZXI6IE91dHB1dFdyYXBwZXIpID0+IHtcclxuICAgICAgICAgICAgb3V0cHV0X3dyYXBwZXJfb3B0aW9uc1tvdXRwdXRfd3JhcHBlci5nZXRJRCgpXSA9IG91dHB1dF93cmFwcGVyLmdldFRpdGxlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X3dyYXBwZXJzID0gdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLm91dHB1dF93cmFwcGVycztcclxuICAgICAgICBsZXQgb2xkX3NlbGVjdGVkX291dHB1dF93cmFwcGVyX29wdGlvbjogc3RyaW5nID0gKG91dHB1dF93cmFwcGVyc1tvdXRwdXRfc3RyZWFtX25hbWVdKSA/IG91dHB1dF93cmFwcGVyc1tvdXRwdXRfc3RyZWFtX25hbWVdIDogXCJuby1vdXRwdXQtd3JhcHBlclwiO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUodGl0bGUpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKGRlc2NyaXB0aW9uKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd25fY29tcG9uZW50ID0+IGRyb3Bkb3duX2NvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcIm5vLW91dHB1dC13cmFwcGVyXCIsIFwiTm8gXCIrb3V0cHV0X3N0cmVhbV9uYW1lK1wiIHdyYXBwZXJcIilcclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKG91dHB1dF93cmFwcGVyX29wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwibmV3XCIsIFwiQ3JlYXRlIGEgbmV3IG91dHB1dCB3cmFwcGVyXCIpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUob2xkX3NlbGVjdGVkX291dHB1dF93cmFwcGVyX29wdGlvbilcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAob3V0cHV0X3dyYXBwZXJfaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0X3dyYXBwZXJfaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5ld1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgT3V0cHV0V3JhcHBlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyX21vZGVsID0gZ2V0TW9kZWw8T3V0cHV0V3JhcHBlck1vZGVsPihPdXRwdXRXcmFwcGVyTW9kZWwubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdfb3V0cHV0X3dyYXBwZXIgPSBvdXRwdXRfd3JhcHBlcl9tb2RlbC5uZXdJbnN0YW5jZSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBPdXRwdXRXcmFwcGVyU2V0dGluZ3NNb2RhbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19vdXRwdXRfd3JhcHBlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDcmVhdGUgb3V0cHV0IHdyYXBwZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0IHdyYXBwZXIgaXMgY3JlYXRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duX2NvbXBvbmVudC5hZGRPcHRpb24obmV3X291dHB1dF93cmFwcGVyLmdldElEKCksIG5ld19vdXRwdXRfd3JhcHBlci5nZXRUaXRsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duX2NvbXBvbmVudC5zZXRWYWx1ZShuZXdfb3V0cHV0X3dyYXBwZXIuZ2V0SUQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfd3JhcHBlcnNbb3V0cHV0X3N0cmVhbV9uYW1lXSA9IG5ld19vdXRwdXRfd3JhcHBlci5nZXRJRCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRfc2VsZWN0ZWRfb3V0cHV0X3dyYXBwZXJfb3B0aW9uID0gZHJvcGRvd25fY29tcG9uZW50LmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb21wdCBjcmVhdGlvbiB3YXMgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25fY29tcG9uZW50LnNldFZhbHVlKG9sZF9zZWxlY3RlZF9vdXRwdXRfd3JhcHBlcl9vcHRpb24pOyAvLyBSZXNldCB0aGUgZHJvcGRvd24gc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3dyYXBwZXJfbW9kZWwuZGVsZXRlSW5zdGFuY2UobmV3X291dHB1dF93cmFwcGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm8tb3V0cHV0LXdyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBvdXRwdXQgd3JhcHBlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF93cmFwcGVyc1tvdXRwdXRfc3RyZWFtX25hbWVdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGFuIGV4aXN0aW5nIG91dHB1dCB3cmFwcGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3dyYXBwZXJzW291dHB1dF9zdHJlYW1fbmFtZV0gPSBvdXRwdXRfd3JhcHBlcl9pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhcHByb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcGVyZm9ybSBhbnkgYWN0aW9uLCBqdXN0IGNsb3NlIHRoZSBtb2RhbC5cclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge1NDX01vZGFsfSBmcm9tIFwiLi4vU0NfTW9kYWxcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NldHRpbmdGaWVsZEdyb3VwfSBmcm9tIFwiLi9TQ19NYWluU2V0dGluZ3NUYWJcIjtcclxuaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBSZW5hbWUgdG8gRGVsZXRlU2hlbGxDb21tYW5kTW9kYWxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWxldGVNb2RhbCBleHRlbmRzIFNDX01vZGFsIHtcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kO1xyXG4gICAgcHJpdmF0ZSBzZXR0aW5nX2dyb3VwOiBTZXR0aW5nRmllbGRHcm91cDtcclxuICAgIHByaXZhdGUgc2hlbGxfY29tbWFuZF9lbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFNDX1BsdWdpbiwgc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nLCBzZXR0aW5nX2dyb3VwOiBTZXR0aW5nRmllbGRHcm91cCwgc2hlbGxfY29tbWFuZF9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX2lkID0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCA9IHBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ19ncm91cCA9IHNldHRpbmdfZ3JvdXA7XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX2VsZW1lbnQgPSBzaGVsbF9jb21tYW5kX2VsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uT3BlbigpIHtcclxuICAgICAgICBzdXBlci5vbk9wZW4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwiaDJcIiwge3RleHQ6IFwiRGVsZXRlOiBcIiArIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpfSk7IC8vIFRPRE86IFVzZSB0aGlzLnNldFRpdGxlKCkgaW5zdGVhZC5cclxuICAgICAgICBpZiAodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkFsaWFzOiBcIiArIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldEFsaWFzKCl9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgc2hlbGwgY29tbWFuZD9cIn0pO1xyXG4gICAgICAgIGNvbnN0IGRlbGV0ZV9idXR0b24gPSB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJidXR0b25cIiwge3RleHQ6IFwiWWVzLCBkZWxldGVcIn0pO1xyXG4gICAgICAgIGRlbGV0ZV9idXR0b24ub25jbGljayA9IGFzeW5jICgpID0+IHRoaXMuYXBwcm92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhc3luYyBhcHByb3ZlKCkge1xyXG4gICAgICAgIC8vIFVucmVnaXN0ZXIgcG9zc2libGUgZXZlbnRzIGluIG9yZGVyIHRvIHByZXZlbnQgdGhlbSBiZWNvbWluZyBnaG9zdHMgdGhhdCBqdXN0IGtlZXAgZXhlY3V0aW5nIGV2ZW4gYWZ0ZXIgcmVtb3ZpbmcgdGhlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQudW5yZWdpc3RlclNDX0V2ZW50cygpO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGNvbW1hbmRcclxuICAgICAgICBkZWJ1Z0xvZyhcIkNvbW1hbmQgXCIgKyB0aGlzLnNoZWxsX2NvbW1hbmRfaWQgKyBcIiBnb25uYSBiZSByZW1vdmVkLlwiKTtcclxuICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZC51bnJlZ2lzdGVyRnJvbUNvbW1hbmRQYWxldHRlKCk7IC8vIFJlbW92ZSBmcm9tIHRoZSBjb21tYW5kIHBhbGV0dGUuXHJcbiAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLmdldFRTaGVsbENvbW1hbmRzKClbdGhpcy5zaGVsbF9jb21tYW5kX2lkXTsgLy8gUmVtb3ZlIHRoZSBUU2hlbGxDb21tYW5kIG9iamVjdC5cclxuICAgICAgICBjb25zdCBzaGVsbF9jb21tYW5kX2luZGV4ID0gdGhpcy5wbHVnaW4uZ2V0U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbkluZGV4KHRoaXMuc2hlbGxfY29tbWFuZF9pZCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hlbGxfY29tbWFuZHMuc3BsaWNlKHNoZWxsX2NvbW1hbmRfaW5kZXgsMSk7IC8vIFJlbW92ZSBmcm9tIHRoZSBwbHVnaW4ncyBzZXR0aW5ncy5cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZXR0aW5nIGZpZWxkc1xyXG4gICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9lbGVtZW50LnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICBkZWJ1Z0xvZyhcIkNvbW1hbmQgcmVtb3ZlZC5cIik7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uLy4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtIb3RrZXksIHNldEljb259IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge0V4dHJhT3B0aW9uc01vZGFsfSBmcm9tIFwiLi4vRXh0cmFPcHRpb25zTW9kYWxcIjtcclxuaW1wb3J0IHtEZWxldGVNb2RhbH0gZnJvbSBcIi4uL0RlbGV0ZU1vZGFsXCI7XHJcbmltcG9ydCB7Q21kT3JDdHJsLCBnZXRIb3RrZXlzRm9yU2hlbGxDb21tYW5kLCBIb3RrZXlUb1N0cmluZ30gZnJvbSBcIi4uLy4uL0hvdGtleXNcIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQge0NyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZX0gZnJvbSBcIi4vQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRDb3JlXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi8uLi9EZWJ1Z1wiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcbmltcG9ydCB7XHJcbiAgICBlc2NhcGVNYXJrZG93bkxpbmtDaGFyYWN0ZXJzLFxyXG4gICAgY29weVRvQ2xpcGJvYXJkLFxyXG59IGZyb20gXCIuLi8uLi9Db21tb25cIjtcclxuaW1wb3J0IHtcclxuICAgIFNoZWxsQ29tbWFuZEV4ZWN1dG9yXHJcbn0gZnJvbSBcIi4uLy4uL2ltcG9ydHNcIjtcclxuaW1wb3J0IHtTQ19NYWluU2V0dGluZ3NUYWJ9IGZyb20gXCIuLi9TQ19NYWluU2V0dGluZ3NUYWJcIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBwYXJhbSBjb250YWluZXJfZWxlbWVudFxyXG4gKiBAcGFyYW0gc2V0dGluZ190YWJcclxuICogQHBhcmFtIHNoZWxsX2NvbW1hbmRfaWQgRWl0aGVyIGEgc3RyaW5nIGZvcm1hdHRlZCBpbnRlZ2VyIChcIjBcIiwgXCIxXCIgZXRjKSBvciBcIm5ld1wiIGlmIGl0J3MgYSBmaWVsZCBmb3IgYSBjb21tYW5kIHRoYXQgZG9lcyBub3QgZXhpc3QgeWV0LlxyXG4gKiBAcGFyYW0gc2hvd19hdXRvY29tcGxldGVfbWVudVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkKHBsdWdpbjogU0NfUGx1Z2luLCBjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHNldHRpbmdfdGFiOiBTQ19NYWluU2V0dGluZ3NUYWIsIHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZywgc2hvd19hdXRvY29tcGxldGVfbWVudTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgaXNfbmV3ID0gXCJuZXdcIiA9PT0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgIGxldCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQ7XHJcbiAgICBpZiAoaXNfbmV3KSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGNvbW1hbmRcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQgPSBwbHVnaW4ubmV3VFNoZWxsQ29tbWFuZCgpO1xyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfaWQgPSB0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKTsgLy8gUmVwbGFjZSBcIm5ld1wiIHdpdGggYSByZWFsIGlkLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBVc2UgYW4gb2xkIHNoZWxsIGNvbW1hbmRcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQgPSBwbHVnaW4uZ2V0VFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgIH1cclxuICAgIGRlYnVnTG9nKFwiQ3JlYXRlIGNvbW1hbmQgZmllbGQgZm9yIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZCArIChpc19uZXcgPyBcIiAoTkVXKVwiIDogXCJcIikpO1xyXG4gICAgbGV0IHNoZWxsX2NvbW1hbmQ6IHN0cmluZztcclxuICAgIGlmIChpc19uZXcpIHtcclxuICAgICAgICBzaGVsbF9jb21tYW5kID0gXCJcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hlbGxfY29tbWFuZCA9IHRfc2hlbGxfY29tbWFuZC5nZXREZWZhdWx0U2hlbGxDb21tYW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV3JhcCBhbGwgc2hlbGwgY29tbWFuZCBzZXR0aW5nIGVsZW1lbnRzIGluIGEgc2luZ2xlIGRpdi5cclxuICAgIGNvbnN0IHNoZWxsX2NvbW1hbmRfZWxlbWVudCA9IGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZURpdigpO1xyXG4gICAgc2hlbGxfY29tbWFuZF9lbGVtZW50LmFkZENsYXNzKFwiU0MtaWQtXCIgKyBzaGVsbF9jb21tYW5kX2lkKTtcclxuXHJcbiAgICBjb25zdCBzZXR0aW5nX2dyb3VwID0gQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRDb3JlKFxyXG4gICAgICAgIHBsdWdpbixcclxuICAgICAgICBzaGVsbF9jb21tYW5kX2VsZW1lbnQsXHJcbiAgICAgICAgZ2VuZXJhdGVTaGVsbENvbW1hbmRGaWVsZEljb25BbmROYW1lKHRfc2hlbGxfY29tbWFuZCksXHJcbiAgICAgICAgc2hlbGxfY29tbWFuZCxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGwoKSxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgc2hvd19hdXRvY29tcGxldGVfbWVudSxcclxuICAgICAgICBhc3luYyAoc2hlbGxfY29tbWFuZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc19uZXcpIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ3JlYXRpbmcgbmV3IGNvbW1hbmQgXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IFwiICsgc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkNvbW1hbmQgXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCIgZ29ubmEgY2hhbmdlIHRvOiBcIiArIHNoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEbyB0aGlzIGluIGJvdGggY2FzZXMsIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29tbWFuZCBhbmQgd2hlbiBjaGFuZ2luZyBhbiBvbGQgb25lOlxyXG4gICAgICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLnBsYXRmb3JtX3NwZWNpZmljX2NvbW1hbmRzLmRlZmF1bHQgPSBzaGVsbF9jb21tYW5kO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzX25ldykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbW1hbmRcclxuICAgICAgICAgICAgICAgIC8vIHBsdWdpbi5yZWdpc3RlclNoZWxsQ29tbWFuZCh0X3NoZWxsX2NvbW1hbmQpOyAvLyBJIGRvbid0IHRoaW5rIHRoaXMgaXMgbmVlZGVkIHRvIGJlIGRvbmUgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJDb21tYW5kIGNyZWF0ZWQuXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGFuIG9sZCBjb21tYW5kXHJcbiAgICAgICAgICAgICAgICB0X3NoZWxsX2NvbW1hbmQucmVuYW1lT2JzaWRpYW5Db21tYW5kKHRfc2hlbGxfY29tbWFuZC5nZXRTaGVsbENvbW1hbmQoKSwgdF9zaGVsbF9jb21tYW5kLmdldEFsaWFzKCkpOyAvLyBDaGFuZ2UgdGhlIGNvbW1hbmQncyBuYW1lIGluIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlIGFuZCBpbiBob3RrZXkgc2V0dGluZ3MuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkNvbW1hbmQgY2hhbmdlZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIH0sXHJcbiAgICApO1xyXG4gICAgc2V0dGluZ190YWIuc2V0dGluZ19ncm91cHNbc2hlbGxfY29tbWFuZF9pZF0gPSBzZXR0aW5nX2dyb3VwO1xyXG5cclxuICAgIC8vIFByaW1hcnkgaWNvbiBidXR0b25zXHJcbiAgICBzZXR0aW5nX2dyb3VwLm5hbWVfc2V0dGluZ1xyXG4gICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiTm9ybWFsIGNsaWNrOiBFeGVjdXRlIG5vdy4gXCIgKyBDbWRPckN0cmwoKSArIFwiICsgY2xpY2s6IEV4ZWN1dGUgYW5kIGFzayB3aGF0IHRvIGRvIHdpdGggb3V0cHV0LlwiKVxyXG4gICAgICAgICAgICAuc2V0SWNvbihcInJ1bi1jb21tYW5kXCIpXHJcbiAgICAgICAgICAgIC5leHRyYVNldHRpbmdzRWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jIChldmVudDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3RybF9jbGlja2VkID0gZXZlbnQuY3RybEtleTtcclxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIHNoZWxsIGNvbW1hbmQgbm93IChmb3IgdHJ5aW5nIGl0IG91dCBpbiB0aGUgc2V0dGluZ3MpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzaW5nX3Byb2Nlc3MgPSB0X3NoZWxsX2NvbW1hbmQuY3JlYXRlUGFyc2luZ1Byb2Nlc3MobnVsbCk7IC8vIE5vIFNDX0V2ZW50IGlzIGF2YWlsYWJsZSB3aGVuIGV4ZWN1dGluZyBzaGVsbCBjb21tYW5kcyBtYW51YWxseS5cclxuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBwYXJzaW5nX3Byb2Nlc3MucHJvY2VzcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0b3IgPSBuZXcgU2hlbGxDb21tYW5kRXhlY3V0b3IocGx1Z2luLCB0X3NoZWxsX2NvbW1hbmQsIG51bGwpOyAvLyBObyBTQ19FdmVudCBpcyBhdmFpbGFibGUgd2hlbiBtYW51YWxseSBleGVjdXRpbmcgdGhlIHNoZWxsIGNvbW1hbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXhlY3V0b3IuZG9QcmVhY3Rpb25zQW5kRXhlY3V0ZVNoZWxsQ29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ19wcm9jZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsX2NsaWNrZWQgPyBcIm1vZGFsXCIgOiB1bmRlZmluZWQgLy8gSWYgY3RybC9jbWQgaXMgcHJlc3NlZCwgb3ZlcnJpZGUgb3V0cHV0IGNoYW5uZWxzIHdpdGggJ0FzayBhZnRlciBleGVjdXRpb24nIG1vZGFsLiBPdGhlcndpc2UsIHVzZSB1bmRlZmluZWQgdG8gaW5kaWNhdGUgdGhhdCB0aGUgc2hlbGwgY29tbWFuZCdzIG5vcm1hbCBvdXRwdXQgY2hhbm5lbHMgc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2luZ19wcm9jZXNzLmRpc3BsYXlFcnJvck1lc3NhZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKEV4dHJhT3B0aW9uc01vZGFsLkdFTkVSQUxfT1BUSU9OU19TVU1NQVJZKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGFuIGV4dHJhIG9wdGlvbnMgbW9kYWw6IEdlbmVyYWwgdGFiXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBFeHRyYU9wdGlvbnNNb2RhbChwbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQsIHNldHRpbmdfdGFiKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLmFjdGl2YXRlVGFiKFwiZXh0cmEtb3B0aW9ucy1nZW5lcmFsXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChFeHRyYU9wdGlvbnNNb2RhbC5QUkVBQ1RJT05TX09QVElPTlNfU1VNTUFSWSlcclxuICAgICAgICAgICAgLnNldEljb24oXCJub3RlLWdseXBoXCIpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE9wZW4gYW4gZXh0cmEgb3B0aW9ucyBtb2RhbDogUHJlYWN0aW9ucyB0YWJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEV4dHJhT3B0aW9uc01vZGFsKHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ190YWIpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuYWN0aXZhdGVUYWIoXCJleHRyYS1vcHRpb25zLXByZWFjdGlvbnNcIik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKEV4dHJhT3B0aW9uc01vZGFsLk9VVFBVVF9PUFRJT05TX1NVTU1BUlkpXHJcbiAgICAgICAgICAgIC5zZXRJY29uKFwibGluZXMtb2YtdGV4dFwiKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGFuIGV4dHJhIG9wdGlvbnMgbW9kYWw6IE91dHB1dCB0YWJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEV4dHJhT3B0aW9uc01vZGFsKHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ190YWIpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuYWN0aXZhdGVUYWIoXCJleHRyYS1vcHRpb25zLW91dHB1dFwiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldFRvb2x0aXAoRXh0cmFPcHRpb25zTW9kYWwuRU5WSVJPTk1FTlRTX09QVElPTlNfU1VNTUFSWSlcclxuICAgICAgICAgICAgLnNldEljb24oXCJzdGFja2VkLWxldmVsc1wiKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGFuIGV4dHJhIG9wdGlvbnMgbW9kYWw6IEVudmlyb25tZW50cyB0YWJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEV4dHJhT3B0aW9uc01vZGFsKHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ190YWIpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuYWN0aXZhdGVUYWIoXCJleHRyYS1vcHRpb25zLWVudmlyb25tZW50c1wiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldFRvb2x0aXAoRXh0cmFPcHRpb25zTW9kYWwuRVZFTlRTX1NVTU1BUlkpXHJcbiAgICAgICAgICAgIC5zZXRJY29uKFwiZGljZVwiKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGFuIGV4dHJhIG9wdGlvbnMgbW9kYWw6IEV2ZW50cyB0YWJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEV4dHJhT3B0aW9uc01vZGFsKHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ190YWIpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuYWN0aXZhdGVUYWIoXCJleHRyYS1vcHRpb25zLWV2ZW50c1wiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldFRvb2x0aXAoRXh0cmFPcHRpb25zTW9kYWwuVkFSSUFCTEVTX1NVTU1BUlkpXHJcbiAgICAgICAgICAgIC5zZXRJY29uKFwiY29kZS1nbHlwaFwiKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGFuIGV4dHJhIG9wdGlvbnMgbW9kYWw6IFZhcmlhYmxlcyB0YWJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEV4dHJhT3B0aW9uc01vZGFsKHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ190YWIpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuYWN0aXZhdGVUYWIoXCJleHRyYS1vcHRpb25zLXZhcmlhYmxlc1wiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJEZWxldGUgdGhpcyBzaGVsbCBjb21tYW5kXCIpXHJcbiAgICAgICAgICAgIC5zZXRJY29uKFwidHJhc2hcIilcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gT3BlbiBhIGRlbGV0ZSBtb2RhbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgRGVsZXRlTW9kYWwocGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkLCBzZXR0aW5nX2dyb3VwLCBzaGVsbF9jb21tYW5kX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgIDtcclxuXHJcbiAgICAvLyBJbmZvcm1hdGlvbmFsIGljb25zICg9IG5vbi1jbGlja2FibGUpXHJcbiAgICBjb25zdCBpY29uX2NvbnRhaW5lciA9IHNldHRpbmdfZ3JvdXAubmFtZV9zZXR0aW5nLm5hbWVFbC5jcmVhdGVFbChcInNwYW5cIiwge2F0dHI6IHtjbGFzczogXCJTQy1tYWluLWljb24tY29udGFpbmVyXCJ9fSk7XHJcblxyXG4gICAgLy8gXCJBc2sgY29uZmlybWF0aW9uXCIgaWNvbi5cclxuICAgIGNvbnN0IGNvbmZpcm1fZXhlY3V0aW9uX2ljb25fY29udGFpbmVyID0gaWNvbl9jb250YWluZXIuY3JlYXRlRWwoXCJzcGFuXCIsIHthdHRyOiB7XCJhcmlhLWxhYmVsXCI6IFwiQXNrcyBjb25maXJtYXRpb24gYmVmb3JlIGV4ZWN1dGlvbi5cIiwgY2xhc3M6IFwic2hlbGwtY29tbWFuZHMtY29uZmlybS1leGVjdXRpb24taWNvbi1jb250YWluZXJcIn19KTtcclxuICAgIHNldEljb24oY29uZmlybV9leGVjdXRpb25faWNvbl9jb250YWluZXIsIFwibGFuZ3VhZ2VzXCIpO1xyXG4gICAgaWYgKCF0X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlybUV4ZWN1dGlvbigpKSB7XHJcbiAgICAgICAgLy8gRG8gbm90IGRpc3BsYXkgdGhlIGljb24gZm9yIGNvbW1hbmRzIHRoYXQgZG8gbm90IHVzZSBjb25maXJtYXRpb24uXHJcbiAgICAgICAgY29uZmlybV9leGVjdXRpb25faWNvbl9jb250YWluZXIuYWRkQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFwiSWdub3JlZCBlcnJvciBjb2Rlc1wiIGljb25cclxuICAgIGNvbnN0IGlnbm9yZWRfZXJyb3JfY29kZXNfaWNvbl9jb250YWluZXIgPSBpY29uX2NvbnRhaW5lci5jcmVhdGVFbChcInNwYW5cIiwge2F0dHI6IHtcImFyaWEtbGFiZWxcIjogZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZSh0X3NoZWxsX2NvbW1hbmQuZ2V0SWdub3JlRXJyb3JDb2RlcygpKSwgY2xhc3M6IFwic2hlbGwtY29tbWFuZHMtaWdub3JlZC1lcnJvci1jb2Rlcy1pY29uLWNvbnRhaW5lclwifX0pO1xyXG4gICAgc2V0SWNvbihpZ25vcmVkX2Vycm9yX2NvZGVzX2ljb25fY29udGFpbmVyLCBcInN0cmlrZXRocm91Z2gtZ2x5cGhcIik7XHJcbiAgICBpZiAoIXRfc2hlbGxfY29tbWFuZC5nZXRJZ25vcmVFcnJvckNvZGVzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90IGRpc3BsYXkgdGhlIGljb24gZm9yIGNvbW1hbmRzIHRoYXQgZG8gbm90IGlnbm9yZSBhbnkgZXJyb3JzLlxyXG4gICAgICAgIGlnbm9yZWRfZXJyb3JfY29kZXNfaWNvbl9jb250YWluZXIuYWRkQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlY29uZGFyeSBpY29uIGJ1dHRvbnNcclxuICAgIHNldHRpbmdfZ3JvdXAucHJldmlld19zZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAuc2V0SWNvbihcImxpbmtcIilcclxuICAgICAgICAuc2V0VG9vbHRpcChcIkNvcHkgdGhpcyBzaGVsbCBjb21tYW5kJ3MgT2JzaWRpYW4gVVJJIHRvIHRoZSBjbGlwYm9hcmQuIFZpc2l0aW5nIHRoZSBVUkkgZXhlY3V0ZXMgdGhlIHNoZWxsIGNvbW1hbmQuIFwiICsgQ21kT3JDdHJsKCkgKyBcIiArIGNsaWNrOiBDb3B5IGEgbWFya2Rvd24gbGluay5cIilcclxuXHJcbiAgICAgICAgLy8gb25DbGljaygpIGhhbmRsZXIgLSB1c2UgYSBjdXN0b20gb25lIGluc3RlYWQgb2YgRXh0cmFCdXR0b25Db21wb25lbnQub25DbGljaygpLCBiZWNhdXNlIE9ic2lkaWFuIEFQSSAoYXQgbGVhc3Qgdi4gMC4xNC44KSBkb2VzIG5vdCBzdXBwb3J0IGRldGVjdGluZyBDVFJMIHByZXNzLiBodHRwczovL2ZvcnVtLm9ic2lkaWFuLm1kL3QvZnItc2V0dGluZ3MtcGFzcy1tb3VzZWV2ZW50LXRvLWV4dHJhYnV0dG9uY29tcG9uZW50LW9uY2xpY2svMzcxNzdcclxuICAgICAgICAuZXh0cmFTZXR0aW5nc0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3RybF9jbGlja2VkID0gZXZlbnQuY3RybEtleTtcclxuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uX3VyaSA9IHRfc2hlbGxfY29tbWFuZC5nZXRFeGVjdXRpb25VUkkoKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDogc3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAoY3RybF9jbGlja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBIGZ1bGwgbGluayBpcyB3YW50ZWQuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBgWyR7ZXNjYXBlTWFya2Rvd25MaW5rQ2hhcmFjdGVycyh0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSl9XSgke2VzY2FwZU1hcmtkb3duTGlua0NoYXJhY3RlcnMoZXhlY3V0aW9uX3VyaSl9KWA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHRoZSBVUkkgaXMgd2FudGVkLlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhlY3V0aW9uX3VyaTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29weVRvQ2xpcGJvYXJkKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHBsdWdpbi5uZXdOb3RpZmljYXRpb24oXCJDb3BpZWQgdG8gY2xpcGJvYXJkOiBcIiArIEVPTCArIHJlc3VsdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0X3NoZWxsX2NvbW1hbmQuY2FuSGF2ZUhvdGtleXMoKSkge1xyXG4gICAgICAgIHNldHRpbmdfZ3JvdXAucHJldmlld19zZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldEljb24oXCJhbnkta2V5XCIpXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiR28gdG8gaG90a2V5IHNldHRpbmdzLlwiKVxyXG4gICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydHMgb2YgdGhpcyBjbG9zdXJlIGZ1bmN0aW9uIGFyZSBjb3BpZWQgMjAyMi0wNC0yNyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wamVieS9ob3RrZXktaGVscGVyL2Jsb2IvYzhhMDMyZTRjNTJiZDljZTA4Y2I5MDljZWMxNWQxZWQ5ZDBhMzQzOS9zcmMvcGx1Z2luLmpzI0w0MzYtTDQ0MiAoYWxzbyBmcm9tIG90aGVyIGxpbmVzIG9mIHRoZSBzYW1lIGZpbGUpLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVGhpcyBpcyBwcml2YXRlIEFQSSBhY2Nlc3MuIE5vdCBnb29kLCBidXQgdGhlbiBhZ2FpbiB0aGUgZmVhdHVyZSBpcyBub3QgY3J1Y2lhbCAtIGlmIGl0IGJyZWFrcywgaXQgd29uJ3QgaW50ZXJydXB0IGFueXRoaW5nIGltcG9ydGFudC5cclxuICAgICAgICAgICAgICAgIHBsdWdpbi5hcHAuc2V0dGluZz8ub3BlblRhYkJ5SWQoXCJob3RrZXlzXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhvdGtleXNfc2V0dGluZ3NfdGFiID0gcGx1Z2luLmFwcC5zZXR0aW5nLnNldHRpbmdUYWJzLmZpbHRlcih0YWIgPT4gdGFiLmlkID09PSBcImhvdGtleXNcIikuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChob3RrZXlzX3NldHRpbmdzX3RhYiAmJiBob3RrZXlzX3NldHRpbmdzX3RhYi5zZWFyY2hJbnB1dEVsICYmIGhvdGtleXNfc2V0dGluZ3NfdGFiLnVwZGF0ZUhvdGtleVZpc2liaWxpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkhvdGtleXM6IEZpbHRlcmluZyBieSBzaGVsbCBjb21tYW5kIFwiICsgdF9zaGVsbF9jb21tYW5kLmdldE9ic2lkaWFuQ29tbWFuZCgpLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdGtleXNfc2V0dGluZ3NfdGFiLnNlYXJjaElucHV0RWwudmFsdWUgPSB0X3NoZWxsX2NvbW1hbmQuZ2V0T2JzaWRpYW5Db21tYW5kKCkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBob3RrZXlzX3NldHRpbmdzX3RhYi51cGRhdGVIb3RrZXlWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiSG90a2V5czogQ2Fubm90IGRvIGZpbHRlcmluZyBkdWUgdG8gQVBJIGNoYW5nZXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBob3RrZXkgaW5mb3JtYXRpb25cclxuICAgIGlmICghaXNfbmV3ICYmIHRfc2hlbGxfY29tbWFuZC5jYW5IYXZlSG90a2V5cygpKSB7XHJcbiAgICAgICAgY29uc3QgaG90a2V5cyA9IGdldEhvdGtleXNGb3JTaGVsbENvbW1hbmQocGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkKTtcclxuICAgICAgICBpZiAoaG90a2V5cykge1xyXG4gICAgICAgICAgICBsZXQgaG90a2V5c19qb2luZWQgPSBcIlwiO1xyXG4gICAgICAgICAgICBob3RrZXlzLmZvckVhY2goKGhvdGtleTogSG90a2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG90a2V5c19qb2luZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3RrZXlzX2pvaW5lZCArPSBcIjxicj5cIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaG90a2V5c19qb2luZWQgKz0gSG90a2V5VG9TdHJpbmcoaG90a2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvdGtleV9kaXYgPSBzZXR0aW5nX2dyb3VwLnByZXZpZXdfc2V0dGluZy5jb250cm9sRWwuY3JlYXRlRWwoXCJkaXZcIiwge2F0dHI6IHtjbGFzczogXCJzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb24gU0MtaG90a2V5LWluZm9cIn19KTtcclxuICAgICAgICAgICAgLy8gQ29tbWVudCBvdXQgdGhlIGljb24gYmVjYXVzZSBpdCB3b3VsZCBsb29rIGxpa2UgYSBjbGlja2FibGUgYnV0dG9uIChhcyB0aGVyZSBhcmUgb3RoZXIgY2xpY2thYmxlIGljb25zIGluIHRoZSBzZXR0aW5ncykuXHJcbiAgICAgICAgICAgIC8vIHNldEljb24oaG90a2V5X2RpdiwgXCJhbnkta2V5XCIsIDIyKTsgLy8gSG90a2V5IGljb25cclxuICAgICAgICAgICAgaG90a2V5X2Rpdi5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCIgXCIgKyBob3RrZXlzX2pvaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVidWdMb2coXCJDcmVhdGVkLlwiKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmRcclxuICogQHB1YmxpYyBFeHBvcnRlZCBiZWNhdXNlIFNoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsIHVzZXMgdGhpcyB0b28uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGVsbENvbW1hbmRGaWVsZEljb25BbmROYW1lKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgY29uc3QgaWNvbl9odG1sID0gdF9zaGVsbF9jb21tYW5kLmdldEljb25IVE1MKCkgKyBcIiBcIjtcclxuICAgIGlmICh0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSkge1xyXG4gICAgICAgIHJldHVybiBpY29uX2h0bWwgKyB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpY29uX2h0bWwgKyBcIlNoZWxsIGNvbW1hbmQgd2l0aG91dCBhbGlhc1wiO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIGlnbm9yZWRfZXJyb3JfY29kZXNcclxuICogQHB1YmxpYyBFeHBvcnRlZCBiZWNhdXNlIFNoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsIHVzZXMgdGhpcyB0b28uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZShpZ25vcmVkX2Vycm9yX2NvZGVzOiBudW1iZXJbXSkge1xyXG4gICAgY29uc3QgcGx1cmFsID0gaWdub3JlZF9lcnJvcl9jb2Rlcy5sZW5ndGggIT09IDEgPyBcInNcIiA6IFwiXCI7XHJcbiAgICByZXR1cm4gXCJJZ25vcmVkIGVycm9yXCIrcGx1cmFsK1wiOiBcIiArIGlnbm9yZWRfZXJyb3JfY29kZXMuam9pbihcIixcIik7XHJcbn0iLCIvKlxyXG4gKiAnU2hlbGwgY29tbWFuZHMnIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIENvcHlyaWdodCAoQykgMjAyMSAtIDIwMjIgSmFya2tvIExpbm5hbnZpcnRhXHJcbiAqXHJcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XHJcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XHJcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZS5cclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXHJcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXHJcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cclxuICpcclxuICogQ29udGFjdCB0aGUgYXV0aG9yIChKYXJra28gTGlubmFudmlydGEpOiBodHRwczovL2dpdGh1Yi5jb20vVGFpdGF2YS9cclxuICovXHJcblxyXG5pbXBvcnQge0FwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2VhcmNoQ29tcG9uZW50LCBTZXR0aW5nfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge2dldFZhdWx0QWJzb2x1dGVQYXRoLCBnb3RvVVJMfSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7Y3JlYXRlU2hlbGxTZWxlY3Rpb25GaWVsZH0gZnJvbSBcIi4vc2V0dGluZ19lbGVtZW50cy9DcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkXCI7XHJcbmltcG9ydCB7Y3JlYXRlU2hlbGxDb21tYW5kRmllbGR9IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRcIjtcclxuaW1wb3J0IHtjcmVhdGVUYWJzLCBUYWJTdHJ1Y3R1cmV9IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvVGFic1wiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi4vRGVidWdcIjtcclxuaW1wb3J0IHtcclxuICAgIERvY3VtZW50YXRpb25BdXRvY29tcGxldGVMaW5rLFxyXG4gICAgRG9jdW1lbnRhdGlvbk1haW5MaW5rLFxyXG4gICAgRG9jdW1lbnRhdGlvbkJ1aWx0SW5WYXJpYWJsZXNMaW5rLFxyXG4gICAgR2l0SHViTGluayxcclxuICAgIENoYW5nZWxvZ0xpbmssXHJcbiAgICBEb2N1bWVudGF0aW9uQ3VzdG9tVmFyaWFibGVzTGluayxcclxuICAgIExpY2Vuc2VMaW5rLFxyXG4gICAgRG9jdW1lbnRhdGlvbk91dHB1dFdyYXBwZXJzTGluayxcclxufSBmcm9tIFwiLi4vRG9jdW1lbnRhdGlvblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi4vdmFyaWFibGVzL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0U0NfRXZlbnRzfSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50TGlzdFwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtcclxuICAgIEN1c3RvbVZhcmlhYmxlLFxyXG4gICAgQ3VzdG9tVmFyaWFibGVJbnN0YW5jZSxcclxuICAgIEN1c3RvbVZhcmlhYmxlTW9kZWwsXHJcbiAgICBnZXRNb2RlbCxcclxuICAgIGNyZWF0ZVBBVEhBdWdtZW50YXRpb25GaWVsZHMsXHJcbiAgICBQcm9tcHQsXHJcbiAgICBQcm9tcHRNb2RlbFxyXG59IGZyb20gXCIuLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7Y3JlYXRlTmV3TW9kZWxJbnN0YW5jZUJ1dHRvbn0gZnJvbSBcIi4uL21vZGVscy9jcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9uXCI7XHJcbmltcG9ydCB7RXhlY3V0aW9uTm90aWZpY2F0aW9uTW9kZX0gZnJvbSBcIi4vU0NfTWFpblNldHRpbmdzXCI7XHJcbmltcG9ydCB7T3V0cHV0V3JhcHBlck1vZGVsfSBmcm9tIFwiLi4vbW9kZWxzL291dHB1dF93cmFwcGVyL091dHB1dFdyYXBwZXJNb2RlbFwiO1xyXG5pbXBvcnQge091dHB1dFdyYXBwZXJ9IGZyb20gXCIuLi9tb2RlbHMvb3V0cHV0X3dyYXBwZXIvT3V0cHV0V3JhcHBlclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNDX01haW5TZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW46IFNDX1BsdWdpbjtcclxuXHJcbiAgICBwcml2YXRlIHRhYl9zdHJ1Y3R1cmU6IFRhYlN0cnVjdHVyZTtcclxuXHJcbiAgICBwdWJsaWMgc2V0dGluZ19ncm91cHM6IFNldHRpbmdGaWVsZEdyb3VwQ29udGFpbmVyID0ge307XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xyXG5cclxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICB0aGlzLnRhYl9zdHJ1Y3R1cmUgPSBjcmVhdGVUYWJzKGNvbnRhaW5lckVsLCB7XHJcbiAgICAgICAgICAgIFwibWFpbi1zaGVsbC1jb21tYW5kc1wiOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJTaGVsbCBjb21tYW5kc1wiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJydW4tY29tbWFuZFwiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudF9nZW5lcmF0b3I6IChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYlNoZWxsQ29tbWFuZHMoY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtYWluLWVudmlyb25tZW50c1wiOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJFbnZpcm9ubWVudHNcIixcclxuICAgICAgICAgICAgICAgIGljb246IFwic3RhY2tlZC1sZXZlbHNcIixcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJFbnZpcm9ubWVudHMoY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtYWluLXByZWFjdGlvbnNcIjoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUHJlYWN0aW9uc1wiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJub3RlLWdseXBoXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiUHJlYWN0aW9ucyhjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1haW4tb3V0cHV0XCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk91dHB1dFwiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJsaW5lcy1vZi10ZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiT3V0cHV0KGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWFpbi1ldmVudHNcIjoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRXZlbnRzXCIsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBcImRpY2VcIixcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJFdmVudHMoY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtYWluLXZhcmlhYmxlc1wiOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIGljb246IFwiY29kZS1nbHlwaFwiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudF9nZW5lcmF0b3I6IChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYlZhcmlhYmxlcyhjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBEb2N1bWVudGF0aW9uIGxpbmsgJiBHaXRIdWIgbGlua3NcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIikuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsXHJcbiAgICAgICAgICAgIFwiPGEgaHJlZj1cXFwiXCIgKyBEb2N1bWVudGF0aW9uTWFpbkxpbmsgKyBcIlxcXCI+RG9jdW1lbnRhdGlvbjwvYT4gLSBcIiArXHJcbiAgICAgICAgICAgIFwiPGEgaHJlZj1cXFwiXCIgKyBHaXRIdWJMaW5rICsgXCJcXFwiPlNDIG9uIEdpdEh1YjwvYT4gLSBcIiArXHJcbiAgICAgICAgICAgIFwiPGEgaHJlZj1cXFwiXCIgKyBDaGFuZ2Vsb2dMaW5rICsgXCJcXFwiPlNDIHZlcnNpb246IFwiICsgdGhpcy5wbHVnaW4uZ2V0UGx1Z2luVmVyc2lvbigpICsgXCI8L2E+XCIsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQ29weXJpZ2h0IG5vdGljZVxyXG4gICAgICAgIGNvbnN0IGNvcHlyaWdodF9wYXJhZ3JhcGggPSBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIik7XHJcbiAgICAgICAgY29weXJpZ2h0X3BhcmFncmFwaC5hZGRDbGFzcyhcIlNDLXNtYWxsLWZvbnRcIik7XHJcbiAgICAgICAgY29weXJpZ2h0X3BhcmFncmFwaC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgYFxyXG4gICAgICAgICAgICA8ZW0+U2hlbGwgY29tbWFuZHM8L2VtPiBwbHVnaW4gQ29weXJpZ2h0ICZjb3B5OyAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGEuIFRoaXMgcHJvZ3JhbSBjb21lcyB3aXRoIEFCU09MVVRFTFkgTk8gV0FSUkFOVFkuIFRoaXMgaXMgZnJlZSBzb2Z0d2FyZSwgYW5kIHlvdSBhcmUgd2VsY29tZSB0byByZWRpc3RyaWJ1dGUgaXQgdW5kZXIgY2VydGFpbiBjb25kaXRpb25zLiBTZWUgbW9yZSBpbmZvcm1hdGlvbiBpbiB0aGUgbGljZW5zZTogPGEgaHJlZj1cIiR7TGljZW5zZUxpbmt9XCI+R05VIEdQTC0zLjA8L2E+LlxyXG4gICAgICAgIGApO1xyXG5cclxuICAgICAgICAvLyBLRUVQIFRISVMgQUZURVIgQ1JFQVRJTkcgQUxMIEVMRU1FTlRTOlxyXG4gICAgICAgIHRoaXMucmVtZW1iZXJMYXN0UG9zaXRpb24oY29udGFpbmVyRWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiU2hlbGxDb21tYW5kcyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBTaG93IGEgc2VhcmNoIGZpZWxkXHJcbiAgICAgICAgdGhpcy5jcmVhdGVTZWFyY2hGaWVsZChjb250YWluZXJfZWxlbWVudCk7XHJcblxyXG4gICAgICAgIC8vIEEgPGRpdj4gZWxlbWVudCBmb3IgYWxsIGNvbW1hbmQgaW5wdXQgZmllbGRzLiBOZXcgY29tbWFuZCBmaWVsZHMgY2FuIGJlIGNyZWF0ZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgICAgY29uc3QgY29tbWFuZF9maWVsZHNfY29udGFpbmVyID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJkaXZcIik7XHJcblxyXG4gICAgICAgIC8vIEZpZWxkcyBmb3IgbW9kaWZ5aW5nIGV4aXN0aW5nIGNvbW1hbmRzXHJcbiAgICAgICAgbGV0IHNoZWxsX2NvbW1hbmRzX2V4aXN0ID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb21tYW5kX2lkIGluIHRoaXMucGx1Z2luLmdldFRTaGVsbENvbW1hbmRzKCkpIHtcclxuICAgICAgICAgICAgY3JlYXRlU2hlbGxDb21tYW5kRmllbGQodGhpcy5wbHVnaW4sIGNvbW1hbmRfZmllbGRzX2NvbnRhaW5lciwgdGhpcywgY29tbWFuZF9pZCwgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd19hdXRvY29tcGxldGVfbWVudSk7XHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRzX2V4aXN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICdObyBzaGVsbCBjb21tYW5kcyB5ZXQnIHBhcmFncmFwaC5cclxuICAgICAgICBjb25zdCBub19zaGVsbF9jb21tYW5kc19wYXJhZ3JhcGggPSBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiTm8gc2hlbGwgY29tbWFuZHMgeWV0LCBjbGljayB0aGUgJ05ldyBzaGVsbCBjb21tYW5kJyBidXR0b24gYmVsb3cuXCJ9KTtcclxuICAgICAgICBpZiAoc2hlbGxfY29tbWFuZHNfZXhpc3QpIHtcclxuICAgICAgICAgICAgLy8gU2hlbGwgY29tbWFuZHMgZXhpc3QsIHNvIGRvIG5vdCBzaG93IHRoZSBcIk5vIHNoZWxsIGNvbW1hbmRzIHlldFwiIHRleHQuXHJcbiAgICAgICAgICAgIG5vX3NoZWxsX2NvbW1hbmRzX3BhcmFncmFwaC5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBcIk5ldyBjb21tYW5kXCIgYnV0dG9uXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJOZXcgc2hlbGwgY29tbWFuZFwiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkKHRoaXMucGx1Z2luLCBjb21tYW5kX2ZpZWxkc19jb250YWluZXIsIHRoaXMsIFwibmV3XCIsIHRoaXMucGx1Z2luLnNldHRpbmdzLnNob3dfYXV0b2NvbXBsZXRlX21lbnUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vX3NoZWxsX2NvbW1hbmRzX3BhcmFncmFwaC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJOZXcgZW1wdHkgY29tbWFuZCBjcmVhdGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVTZWFyY2hGaWVsZChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBzZWFyY2hfY29udGFpbmVyID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRGl2KCk7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoX3RpdGxlID0gXCJTZWFyY2ggc2hlbGwgY29tbWFuZHNcIjtcclxuICAgICAgICBjb25zdCBzZWFyY2hfc2V0dGluZyA9IG5ldyBTZXR0aW5nKHNlYXJjaF9jb250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKHNlYXJjaF90aXRsZSlcclxuICAgICAgICAgICAgLnNldERlc2MoXCJMb29rcyB1cCBzaGVsbCBjb21tYW5kcycgYWxpYXNlcywgY29tbWFuZHMsIGlkcyBhbmQgaWNvbnMuXCIpXHJcbiAgICAgICAgICAgIC5hZGRTZWFyY2goc2VhcmNoX2NvbXBvbmVudCA9PiBzZWFyY2hfY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoKHNlYXJjaF90ZXJtOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnRfbWF0Y2hlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzaGVsbF9jb21tYW5kX2lkIGluIHRoaXMucGx1Z2luLmdldFRTaGVsbENvbW1hbmRzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBzZWFyY2ggdGVybSB3YXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT0gc2VhcmNoX3Rlcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgYWxsIHNoZWxsIGNvbW1hbmRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHNlYXJjaCB0ZXJtIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZpbmUgZmllbGRzIHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBzZWFyY2ggdGVybVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdF9zaGVsbF9jb21tYW5kID0gdGhpcy5wbHVnaW4uZ2V0VFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaF90YXJnZXRzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmFsaWFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF90YXJnZXRzLnB1c2goLi4uT2JqZWN0LnZhbHVlcyh0X3NoZWxsX2NvbW1hbmQuZ2V0UGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZHMoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBpbmNsdWRlIGljb24gaW4gdGhlIHNlYXJjaCBpZiBpdCdzIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5pY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3RhcmdldHMucHVzaCh0X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmljb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBtYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3RhcmdldHMuZm9yRWFjaCgoc2VhcmNoX3RhcmdldDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaF90YXJnZXQudG9Mb2NhbGVMb3dlckNhc2UoKS5jb250YWlucyhzZWFyY2hfdGVybS50b0xvY2FsZUxvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJTZWFyY2ggXCIgKyBzZWFyY2hfdGVybSArIFwiIE1BVENIRUQgXCIgKyBzZWFyY2hfdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBvciBoaWRlIHRoZSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGVsbF9jb21tYW5kX2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2LlNDLWlkLVwiICsgc2hlbGxfY29tbWFuZF9pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hlbGxfY29tbWFuZF9lbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGVsbCBjb21tYW5kIHNldHRpbmcgZWxlbWVudCBkb2VzIG5vdCBleGlzdCB3aXRoIHNlbGVjdG9yIGRpdi5TQy1pZC1cIiArIHNoZWxsX2NvbW1hbmRfaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVsbF9jb21tYW5kX2VsZW1lbnQucmVtb3ZlQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRfbWF0Y2hlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9lbGVtZW50LmFkZENsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBtYXRjaCBjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiID09IHNlYXJjaF90ZXJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgbWF0Y2ggY291bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF9zZXR0aW5nLnNldE5hbWUoc2VhcmNoX3RpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IG1hdGNoIGNvdW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvdW50X21hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF9zZXR0aW5nLnNldE5hbWUoXCJObyBtYXRjaGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3NldHRpbmcuc2V0TmFtZShcIjEgbWF0Y2hcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3NldHRpbmcuc2V0TmFtZShjb3VudF9tYXRjaGVzICsgXCIgbWF0Y2hlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHNlYXJjaF9jb21wb25lbnQ6IFNlYXJjaENvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvY3VzIG9uIHRoZSBzZWFyY2ggZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX2NvbXBvbmVudC5pbnB1dEVsLmFkZENsYXNzKFwiU0MtZm9jdXMtZWxlbWVudC1vbi10YWItb3BlbmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJFdmVudHMoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIEEgZ2VuZXJhbCBkZXNjcmlwdGlvbiBhYm91dCBldmVudHNcclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiRXZlbnRzIGludHJvZHVjZSBhIHdheSB0byBleGVjdXRlIHNoZWxsIGNvbW1hbmRzIGF1dG9tYXRpY2FsbHkgaW4gY2VydGFpbiBzaXR1YXRpb25zLCBlLmcuIHdoZW4gT2JzaWRpYW4gc3RhcnRzLiBUaGV5IGFyZSBzZXQgdXAgZm9yIGVhY2ggc2hlbGwgY29tbWFuZCBzZXBhcmF0ZWx5LCBidXQgdGhpcyB0YWIgY29udGFpbnMgZ2VuZXJhbCBvcHRpb25zIGZvciB0aGVtLlwifSk7XHJcblxyXG4gICAgICAgIC8vIEVuYWJsZS9kaXNhYmxlIGFsbCBldmVudHNcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJFbmFibGUgZXZlbnRzXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVGhpcyBpcyBhIHF1aWNrIHdheSB0byBpbW1lZGlhdGVseSB0dXJuIG9mZiBhbGwgZXZlbnRzLCBpZiB5b3Ugd2FudC5cIilcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlX2V2ZW50cylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAoZW5hYmxlX2V2ZW50czogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0b2dnbGUgd2FzIGNsaWNrZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlX2V2ZW50cyA9IGVuYWJsZV9ldmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZV9ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlclNDX0V2ZW50cyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnJlZ2lzdGVyIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4udW5yZWdpc3RlclNDX0V2ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBBIGxpc3Qgb2YgY3VycmVudCBlbmFibGUgZXZlbnRzXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIlRoZSBmb2xsb3dpbmcgZ2l2ZXMganVzdCBhIHF1aWNrIGdsYW5jZSBvdmVyIHdoaWNoIGV2ZW50cyBhcmUgZW5hYmxlZCBvbiB3aGljaCBzaGVsbCBjb21tYW5kcy4gVG8gZW5hYmxlL2Rpc2FibGUgZXZlbnRzIGZvciBhIHNoZWxsIGNvbW1hbmQsIGdvIHRvIHRoZSBwYXJ0aWN1bGFyIHNoZWxsIGNvbW1hbmQncyBzZXR0aW5ncyB2aWEgdGhlICdTaGVsbCBjb21tYW5kcycgdGFiLiBUaGUgbGlzdCBpcyBvbmx5IHVwZGF0ZWQgd2hlbiB5b3UgcmVvcGVuIHRoZSB3aG9sZSBzZXR0aW5ncyBwYW5lbC5cIn0pO1xyXG4gICAgICAgIGxldCBmb3VuZF9lbmFibGVkX2V2ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgZ2V0U0NfRXZlbnRzKHRoaXMucGx1Z2luKS5mb3JFYWNoKChzY19ldmVudDogU0NfRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRfZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzID0gc2NfZXZlbnQuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuICAgICAgICAgICAgLy8gSGFzIHRoZSBldmVudCBiZWVuIGVuYWJsZWQgZm9yIGFueSBzaGVsbCBjb21tYW5kcz9cclxuICAgICAgICAgICAgaWYgKGV2ZW50X2VuYWJsZWRfdF9zaGVsbF9jb21tYW5kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFllcywgaXQncyBlbmFibGVkLlxyXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBhIGxpc3Qgb2Ygc2hlbGwgY29tbWFuZHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaF9lbGVtZW50ID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBzY19ldmVudC5zdGF0aWMoKS5nZXRUaXRsZSgpfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0X2VsZW1lbnQgPSBwYXJhZ3JhcGhfZWxlbWVudC5jcmVhdGVFbChcInVsXCIpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRfZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzLmZvckVhY2goKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RfZWxlbWVudC5jcmVhdGVFbChcImxpXCIsIHt0ZXh0OiB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXNPclNoZWxsQ29tbWFuZCgpfSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZm91bmRfZW5hYmxlZF9ldmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWZvdW5kX2VuYWJsZWRfZXZlbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIk5vIGV2ZW50cyBhcmUgZW5hYmxlZCBmb3IgYW55IHNoZWxsIGNvbW1hbmRzLlwifSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiVmFyaWFibGVzKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudClcclxuICAgIHtcclxuICAgICAgICAvLyBcIlByZXZpZXcgdmFyaWFibGVzIGluIGNvbW1hbmQgcGFsZXR0ZVwiIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiUHJldmlldyB2YXJpYWJsZXMgaW4gY29tbWFuZCBwYWxldHRlIGFuZCBtZW51c1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIklmIG9uLCB2YXJpYWJsZSBuYW1lcyBhcmUgc3Vic3RpdHV0ZWQgd2l0aCB0aGVpciByZWFsdGltZSB2YWx1ZXMgd2hlbiB5b3UgdmlldyB5b3VyIGNvbW1hbmRzIGluIHRoZSBjb21tYW5kIHBhbGV0dGUgYW5kIHJpZ2h0IGNsaWNrIGNvbnRleHQgbWVudXMgKGlmIHVzZWQpLiBBIG5pY2Ugd2F5IHRvIGVuc3VyZSB5b3VyIGNvbW1hbmRzIHdpbGwgdXNlIGNvcnJlY3QgdmFsdWVzLlwiKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKGNoZWNrYm94ID0+IGNoZWNrYm94XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ2hhbmdpbmcgcHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlIHRvIFwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXZpZXdfdmFyaWFibGVzX2luX2NvbW1hbmRfcGFsZXR0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gXCJTaG93IGF1dG9jb21wbGV0ZSBtZW51XCIgZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJTaG93IGF1dG9jb21wbGV0ZSBtZW51XCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiSWYgb24sIGEgZHJvcGRvd24gbWVudSBzaG93cyB1cCB3aGVuIHlvdSBiZWdpbiB3cml0aW5nIHt7dmFyaWFibGV9fSBuYW1lcywgc2hvd2luZyBtYXRjaGluZyB2YXJpYWJsZXMgYW5kIHRoZWlyIGluc3RydWN0aW9ucy4gQWxzbyBhbGxvd3MgZGVmaW5pbmcgY3VzdG9tIHN1Z2dlc3Rpb25zIGluIGF1dG9jb21wbGV0ZS55YW1sIGZpbGUgLSBzZWUgdGhlIGRvY3VtZW50YXRpb24uXCIpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoY2hlY2tib3ggPT4gY2hlY2tib3hcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ2hhbmdpbmcgc2hvd19hdXRvY29tcGxldGVfbWVudSB0byBcIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciB0aGUgd2hvbGUgc2V0dGluZ3MgdmlldyB0byBhcHBseSB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGV4dHJhX2J1dHRvbiA9PiBleHRyYV9idXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKFwiaGVscFwiKVxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJEb2N1bWVudGF0aW9uOiBBdXRvY29tcGxldGVcIilcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBnb3RvVVJMKERvY3VtZW50YXRpb25BdXRvY29tcGxldGVMaW5rKVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIEN1c3RvbSB2YXJpYWJsZXNcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJDdXN0b20gdmFyaWFibGVzXCIpXHJcbiAgICAgICAgICAgIC5zZXRIZWFkaW5nKCkgLy8gTWFrZSB0aGUgXCJWYXJpYWJsZXNcIiB0ZXh0IGJvbGQuXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihleHRyYV9idXR0b24gPT4gZXh0cmFfYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcInBhbmUtbGF5b3V0XCIpXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIk9wZW4gYSBwYW5lIHRoYXQgZGlzcGxheXMgYWxsIGN1c3RvbSB2YXJpYWJsZXMgYW5kIHRoZWlyIHZhbHVlcy5cIilcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5jcmVhdGVDdXN0b21WYXJpYWJsZVZpZXcoKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihleHRyYV9idXR0b24gPT4gZXh0cmFfYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImhlbHBcIilcclxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRG9jdW1lbnRhdGlvbjogQ3VzdG9tIHZhcmlhYmxlc1wiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdvdG9VUkwoRG9jdW1lbnRhdGlvbkN1c3RvbVZhcmlhYmxlc0xpbmspO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFNldHRpbmdzIGZvciBlYWNoIEN1c3RvbVZhcmlhYmxlXHJcbiAgICAgICAgY29uc3QgY3VzdG9tX3ZhcmlhYmxlX21vZGVsID0gZ2V0TW9kZWw8Q3VzdG9tVmFyaWFibGVNb2RlbD4oQ3VzdG9tVmFyaWFibGVNb2RlbC5uYW1lKTtcclxuICAgICAgICBjb25zdCBjdXN0b21fdmFyaWFibGVfY29udGFpbmVyID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRGl2KCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4uZ2V0Q3VzdG9tVmFyaWFibGVJbnN0YW5jZXMoKS5mb3JFYWNoKChjdXN0b21fdmFyaWFibGVfaW5zdGFuY2U6IEN1c3RvbVZhcmlhYmxlSW5zdGFuY2UpID0+IHtcclxuICAgICAgICAgICAgY3VzdG9tX3ZhcmlhYmxlX21vZGVsLmNyZWF0ZVNldHRpbmdGaWVsZHMoY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlLCBjdXN0b21fdmFyaWFibGVfY29udGFpbmVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9uPEN1c3RvbVZhcmlhYmxlTW9kZWwsIEN1c3RvbVZhcmlhYmxlSW5zdGFuY2U+KHRoaXMucGx1Z2luLCBDdXN0b21WYXJpYWJsZU1vZGVsLm5hbWUsIGNvbnRhaW5lcl9lbGVtZW50LCBjdXN0b21fdmFyaWFibGVfY29udGFpbmVyLCB0aGlzLnBsdWdpbi5zZXR0aW5ncykudGhlbigpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gQnVpbHQtaW4gdmFyaWFibGUgaW5zdHJ1Y3Rpb25zXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQnVpbHQtaW4gdmFyaWFibGVzXCIpXHJcbiAgICAgICAgICAgIC5zZXRIZWFkaW5nKCkgLy8gTWFrZSB0aGUgXCJWYXJpYWJsZXNcIiB0ZXh0IGJvbGQuXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihleHRyYV9idXR0b24gPT4gZXh0cmFfYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImhlbHBcIilcclxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRG9jdW1lbnRhdGlvbjogQnVpbHQtaW4gdmFyaWFibGVzXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ290b1VSTChEb2N1bWVudGF0aW9uQnVpbHRJblZhcmlhYmxlc0xpbmspXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gdGhpcy5wbHVnaW4uZ2V0VmFyaWFibGVzKCk7XHJcbiAgICAgICAgdmFyaWFibGVzLmZvckVhY2goKHZhcmlhYmxlOiBWYXJpYWJsZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoISh2YXJpYWJsZSBpbnN0YW5jZW9mIEN1c3RvbVZhcmlhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIpO1xyXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoLmluc2VydEFkamFjZW50SFRNTChcImFmdGVyYmVnaW5cIixcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5nZXRIZWxwTmFtZSgpICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxicj5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuaGVscF90ZXh0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmlsaXR5X3RleHQ6IHN0cmluZyA9IHZhcmlhYmxlLmdldEF2YWlsYWJpbGl0eVRleHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFiaWxpdHlfdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8YnI+XCIgKyBhdmFpbGFiaWxpdHlfdGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIldoZW4geW91IHR5cGUgdmFyaWFibGVzIGludG8gY29tbWFuZHMsIGEgcHJldmlldyB0ZXh0IGFwcGVhcnMgdW5kZXIgdGhlIGNvbW1hbmQgZmllbGQgdG8gc2hvdyBob3cgdGhlIGNvbW1hbmQgd2lsbCBsb29rIGxpa2Ugd2hlbiBpdCBnZXRzIGV4ZWN1dGVkIHdpdGggdmFyaWFibGVzIHN1YnN0aXR1dGVkIHdpdGggdGhlaXIgcmVhbCB2YWx1ZXMuXCJ9KTtcclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiU3BlY2lhbCBjaGFyYWN0ZXJzIGluIHZhcmlhYmxlIHZhbHVlcyBhcmUgdHJpZWQgdG8gYmUgZXNjYXBlZCAoZXhjZXB0IGlmIHlvdSB1c2UgQ01EIGFzIHRoZSBzaGVsbCBpbiBXaW5kb3dzKS4gVGhpcyBpcyB0byBpbXByb3ZlIHNlY3VyaXR5IHNvIHRoYXQgYSB2YXJpYWJsZSB3b24ndCBhY2NpZGVudGFsbHkgY2F1c2UgYmFkIHRoaW5ncyB0byBoYXBwZW4uIElmIHlvdSB3YW50IHRvIHVzZSBhIHJhdywgdW5lc2NhcGVkIHZhbHVlLCBhZGQgYW4gZXhjbGFtYXRpb24gbWFyayBiZWZvcmUgdGhlIHZhcmlhYmxlJ3MgbmFtZSwgZS5nLiB7eyF0aXRsZX19LCBidXQgYmUgY2FyZWZ1bCwgaXQncyBkYW5nZXJvdXMhXCJ9KTtcclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiVGhlcmUgaXMgbm8gd2F5IHRvIHByZXZlbnQgdmFyaWFibGUgcGFyc2luZy4gSWYgeW91IG5lZWQge3sgfX0gY2hhcmFjdGVycyBpbiB5b3VyIGNvbW1hbmQsIHRoZXkgd29uJ3QgYmUgcGFyc2VkIGFzIHZhcmlhYmxlcyBhcyBsb25nIGFzIHRoZXkgZG8gbm90IGNvbnRhaW4gYW55IG9mIHRoZSB2YXJpYWJsZSBuYW1lcyBsaXN0ZWQgYmVsb3cuIElmIHlvdSB3b3VsZCBuZWVkIHRvIHBhc3MgZS5nLiB7e3RpdGxlfX0gbGl0ZXJhbGx5IHRvIHlvdXIgY29tbWFuZCwgdGhlcmUgaXMgbm8gd2F5IHRvIGRvIGl0IGF0bSwgcGxlYXNlIGNyZWF0ZSBhIGRpc2N1c3Npb24gaW4gR2l0SHViLlwifSk7XHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkFsbCB2YXJpYWJsZXMgdGhhdCBhY2Nlc3MgdGhlIGN1cnJlbnQgZmlsZSwgbWF5IGNhdXNlIHRoZSBjb21tYW5kIHByZXZpZXcgdG8gZmFpbCBpZiB5b3UgaGFkIG5vIGZpbGUgcGFuZWwgYWN0aXZlIHdoZW4geW91IG9wZW5lZCB0aGUgc2V0dGluZ3Mgd2luZG93IC0gZS5nLiB5b3UgaGFkIGZvY3VzIG9uIGdyYXBoIHZpZXcgaW5zdGVhZCBvZiBhIG5vdGUgPSBubyBmaWxlIGlzIGN1cnJlbnRseSBhY3RpdmUuIEJ1dCB0aGlzIGRvZXMgbm90IGJyZWFrIGFueXRoaW5nIGVsc2UgdGhhbiB0aGUgcHJldmlldy5cIn0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiRW52aXJvbm1lbnRzKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIC8vIFwiV29ya2luZyBkaXJlY3RvcnlcIiBmaWVsZFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIldvcmtpbmcgZGlyZWN0b3J5XCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQSBkaXJlY3Rvcnkgd2hlcmUgeW91ciBjb21tYW5kcyB3aWxsIGJlIHJ1bi4gSWYgZW1wdHksIGRlZmF1bHRzIHRvIHlvdXIgdmF1bHQncyBsb2NhdGlvbi4gQ2FuIGJlIHJlbGF0aXZlICg9IGEgZm9sZGVyIGluIHRoZSB2YXVsdCkgb3IgYWJzb2x1dGUgKD0gY29tcGxldGUgZnJvbSBmaWxlc3lzdGVtIHJvb3QpLlwiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihnZXRWYXVsdEFic29sdXRlUGF0aCh0aGlzLmFwcCkpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mud29ya2luZ19kaXJlY3RvcnkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJDaGFuZ2luZyB3b3JraW5nX2RpcmVjdG9yeSB0byBcIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy53b3JraW5nX2RpcmVjdG9yeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gUGxhdGZvcm1zJyBkZWZhdWx0IHNoZWxsc1xyXG4gICAgICAgIGNyZWF0ZVNoZWxsU2VsZWN0aW9uRmllbGQodGhpcy5wbHVnaW4sIGNvbnRhaW5lcl9lbGVtZW50LCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0X3NoZWxscywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUgZmllbGRzXHJcbiAgICAgICAgY3JlYXRlUEFUSEF1Z21lbnRhdGlvbkZpZWxkcyh0aGlzLnBsdWdpbiwgY29udGFpbmVyX2VsZW1lbnQsIHRoaXMucGx1Z2luLnNldHRpbmdzLmVudmlyb25tZW50X3ZhcmlhYmxlX3BhdGhfYXVnbWVudGF0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJQcmVhY3Rpb25zKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG5cclxuICAgICAgICAvLyBQcm9tcHRzXHJcbiAgICAgICAgY29uc3QgcHJvbXB0X21vZGVsID0gZ2V0TW9kZWw8UHJvbXB0TW9kZWw+KFByb21wdE1vZGVsLm5hbWUpO1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIlByb21wdHNcIilcclxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKSAvLyBNYWtlIHRoZSBcIlByb21wdHNcIiB0ZXh0IHRvIGFwcGVhciBhcyBhIGhlYWRpbmcuXHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNvbnN0IHByb21wdHNfY29udGFpbmVyX2VsZW1lbnQgPSBjb250YWluZXJfZWxlbWVudC5jcmVhdGVEaXYoKTtcclxuICAgICAgICB0aGlzLnBsdWdpbi5nZXRQcm9tcHRzKCkuZm9yRWFjaCgocHJvbXB0OiBQcm9tcHQpID0+IHtcclxuICAgICAgICAgICAgcHJvbXB0X21vZGVsLmNyZWF0ZVNldHRpbmdGaWVsZHMocHJvbXB0LCBwcm9tcHRzX2NvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gJ05ldyBwcm9tcHQnIGJ1dHRvblxyXG4gICAgICAgIGNvbnN0IG5ld19wcm9tcHRfYnV0dG9uX3Byb21pc2UgPSBjcmVhdGVOZXdNb2RlbEluc3RhbmNlQnV0dG9uPFByb21wdE1vZGVsLCBQcm9tcHQ+KHRoaXMucGx1Z2luLCBQcm9tcHRNb2RlbC5uYW1lLCBjb250YWluZXJfZWxlbWVudCwgcHJvbXB0c19jb250YWluZXJfZWxlbWVudCwgdGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgIG5ld19wcm9tcHRfYnV0dG9uX3Byb21pc2UudGhlbigocmVzdWx0OiB7aW5zdGFuY2U6IFByb21wdCwgbWFpbl9zZXR0aW5nOiBTZXR0aW5nfSkgPT4ge1xyXG4gICAgICAgICAgICBwcm9tcHRfbW9kZWwub3BlblNldHRpbmdzTW9kYWwocmVzdWx0Lmluc3RhbmNlLCByZXN1bHQubWFpbl9zZXR0aW5nKTsgLy8gT3BlbiB0aGUgcHJvbXB0IHNldHRpbmdzIG1vZGFsLCBhcyB0aGUgdXNlciB3aWxsIHByb2JhYmx5IHdhbnQgdG8gY29uZmlndXJlIGl0IG5vdyBhbnl3YXkuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJPdXRwdXQoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIE91dHB1dCB3cmFwcGVyc1xyXG4gICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyX21vZGVsID0gZ2V0TW9kZWw8T3V0cHV0V3JhcHBlck1vZGVsPihPdXRwdXRXcmFwcGVyTW9kZWwubmFtZSk7XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiT3V0cHV0IHdyYXBwZXJzXCIpXHJcbiAgICAgICAgICAgIC5zZXRIZWFkaW5nKCkgLy8gTWFrZSB0aGUgXCJPdXRwdXQgd3JhcHBlcnNcIiB0ZXh0IHRvIGFwcGVhciBhcyBhIGhlYWRpbmcuXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihleHRyYV9idXR0b24gPT4gZXh0cmFfYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImhlbHBcIilcclxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRG9jdW1lbnRhdGlvbjogT3V0cHV0IHdyYXBwZXJzXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiBnb3RvVVJMKERvY3VtZW50YXRpb25PdXRwdXRXcmFwcGVyc0xpbmspKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyc19jb250YWluZXJfZWxlbWVudCA9IGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZURpdigpO1xyXG4gICAgICAgIHRoaXMucGx1Z2luLmdldE91dHB1dFdyYXBwZXJzKCkuZm9yRWFjaCgob3V0cHV0X3dyYXBwZXI6IE91dHB1dFdyYXBwZXIpID0+IHtcclxuICAgICAgICAgICAgb3V0cHV0X3dyYXBwZXJfbW9kZWwuY3JlYXRlU2V0dGluZ0ZpZWxkcyhvdXRwdXRfd3JhcHBlciwgb3V0cHV0X3dyYXBwZXJzX2NvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gJ05ldyBvdXRwdXQgd3JhcHBlcicgYnV0dG9uXHJcbiAgICAgICAgY29uc3QgbmV3X291dHB1dF93cmFwcGVyX2J1dHRvbl9wcm9taXNlID0gY3JlYXRlTmV3TW9kZWxJbnN0YW5jZUJ1dHRvbjxPdXRwdXRXcmFwcGVyTW9kZWwsIE91dHB1dFdyYXBwZXI+KHRoaXMucGx1Z2luLCBPdXRwdXRXcmFwcGVyTW9kZWwubmFtZSwgY29udGFpbmVyX2VsZW1lbnQsIG91dHB1dF93cmFwcGVyc19jb250YWluZXJfZWxlbWVudCwgdGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgIG5ld19vdXRwdXRfd3JhcHBlcl9idXR0b25fcHJvbWlzZS50aGVuKChyZXN1bHQ6IHtpbnN0YW5jZTogT3V0cHV0V3JhcHBlciwgbWFpbl9zZXR0aW5nOiBTZXR0aW5nfSkgPT4ge1xyXG4gICAgICAgICAgICBvdXRwdXRfd3JhcHBlcl9tb2RlbC5vcGVuU2V0dGluZ3NNb2RhbChyZXN1bHQuaW5zdGFuY2UsIHJlc3VsdC5tYWluX3NldHRpbmcpOyAvLyBPcGVuIHRoZSBvdXRwdXQgd3JhcHBlciBzZXR0aW5ncyBtb2RhbCwgYXMgdGhlIHVzZXIgd2lsbCBwcm9iYWJseSB3YW50IHRvIGNvbmZpZ3VyZSBpdCBub3cgYW55d2F5LlxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gXCJFcnJvciBtZXNzYWdlIGR1cmF0aW9uXCIgZmllbGRcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vdGlmaWNhdGlvbkR1cmF0aW9uRmllbGQoY29udGFpbmVyX2VsZW1lbnQsIFwiRXJyb3IgbWVzc2FnZSBkdXJhdGlvblwiLCBcIkNvbmNlcm5zIG1lc3NhZ2VzIGFib3V0IGZhaWxlZCBzaGVsbCBjb21tYW5kcy5cIiwgXCJlcnJvcl9tZXNzYWdlX2R1cmF0aW9uXCIpO1xyXG5cclxuICAgICAgICAvLyBcIk5vdGlmaWNhdGlvbiBtZXNzYWdlIGR1cmF0aW9uXCIgZmllbGRcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vdGlmaWNhdGlvbkR1cmF0aW9uRmllbGQoY29udGFpbmVyX2VsZW1lbnQsIFwiTm90aWZpY2F0aW9uIG1lc3NhZ2UgZHVyYXRpb25cIiwgXCJDb25jZXJucyBpbmZvcm1hdGlvbmFsLCBub24tZmF0YWwgbWVzc2FnZXMsIGUuZy4gb3V0cHV0IGRpcmVjdGVkIHRvICdOb3RpZmljYXRpb24gYmFsbG9vbicuXCIsIFwibm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb25cIik7XHJcblxyXG4gICAgICAgIC8vIFwiU2hvdyBhIG5vdGlmaWNhdGlvbiB3aGVuIGV4ZWN1dGluZyBzaGVsbCBjb21tYW5kc1wiIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiU2hvdyBhIG5vdGlmaWNhdGlvbiB3aGVuIGV4ZWN1dGluZyBzaGVsbCBjb21tYW5kc1wiKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd25fY29tcG9uZW50ID0+IGRyb3Bkb3duX2NvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWRcIjogXCJEbyBub3Qgc2hvd1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicXVpY2tcIjogXCJTaG93IGZvciBcIiArIHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGlmaWNhdGlvbl9tZXNzYWdlX2R1cmF0aW9uICsgXCIgc2Vjb25kc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicGVybWFuZW50XCI6IFwiU2hvdyB1bnRpbCB0aGUgcHJvY2VzcyBpcyBmaW5pc2hlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWYtbG9uZ1wiOiBcIlNob3cgb25seSBpZiBleGVjdXRpbmcgdGFrZXMgbG9uZ1wiLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGVjdXRpb25fbm90aWZpY2F0aW9uX21vZGUpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKG5ld19leGVjdXRpb25fbm90aWZpY2F0aW9uX21vZGU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGVjdXRpb25fbm90aWZpY2F0aW9uX21vZGUgPSBuZXdfZXhlY3V0aW9uX25vdGlmaWNhdGlvbl9tb2RlIGFzIEV4ZWN1dGlvbk5vdGlmaWNhdGlvbk1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gXCJPdXRwdXQgY2hhbm5lbCAnQ2xpcGJvYXJkJyBkaXNwbGF5cyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlLCB0b29cIiBmaWVsZFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIk91dHB1dCBjaGFubmVsICdDbGlwYm9hcmQnIGRpc3BsYXlzIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2UsIHRvb1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIklmIGEgc2hlbGwgY29tbWFuZCdzIG91dHB1dCBpcyBkaXJlY3RlZCB0byB0aGUgY2xpcGJvYXJkLCBhbHNvIHNob3cgdGhlIG91dHB1dCBpbiBhIHBvcHVwIGJveCBvbiB0aGUgdG9wIHJpZ2h0IGNvcm5lci4gVGhpcyBoZWxwcyB0byBub3RpY2Ugd2hhdCB3YXMgaW5zZXJ0ZWQgaW50byBjbGlwYm9hcmQuXCIpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoY2hlY2tib3ggPT4gY2hlY2tib3hcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRfY2hhbm5lbF9jbGlwYm9hcmRfYWxzb19vdXRwdXRzX3RvX25vdGlmaWNhdGlvbilcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRfY2hhbm5lbF9jbGlwYm9hcmRfYWxzb19vdXRwdXRzX3RvX25vdGlmaWNhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVOb3RpZmljYXRpb25EdXJhdGlvbkZpZWxkKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgdGl0bGU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgc2V0dGluZ19uYW1lOiBcImVycm9yX21lc3NhZ2VfZHVyYXRpb25cIiB8IFwibm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb25cIikge1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZSh0aXRsZSlcclxuICAgICAgICAgICAgLnNldERlc2MoZGVzY3JpcHRpb24gKyBcIiBJbiBzZWNvbmRzLCBiZXR3ZWVuIDEgYW5kIDE4MC5cIilcclxuICAgICAgICAgICAgLmFkZFRleHQoZmllbGQgPT4gZmllbGRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTdHJpbmcodGhpcy5wbHVnaW4uc2V0dGluZ3Nbc2V0dGluZ19uYW1lXSkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKGR1cmF0aW9uX3N0cmluZzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb246IG51bWJlciA9IHBhcnNlSW50KGR1cmF0aW9uX3N0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID49IDEgJiYgZHVyYXRpb24gPD0gMTgwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ2hhbmdlIFwiICsgc2V0dGluZ19uYW1lICsgXCIgZnJvbSBcIiArIHRoaXMucGx1Z2luLnNldHRpbmdzW3NldHRpbmdfbmFtZV0gKyBcIiB0byBcIiArIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Nbc2V0dGluZ19uYW1lXSA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJDaGFuZ2VkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyBhIG5vdGljZSBpZiBkdXJhdGlvbiBpcyBub3QgYmV0d2VlbiAxIGFuZCAxODAsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBhIHVzZXIgdHlwZXMgaW4gdGhpcyBmaWVsZCwgc28gdGhlIHZhbHVlIG1pZ2h0IG5vdCBiZSBmaW5hbC5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBsYXN0X3Bvc2l0aW9uOiB7XHJcbiAgICAgICAgc2Nyb2xsX3Bvc2l0aW9uOiBudW1iZXI7XHJcbiAgICAgICAgdGFiX25hbWU6IHN0cmluZztcclxuICAgIH0gPSB7XHJcbiAgICAgICAgc2Nyb2xsX3Bvc2l0aW9uOiAwLFxyXG4gICAgICAgIHRhYl9uYW1lOiBcIm1haW4tc2hlbGwtY29tbWFuZHNcIixcclxuICAgIH07XHJcbiAgICBwcml2YXRlIHJlbWVtYmVyTGFzdFBvc2l0aW9uKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IGxhc3RfcG9zaXRpb24gPSB0aGlzLmxhc3RfcG9zaXRpb247XHJcblxyXG4gICAgICAgIC8vIEdvIHRvIGxhc3QgcG9zaXRpb24gbm93XHJcbiAgICAgICAgdGhpcy50YWJfc3RydWN0dXJlLmJ1dHRvbnNbbGFzdF9wb3NpdGlvbi50YWJfbmFtZV0uY2xpY2soKTtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IC8vIE5lZWQgdG8gZGVsYXkgdGhlIHNjcm9sbGluZyBhIGJpdC4gV2l0aG91dCB0aGlzLCBzb21ldGhpbmcgZWxzZSB3b3VsZCBvdmVycmlkZSBzY3JvbGxpbmcgYW5kIHNjcm9sbCBiYWNrIHRvIDAuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LnNjcm9sbFRvKHtcclxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5sYXN0X3Bvc2l0aW9uLnNjcm9sbF9wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBcImF1dG9cIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgMCk7IC8vICd0aW1lb3V0JyBjYW4gYmUgMCBtcywgbm8gbmVlZCB0byB3YWl0IGFueSBsb25nZXIuXHJcblxyXG4gICAgICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0X3Bvc2l0aW9uLnNjcm9sbF9wb3NpdGlvbiA9IGNvbnRhaW5lcl9lbGVtZW50LnNjcm9sbFRvcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRhYl9uYW1lIGluIHRoaXMudGFiX3N0cnVjdHVyZS5idXR0b25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMudGFiX3N0cnVjdHVyZS5idXR0b25zW3RhYl9uYW1lXTtcclxuICAgICAgICAgICAgYnV0dG9uLm9uQ2xpY2tFdmVudCgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxhc3RfcG9zaXRpb24udGFiX25hbWUgPSB0YWJfbmFtZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdGaWVsZEdyb3VwIHtcclxuICAgIG5hbWVfc2V0dGluZzogU2V0dGluZztcclxuICAgIHNoZWxsX2NvbW1hbmRfc2V0dGluZzogU2V0dGluZztcclxuICAgIHByZXZpZXdfc2V0dGluZzogU2V0dGluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5nRmllbGRHcm91cENvbnRhaW5lciB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBTZXR0aW5nRmllbGRHcm91cCxcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc2V0dGluZ3MvU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IHtcclxuICAgIGdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZSxcclxuICAgIGdldE9wZXJhdGluZ1N5c3RlbSxcclxuICAgIG1lcmdlU2V0cyxcclxuICAgIHJlbW92ZUZyb21TZXQsXHJcbn0gZnJvbSBcIi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge2dldFNDX0V2ZW50c30gZnJvbSBcIi4vZXZlbnRzL1NDX0V2ZW50TGlzdFwiO1xyXG5pbXBvcnQge2RlYnVnTG9nfSBmcm9tIFwiLi9EZWJ1Z1wiO1xyXG5pbXBvcnQge0NvbW1hbmR9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlU2V0fSBmcm9tIFwiLi92YXJpYWJsZXMvbG9hZFZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge2dldFVzZWRWYXJpYWJsZXN9IGZyb20gXCIuL3ZhcmlhYmxlcy9wYXJzZVZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgY3JlYXRlUHJlYWN0aW9uLFxyXG4gICAgQ3VzdG9tVmFyaWFibGUsXHJcbiAgICBnZXRJREdlbmVyYXRvcixcclxuICAgIGdldFBBVEhBdWdtZW50YXRpb24sXHJcbiAgICBQYXJzaW5nUHJvY2VzcyxcclxuICAgIFByZWFjdGlvbixcclxuICAgIFByZWFjdGlvbkNvbmZpZ3VyYXRpb25cclxufSBmcm9tIFwiLi9pbXBvcnRzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBWYXJpYWJsZSxcclxuICAgIFZhcmlhYmxlRGVmYXVsdFZhbHVlQ29uZmlndXJhdGlvbixcclxufSBmcm9tIFwiLi92YXJpYWJsZXMvVmFyaWFibGVcIjtcclxuaW1wb3J0IHtcclxuICAgIFBsYXRmb3JtSWQsXHJcbiAgICBQbGF0Zm9ybU5hbWVzLFxyXG59IGZyb20gXCIuL3NldHRpbmdzL1NDX01haW5TZXR0aW5nc1wiO1xyXG5pbXBvcnQge2dldEljb25IVE1MfSBmcm9tIFwiLi9JY29uc1wiO1xyXG5pbXBvcnQge091dHB1dFN0cmVhbX0gZnJvbSBcIi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxDb2RlXCI7XHJcbmltcG9ydCB7T3V0cHV0V3JhcHBlcn0gZnJvbSBcIi4vbW9kZWxzL291dHB1dF93cmFwcGVyL091dHB1dFdyYXBwZXJcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVFNoZWxsQ29tbWFuZENvbnRhaW5lciB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBUU2hlbGxDb21tYW5kLFxyXG59XHJcblxyXG4vKipcclxuICogVE9ETzogUmVuYW1lIHRoaXMgY2xhc3MuIFJlcGxhY2UgdGhlIFQgcHJlZml4IHdpdGggc29tZXRoaW5nIGVsc2UuIFRoZSBUIHN0YW5kcyBmb3IgVHlwZSAoa2luZCBvZiBsaWtlIFRGaWxlIGZyb20gT2JzaWRpYW4pLCBidXQgdGhpcyBpcyBub3QgYSB0eXBlLCB0aGlzIGlzIGEgY2xhc3MuIE1heWJlIFNoZWxsQ29tbWFuZEluc3RhbmNlPyBJdCdzIG5vdCB0aGUgYmVzdCBuYW1lLCBidXQgSSBjYW4ndCBjb21lIHVwIHdpdGggYSBiZXR0ZXIgb25lIG5vdy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUU2hlbGxDb21tYW5kIHtcclxuXHJcbiAgICBwcml2YXRlIHBsdWdpbjogU0NfUGx1Z2luO1xyXG4gICAgcHJpdmF0ZSBjb25maWd1cmF0aW9uOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uO1xyXG4gICAgcHJpdmF0ZSBvYnNpZGlhbl9jb21tYW5kOiBDb21tYW5kO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwbHVnaW46IFNDX1BsdWdpbiwgY29uZmlndXJhdGlvbjogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XHJcblxyXG4gICAgICAgIC8vIEludHJvZHVjZSB0aGUgSUQgdG8gYW4gSUQgZ2VuZXJhdG9yIHNvIHRoYXQgaXQgd29uJ3QgYWNjaWRlbnRhbGx5IGdlbmVyYXRlIHRoZSBzYW1lIElEIGFnYWluIHdoZW4gY3JlYXRpbmcgbmV3IHNoZWxsIGNvbW1hbmRzLlxyXG4gICAgICAgIGdldElER2VuZXJhdG9yKCkuYWRkUmVzZXJ2ZWRJRChjb25maWd1cmF0aW9uLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGx1Z2luKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoaXMgd2hlbiB5b3UgbmVlZCB0byBhbHRlciB0aGUgY29uZmlndXJhdGlvbiB2YWx1ZXMuIGlmIHlvdSBvbmx5IG5lZWQgdG8gcmVhZCBjb25maWd1cmF0aW9uIHZhbHVlcywgdXNlIGdldCooKVxyXG4gICAgICogbWV0aG9kcyBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29uZmlndXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRJZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTaGVsbCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG9wZXJhdGluZ19zeXN0ZW0gPSBnZXRPcGVyYXRpbmdTeXN0ZW0oKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNoZWxsIGNvbW1hbmQgaGFzIGRlZmluZWQgYSBzcGVjaWZpYyBzaGVsbC5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLmNvbmZpZ3VyYXRpb24uc2hlbGxzW29wZXJhdGluZ19zeXN0ZW1dKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaGVsbCBjb21tYW5kIGRvZXMgbm90IGRlZmluZSBhbiBleHBsaWNpdCBzaGVsbC5cclxuICAgICAgICAgICAgLy8gVXNlIGEgZGVmYXVsdCBzaGVsbCBmcm9tIHRoZSBwbHVnaW4ncyBzZXR0aW5ncy5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLmdldERlZmF1bHRTaGVsbCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaGVsbCBjb21tYW5kIGhhcyBhbiBleHBsaWNpdCBzaGVsbCBkZWZpbmVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnNoZWxsc1tvcGVyYXRpbmdfc3lzdGVtXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFNoZWxscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnNoZWxscztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzaGVsbCBjb21tYW5kIHN0cmluZyBzcGVjaWZpYyBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbSwgb3IgYSBnZW5lcmljIHNoZWxsIGNvbW1hbmQgaWYgdGhpcyBzaGVsbFxyXG4gICAgICogY29tbWFuZCBkb2VzIG5vdCBoYXZlIGFuIGV4cGxpY2l0IHZlcnNpb24gZm9yIHRoZSBjdXJyZW50IE9TLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hlbGxDb21tYW5kKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgb3BlcmF0aW5nX3N5c3RlbSA9IGdldE9wZXJhdGluZ1N5c3RlbSgpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2hlbGwgY29tbWFuZCBoYXMgZGVmaW5lZCBhIHNwZWNpZmljIGNvbW1hbmQgZm9yIHRoaXMgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLmNvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHNbb3BlcmF0aW5nX3N5c3RlbV0pIHtcclxuICAgICAgICAgICAgLy8gTm8gY29tbWFuZCBpcyBkZWZpbmVkIHNwZWNpZmljYWxseSBmb3IgdGhpcyBvcGVyYXRpbmcgc3lzdGVtLlxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gXCJPUyBhZ25vc3RpY1wiIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHMuZGVmYXVsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgc2hlbGwgY29tbWFuZCBoYXMgZGVmaW5lZCBhIHNwZWNpZmljIGNvbW1hbmQgZm9yIHRoaXMgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5wbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kc1tvcGVyYXRpbmdfc3lzdGVtXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgc2hlbGwgY29tbWFuZCB0aGF0IHNob3VsZCBiZSB1c2VkIGlmIG5vIHBsYXRmb3JtIHNwZWNpZmljIGNvbW1hbmQgaXMgZGVmaW5lZCBmb3IgdGhlXHJcbiAgICAgKiBjdXJyZW50IHBsYXRmb3JtLiBJZiB5b3UgcGxhbiB0byB1c2UgdGhpcyBmb3IgZXhlY3V0aW9uLCBjb25zaWRlciB1c2luZyBnZXRTaGVsbENvbW1hbmQoKSBpbnN0ZWFkLCBhcyBpdCB0YWtlcyB0aGVcclxuICAgICAqIGN1cnJlbnQgcGxhdGZvcm0gaW50byBhY2NvdW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGVmYXVsdFNoZWxsQ29tbWFuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBsYXRmb3JtX3NwZWNpZmljX2NvbW1hbmRzLmRlZmF1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBsYXRmb3JtU3BlY2lmaWNTaGVsbENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBQbGF0Zm9ybUlkcyB0aGF0IGhhdmUgYSBzaGVsbCBjb21tYW5kIHZlcnNpb24gZGVmaW5lZC4gJ2RlZmF1bHQnIGlzIG5ldmVyIGluY2x1ZGVkIGluIHRoZSBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIFRPRE86IEludmVudCBhIGJldHRlciBuYW1lIGZvciB0aGlzIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE5vbkVtcHR5UGxhdGZvcm1JZHMoKSB7XHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm1fc3BlY2lmaWNfc2hlbGxfY29tbWFuZHMgPSB0aGlzLmdldFBsYXRmb3JtU3BlY2lmaWNTaGVsbENvbW1hbmRzKCk7XHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm1faWRzX3dpdGhfbm9uX2VtcHR5X3NoZWxsX2NvbW1hbmRzOiBQbGF0Zm9ybUlkW10gPSBbXTtcclxuICAgICAgICBsZXQgcGxhdGZvcm1faWQ6IFBsYXRmb3JtSWQ7XHJcbiAgICAgICAgZm9yIChwbGF0Zm9ybV9pZCBpbiBQbGF0Zm9ybU5hbWVzKSB7IC8vIE5vdGUgdGhhdCB0aGlzIGxvb3AgZG9lcyBub3QgaXRlcmF0ZSAnZGVmYXVsdCcgcGxhdGZvcm0gaWQgKD0gdGhlIGZhbGxiYWNrIHBsYXRmb3JtIGlkIHRoYXQgaXMgdXNlZCB3aGVuIGEgc2hlbGwgY29tbWFuZCBkb2VzIG5vdCBoYXZlIGEgdmVyc2lvbiBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0pLlxyXG4gICAgICAgICAgICBjb25zdCBwbGF0Zm9ybV9zcGVjaWZpY19zaGVsbF9jb21tYW5kID0gcGxhdGZvcm1fc3BlY2lmaWNfc2hlbGxfY29tbWFuZHNbcGxhdGZvcm1faWQgYXMgUGxhdGZvcm1JZF07XHJcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybV9zcGVjaWZpY19zaGVsbF9jb21tYW5kICYmIFwiXCIgIT09IHBsYXRmb3JtX3NwZWNpZmljX3NoZWxsX2NvbW1hbmQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV9pZHNfd2l0aF9ub25fZW1wdHlfc2hlbGxfY29tbWFuZHMucHVzaChwbGF0Zm9ybV9pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtX2lkc193aXRoX25vbl9lbXB0eV9zaGVsbF9jb21tYW5kcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SWNvbklkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaWNvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SWNvbkhUTUwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5pY29uKSB7XHJcbiAgICAgICAgICAgIC8vIEFuIGljb24gaXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgcmV0dXJuIGdldEljb25IVE1MKHRoaXMuY29uZmlndXJhdGlvbi5pY29uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBpY29uIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QWxpYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5hbGlhcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE86IFVzZSB0aGlzIG1ldGhvZCBpbiBhbGwgcGxhY2VzIHdoZXJlIHNpbWlsYXIgbG9naWMgaXMgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QWxpYXNPclNoZWxsQ29tbWFuZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYWxpYXMgfHwgdGhpcy5nZXRTaGVsbENvbW1hbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29uZmlybUV4ZWN1dGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmNvbmZpcm1fZXhlY3V0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRJZ25vcmVFcnJvckNvZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaWdub3JlX2Vycm9yX2NvZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRPdXRwdXRDaGFubmVsT3JkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbF9vcmRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0T3V0cHV0Q2hhbm5lbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE91dHB1dEhhbmRsaW5nTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm91dHB1dF9oYW5kbGluZ19tb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYW4gb3V0cHV0IHdyYXBwZXIgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuIE91dHB1dFN0cmVhbS4gUmV0dXJucyBudWxsLCBpZiBubyBPdXRwdXRXcmFwcGVyIHNob3VsZFxyXG4gICAgICogYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0X3N0cmVhbVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T3V0cHV0V3JhcHBlcihvdXRwdXRfc3RyZWFtOiBPdXRwdXRTdHJlYW0pOiBPdXRwdXRXcmFwcGVyIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X3dyYXBwZXJfaWQgPSB0aGlzLmNvbmZpZ3VyYXRpb24ub3V0cHV0X3dyYXBwZXJzW291dHB1dF9zdHJlYW1dO1xyXG4gICAgICAgIGlmICghb3V0cHV0X3dyYXBwZXJfaWQpIHtcclxuICAgICAgICAgICAgLy8gTm8gb3V0cHV0IHdyYXBwZXIgaXMgZGVmaW5lZCBmb3IgdGhpcyBvdXRwdXQgc3RyZWFtIGluIHRoaXMgc2hlbGwgY29tbWFuZC5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0X3dyYXBwZXIgb2YgdGhpcy5wbHVnaW4uZ2V0T3V0cHV0V3JhcHBlcnMoKS52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBvdXRwdXQgd3JhcHBlciBkZWZpbmVkIGZvciB0aGlzIHNoZWxsIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIGlmIChvdXRwdXRfd3JhcHBlci5nZXRJRCgpID09PSBvdXRwdXRfd3JhcHBlcl9pZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvcnJlY3Qgb3V0cHV0IHdyYXBwZXIgd2FzIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dF93cmFwcGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dHB1dFdyYXBwZXIgd2l0aCBJRCBcIiArIG91dHB1dF93cmFwcGVyX2lkICsgXCIgd2FzIG5vdCBmb3VuZC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgZGlmZmVyZW50IG91dHB1dCBzdHJlYW1zIGNhbiBiZSB3cmFwcGVkIHRvZ2V0aGVyLiBJbiBhZGRpdGlvbiB0byB0aGlzLCBjb21iaW5pbmcgb3V0cHV0IHN0cmVhbXMgYWxzb1xyXG4gICAgICogcmVxdWlyZXMgdGhlIE91dHB1dENoYW5uZWxzIHRvIGJlIHRoZSBzYW1lLCBidXQgdGhhdCdzIG5vdCBjaGVja2VkIGluIHRoaXMgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNPdXRwdXRXcmFwcGVyU3Rkb3V0U2FtZUFzU3RkZXJyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ub3V0cHV0X3dyYXBwZXJzW1wic3Rkb3V0XCJdID09PSB0aGlzLmNvbmZpZ3VyYXRpb24ub3V0cHV0X3dyYXBwZXJzW1wic3RkZXJyXCJdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRFdmVudHNDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZXZlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRFdmVudENvbmZpZ3VyYXRpb24oc2NfZXZlbnQ6IFNDX0V2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnRzQ29uZmlndXJhdGlvbigpW3NjX2V2ZW50LnN0YXRpYygpLmdldENvZGUoKV0gfHwgc2NfZXZlbnQuZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc1NDX0V2ZW50RW5hYmxlZChldmVudF9jb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBldmVudHNfY29uZmlndXJhdGlvbiA9ICB0aGlzLmdldEV2ZW50c0NvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBldmVudHNfY29uZmlndXJhdGlvbltldmVudF9jb2RlXSkge1xyXG4gICAgICAgICAgICAvLyBOb3QgZW5hYmxlZFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWF5YmUgZW5hYmxlZFxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0uZW5hYmxlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2luZyBldmVudCBzZXR0aW5ncyBpbiBTaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbC5cclxuICAgICAqIHBsdWdpbi5zYXZlU2V0dGluZ3MoKSBuZWVkcyB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZVNDX0V2ZW50KHNjX2V2ZW50OiBTQ19FdmVudCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50X2NvZGUgPSBzY19ldmVudC5zdGF0aWMoKS5nZXRDb2RlKCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzX2NvbmZpZ3VyYXRpb24gPSAgdGhpcy5nZXRFdmVudHNDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0pIHtcclxuICAgICAgICAgICAgLy8gTm90IGVuYWJsZWRcclxuICAgICAgICAgICAgLy8gRW5hYmxlXHJcbiAgICAgICAgICAgIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdID0gc2NfZXZlbnQuZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWF5YmUgZW5hYmxlZFxyXG4gICAgICAgICAgICBpZiAoIWV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY19ldmVudC5jYW5SZWdpc3RlckFmdGVyQ2hhbmdpbmdTZXR0aW5ncygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJTQ19FdmVudChzY19ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjX2V2ZW50Lm9uQWZ0ZXJFbmFibGluZyh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5naW5nIGV2ZW50IHNldHRpbmdzIGluIFNoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsLlxyXG4gICAgICogcGx1Z2luLnNhdmVTZXR0aW5ncygpIG5lZWRzIHRvIGJlIGNhbGxlZCBhZnRlciB0aGlzIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzY19ldmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzYWJsZVNDX0V2ZW50KHNjX2V2ZW50OiBTQ19FdmVudCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50X2NvZGUgPSBzY19ldmVudC5zdGF0aWMoKS5nZXRDb2RlKCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzX2NvbmZpZ3VyYXRpb24gPSAgdGhpcy5nZXRFdmVudHNDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0pIHtcclxuICAgICAgICAgICAgLy8gTWF5YmUgZW5hYmxlZFxyXG4gICAgICAgICAgICBpZiAoZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0uZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXMgZW5hYmxlZC5cclxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uX3Byb3BlcnR5X25hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25fcHJvcGVydHlfbmFtZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgbW9yZSBzZXR0aW5ncyB0aGFuIGp1c3QgJ2VuYWJsZScuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBieSBzZXR0aW5nICdlbmFibGUnIHRvIGZhbHNlLCBkb24ndCBmbHVzaCB0aGUgc2V0dGluZ3MsIHRoZXkgY2FuIGJlIHVzZWZ1bCBpZiB0aGUgZXZlbnQgZ2V0cyByZS1lbmFibGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2VuYWJsZWQnIGlzIHRoZSBvbmx5IHNldHRpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBieSByZW1vdmluZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgY29tcGxldGVseSB0byBtYWtlIHRoZSBzZXR0aW5ncyBmaWxlIGNsZWFuZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY19ldmVudC5jYW5SZWdpc3RlckFmdGVyQ2hhbmdpbmdTZXR0aW5ncygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBTQ19FdmVudHMgdGhhdCBhcmUgZW5hYmxlZCBmcm8gdGhpcyBzaGVsbCBjb21tYW5kLlxyXG4gICAgICpcclxuICAgICAqIFByaXZhdGUgYXMgaXQncyBjdXJyZW50bHkgb25seSB1c2VkIGRvbWVzdGljYWxseSwgYnV0IGNhbiBiZSBjaGFuZ2VkIHRvIHB1YmxpYyBpZiBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0U0NfRXZlbnRzKCk6IFNDX0V2ZW50W10ge1xyXG4gICAgICAgIGNvbnN0IGVuYWJsZWRfc2NfZXZlbnRzOiBTQ19FdmVudFtdID0gW107XHJcbiAgICAgICAgZ2V0U0NfRXZlbnRzKHRoaXMucGx1Z2luKS5mb3JFYWNoKChzY19ldmVudDogU0NfRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTQ19FdmVudEVuYWJsZWQoc2NfZXZlbnQuc3RhdGljKCkuZ2V0Q29kZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZF9zY19ldmVudHMucHVzaChzY19ldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZW5hYmxlZF9zY19ldmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlLCBpZiB5b3UgbmVlZCBhY2Nlc3MgZnJvbSBvdXRzaWRlLCB1c2UgZW5hYmxlU0NfRXZlbnQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnaXN0ZXJTQ19FdmVudChzY19ldmVudDogU0NfRXZlbnQpIHtcclxuICAgICAgICBzY19ldmVudC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGUsIGlmIHlvdSBuZWVkIGFjY2VzcyBmcm9tIG91dHNpZGUsIHVzZSBkaXNhYmxlU0NfRXZlbnQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdW5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50OiBTQ19FdmVudCkge1xyXG4gICAgICAgIHNjX2V2ZW50LnVucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQncyB1cCBhbGwgZXZlbnRzIHRoYXQgYXJlIGVuYWJsZWQgZm9yIHRoaXMgc2hlbGwgY29tbWFuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGVkX2FmdGVyX2NoYW5naW5nX3NldHRpbmdzIFNldCB0bzogdHJ1ZSwgaWYgdGhpcyBoYXBwZW5zIGFmdGVyIGNoYW5naW5nIGNvbmZpZ3VyYXRpb247IGZhbHNlLCBpZiB0aGlzIGhhcHBlbnMgZHVyaW5nIGxvYWRpbmcgdGhlIHBsdWdpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZ2lzdGVyU0NfRXZlbnRzKGNhbGxlZF9hZnRlcl9jaGFuZ2luZ19zZXR0aW5nczogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuZ2V0U0NfRXZlbnRzKCkuZm9yRWFjaCgoc2NfZXZlbnQ6IFNDX0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbl9yZWdpc3RlciA9ICFjYWxsZWRfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3MgfHwgc2NfZXZlbnQuY2FuUmVnaXN0ZXJBZnRlckNoYW5naW5nU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgaWYgKGNhbl9yZWdpc3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1bnJlZ2lzdGVyU0NfRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U0NfRXZlbnRzKCkuZm9yRWFjaCgoc2NfZXZlbnQ6IFNDX0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJUb0NvbW1hbmRQYWxldHRlKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhlIGxvZ2ljIGZyb20gcGx1Z2luLnJlZ2lzdGVyU2hlbGxDb21tYW5kKCkgdG8gaGVyZSwgYnV0IHNwbGl0IHRvIG11bHRpcGxlIG1ldGhvZHMuXHJcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJTaGVsbENvbW1hbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVucmVnaXN0ZXJGcm9tQ29tbWFuZFBhbGV0dGUoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRklYTUU6IEkgdGhpbmsgdGhlIHVucmVnaXN0ZXJpbmcgZG9lcyBub3Qgd29yay5cclxuICAgICAgICBkZWxldGUgdGhpcy5wbHVnaW4ub2JzaWRpYW5fY29tbWFuZHNbdGhpcy5nZXRJZCgpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eSBhbmQgcmV0dXJuczpcclxuICAgICAqICAtIHRydWUsIGlmIHRoZSB2YWx1ZSBpcyBcImVuYWJsZWRcIiBvciBcInVubGlzdGVkXCJcclxuICAgICAqICAtIGZhbHNlLCBpZiB0aGUgdmFsdWUgaXMgXCJkaXNhYmxlZFwiXHJcbiAgICAgKlxyXG4gICAgICogQWRkaW5nIHRvIGNvbW1hbmQgcGFsZXR0ZSBhbHNvIGVuYWJsZXMgaG90a2V5cywgd2hpY2ggaXMgd2h5IGFkZGluZyBjYW4gYmUgcGVybWl0dGVkLCBidXQgc2hvd2luZyBkZW5pZWQsIGlmIGEgc2hlbGwgY29tbWFuZCBzaG91bGQgb25seSBiZSBhdmFpbGFibGUgdmlhIGhvdGtleXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYW5BZGRUb0NvbW1hbmRQYWxldHRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ3VyYXRpb24oKS5jb21tYW5kX3BhbGV0dGVfYXZhaWxhYmlsaXR5ICE9PSBcImRpc2FibGVkXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbm90aGVyIG5hbWUgZm9yIGNhbkFkZFRvQ29tbWFuZFBhbGV0dGUoKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbkhhdmVIb3RrZXlzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFkZFRvQ29tbWFuZFBhbGV0dGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eSBhbmQgcmV0dXJuczpcclxuICAgICAqICAtIHRydWUsIGlmIHRoZSB2YWx1ZSBpcyBcImVuYWJsZWRcIlxyXG4gICAgICogIC0gZmFsc2UsIGlmIHRoZSB2YWx1ZSBpcyBcImRpc2FibGVkXCIgb3IgXCJ1bmxpc3RlZFwiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYW5TaG93SW5Db21tYW5kUGFsZXR0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWd1cmF0aW9uKCkuY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eSA9PT0gXCJlbmFibGVkXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBhcnNpbmdQcm9jZXNzIGluc3RhbmNlIGFuZCBkZWZpbmVzIHR3byBzZXRzIG9mIHZhcmlhYmxlczpcclxuICAgICAqICAtIEZpcnN0IHNldDogQWxsIHZhcmlhYmxlcyB0aGF0IGFyZSBub3QgdGllZCB0byBhbnkgcHJlYWN0aW9ucy5cclxuICAgICAqICAtIFNlY29uZCBzZXQ6IFZhcmlhYmxlcyB0aGF0IGFyZSB0aWVkIHRvIHByZWFjdGlvbnMuIENhbiBiZSBhbiBlbXB0eSBzZXQuXHJcbiAgICAgKiBZb3UgbmVlZCB0byBzdGlsbCBjYWxsIFBhcnNpbmdQcm9jZXNzLnByb2Nlc3MoKSB0byBwYXJzZSB0aGUgZmlyc3Qgc2V0LiBTaGVsbENvbW1hbmRFeGVjdXRvciB0YWtlcyBjYXJlIG9mIGNhbGxpbmdcclxuICAgICAqIFBhcnNpbmdQcm9jZXNzLnByb2Nlc3NSZXN0KCkgdG8gcHJvY2VzcyBhbGwgbm9uLXByb2Nlc3NlZCBzZXRzLlxyXG4gICAgICpcclxuICAgICAqIEBTZWUgUGFyc2luZ1Byb2Nlc3MgY2xhc3MgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIHByb2Nlc3MuXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnQgTmVlZGVkIHRvIGdldCB7e2V2ZW50Xyp9fSB2YXJpYWJsZXMgcGFyc2VkLiBDYW4gYmUgbGVmdCBvdXQgaWYgd29ya2luZyBvdXRzaWRlIGFueSBTQ19FdmVudCBjb250ZXh0LCBpbiB3aGljaCBjYXNlIHt7ZXZlbnRfKn19IHZhcmlhYmxlcyBhcmUgaW5hY2Nlc3NpYmxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlUGFyc2luZ1Byb2Nlc3Moc2NfZXZlbnQ6IFNDX0V2ZW50IHwgbnVsbCk6IFNoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzIHtcclxuICAgICAgICBjb25zdCBzdGRvdXRfb3V0cHV0X3dyYXBwZXIgPSB0aGlzLmdldE91dHB1dFdyYXBwZXIoXCJzdGRvdXRcIik7IC8vIENhbiBiZSBudWxsXHJcbiAgICAgICAgY29uc3Qgc3RkZXJyX291dHB1dF93cmFwcGVyID0gdGhpcy5nZXRPdXRwdXRXcmFwcGVyKFwic3RkZXJyXCIpOyAvLyBDYW4gYmUgbnVsbFxyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2luZ1Byb2Nlc3M8c2hlbGxfY29tbWFuZF9wYXJzaW5nX21hcD4oXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzaGVsbF9jb21tYW5kOiB0aGlzLmdldFNoZWxsQ29tbWFuZCgpLFxyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHRoaXMuZ2V0QWxpYXMoKSxcclxuICAgICAgICAgICAgICAgIGVudmlyb25tZW50X3ZhcmlhYmxlX3BhdGhfYXVnbWVudGF0aW9uOiBnZXRQQVRIQXVnbWVudGF0aW9uKHRoaXMucGx1Z2luKSA/PyBcIlwiLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0X3dyYXBwZXJfc3Rkb3V0OiBzdGRvdXRfb3V0cHV0X3dyYXBwZXIgPyBzdGRvdXRfb3V0cHV0X3dyYXBwZXIuZ2V0Q29udGVudCgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0X3dyYXBwZXJfc3RkZXJyOiBzdGRlcnJfb3V0cHV0X3dyYXBwZXIgPyBzdGRlcnJfb3V0cHV0X3dyYXBwZXIuZ2V0Q29udGVudCgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICBzY19ldmVudCxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXROb25QcmVhY3Rpb25zRGVwZW5kZW50VmFyaWFibGVzKCksIC8vIEZpcnN0IHNldDogQWxsIHZhcmlhYmxlcyB0aGF0IGFyZSBub3QgdGllZCB0byBhbnkgcHJlYWN0aW9ucy5cclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJlYWN0aW9uc0RlcGVuZGVudFZhcmlhYmxlcygpLCAvLyBTZWNvbmQgc2V0OiBWYXJpYWJsZXMgdGhhdCBhcmUgdGllZCB0byBwcmVhY3Rpb25zLiBDYW4gYmUgYW4gZW1wdHkgc2V0LlxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZXNjYXBlIHZhcmlhYmxlcyBpbiBvdXRwdXQgd3JhcHBlcnMsIGJlY2F1c2UgdGhleSBhcmUgbm90IGdvaW5nIHRocm91Z2ggYSBzaGVsbCBhbmQgZXNjYXBlIGNoYXJhY3RlcnMgd291bGQgYmUgdmlzaWJsZSBpbiB0aGUgZW5kIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICdvdXRwdXRfd3JhcHBlcl9zdGRvdXQnLFxyXG4gICAgICAgICAgICAgICAgJ291dHB1dF93cmFwcGVyX3N0ZGVycicsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0T2JzaWRpYW5Db21tYW5kKG9ic2lkaWFuX2NvbW1hbmQ6IENvbW1hbmQpIHtcclxuICAgICAgICB0aGlzLm9ic2lkaWFuX2NvbW1hbmQgPSBvYnNpZGlhbl9jb21tYW5kO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRPYnNpZGlhbkNvbW1hbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzaWRpYW5fY29tbWFuZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vIHJlbmFtaW5nIGlzIGRvbmUgaWYgdGhlIHNoZWxsIGNvbW1hbmQgaXMgZXhjbHVkZWQgZnJvbSB0aGUgY29tbWFuZCBwYWxldHRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVuYW1lT2JzaWRpYW5Db21tYW5kKHNoZWxsX2NvbW1hbmQ6IHN0cmluZywgYWxpYXM6IHN0cmluZykge1xyXG4gICAgICAgIC8vIFJlbmFtZSB0aGUgY29tbWFuZCBpbiBjb21tYW5kIHBhbGV0dGVcclxuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5OYW1lKCkgKyBcIjogXCI7IC8vIE5vcm1hbGx5IE9ic2lkaWFuIHByZWZpeGVzIGFsbCBjb21tYW5kcyB3aXRoIHRoZSBwbHVnaW4gbmFtZSBhdXRvbWF0aWNhbGx5LCBidXQgbm93IHRoYXQgd2UgYXJlIGFjdHVhbGx5IF9lZGl0aW5nXyBhIGNvbW1hbmQgaW4gdGhlIHBhbGV0dGUgKG5vdCBjcmVhdGluZyBhIG5ldyBvbmUpLCBPYnNpZGlhbiB3b24ndCBkbyB0aGUgcHJlZml4aW5nIGZvciB1cy5cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgc2hlbGwgY29tbWFuZCBpcyBhY3R1YWxseSByZWdpc3RlcmVkIHRvIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlLlxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMub2JzaWRpYW5fY29tbWFuZCkge1xyXG4gICAgICAgICAgICAvLyBZZXMsIHRoZSBzaGVsbCBjb21tYW5kIGlzIHJlZ2lzdGVyZWQgaW4gT2JzaWRpYW4ncyBjb21tYW5kIHBhbGV0dGUuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tbWFuZCBwYWxldHRlIG5hbWUuXHJcbiAgICAgICAgICAgIHRoaXMub2JzaWRpYW5fY29tbWFuZC5uYW1lID0gcHJlZml4ICsgZ2VuZXJhdGVPYnNpZGlhbkNvbW1hbmROYW1lKHRoaXMucGx1Z2luLCBzaGVsbF9jb21tYW5kLCBhbGlhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBzaGVsbCBjb21tYW5kJ3MgXCJjb21tYW5kX3BhbGV0dGVfYXZhaWxhYmlsaXR5XCIgc2V0dGluZ3MgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIiwgdGhlbiB0aGUgc2hlbGwgY29tbWFuZCBpcyBub3QgcHJlc2VudCBpbiB0aGlzLm9ic2lkaWFuX2NvbW1hbmQgYW5kIHNvIHRoZSBjb21tYW5kIHBhbGV0dGUgbmFtZSBkb2VzIG5vdCBuZWVkIHVwZGF0aW5nLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFuIGludGVybmFsIGNhY2hlIHVzZWQgYnkgLmdldFByZWFjdGlvbnMoKS5cclxuICAgICAqIE9ubHkgbmVlZGVkIHRvIGJlIGNhbGxlZCBhZnRlciBjcmVhdGluZyBuZXcgUHJlYWN0aW9uQ29uZmlndXJhdGlvbnMgb3IgZGVsZXRpbmcgb2xkIG9uZXMuIFNob3VsZCBub3QgbmVlZCB0byBiZSBjYWxsZWRcclxuICAgICAqIHdoZW4gbW9kaWZ5aW5nIHByb3BlcnRpZXMgaW4gZXhpc3RpbmcgUHJlYWN0aW9uQ29uZmlndXJhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldFByZWFjdGlvbnMoKSB7XHJcbiAgICAgICAgZGVidWdMb2coYFRTaGVsbENvbW1hbmQgJHt0aGlzLmdldElkKCl9OiBSZXNldHRpbmcgcHJlYWN0aW9ucy5gKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZWRfcHJlYWN0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhY2hlZF9wcmVhY3Rpb25zOiBQcmVhY3Rpb25bXTtcclxuICAgIHB1YmxpYyBnZXRQcmVhY3Rpb25zKCk6IFByZWFjdGlvbltdIHtcclxuICAgICAgICBkZWJ1Z0xvZyhgVFNoZWxsQ29tbWFuZCAke3RoaXMuZ2V0SWQoKX06IEdldHRpbmcgcHJlYWN0aW9ucy5gKTtcclxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkX3ByZWFjdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRfcHJlYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmdldENvbmZpZ3VyYXRpb24oKS5wcmVhY3Rpb25zLmZvckVhY2goKHByZWFjdGlvbl9jb25maWd1cmF0aW9uOiBQcmVhY3Rpb25Db25maWd1cmF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSB0aGUgcHJlYWN0aW9uIGlmIGl0J3MgZW5hYmxlZC5cclxuICAgICAgICAgICAgICAgIGlmIChwcmVhY3Rpb25fY29uZmlndXJhdGlvbi5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWWVzLCBpdCdzIGVuYWJsZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIFByZWFjdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZF9wcmVhY3Rpb25zLnB1c2goY3JlYXRlUHJlYWN0aW9uKHRoaXMucGx1Z2luLCBwcmVhY3Rpb25fY29uZmlndXJhdGlvbiwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkX3ByZWFjdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZhcmlhYmxlcyB0aGF0IGFyZSBub3QgZGVwZW5kZW50IG9uIGFueSBQcmVhY3Rpb24uXHJcbiAgICAgKiBAcHJpdmF0ZSBDYW4gYmUgbWFkZSBwdWJsaWMgaWYgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldE5vblByZWFjdGlvbnNEZXBlbmRlbnRWYXJpYWJsZXMoKTogVmFyaWFibGVTZXQge1xyXG4gICAgICAgIGRlYnVnTG9nKGBUU2hlbGxDb21tYW5kICR7dGhpcy5nZXRJZCgpfTogR2V0dGluZyBub24gcHJlYWN0aW9ucyBkZXBlbmRlbnQgdmFyaWFibGVzLmApO1xyXG4gICAgICAgIGNvbnN0IGFsbF92YXJpYWJsZXMgPSB0aGlzLnBsdWdpbi5nZXRWYXJpYWJsZXMoKTtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVNldChhbGxfdmFyaWFibGVzLCB0aGlzLmdldFByZWFjdGlvbnNEZXBlbmRlbnRWYXJpYWJsZXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZSBDYW4gYmUgbWFkZSBwdWJsaWMgaWYgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFByZWFjdGlvbnNEZXBlbmRlbnRWYXJpYWJsZXMoKTogVmFyaWFibGVTZXQge1xyXG4gICAgICAgIGRlYnVnTG9nKGBUU2hlbGxDb21tYW5kICR7dGhpcy5nZXRJZCgpfTogR2V0dGluZyBwcmVhY3Rpb25zIGRlcGVuZGVudCB2YXJpYWJsZXMuYCk7XHJcbiAgICAgICAgbGV0IGRlcGVuZGVudF92YXJpYWJsZXMgPSBuZXcgVmFyaWFibGVTZXQoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByZWFjdGlvbiBvZiB0aGlzLmdldFByZWFjdGlvbnMoKSkge1xyXG4gICAgICAgICAgICBkZXBlbmRlbnRfdmFyaWFibGVzID0gbWVyZ2VTZXRzKGRlcGVuZGVudF92YXJpYWJsZXMsIHByZWFjdGlvbi5nZXREZXBlbmRlbnRWYXJpYWJsZXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXBlbmRlbnRfdmFyaWFibGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBSZXR1cm5zIHVuZGVmaW5lZCwgaWYgbm8gY29uZmlndXJhdGlvbiBpcyBkZWZpbmVkIGZvciB0aGlzIHZhcmlhYmxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGVmYXVsdFZhbHVlQ29uZmlndXJhdGlvbkZvclZhcmlhYmxlKHZhcmlhYmxlOiBWYXJpYWJsZSk6IFZhcmlhYmxlRGVmYXVsdFZhbHVlQ29uZmlndXJhdGlvbiB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi52YXJpYWJsZV9kZWZhdWx0X3ZhbHVlc1t2YXJpYWJsZS5nZXRJZGVudGlmaWVyKCldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBVUkkgdGhhdCBjYW4gYmUgdXNlZCBpbiBsaW5rcyAoaW4gb3Igb3V0c2lkZSBvZiBPYnNpZGlhbikgdG8gZXhlY3V0ZSB0aGlzIHNoZWxsIGNvbW1hbmQuIFRoZSBVUkkgYWxzb1xyXG4gICAgICogY29udGFpbnMgc3R1YnMgZm9yIGFueSBwb3NzaWJsZSBDdXN0b21WYXJpYWJsZXMgdGhhdCBtaWdodCBiZSB1c2VkIGluIHRoZSBzaGVsbCBjb21tYW5kIChpZiBhbnkpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXhlY3V0aW9uVVJJKCkge1xyXG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl91cmkgPSB0aGlzLnBsdWdpbi5nZXRPYnNpZGlhblVSSShTQ19QbHVnaW4uU0hFTExfQ09NTUFORFNfVVJJX0FDVElPTiwge2V4ZWN1dGU6IHRoaXMuZ2V0SWQoKX0pO1xyXG5cclxuICAgICAgICAvLyBHZXQgYSBsaXN0IEN1c3RvbVZhcmlhYmxlcyB0aGF0IHRoZSBzaGVsbCBjb21tYW5kIHVzZXMuXHJcbiAgICAgICAgY29uc3QgY3VzdG9tX3ZhcmlhYmxlcyA9IG5ldyBWYXJpYWJsZVNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tX3ZhcmlhYmxlIG9mIGdldFVzZWRWYXJpYWJsZXModGhpcy5wbHVnaW4sIHRoaXMuZ2V0U2hlbGxDb21tYW5kKCkpKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHZhcmlhYmxlIElTIGEgQ3VzdG9tVmFyaWFibGUuXHJcbiAgICAgICAgICAgIGlmIChjdXN0b21fdmFyaWFibGUgaW5zdGFuY2VvZiBDdXN0b21WYXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tX3ZhcmlhYmxlcy5hZGQoY3VzdG9tX3ZhcmlhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXhjbHVkZSB2YXJpYWJsZXMgd2hvc2UgdmFsdWVzIHdpbGwgY29tZSBmcm9tIFByZWFjdGlvbnMgLSB0aGV5IHdpbGwgbm90IHByb2JhYmx5IGJlIG5lZWRlZCBpbiB0aGUgVVJJLlxyXG4gICAgICAgIGNvbnN0IGN1c3RvbV92YXJpYWJsZXNfc3VpdGFibGVfZm9yX3VyaSA9IHJlbW92ZUZyb21TZXQoY3VzdG9tX3ZhcmlhYmxlcywgdGhpcy5nZXRQcmVhY3Rpb25zRGVwZW5kZW50VmFyaWFibGVzKCkpO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgdGhlIHN1aXRhYmxlIGN1c3RvbSB2YXJpYWJsZSBuYW1lcyB0byB0aGUgdXJpLlxyXG4gICAgICAgIGxldCBleGVjdXRpb25fdXJpX3dpdGhfdmFyaWFibGVzID0gZXhlY3V0aW9uX3VyaTtcclxuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbV92YXJpYWJsZSBvZiBjdXN0b21fdmFyaWFibGVzX3N1aXRhYmxlX2Zvcl91cmkpIHtcclxuICAgICAgICAgICAgZXhlY3V0aW9uX3VyaV93aXRoX3ZhcmlhYmxlcyArPSBcIiZcIiArIGN1c3RvbV92YXJpYWJsZS52YXJpYWJsZV9uYW1lICsgXCI9XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5pc2hlZC5cclxuICAgICAgICByZXR1cm4gZXhlY3V0aW9uX3VyaV93aXRoX3ZhcmlhYmxlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYWRqYWNlbnQgVFNoZWxsQ29tbWFuZCB0aGF0IGFwcGVhcnMgbmV4dCBpbiB0aGUgY29uZmlndXJhdGlvbiBsaXN0LiBSZXR1cm5zIHVuZGVmaW5lZCwgaWYgdGhpcyBpcyB0aGVcclxuICAgICAqIGxhc3QgVFNoZWxsQ29tbWFuZC4gVXNlZCBpbiBzZXR0aW5ncyB0byBzd2l0Y2ggcXVpY2tseSBmcm9tIG9uZSBUU2hlbGxDb21tYW5kIHRvIGFub3RoZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZXh0VFNoZWxsQ29tbWFuZCgpIHtcclxuICAgICAgICBjb25zdCB0X3NoZWxsX2NvbW1hbmRzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpKTtcclxuICAgICAgICBjb25zdCB0aGlzX2luZGV4ID0gdF9zaGVsbF9jb21tYW5kcy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzX2luZGV4ID09PSB0X3NoZWxsX2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRfc2hlbGxfY29tbWFuZHNbdGhpc19pbmRleCArIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhZGphY2VudCBUU2hlbGxDb21tYW5kIHRoYXQgYXBwZWFycyBiZWZvcmUgaW4gdGhlIGNvbmZpZ3VyYXRpb24gbGlzdC4gUmV0dXJucyB1bmRlZmluZWQsIGlmIHRoaXMgaXMgdGhlXHJcbiAgICAgKiBmaXJzdCBUU2hlbGxDb21tYW5kLiBVc2VkIGluIHNldHRpbmdzIHRvIHN3aXRjaCBxdWlja2x5IGZyb20gb25lIFRTaGVsbENvbW1hbmQgdG8gYW5vdGhlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHByZXZpb3VzVFNoZWxsQ29tbWFuZCgpIHtcclxuICAgICAgICBjb25zdCB0X3NoZWxsX2NvbW1hbmRzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpKTtcclxuICAgICAgICBjb25zdCB0aGlzX2luZGV4ID0gdF9zaGVsbF9jb21tYW5kcy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzX2luZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0X3NoZWxsX2NvbW1hbmRzW3RoaXNfaW5kZXggLSAxXTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaGVsbENvbW1hbmRQYXJzaW5nUmVzdWx0IHtcclxuICAgIHNoZWxsX2NvbW1hbmQ6IHN0cmluZyxcclxuICAgIGFsaWFzOiBzdHJpbmcsXHJcbiAgICBlbnZpcm9ubWVudF92YXJpYWJsZV9wYXRoX2F1Z21lbnRhdGlvbjogc3RyaW5nLFxyXG4gICAgb3V0cHV0X3dyYXBwZXJfc3Rkb3V0Pzogc3RyaW5nLFxyXG4gICAgb3V0cHV0X3dyYXBwZXJfc3RkZXJyPzogc3RyaW5nLFxyXG4gICAgc3VjY2VlZGVkOiBib29sZWFuO1xyXG4gICAgZXJyb3JfbWVzc2FnZXM6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcyA9IFBhcnNpbmdQcm9jZXNzPHNoZWxsX2NvbW1hbmRfcGFyc2luZ19tYXA+O1xyXG5cclxudHlwZSBzaGVsbF9jb21tYW5kX3BhcnNpbmdfbWFwID0ge1xyXG4gICAgc2hlbGxfY29tbWFuZDogc3RyaW5nLFxyXG4gICAgYWxpYXM6IHN0cmluZyxcclxuICAgIGVudmlyb25tZW50X3ZhcmlhYmxlX3BhdGhfYXVnbWVudGF0aW9uOiBzdHJpbmcsXHJcbiAgICBvdXRwdXRfd3JhcHBlcl9zdGRvdXQ/OiBzdHJpbmcsXHJcbiAgICBvdXRwdXRfd3JhcHBlcl9zdGRlcnI/OiBzdHJpbmcsXHJcbn07IiwiLyoqXHJcbiAqIENvcGllZCAyMDIxLTEwLTI5IGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vVGhlRGlzdGFudFNlYS84MDIxMzU5XHJcbiAqIE1vZGlmaWNhdGlvbnM6XHJcbiAqICAtIE1hZGUgY29tcGF0aWJsZSB3aXRoIFR5cGVTY3JpcHQgYnkgYWRkaW5nIHR5cGUgZGVmaW5pdGlvbnMuXHJcbiAqICAtIENoYW5nZWQgdmFyIHRvIGxldC5cclxuICpcclxuICogQ29tcGFyZXMgdHdvIHNvZnR3YXJlIHZlcnNpb24gbnVtYmVycyAoZS5nLiBcIjEuNy4xXCIgb3IgXCIxLjJiXCIpLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdhcyBib3JuIGluIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY4MzI3MjEuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2MSBUaGUgZmlyc3QgdmVyc2lvbiB0byBiZSBjb21wYXJlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHYyIFRoZSBzZWNvbmQgdmVyc2lvbiB0byBiZSBjb21wYXJlZC5cclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBmbGFncyB0aGF0IGFmZmVjdCBjb21wYXJpc29uIGJlaGF2aW9yOlxyXG4gKiA8dWw+XHJcbiAqICAgICA8bGk+XHJcbiAqICAgICAgICAgPHR0PmxleGljb2dyYXBoaWNhbDogdHJ1ZTwvdHQ+IGNvbXBhcmVzIGVhY2ggcGFydCBvZiB0aGUgdmVyc2lvbiBzdHJpbmdzIGxleGljb2dyYXBoaWNhbGx5IGluc3RlYWQgb2ZcclxuICogICAgICAgICBuYXR1cmFsbHk7IHRoaXMgYWxsb3dzIHN1ZmZpeGVzIHN1Y2ggYXMgXCJiXCIgb3IgXCJkZXZcIiBidXQgd2lsbCBjYXVzZSBcIjEuMTBcIiB0byBiZSBjb25zaWRlcmVkIHNtYWxsZXIgdGhhblxyXG4gKiAgICAgICAgIFwiMS4yXCIuXHJcbiAqICAgICA8L2xpPlxyXG4gKiAgICAgPGxpPlxyXG4gKiAgICAgICAgIDx0dD56ZXJvRXh0ZW5kOiB0cnVlPC90dD4gY2hhbmdlcyB0aGUgcmVzdWx0IGlmIG9uZSB2ZXJzaW9uIHN0cmluZyBoYXMgbGVzcyBwYXJ0cyB0aGFuIHRoZSBvdGhlci4gSW5cclxuICogICAgICAgICB0aGlzIGNhc2UgdGhlIHNob3J0ZXIgc3RyaW5nIHdpbGwgYmUgcGFkZGVkIHdpdGggXCJ6ZXJvXCIgcGFydHMgaW5zdGVhZCBvZiBiZWluZyBjb25zaWRlcmVkIHNtYWxsZXIuXHJcbiAqICAgICA8L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfE5hTn1cclxuICogPHVsPlxyXG4gKiAgICA8bGk+MCBpZiB0aGUgdmVyc2lvbnMgYXJlIGVxdWFsPC9saT5cclxuICogICAgPGxpPmEgbmVnYXRpdmUgaW50ZWdlciBpZmYgdjEgPCB2MjwvbGk+XHJcbiAqICAgIDxsaT5hIHBvc2l0aXZlIGludGVnZXIgaWZmIHYxID4gdjI8L2xpPlxyXG4gKiAgICA8bGk+TmFOIGlmIGVpdGhlciB2ZXJzaW9uIHN0cmluZyBpcyBpbiB0aGUgd3JvbmcgZm9ybWF0PC9saT5cclxuICogPC91bD5cclxuICpcclxuICogQGNvcHlyaWdodCBieSBKb24gUGFwYWlvYW5ub3UgKFtcImpvaG5cIiwgXCJwYXBhaW9hbm5vdVwiXS5qb2luKFwiLlwiKSArIFwiQGdtYWlsLmNvbVwiKVxyXG4gKiBAbGljZW5zZSBUaGlzIGZ1bmN0aW9uIGlzIGluIHRoZSBwdWJsaWMgZG9tYWluLiBEbyB3aGF0IHlvdSB3YW50IHdpdGggaXQsIG5vIHN0cmluZ3MgYXR0YWNoZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmVyc2lvbkNvbXBhcmUodjE6IHN0cmluZywgdjI6IHN0cmluZywgb3B0aW9uczoge2xleGljb2dyYXBoaWNhbD86IGJvb2xlYW4sIHplcm9FeHRlbmQ/OiBib29sZWFufSA9IHt9KSB7XHJcbiAgICBsZXQgbGV4aWNvZ3JhcGhpY2FsID0gb3B0aW9ucyAmJiBvcHRpb25zLmxleGljb2dyYXBoaWNhbCxcclxuICAgICAgICB6ZXJvRXh0ZW5kID0gb3B0aW9ucyAmJiBvcHRpb25zLnplcm9FeHRlbmQsXHJcbiAgICAgICAgdjFwYXJ0czogYW55ID0gdjEuc3BsaXQoJy4nKSxcclxuICAgICAgICB2MnBhcnRzOiBhbnkgPSB2Mi5zcGxpdCgnLicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzVmFsaWRQYXJ0KHg6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiAobGV4aWNvZ3JhcGhpY2FsID8gL15cXGQrW0EtWmEtel0qJC8gOiAvXlxcZCskLykudGVzdCh4KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXYxcGFydHMuZXZlcnkoaXNWYWxpZFBhcnQpIHx8ICF2MnBhcnRzLmV2ZXJ5KGlzVmFsaWRQYXJ0KSkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHplcm9FeHRlbmQpIHtcclxuICAgICAgICB3aGlsZSAodjFwYXJ0cy5sZW5ndGggPCB2MnBhcnRzLmxlbmd0aCkgdjFwYXJ0cy5wdXNoKFwiMFwiKTtcclxuICAgICAgICB3aGlsZSAodjJwYXJ0cy5sZW5ndGggPCB2MXBhcnRzLmxlbmd0aCkgdjJwYXJ0cy5wdXNoKFwiMFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWxleGljb2dyYXBoaWNhbCkge1xyXG4gICAgICAgIHYxcGFydHMgPSB2MXBhcnRzLm1hcChOdW1iZXIpO1xyXG4gICAgICAgIHYycGFydHMgPSB2MnBhcnRzLm1hcChOdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdjFwYXJ0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmICh2MnBhcnRzLmxlbmd0aCA9PSBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHYxcGFydHNbaV0gPT0gdjJwYXJ0c1tpXSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodjFwYXJ0c1tpXSA+IHYycGFydHNbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh2MXBhcnRzLmxlbmd0aCAhPSB2MnBhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxufSIsIi8qXHJcbiAqICdTaGVsbCBjb21tYW5kcycgcGx1Z2luIGZvciBPYnNpZGlhbi5cclxuICogQ29weXJpZ2h0IChDKSAyMDIxIC0gMjAyMiBKYXJra28gTGlubmFudmlydGFcclxuICpcclxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcclxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcclxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXHJcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXHJcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxyXG4gKlxyXG4gKiBDb250YWN0IHRoZSBhdXRob3IgKEphcmtrbyBMaW5uYW52aXJ0YSk6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcblx0Q3VzdG9tVmFyaWFibGUsXHJcblx0Q3VzdG9tVmFyaWFibGVJbnN0YW5jZU1hcCxcclxuXHRDdXN0b21WYXJpYWJsZU1vZGVsLFxyXG5cdEN1c3RvbVZhcmlhYmxlVmlldyxcclxuXHRnZXRJREdlbmVyYXRvcixcclxuXHRnZXRNb2RlbCxcclxuXHRpbnRyb2R1Y2VNb2RlbHMsXHJcblx0UHJvbXB0TWFwLFxyXG5cdFByb21wdE1vZGVsLFxyXG5cdFNoZWxsQ29tbWFuZEV4ZWN1dG9yLFxyXG59IGZyb20gXCIuL2ltcG9ydHNcIjtcclxuaW1wb3J0IHtcclxuICAgIENvbW1hbmQsXHJcbiAgICBOb3RpY2UsXHJcbiAgICBPYnNpZGlhblByb3RvY29sRGF0YSxcclxuICAgIFBsdWdpbixcclxuICAgIHNldEljb24sXHJcbiAgICBXb3Jrc3BhY2VMZWFmLFxyXG59IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHtcclxuXHRjb21iaW5lT2JqZWN0cyxcclxuXHRnZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZE5hbWUsXHJcblx0Z2V0T3BlcmF0aW5nU3lzdGVtLFxyXG5cdGdldFBsdWdpbkFic29sdXRlUGF0aCxcclxufSBmcm9tIFwiLi9Db21tb25cIjtcclxuaW1wb3J0IHtSdW5NaWdyYXRpb25zfSBmcm9tIFwiLi9NaWdyYXRpb25zXCI7XHJcbmltcG9ydCB7XHJcbiAgICBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uLFxyXG4gICAgU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbixcclxufSBmcm9tIFwiLi9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7XHJcblx0Z2V0RGVmYXVsdFNldHRpbmdzLFxyXG5cdFNldHRpbmdzVmVyc2lvblN0cmluZyxcclxuXHRTQ19NYWluU2V0dGluZ3MsXHJcbn0gZnJvbSBcIi4vc2V0dGluZ3MvU0NfTWFpblNldHRpbmdzXCI7XHJcbmltcG9ydCB7T2JzaWRpYW5Db21tYW5kc0NvbnRhaW5lcn0gZnJvbSBcIi4vT2JzaWRpYW5Db21tYW5kc0NvbnRhaW5lclwiO1xyXG5pbXBvcnQge1NDX01haW5TZXR0aW5nc1RhYn0gZnJvbSBcIi4vc2V0dGluZ3MvU0NfTWFpblNldHRpbmdzVGFiXCI7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kUGFyc2luZ1Byb2Nlc3MsIFRTaGVsbENvbW1hbmQsIFRTaGVsbENvbW1hbmRDb250YWluZXJ9IGZyb20gXCIuL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtnZXRVc2Vyc0RlZmF1bHRTaGVsbH0gZnJvbSBcIi4vU2hlbGxcIjtcclxuaW1wb3J0IHt2ZXJzaW9uQ29tcGFyZX0gZnJvbSBcIi4vbGliL3ZlcnNpb25fY29tcGFyZVwiO1xyXG5pbXBvcnQge2RlYnVnTG9nLCBzZXRERUJVR19PTn0gZnJvbSBcIi4vRGVidWdcIjtcclxuaW1wb3J0IHthZGRDdXN0b21BdXRvY29tcGxldGVJdGVtc30gZnJvbSBcIi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtnZXRTQ19FdmVudHN9IGZyb20gXCIuL2V2ZW50cy9TQ19FdmVudExpc3RcIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7XHJcblx0bG9hZFZhcmlhYmxlcyxcclxuXHRWYXJpYWJsZVNldCxcclxufSBmcm9tIFwiLi92YXJpYWJsZXMvbG9hZFZhcmlhYmxlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgT3V0cHV0V3JhcHBlck1hcCxcclxuICAgIE91dHB1dFdyYXBwZXJNb2RlbCxcclxufSBmcm9tIFwiLi9tb2RlbHMvb3V0cHV0X3dyYXBwZXIvT3V0cHV0V3JhcHBlck1vZGVsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTQ19QbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdC8qKlxyXG5cdCAqIERlZmluZXMgdGhlIHNldHRpbmdzIHN0cnVjdHVyZSB2ZXJzaW9uLiBDaGFuZ2UgdGhpcyB3aGVuIGEgbmV3IHBsdWdpbiB2ZXJzaW9uIGlzIHJlbGVhc2VkLCBidXQgb25seSBpZiB0aGF0IHBsdWdpblxyXG5cdCAqIHZlcnNpb24gaW50cm9kdWNlcyBjaGFuZ2VzIHRvIHRoZSBzZXR0aW5ncyBzdHJ1Y3R1cmUuIERvIG5vdCBjaGFuZ2UgaWYgdGhlIHNldHRpbmdzIHN0cnVjdHVyZSBzdGF5cyB1bmNoYW5nZWQuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBTZXR0aW5nc1ZlcnNpb246IFNldHRpbmdzVmVyc2lvblN0cmluZyA9IFwiMC4xNy4wXCI7XHJcblxyXG5cdHB1YmxpYyBzZXR0aW5nczogU0NfTWFpblNldHRpbmdzOyAvLyBUT0RPOiBSZW5hbWUgdG8gJ2NvbmZpZ3VyYXRpb24nLlxyXG5cdHB1YmxpYyBvYnNpZGlhbl9jb21tYW5kczogT2JzaWRpYW5Db21tYW5kc0NvbnRhaW5lciA9IHt9O1xyXG5cdHByaXZhdGUgdF9zaGVsbF9jb21tYW5kczogVFNoZWxsQ29tbWFuZENvbnRhaW5lciA9IHt9O1xyXG5cdHByaXZhdGUgcHJvbXB0czogUHJvbXB0TWFwO1xyXG5cdHByaXZhdGUgY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlczogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZU1hcDtcclxuXHRwcml2YXRlIHZhcmlhYmxlczogVmFyaWFibGVTZXQ7XHJcbiAgICBwcml2YXRlIG91dHB1dF93cmFwcGVyczogT3V0cHV0V3JhcHBlck1hcDtcclxuXHJcblx0LyoqXHJcblx0ICogSG9sZGVyIGZvciBzaGVsbCBjb21tYW5kcyBhbmQgYWxpYXNlcywgd2hvc2UgdmFyaWFibGVzIGFyZSBwYXJzZWQgYmVmb3JlIHRoZSBhY3R1YWwgZXhlY3V0aW9uIGR1cmluZyBjb21tYW5kXHJcblx0ICogcGFsZXR0ZSBwcmV2aWV3LiBUaGlzIGFycmF5IGdldHMgZW1wdGllZCBhZnRlciBldmVyeSB0aW1lIGEgc2hlbGwgY29tbWFuZCBpcyBleGVjdXRlZCB2aWEgdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgb25seSB1c2VkIGZvciBjb21tYW5kIHBhbGV0dGUsIG5vdCB3aGVuIGV4ZWN1dGluZyBhIHNoZWxsIGNvbW1hbmQgZnJvbSB0aGUgc2V0dGluZ3MgcGFuZWwsIG5vciB3aGVuXHJcblx0ICogZXhlY3V0aW5nIHNoZWxsIGNvbW1hbmRzIHZpYSBTQ19FdmVudHMuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHByaXZhdGUgY2FjaGVkX3BhcnNpbmdfcHJvY2Vzc2VzOiB7XHJcblx0XHRba2V5OiBzdHJpbmddOiBTaGVsbENvbW1hbmRQYXJzaW5nUHJvY2VzcyxcclxuXHR9ID0ge307XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU0hFTExfQ09NTUFORFNfVVJJX0FDVElPTiA9IFwic2hlbGwtY29tbWFuZHNcIlxyXG5cclxuICAgIC8qKiBAc2VlIGdldE91dHB1dFN0YXR1c0JhckVsZW1lbnQoKSAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0dXNCYXJFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcblx0cHVibGljIGFzeW5jIG9ubG9hZCgpIHtcclxuXHRcdGRlYnVnTG9nKCdsb2FkaW5nIHBsdWdpbicpO1xyXG5cclxuXHRcdC8vIExvYWQgc2V0dGluZ3NcclxuXHRcdGlmICghYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKSkge1xyXG5cdFx0XHQvLyBMb2FkaW5nIHRoZSBzZXR0aW5ncyBoYXMgZmFpbGVkIGR1ZSB0byBhbiB1bnN1cHBvcnRlZCBzZXR0aW5ncyBmaWxlIHZlcnNpb24uXHJcblx0XHRcdC8vIFRoZSBwbHVnaW4gc2hvdWxkIG5vdCBiZSB1c2VkLCBhbmQgaXQgaGFzIGFjdHVhbGx5IGRpc2FibGVkIGl0c2VsZiwgYnV0IHRoZSBjb2RlIGV4ZWN1dGlvbiBuZWVkcyB0byBiZVxyXG5cdFx0XHQvLyBzdG9wcGVkIG1hbnVhbGx5LlxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUnVuIHBvc3NpYmxlIGNvbmZpZ3VyYXRpb24gbWlncmF0aW9uc1xyXG5cdFx0YXdhaXQgUnVuTWlncmF0aW9ucyh0aGlzKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgbW9kZWxzXHJcblx0XHRpbnRyb2R1Y2VNb2RlbHModGhpcyk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgVFNoZWxsQ29tbWFuZCBvYmplY3RzIGZyb20gY29uZmlndXJhdGlvbiAob25seSBhZnRlciBjb25maWd1cmF0aW9uIG1pZ3JhdGlvbnMgYXJlIGRvbmUpXHJcblx0XHR0aGlzLmxvYWRUU2hlbGxDb21tYW5kcygpO1xyXG5cclxuXHRcdC8vIExvYWQgUHJvbXB0c1xyXG5cdFx0Y29uc3QgcHJvbXB0X21vZGVsID0gZ2V0TW9kZWw8UHJvbXB0TW9kZWw+KFByb21wdE1vZGVsLm5hbWUpO1xyXG5cdFx0dGhpcy5wcm9tcHRzID0gcHJvbXB0X21vZGVsLmxvYWRJbnN0YW5jZXModGhpcy5zZXR0aW5ncyk7XHJcblxyXG5cdFx0Ly8gTG9hZCBDdXN0b21WYXJpYWJsZXMgKGNvbmZpZ3VyYXRpb24gaW5zdGFuY2VzKVxyXG5cdFx0Y29uc3QgY3VzdG9tX3ZhcmlhYmxlX21vZGVsID0gZ2V0TW9kZWw8Q3VzdG9tVmFyaWFibGVNb2RlbD4oQ3VzdG9tVmFyaWFibGVNb2RlbC5uYW1lKTtcclxuXHRcdHRoaXMuY3VzdG9tX3ZhcmlhYmxlX2luc3RhbmNlcyA9IGN1c3RvbV92YXJpYWJsZV9tb2RlbC5sb2FkSW5zdGFuY2VzKHRoaXMuc2V0dGluZ3MpO1xyXG5cclxuXHRcdC8vIExvYWQgdmFyaWFibGVzIChib3RoIGJ1aWx0LWluIGFuZCBjdXN0b20gb25lcykuIERvIHRoaXMgQUZURVIgbG9hZGluZyBjb25maWdzIGZvciBjdXN0b20gdmFyaWFibGVzIVxyXG5cdFx0dGhpcy52YXJpYWJsZXMgPSBsb2FkVmFyaWFibGVzKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIG91dHB1dCB3cmFwcGVyc1xyXG4gICAgICAgIGNvbnN0IG91dHB1dF93cmFwcGVyX21vZGVsID0gZ2V0TW9kZWw8T3V0cHV0V3JhcHBlck1vZGVsPihPdXRwdXRXcmFwcGVyTW9kZWwubmFtZSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRfd3JhcHBlcnMgPSBvdXRwdXRfd3JhcHBlcl9tb2RlbC5sb2FkSW5zdGFuY2VzKHRoaXMuc2V0dGluZ3MpO1xyXG5cclxuXHRcdC8vIE1ha2UgYWxsIGRlZmluZWQgc2hlbGwgY29tbWFuZHMgdG8gYXBwZWFyIGluIHRoZSBPYnNpZGlhbiBjb21tYW5kIHBhbGV0dGUuXHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kcyA9IHRoaXMuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuXHRcdGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9pZCBpbiBzaGVsbF9jb21tYW5kcykge1xyXG5cdFx0XHRjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuXHRcdFx0aWYgKHRfc2hlbGxfY29tbWFuZC5jYW5BZGRUb0NvbW1hbmRQYWxldHRlKCkpIHtcclxuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBQZXJmb3JtIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIGlmIGVuYWJsZWQuXHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVfZXZlbnRzKSB7XHJcblx0XHRcdHRoaXMucmVnaXN0ZXJTQ19FdmVudHMoZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExvYWQgYSBjdXN0b20gYXV0b2NvbXBsZXRlIGxpc3QgaWYgaXQgZXhpc3RzLlxyXG5cdFx0dGhpcy5sb2FkQ3VzdG9tQXV0b2NvbXBsZXRlTGlzdCgpO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBhIFNldHRpbmdzVGFiLlxyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTQ19NYWluU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcblx0XHQvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGNyZWF0ZSBDdXN0b21WYXJpYWJsZVZpZXdzLlxyXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoQ3VzdG9tVmFyaWFibGVWaWV3LlZpZXdUeXBlLCAobGVhZjogV29ya3NwYWNlTGVhZikgPT4gbmV3IEN1c3RvbVZhcmlhYmxlVmlldyh0aGlzLCBsZWFmKSk7XHJcblxyXG5cdFx0Ly8gRGVidWcgcmVzZXJ2ZWQgSURzXHJcblx0XHRkZWJ1Z0xvZyhcIklER2VuZXJhdG9yJ3MgcmVzZXJ2ZWQgSURzOlwiKTtcclxuXHRcdGRlYnVnTG9nKGdldElER2VuZXJhdG9yKCkuZ2V0UmVzZXJ2ZWRJRHMoKSk7XHJcblxyXG5cdFx0Ly8gUmVnaXN0ZXIgYW4gVVJJIGhhbmRsZXIuXHJcblx0XHR0aGlzLnJlZ2lzdGVyVVJJSGFuZGxlcigpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBsb2FkVFNoZWxsQ29tbWFuZHMoKSB7XHJcblx0XHR0aGlzLnRfc2hlbGxfY29tbWFuZHMgPSB7fTsgLy8gVE9ETzogQ29uc2lkZXIgY2hhbmdpbmcgdGhpcyB0byBlaXRoZXIgYW4gYXJyYXkgb3IgYSBNYXAuXHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25zID0gdGhpcy5nZXRTaGVsbENvbW1hbmRDb25maWd1cmF0aW9ucygpO1xyXG5cclxuXHRcdGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uIG9mIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbnMpIHtcclxuXHRcdFx0dGhpcy50X3NoZWxsX2NvbW1hbmRzW3NoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZF0gPSBuZXcgVFNoZWxsQ29tbWFuZCh0aGlzLCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFRTaGVsbENvbW1hbmRzKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudF9zaGVsbF9jb21tYW5kcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRWYXJpYWJsZXMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy52YXJpYWJsZXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0UHJvbXB0cygpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb21wdHM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0Q3VzdG9tVmFyaWFibGVJbnN0YW5jZXMoKTogQ3VzdG9tVmFyaWFibGVJbnN0YW5jZU1hcCB7XHJcblx0XHRyZXR1cm4gdGhpcy5jdXN0b21fdmFyaWFibGVfaW5zdGFuY2VzO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBnZXRTaGVsbENvbW1hbmRDb25maWd1cmF0aW9ucygpOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3Muc2hlbGxfY29tbWFuZHM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0T3V0cHV0V3JhcHBlcnMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXRfd3JhcHBlcnM7XHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZXMgdG8gZmluZCBhbiBpbmRleCBhdCB3aGljaCBhIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIGxvY2F0ZWQgaW4gdGhpcy5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcy5cclxuICAgICAqIFJldHVybnMgdW5kZWZpbmVkLCBpZiBpdCdzIG5vdCBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBETyBOT1QgRVhQT1NFIFRIRSBJTkRFWCBPVVRTSURFIFRIRSBQTFVHSU4hIEl0J3Mgbm90IGEgc3RhYmxlIHJlZmVyZW5jZSB0byBhIHNoZWxsIGNvbW1hbmQsIGJlY2F1c2Ugc2hlbGwgY29tbWFuZHNcclxuICAgICAqIGNhbiBiZSByZW9yZGVyZWQgKHdlbGwsIGF0IGxlYXN0IGluIHNvbWUgZnV0dXJlIHZlcnNpb24gb2YgdGhlIHBsdWdpbikuIEFsd2F5cyB1c2UgdGhlIElEIGFzIGEgc3RhYmxlLCBleHRlcm5hbGx5XHJcbiAgICAgKiBzYWZlIHJlZmVyZW5jZSFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2hlbGxfY29tbWFuZF9pZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbkluZGV4KHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Muc2hlbGxfY29tbWFuZHMuZmluZEluZGV4KChzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZCA9PSBzaGVsbF9jb21tYW5kX2lkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBPYnNpZGlhbiBVUkkgdGhhdCBjb21wbGllcyB3aXRoIHRoZSBmb3JtYXQgb2JzaWRpYW46Ly9hY3Rpb24vP3ZhdWx0PVhZWiBhbmQgdGhhdCBtYXkgY29udGFpbiBwb3NzaWJsZVxyXG4gICAgICogY3VzdG9tIGFyZ3VtZW50cyBhdCB0aGUgZW5kLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBpZiAnYWN0aW9uJyBpcyAnb3BlbicgYW5kIGEgJ2ZpbGUnIGFyZ3VtZW50IGlzIHByZXNlbnQgaW4gJ3VyaV9hcmd1bWVudHMnLCB0aGUgVVJJIHdpbGwgdXNlIHRoZSBzaG9ydGhhbmQgc3ludGF4IGRlc2NyaWJlZCBoZXJlOiBodHRwczovL2hlbHAub2JzaWRpYW4ubWQvQWR2YW5jZWQrdG9waWNzL1VzaW5nK29ic2lkaWFuK1VSSSNTaG9ydGhhbmQrZm9ybWF0c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb25cclxuICAgICAqIEBwYXJhbSB1cmlfYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPYnNpZGlhblVSSShhY3Rpb246IHN0cmluZywgdXJpX2FyZ3VtZW50czogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9KTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBlbmNvZGVkX3ZhdWx0X25hbWU6IHN0cmluZyA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmFwcC52YXVsdC5nZXROYW1lKCkpO1xyXG4gICAgICAgIGxldCBiYXNlX3VyaTogc3RyaW5nO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB3aGljaCBraW5kIG9mIHVyaSB0eXBlIHNob3VsZCBiZSB1c2VkOiBzaG9ydGhhbmQgb3Igbm9ybWFsXHJcbiAgICAgICAgaWYgKFwib3BlblwiID09PSBhY3Rpb24gJiYgdXJpX2FyZ3VtZW50cy5maWxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVXNlIHNob3J0aGFuZCB1cmkgdHlwZSBmb3Igb3BlbmluZyBhIGZpbGUuXHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRfZmlsZSA9IGVuY29kZVVSSUNvbXBvbmVudCh1cmlfYXJndW1lbnRzLmZpbGUpO1xyXG4gICAgICAgICAgICBiYXNlX3VyaSA9IGBvYnNpZGlhbjovL3ZhdWx0LyR7ZW5jb2RlZF92YXVsdF9uYW1lfS8ke2VuY29kZWRfZmlsZX1gXHJcbiAgICAgICAgICAgIGRlbGV0ZSB1cmlfYXJndW1lbnRzLmZpbGU7IC8vIFByZXZlbnQgYWRkaW5nIGFuIGV4dHJhICcmZmlsZT0nIGFyZ3VtZW50IHRvIHRoZSBlbmQgb2YgdGhlIFVSSS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2Ugbm9ybWFsIHVyaSB0eXBlIGZvciBldmVyeXRoaW5nIGVsc2UuXHJcbiAgICAgICAgICAgIGJhc2VfdXJpID0gYG9ic2lkaWFuOi8vJHthY3Rpb259Lz92YXVsdD0ke2VuY29kZWRfdmF1bHRfbmFtZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29uY2F0ZW5hdGVkX3VyaV9hcmd1bWVudHMgPSBcIlwiO1xyXG4gICAgICAgIGZvciAoY29uc3QgdXJpX2FyZ3VtZW50X25hbWUgaW4gdXJpX2FyZ3VtZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCB1cmlfYXJndW1lbnRfdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodXJpX2FyZ3VtZW50c1t1cmlfYXJndW1lbnRfbmFtZV0pO1xyXG4gICAgICAgICAgICBjb25jYXRlbmF0ZWRfdXJpX2FyZ3VtZW50cyArPSBgJiR7dXJpX2FyZ3VtZW50X25hbWV9PSR7dXJpX2FyZ3VtZW50X3ZhbHVlfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYXNlX3VyaSArIGNvbmNhdGVuYXRlZF91cmlfYXJndW1lbnRzO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IHNoZWxsIGNvbW1hbmQgb2JqZWN0IGFuZCByZWdpc3RlcnMgaXQgdG8gT2JzaWRpYW4ncyBjb21tYW5kIHBhbGV0dGUsIGJ1dCBkb2VzIG5vdCBzYXZlIHRoZSBtb2RpZmllZFxyXG5cdCAqIGNvbmZpZ3VyYXRpb24gdG8gZGlzay4gVG8gc2F2ZSB0aGUgYWRkaXRpb24sIGNhbGwgc2F2ZVNldHRpbmdzKCkuXHJcblx0ICovXHJcblx0cHVibGljIG5ld1RTaGVsbENvbW1hbmQoKSB7XHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kX2lkID0gZ2V0SURHZW5lcmF0b3IoKS5nZW5lcmF0ZUlEKCk7XHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gPSBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKHNoZWxsX2NvbW1hbmRfaWQpO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc2hlbGxfY29tbWFuZHMucHVzaChzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24pO1xyXG5cdFx0Y29uc3QgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kID0gbmV3IFRTaGVsbENvbW1hbmQodGhpcywgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKTtcclxuXHRcdHRoaXMudF9zaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXSA9IHRfc2hlbGxfY29tbWFuZDtcclxuXHRcdGlmICh0X3NoZWxsX2NvbW1hbmQuY2FuQWRkVG9Db21tYW5kUGFsZXR0ZSgpKSB7IC8vIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUsIGJlY2F1c2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBlbmFibGVzIGFkZGluZyB0byB0aGUgY29tbWFuZCBwYWxldHRlLCBidXQgY2hlY2sganVzdCBpbiBjYXNlLlxyXG5cdFx0XHR0aGlzLnJlZ2lzdGVyU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdF9zaGVsbF9jb21tYW5kO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVE9ETzogTW92ZSB0byBUU2hlbGxDb21tYW5kLnJlZ2lzdGVyVG9Db21tYW5kUGFsZXR0ZSgpLCBidXQgc3BsaXQgdG8gbXVsdGlwbGUgbWV0aG9kcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmRcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVnaXN0ZXJTaGVsbENvbW1hbmQodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSB7XHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kX2lkID0gdF9zaGVsbF9jb21tYW5kLmdldElkKCk7XHJcblx0XHRkZWJ1Z0xvZyhcIlJlZ2lzdGVyaW5nIHNoZWxsIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiLi4uXCIpO1xyXG5cclxuXHRcdC8vIERlZmluZSBhIGZ1bmN0aW9uIGZvciBleGVjdXRpbmcgdGhlIHNoZWxsIGNvbW1hbmQuXHJcblx0XHRjb25zdCBleGVjdXRvciA9IGFzeW5jIChwYXJzaW5nX3Byb2Nlc3M6IFNoZWxsQ29tbWFuZFBhcnNpbmdQcm9jZXNzIHwgdW5kZWZpbmVkKSA9PiB7XHJcblx0XHRcdGlmICghcGFyc2luZ19wcm9jZXNzKSB7XHJcblx0XHRcdFx0cGFyc2luZ19wcm9jZXNzID0gdF9zaGVsbF9jb21tYW5kLmNyZWF0ZVBhcnNpbmdQcm9jZXNzKG51bGwpOyAvLyBObyBTQ19FdmVudCBpcyBhdmFpbGFibGUgd2hlbiBleGVjdXRpbmcgc2hlbGwgY29tbWFuZHMgdmlhIHRoZSBjb21tYW5kIHBhbGV0dGUgLyBob3RrZXlzLlxyXG5cdFx0XHRcdC8vIFRyeSB0byBwcm9jZXNzIHZhcmlhYmxlcyB0aGF0IGNhbiBiZSBwcm9jZXNzZWQgYmVmb3JlIHBlcmZvcm1pbmcgcHJlYWN0aW9ucy5cclxuXHRcdFx0XHRhd2FpdCBwYXJzaW5nX3Byb2Nlc3MucHJvY2VzcygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwYXJzaW5nX3Byb2Nlc3MuZ2V0UGFyc2luZ1Jlc3VsdHMoKS5zaGVsbF9jb21tYW5kLnN1Y2NlZWRlZCkge1xyXG5cdFx0XHRcdC8vIFRoZSBjb21tYW5kIHdhcyBwYXJzZWQgY29ycmVjdGx5LlxyXG5cdFx0XHRcdGNvbnN0IGV4ZWN1dG9yX2luc3RhbmNlID0gbmV3IFNoZWxsQ29tbWFuZEV4ZWN1dG9yKCAvLyBOYW1lZCAnZXhlY3V0b3JfaW5zdGFuY2UnIGJlY2F1c2UgJ2V4ZWN1dG9yJyBpcyBhbm90aGVyIGNvbnN0YW50LlxyXG5cdFx0XHRcdFx0dGhpcyxcclxuXHRcdFx0XHRcdHRfc2hlbGxfY29tbWFuZCxcclxuXHRcdFx0XHRcdG51bGwgLy8gTm8gU0NfRXZlbnQgaXMgYXZhaWxhYmxlIHdoZW4gZXhlY3V0aW5nIHZpYSBjb21tYW5kIHBhbGV0dGUgb3IgaG90a2V5LlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0YXdhaXQgZXhlY3V0b3JfaW5zdGFuY2UuZG9QcmVhY3Rpb25zQW5kRXhlY3V0ZVNoZWxsQ29tbWFuZChwYXJzaW5nX3Byb2Nlc3MpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFRoZSBjb21tYW5kIGNvdWxkIG5vdCBiZSBwYXJzZWQgY29ycmVjdGx5LlxyXG5cdFx0XHRcdC8vIERpc3BsYXkgZXJyb3IgbWVzc2FnZXNcclxuXHRcdFx0XHRwYXJzaW5nX3Byb2Nlc3MuZGlzcGxheUVycm9yTWVzc2FnZXMoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlZ2lzdGVyIGFuIE9ic2lkaWFuIGNvbW1hbmRcclxuXHRcdGNvbnN0IG9ic2lkaWFuX2NvbW1hbmQ6IENvbW1hbmQgPSB7XHJcblx0XHRcdGlkOiB0aGlzLmdlbmVyYXRlT2JzaWRpYW5Db21tYW5kSWQoc2hlbGxfY29tbWFuZF9pZCksXHJcblx0XHRcdG5hbWU6IGdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZSh0aGlzLCB0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGxDb21tYW5kKCksIHRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpKSwgLy8gV2lsbCBiZSBvdmVycmlkZGVuIGluIGNvbW1hbmQgcGFsZXR0ZSwgYnV0IHRoaXMgd2lsbCBwcm9iYWJseSBzaG93IHVwIGluIGhvdGtleSBzZXR0aW5ncyBwYW5lbC5cclxuXHRcdFx0Ly8gVXNlICdjaGVja0NhbGxiYWNrJyBpbnN0ZWFkIG9mIG5vcm1hbCAnY2FsbGJhY2snIGJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGdldCBjYWxsZWQgd2hlbiB0aGUgY29tbWFuZCBwYWxldHRlIGlzIG9wZW5lZC5cclxuXHRcdFx0Y2hlY2tDYWxsYmFjazogKGlzX29wZW5pbmdfY29tbWFuZF9wYWxldHRlKTogYm9vbGVhbiB8IHZvaWQgPT4geyAvLyBJZiBpc19vcGVuaW5nX2NvbW1hbmRfcGFsZXR0ZSBpcyB0cnVlLCB0aGVuIHRoZSByZXR1cm4gdHlwZSBpcyBib29sZWFuLCBvdGhlcndpc2Ugdm9pZC5cclxuXHRcdFx0XHRpZiAoaXNfb3BlbmluZ19jb21tYW5kX3BhbGV0dGUpIHtcclxuXHRcdFx0XHRcdC8vIFRoZSB1c2VyIGlzIGN1cnJlbnRseSBvcGVuaW5nIHRoZSBjb21tYW5kIHBhbGV0dGUuXHJcblxyXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgY2FuIHRoZSBzaGVsbCBjb21tYW5kIGJlIHNob3duIGluIGNvbW1hbmQgcGFsZXR0ZVxyXG5cdFx0XHRcdFx0aWYgKCF0X3NoZWxsX2NvbW1hbmQuY2FuU2hvd0luQ29tbWFuZFBhbGV0dGUoKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgcHJldmlldyBhbmQgZGVueSBzaG93aW5nIGluIGNvbW1hbmQgcGFsZXR0ZS5cclxuXHRcdFx0XHRcdFx0ZGVidWdMb2coXCJTaGVsbCBjb21tYW5kICNcIiArIHRfc2hlbGxfY29tbWFuZC5nZXRJZCgpICsgXCIgd29uJ3QgYmUgc2hvd24gaW4gY29tbWFuZCBwYWxldHRlLlwiKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIERvIG5vdCBleGVjdXRlIHRoZSBjb21tYW5kIHlldCwgYnV0IHBhcnNlIHZhcmlhYmxlcyBmb3IgcHJldmlldywgaWYgZW5hYmxlZCBpbiB0aGUgc2V0dGluZ3MuXHJcblx0XHRcdFx0XHRkZWJ1Z0xvZyhcIkdldHRpbmcgY29tbWFuZCBwYWxldHRlIHByZXZpZXcgZm9yIHNoZWxsIGNvbW1hbmQgI1wiICsgdF9zaGVsbF9jb21tYW5kLmdldElkKCkpO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MucHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlKSB7XHJcblx0XHRcdFx0XHRcdC8vIFByZXBhcnNlIHZhcmlhYmxlc1xyXG5cdFx0XHRcdFx0XHRjb25zdCBwYXJzaW5nX3Byb2Nlc3MgPSB0X3NoZWxsX2NvbW1hbmQuY3JlYXRlUGFyc2luZ1Byb2Nlc3MobnVsbCk7IC8vIE5vIFNDX0V2ZW50IGlzIGF2YWlsYWJsZSB3aGVuIGV4ZWN1dGluZyBzaGVsbCBjb21tYW5kcyB2aWEgdGhlIGNvbW1hbmQgcGFsZXR0ZSAvIGhvdGtleXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdfcHJvY2Vzcy5wcm9jZXNzKCkudGhlbigocGFyc2luZ19zdWNjZWVkZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzaW5nX3N1Y2NlZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNpbmcgc3VjY2VlZGVkXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbmFtZSBPYnNpZGlhbiBjb21tYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2luZ19yZXN1bHQgPSBwYXJzaW5nX3Byb2Nlc3MuZ2V0UGFyc2luZ1Jlc3VsdHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0X3NoZWxsX2NvbW1hbmQucmVuYW1lT2JzaWRpYW5Db21tYW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzaW5nX3Jlc3VsdFtcInNoZWxsX2NvbW1hbmRcIl0ucGFyc2VkX2NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdfcmVzdWx0W1wiYWxpYXNcIl0ucGFyc2VkX2NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHByZXBhcnNlZCB2YXJpYWJsZXMgc28gdGhhdCB0aGV5IHdpbGwgYmUgdXNlZCBpZiB0aGlzIHNoZWxsIGNvbW1hbmQgZ2V0cyBleGVjdXRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZF9wYXJzaW5nX3Byb2Nlc3Nlc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0gPSBwYXJzaW5nX3Byb2Nlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIElmIHBhcnNpbmcgZmFpbGVkIChvciB3YXMgZGlzYWJsZWQpLCB0aGVuIHVzZSB1bnBhcnNlZCB0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGxDb21tYW5kKCkgYW5kIHRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpLlxyXG5cdFx0XHRcdFx0dF9zaGVsbF9jb21tYW5kLnJlbmFtZU9ic2lkaWFuQ29tbWFuZCh0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGxDb21tYW5kKCksIHRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpKTtcclxuXHRcdFx0XHRcdHRoaXMuY2FjaGVkX3BhcnNpbmdfcHJvY2Vzc2VzW3Rfc2hlbGxfY29tbWFuZC5nZXRJZCgpXSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gVGhlIHVzZXIgaGFzIGluc3RydWN0ZWQgdG8gZXhlY3V0ZSB0aGUgY29tbWFuZC5cclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRfcGFyc2luZ19wcm9jZXNzZXNbdF9zaGVsbF9jb21tYW5kLmdldElkKCldLCAvLyBDYW4gYmUgdW5kZWZpbmVkLCBpZiBubyBwcmVwYXJzaW5nIHdhcyBkb25lLiBleGVjdXRvcigpIHdpbGwgaGFuZGxlIGNyZWF0aW5nIHRoZSBwYXJzaW5nIHByb2Nlc3MgdGhlbi5cclxuICAgICAgICAgICAgICAgICAgICApLnRoZW4oKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSB3aG9sZSBhcnJheSBvZiBwcmVwYXJzZWQgY29tbWFuZHMuIEV2ZW4gdGhvdWdoIHdlIG9ubHkgdXNlZCBqdXN0IG9uZSBjb21tYW5kIGZyb20gaXQsIHdlIG5lZWQgdG8gbm90aWNlIHRoYXQgb3BlbmluZyBhIGNvbW1hbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFsZXR0ZSBtaWdodCBnZW5lcmF0ZSBtdWx0aXBsZSBwcmVwYXJzZWQgY29tbWFuZHMgaW4gdGhlIGFycmF5LCBidXQgYXMgdGhlIHVzZXIgc2VsZWN0cyBhbmQgZXhlY3V0ZXMgb25seSBvbmUgY29tbWFuZCwgYWxsIHRoZXNlIHRlbXBvcmFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21tYW5kcyBhcmUgbm93IG9ic29sZXRlLiBEZWxldGUgdGhlbSBqdXN0IGluIGNhc2UgdGhlIHVzZXIgdG9nZ2xlcyB0aGUgdmFyaWFibGUgcHJldmlldyBmZWF0dXJlIG9mZiBpbiB0aGUgc2V0dGluZ3MsIG9yIGV4ZWN1dGVzIGNvbW1hbmRzIHZpYSBob3RrZXlzLiBXZSBkbyBub3Qgd2FudCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIG9ic29sZXRlIGNvbW1hbmRzIGFjY2lkZW50YWxseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkZWxldGlvbiBhbHNvIG5lZWRzIHRvIGJlIGRvbmUgZXZlbiBpZiB0aGUgZXhlY3V0ZWQgY29tbWFuZCB3YXMgbm90IGEgcHJlcGFyc2VkIGNvbW1hbmQsIGJlY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiB3aGVuIHByZXBhcnNpbmcgaXMgdHVybmVkIG9uIGluIHRoZSBzZXR0aW5ncywgc29tZSBjb21tYW5kcyBtYXkgZmFpbCB0byBwYXJzZSwgYW5kIHRoZXJlZm9yZSB0aGV5IHdvdWxkIG5vdCBiZSBpbiB0aGlzIGFycmF5LCBidXQgb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFuZHMgbWlnaHQgYmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkX3BhcnNpbmdfcHJvY2Vzc2VzID0ge307IC8vIFJlbW92ZXMgb2Jzb2xldGUgcHJlcGFyc2VkIHZhcmlhYmxlcyBmcm9tIGFsbCBzaGVsbCBjb21tYW5kcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXaGVuIHdlIGFyZSBub3QgaW4gdGhlIGNvbW1hbmQgcGFsZXR0ZSBjaGVjayBwaGFzZSwgdGhlcmUncyBubyBuZWVkIHRvIHJldHVybiBhIHZhbHVlLiBKdXN0IGhhdmUgdGhpcyAncmV0dXJuJyBzdGF0ZW1lbnQgYmVjYXVzZSBhbGwgb3RoZXIgcmV0dXJuIHBvaW50cyBoYXZlIGEgJ3JldHVybicgdG9vLlxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuYWRkQ29tbWFuZChvYnNpZGlhbl9jb21tYW5kKVxyXG5cdFx0dGhpcy5vYnNpZGlhbl9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXSA9IG9ic2lkaWFuX2NvbW1hbmQ7IC8vIFN0b3JlIHRoZSByZWZlcmVuY2Ugc28gdGhhdCB3ZSBjYW4gZWRpdCB0aGUgY29tbWFuZCBsYXRlciBpbiBTaGVsbENvbW1hbmRzU2V0dGluZ3NUYWIgaWYgbmVlZGVkLiBUT0RPOiBVc2UgdFNoZWxsQ29tbWFuZCBpbnN0ZWFkLlxyXG5cdFx0dF9zaGVsbF9jb21tYW5kLnNldE9ic2lkaWFuQ29tbWFuZChvYnNpZGlhbl9jb21tYW5kKTtcclxuXHRcdGRlYnVnTG9nKFwiUmVnaXN0ZXJlZC5cIilcclxuXHR9XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBHb2VzIHRocm91Z2ggYWxsIGV2ZW50cyBhbmQgYWxsIHNoZWxsIGNvbW1hbmRzLCBhbmQgZm9yIGVhY2ggc2hlbGwgY29tbWFuZCwgcmVnaXN0ZXJzIGFsbCB0aGUgZXZlbnRzIHRoYXQgdGhlIHNoZWxsXHJcblx0ICogY29tbWFuZCBhcyBlbmFibGVkIGluIGl0cyBjb25maWd1cmF0aW9uLiBEb2VzIG5vdCBtb2RpZnkgdGhlIGNvbmZpZ3VyYXRpb25zLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNhbGxlZF9hZnRlcl9jaGFuZ2luZ19zZXR0aW5ncyBTZXQgdG86IHRydWUsIGlmIHRoaXMgaGFwcGVucyBhZnRlciBjaGFuZ2luZyBjb25maWd1cmF0aW9uOyBmYWxzZSwgaWYgdGhpcyBoYXBwZW5zIGR1cmluZyBsb2FkaW5nIHRoZSBwbHVnaW4uXHJcblx0ICovXHJcblx0cHVibGljIHJlZ2lzdGVyU0NfRXZlbnRzKGNhbGxlZF9hZnRlcl9jaGFuZ2luZ19zZXR0aW5nczogYm9vbGVhbikge1xyXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgT2JzaWRpYW4gaXMgZnVsbHkgbG9hZGVkIGJlZm9yZSBhbGxvd2luZyBhbnkgZXZlbnRzIHRvIHRyaWdnZXIuXHJcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeSgoKSA9PiB7XHJcblx0XHRcdC8vIEV2ZW4gYWZ0ZXIgT2JzaWRpYW4gaXMgZnVsbHkgbG9hZGVkLCB3YWl0IGEgd2hpbGUgaW4gb3JkZXIgdG8gcHJldmVudCBTQ19FdmVudF9vbkFjdGl2ZUxlYWZDaGFuZ2VkIHRyaWdnZXJpbmcgcmlnaHQgYWZ0ZXIgc3RhcnQtdXAuXHJcblx0XHRcdC8vIEF0IGxlYXN0IG9uIE9ic2lkaWFuIDAuMTIuMTkgaXQncyBub3QgZW5vdWdoIHRvIGRlbGF5IHVudGlsIG9uTGF5b3V0UmVhZHksIG5lZWQgdG8gd2FpdCBhIGJpdCBtb3JlIGluIG9yZGVyIHRvIGF2b2lkIHRoZSBtaXNzLXRyaWdnZXJpbmcuXHJcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgLy8gc2V0VGltZW91dCgpIHNob3VsZCBub3QgbmVlZCByZWdpc3RlcmluZyB0byBPYnNpZGlhbiBBUEksIEkgZ3Vlc3MuXHJcblx0XHRcdFx0Ly8gSXRlcmF0ZSBhbGwgc2hlbGwgY29tbWFuZHMgYW5kIHJlZ2lzdGVyIHBvc3NpYmxlIGV2ZW50cy5cclxuXHRcdFx0XHRjb25zdCBzaGVsbF9jb21tYW5kcyA9IHRoaXMuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuXHRcdFx0XHRmb3IgKGNvbnN0IHNoZWxsX2NvbW1hbmRfaWQgaW4gc2hlbGxfY29tbWFuZHMpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHRfc2hlbGxfY29tbWFuZCA9IHNoZWxsX2NvbW1hbmRzW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG5cdFx0XHRcdFx0dF9zaGVsbF9jb21tYW5kLnJlZ2lzdGVyU0NfRXZlbnRzKGNhbGxlZF9hZnRlcl9jaGFuZ2luZ19zZXR0aW5ncyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCAwKTsgLy8gMCBtZWFucyB0byBjYWxsIHRoZSBjYWxsYmFjayBvbiBcInRoZSBuZXh0IGV2ZW50IGN5Y2xlXCIsIGFjY29yZGluZyB0byB3aW5kb3cuc2V0VGltZW91dCgpIGRvY3VtZW50YXRpb24uIEl0IHNob3VsZCBiZSBhIGxvbmcgZW5vdWdoIGRlbGF5LiBCdXQgaWYgU0NfRXZlbnRfb25BY3RpdmVMZWFmQ2hhbmdlZCBzdGlsbCBnZXRzIHRyaWdnZXJlZCBkdXJpbmcgc3RhcnQtdXAsIHRoaXMgdmFsdWUgY2FuIGJlIHJhaXNlZCB0byBmb3IgZXhhbXBsZSAxMDAwICg9IG9uZSBzZWNvbmQpLlxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHb2VzIHRocm91Z2ggYWxsIGV2ZW50cyBhbmQgYWxsIHNoZWxsIGNvbW1hbmRzLCBhbmQgbWFrZXMgc3VyZSBhbGwgb2YgdGhlbSBhcmUgdW5yZWdpc3RlcmVkLCBlLmcuIHdpbGwgbm90IHRyaWdnZXJcclxuXHQgKiBhdXRvbWF0aWNhbGx5LiBEb2VzIG5vdCBtb2RpZnkgdGhlIGNvbmZpZ3VyYXRpb25zLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB1bnJlZ2lzdGVyU0NfRXZlbnRzKCkge1xyXG5cdFx0Ly8gSXRlcmF0ZSBhbGwgZXZlbnRzXHJcblx0XHRnZXRTQ19FdmVudHModGhpcykuZm9yRWFjaCgoc2NfZXZlbnQ6IFNDX0V2ZW50KSA9PiB7XHJcblx0XHRcdC8vIEl0ZXJhdGUgYWxsIHNoZWxsIGNvbW1hbmRzXHJcblx0XHRcdGNvbnN0IHNoZWxsX2NvbW1hbmRzID0gdGhpcy5nZXRUU2hlbGxDb21tYW5kcygpO1xyXG5cdFx0XHRmb3IgKGNvbnN0IHNoZWxsX2NvbW1hbmRfaWQgaW4gc2hlbGxfY29tbWFuZHMpIHtcclxuXHRcdFx0XHRjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuXHRcdFx0XHRzY19ldmVudC51bnJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVmaW5lcyBhbiBPYnNpZGlhbiBwcm90b2NvbCBoYW5kbGVyIHRoYXQgYWxsb3dzIHJlY2VpdmluZyByZXF1ZXN0cyB2aWEgb2JzaWRpYW46Ly9zaGVsbC1jb21tYW5kcyBVUkkuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRwcml2YXRlIHJlZ2lzdGVyVVJJSGFuZGxlcigpIHtcclxuXHRcdHRoaXMucmVnaXN0ZXJPYnNpZGlhblByb3RvY29sSGFuZGxlcihTQ19QbHVnaW4uU0hFTExfQ09NTUFORFNfVVJJX0FDVElPTiwgYXN5bmMgKHBhcmFtZXRlcnM6IE9ic2lkaWFuUHJvdG9jb2xEYXRhKSA9PiB7XHJcblx0XHRcdGNvbnN0IHBhcmFtZXRlcl9uYW1lczogc3RyaW5nW10gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJhbWV0ZXJzKTtcclxuXHJcblx0XHRcdC8vIEFzc2lnbiB2YWx1ZXMgdG8gY3VzdG9tIHZhcmlhYmxlcyAoYWxzbyBkZWxldGUgc29tZSB1bm5lZWRlZCBlbnRyaWVzIGZyb20gcGFyYW1ldGVyX25hbWVzKVxyXG5cdFx0XHRsZXQgY3VzdG9tX3ZhcmlhYmxlX2Fzc2lnbm1lbnRzX2ZhaWxlZCA9IGZhbHNlO1xyXG5cdFx0XHRmb3IgKGNvbnN0IHBhcmFtZXRlcl9pbmRleCBpbiBwYXJhbWV0ZXJfbmFtZXMpIHtcclxuXHRcdFx0XHRjb25zdCBwYXJhbWV0ZXJfbmFtZSA9IHBhcmFtZXRlcl9uYW1lc1twYXJhbWV0ZXJfaW5kZXhdO1xyXG5cclxuXHRcdFx0XHQvLyBDaGVjayBpZiB0aGUgcGFyYW1ldGVyIG5hbWUgaXMgYSBjdXN0b20gdmFyaWFibGVcclxuXHRcdFx0XHRpZiAocGFyYW1ldGVyX25hbWUubWF0Y2goL15fLykpIHtcclxuXHRcdFx0XHRcdC8vIFRoaXMgcGFyYW1ldGVyIGRlZmluZXMgYSB2YWx1ZSBmb3IgYSBjdXN0b20gdmFyaWFibGVcclxuXHRcdFx0XHRcdC8vIEZpbmQgdGhlIHZhcmlhYmxlLlxyXG5cdFx0XHRcdFx0bGV0IGZvdW5kX2N1c3RvbV92YXJpYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB2YXJpYWJsZSBvZiB0aGlzLmdldFZhcmlhYmxlcygpKSB7XHJcblx0XHRcdFx0XHRcdGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIEN1c3RvbVZhcmlhYmxlICYmIHZhcmlhYmxlLnZhcmlhYmxlX25hbWUgPT09IHBhcmFtZXRlcl9uYW1lKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gRm91bmQgdGhlIGNvcnJlY3QgdmFyaWFibGUuXHJcblx0XHRcdFx0XHRcdFx0Zm91bmRfY3VzdG9tX3ZhcmlhYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgY3VzdG9tIHZhcmlhYmxlLlxyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHZhcmlhYmxlLnNldFZhbHVlKHBhcmFtZXRlcnNbcGFyYW1ldGVyX25hbWVdKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFmb3VuZF9jdXN0b21fdmFyaWFibGUpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5uZXdFcnJvcihcIlNoZWxsIGNvbW1hbmRzIFVSSTogQSBjdXN0b20gdmFyaWFibGUgZG9lcyBub3QgZXhpc3Q6IFwiICsgcGFyYW1ldGVyX25hbWUpO1xyXG5cdFx0XHRcdFx0XHRjdXN0b21fdmFyaWFibGVfYXNzaWdubWVudHNfZmFpbGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghY3VzdG9tX3ZhcmlhYmxlX2Fzc2lnbm1lbnRzX2ZhaWxlZCkge1xyXG5cdFx0XHRcdC8vIERldGVybWluZSBhY3Rpb25cclxuXHRcdFx0XHRpZiAodW5kZWZpbmVkICE9PSBwYXJhbWV0ZXJzLmV4ZWN1dGUpIHtcclxuXHRcdFx0XHRcdC8vIEV4ZWN1dGUgYSBzaGVsbCBjb21tYW5kLlxyXG5cdFx0XHRcdFx0Y29uc3QgZXhlY3V0YWJsZV9zaGVsbF9jb21tYW5kX2lkID0gcGFyYW1ldGVycy5leGVjdXRlO1xyXG5cdFx0XHRcdFx0cGFyYW1ldGVyX25hbWVzLnJlbW92ZShcImV4ZWN1dGVcIik7IC8vIE1hcmsgdGhlIHBhcmFtZXRlciBhcyBoYW5kbGVkLiBQcmV2ZW50cyBzaG93aW5nIGFuIGVycm9yIG1lc3NhZ2UgZm9yIGFuIHVucmVjb2duaXNlZCBwYXJhbWV0ZXIuXHJcblxyXG5cdFx0XHRcdFx0Ly8gRmluZCB0aGUgZXhlY3V0YWJsZSBzaGVsbCBjb21tYW5kXHJcblx0XHRcdFx0XHRsZXQgZm91bmRfdF9zaGVsbF9jb21tYW5kID0gZmFsc2U7XHJcblx0XHRcdFx0XHRjb25zdCBzaGVsbF9jb21tYW5kcyA9IHRoaXMuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuXHRcdFx0XHRcdGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9pZCBpbiBzaGVsbF9jb21tYW5kcykge1xyXG5cdFx0XHRcdFx0XHRjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuXHRcdFx0XHRcdFx0aWYgKHRfc2hlbGxfY29tbWFuZC5nZXRJZCgpID09PSBleGVjdXRhYmxlX3NoZWxsX2NvbW1hbmRfaWQpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBjb3JyZWN0IHNoZWxsIGNvbW1hbmQuXHJcblx0XHRcdFx0XHRcdFx0Zm91bmRfdF9zaGVsbF9jb21tYW5kID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSBpdC5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBleGVjdXRvciA9IG5ldyBTaGVsbENvbW1hbmRFeGVjdXRvcih0aGlzLCB0X3NoZWxsX2NvbW1hbmQsIG51bGwpO1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IGV4ZWN1dG9yLmRvUHJlYWN0aW9uc0FuZEV4ZWN1dGVTaGVsbENvbW1hbmQoKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICghZm91bmRfdF9zaGVsbF9jb21tYW5kKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubmV3RXJyb3IoXCJTaGVsbCBjb21tYW5kcyBVUkk6IEEgc2hlbGwgY29tbWFuZCBpZCBkb2VzIG5vdCBleGlzdDogXCIgKyBleGVjdXRhYmxlX3NoZWxsX2NvbW1hbmRfaWQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmFpc2UgZXJyb3JzIGZvciBhbnkgbGVmdC1vdmVyIHBhcmFtZXRlcnMsIGlmIGV4aXN0cy5cclxuXHRcdFx0Zm9yIChjb25zdCBwYXJhbWV0ZXJfbmFtZSBvZiBwYXJhbWV0ZXJfbmFtZXMpIHtcclxuXHRcdFx0XHRzd2l0Y2ggKHBhcmFtZXRlcl9uYW1lKSB7XHJcblx0XHRcdFx0XHRjYXNlIFwiXCI6IC8vIEZvciBzb21lIHJlYXNvbiBPYnNpZGlhbiAwLjE0LjUgYWRkcyBhbiBlbXB0eS1uYW1lZCBwYXJhbWV0ZXIgaWYgdGhlcmUgYXJlIG5vID9xdWVyeT1wYXJhbWV0ZXJzIHByZXNlbnQuXHJcblx0XHRcdFx0XHRjYXNlIFwiYWN0aW9uXCI6IC8vIE9ic2lkaWFuIHByb3ZpZGVzIHRoaXMgYWx3YXlzLiBEb24ndCBzaG93IGFuIGVycm9yIG1lc3NhZ2UgZm9yIHRoaXMuXHJcblx0XHRcdFx0XHRjYXNlIFwidmF1bHRcIjogLy8gT2JzaWRpYW4gaGFuZGxlcyB0aGlzIHBhcmFtZXRlciBhdXRvbWF0aWNhbGx5LiBKdXN0IG1ha2Ugc3VyZSBubyBlcnJvciBtZXNzYWdlIGlzIGRpc3BsYXllZCB3aGVuIHRoaXMgaXMgcHJlc2VudC5cclxuXHRcdFx0XHRcdFx0Ly8gRG8gbm90aGluZ1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGlmIChwYXJhbWV0ZXJfbmFtZS5tYXRjaCgvXl8vKSkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIEN1c3RvbSB2YXJpYWJsZSBwYXJhbWV0ZXJzIChhbmQgYW55IHBvc3NpYmxlIGVycm9ycyByZWxhdGVkIHRvIHRoZW0pIGFyZSBhbHJlYWR5IGhhbmRsZWQgYWJvdmUuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRG8gbm90aGluZy5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBUaHJvdyBhbiBlcnJvciBmb3IgZXZlcnl0aGluZyBlbHNlLlxyXG5cdFx0XHRcdFx0XHRcdHRoaXMubmV3RXJyb3IoXCJTaGVsbCBjb21tYW5kcyBVUkk6IFVucmVjb2duaXNlZCBwYXJhbWV0ZXI6IFwiICsgcGFyYW1ldGVyX25hbWUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2VuZXJhdGVPYnNpZGlhbkNvbW1hbmRJZChzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmcpIHtcclxuXHRcdHJldHVybiBcInNoZWxsLWNvbW1hbmQtXCIgKyBzaGVsbF9jb21tYW5kX2lkO1xyXG5cdH1cclxuXHJcblx0cHVibGljIG9udW5sb2FkKCkge1xyXG5cdFx0ZGVidWdMb2coJ1VubG9hZGluZyBTaGVsbCBjb21tYW5kcyBwbHVnaW4uJyk7XHJcblxyXG5cdFx0Ly8gQ2xvc2UgQ3VzdG9tVmFyaWFibGVWaWV3cy5cclxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoQ3VzdG9tVmFyaWFibGVWaWV3LlZpZXdUeXBlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGN1cnJlbnRfc2V0dGluZ3NfdmVyc2lvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiBzZXR0aW5ncyB2ZXJzaW9uIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbiB2ZXJzaW9uLCBvciBhbiBlcnJvciBtZXNzYWdlIHN0cmluZyBpZiBpdCdzIG5vdCBzdXBwb3J0ZWQuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBpc1NldHRpbmdzVmVyc2lvblN1cHBvcnRlZChjdXJyZW50X3NldHRpbmdzX3ZlcnNpb246IFNldHRpbmdzVmVyc2lvblN0cmluZykge1xyXG5cdFx0aWYgKGN1cnJlbnRfc2V0dGluZ3NfdmVyc2lvbiA9PT0gXCJwcmlvci10by0wLjcuMFwiKSB7XHJcblx0XHRcdC8vIDAueC55IHN1cHBvcnRzIGFsbCBvbGQgc2V0dGluZ3MgZm9ybWF0cyB0aGF0IGRvIG5vdCBkZWZpbmUgYSB2ZXJzaW9uIG51bWJlci4gVGhpcyBzdXBwb3J0IHdpbGwgYmUgcmVtb3ZlZCBpbiAxLjAuMC5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBDb21wYXJlIHRoZSB2ZXJzaW9uIG51bWJlclxyXG5cdFx0XHQvKiogTm90ZSB0aGF0IHRoZSBwbHVnaW4gdmVyc2lvbiBtYXkgYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHZlcnNpb24gY29tcGFyaXNvbi4gVGhlIHBsdWdpbiB2ZXJzaW9uIHdpbGwgYmUgZGlzcGxheWVkIGluIHBvc3NpYmxlIGVycm9yIG1lc3NhZ2VzLiAqL1xyXG5cdFx0XHRjb25zdCBwbHVnaW5fdmVyc2lvbiA9IHRoaXMuZ2V0UGx1Z2luVmVyc2lvbigpO1xyXG5cdFx0XHRjb25zdCB2ZXJzaW9uX2NvbXBhcmlzb24gPSB2ZXJzaW9uQ29tcGFyZShTQ19QbHVnaW4uU2V0dGluZ3NWZXJzaW9uLCBjdXJyZW50X3NldHRpbmdzX3ZlcnNpb24pO1xyXG5cdFx0XHRpZiAodmVyc2lvbl9jb21wYXJpc29uID09PSAwKSB7XHJcblx0XHRcdFx0Ly8gVGhlIHZlcnNpb25zIGFyZSBlcXVhbC5cclxuXHRcdFx0XHQvLyBTdXBwb3J0ZWQuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0gZWxzZSBpZiAodmVyc2lvbl9jb21wYXJpc29uIDwgMCkge1xyXG5cdFx0XHRcdC8vIFRoZSBjb21wYXJlZCB2ZXJzaW9uIGlzIG5ld2VyIHRoYW4gd2hhdCB0aGUgcGx1Z2luIGNhbiBzdXBwb3J0LlxyXG5cdFx0XHRcdHJldHVybiBcIlRoZSBzZXR0aW5ncyBmaWxlIGlzIHNhdmVkIGJ5IGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGlzIHBsdWdpbiwgc28gdGhpcyBwbHVnaW4gZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3RydWN0dXJlIG9mIHRoZSBzZXR0aW5ncyBmaWxlLiBQbGVhc2UgdXBncmFkZSB0aGlzIHBsdWdpbiB0byBhdCBsZWFzdCB2ZXJzaW9uIFwiICsgY3VycmVudF9zZXR0aW5nc192ZXJzaW9uICsgXCIuIE5vdyB0aGUgcGx1Z2luIHZlcnNpb24gaXMgXCIgKyBwbHVnaW5fdmVyc2lvbjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBUaGUgY29tcGFyZWQgdmVyc2lvbiBpcyBvbGRlciB0aGFuIHRoZSB2ZXJzaW9uIHRoYXQgdGhlIHBsdWdpbiBjdXJyZW50bHkgdXNlcyB0byB3cml0ZSBzZXR0aW5ncy5cclxuXHRcdFx0XHQvLyAwLngueSBzdXBwb3J0cyBhbGwgb2xkIHNldHRpbmdzIHZlcnNpb25zLiBJbiAxLjAuMCwgc29tZSBvbGQgc2V0dGluZ3MgZm9ybWF0cyBtaWdodCBsb3NlIHRoZWlyIHN1cHBvcnQsIGJ1dCB0aGF0J3Mgbm90IHlldCBjZXJ0YWluLlxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFBsdWdpblZlcnNpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYW5pZmVzdC52ZXJzaW9uO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblxyXG5cdFx0Ly8gVHJ5IHRvIHJlYWQgYSBzZXR0aW5ncyBmaWxlXHJcblx0XHRsZXQgYWxsX3NldHRpbmdzOiBTQ19NYWluU2V0dGluZ3M7XHJcblx0XHR0aGlzLnNldHRpbmdzID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpOyAvLyBNYXkgaGF2ZSBtaXNzaW5nIG1haW4gc2V0dGluZ3MgZmllbGRzLCBpZiB0aGUgc2V0dGluZ3MgZmlsZSBpcyBmcm9tIGFuIG9sZGVyIHZlcnNpb24gb2YgU0MuIEl0IHdpbGwgYmUgbWlncmF0ZWQgbGF0ZXIuXHJcblx0XHRpZiAobnVsbCA9PT0gdGhpcy5zZXR0aW5ncykge1xyXG5cdFx0XHQvLyBUaGUgc2V0dGluZ3MgZmlsZSBkb2VzIG5vdCBleGlzdC5cclxuXHRcdFx0Ly8gVXNlIGRlZmF1bHQgc2V0dGluZ3NcclxuXHRcdFx0dGhpcy5zZXR0aW5ncyA9IGdldERlZmF1bHRTZXR0aW5ncyh0cnVlKTtcclxuXHRcdFx0YWxsX3NldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFN1Y2NlZWRlZCB0byBsb2FkIGEgc2V0dGluZ3MgZmlsZS5cclxuXHRcdFx0Ly8gSW4gY2FzZSB0aGUgc2V0dGluZ3MgZmlsZSBkb2VzIG5vdCBoYXZlICdkZWJ1Zycgb3IgJ3NldHRpbmdzX3ZlcnNpb24nIGZpZWxkcywgY3JlYXRlIHRoZW0uXHJcblx0XHRcdGFsbF9zZXR0aW5ncyA9IGNvbWJpbmVPYmplY3RzKGdldERlZmF1bHRTZXR0aW5ncyhmYWxzZSksIHRoaXMuc2V0dGluZ3MpOyAvLyBUaGlzIHRlbXBvcmFyeSBzZXR0aW5ncyBvYmplY3QgYWx3YXlzIGhhcyBhbGwgZmllbGRzIGRlZmluZWQgKGV4Y2VwdCBzdWIgZmllbGRzLCBzdWNoIGFzIHNoZWxsIGNvbW1hbmQgc3BlY2lmaWMgZmllbGRzLCBtYXkgc3RpbGwgYmUgbWlzc2luZywgYnV0IHRoZXkgYXJlIG5vdCBuZWVkZWQgdGhpcyBlYXJseSkuIFRoaXMgaXMgdXNlZCBzbyB0aGF0IGl0J3MgY2VydGFpbiB0aGF0IHRoZSBmaWVsZHMgJ2RlYnVnJyBhbmQgJ3NldHRpbmdzX3ZlcnNpb24nIGV4aXN0LlxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBkZWJ1ZyBzdGF0dXMgLSBiZWZvcmUgdGhpcyBsaW5lIGRlYnVnZ2luZyBpcyBhbHdheXMgT0ZGIVxyXG5cdFx0c2V0REVCVUdfT04oYWxsX3NldHRpbmdzLmRlYnVnKTtcclxuXHJcblx0XHQvLyBFbnN1cmUgdGhhdCB0aGUgbG9hZGVkIHNldHRpbmdzIGZpbGUgaXMgc3VwcG9ydGVkLlxyXG5cdFx0Y29uc3QgdmVyc2lvbl9zdXBwb3J0ID0gdGhpcy5pc1NldHRpbmdzVmVyc2lvblN1cHBvcnRlZChhbGxfc2V0dGluZ3Muc2V0dGluZ3NfdmVyc2lvbik7XHJcblx0XHRpZiAodHlwZW9mIHZlcnNpb25fc3VwcG9ydCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHQvLyBUaGUgc2V0dGluZ3MgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkLlxyXG5cdFx0XHRuZXcgTm90aWNlKFwiU0hFTEwgQ09NTUFORFMgUExVR0lOIEhBUyBESVNBQkxFRCBJVFNFTEYgaW4gb3JkZXIgdG8gcHJldmVudCBtaXNpbnRlcnByZXRpbmcgc2V0dGluZ3MgLyBjb3JydXB0aW5nIHRoZSBzZXR0aW5ncyBmaWxlIVwiLCAxMjAqMTAwMCk7XHJcblx0XHRcdG5ldyBOb3RpY2UodmVyc2lvbl9zdXBwb3J0IGFzIHN0cmluZywgMTIwKjEwMDApO1xyXG5cdFx0XHRhd2FpdCB0aGlzLmRpc2FibGVQbHVnaW4oKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBUaGUgcGx1Z2luIHNob3VsZCBub3QgYmUgdXNlZC5cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlOyAvLyBTZXR0aW5ncyBhcmUgbG9hZGVkIGFuZCB0aGUgcGx1Z2luIGNhbiBiZSB1c2VkLlxyXG5cdH1cclxuXHJcblx0cHVibGljIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdC8vIFVwZGF0ZSBzZXR0aW5ncyB2ZXJzaW9uIGluIGNhc2UgaXQncyBvbGQuXHJcblx0XHR0aGlzLnNldHRpbmdzLnNldHRpbmdzX3ZlcnNpb24gPSBTQ19QbHVnaW4uU2V0dGluZ3NWZXJzaW9uO1xyXG5cclxuXHRcdC8vIFdyaXRlIHNldHRpbmdzXHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBsb2FkQ3VzdG9tQXV0b2NvbXBsZXRlTGlzdCgpIHtcclxuXHRcdGNvbnN0IGN1c3RvbV9hdXRvY29tcGxldGVfZmlsZV9uYW1lID0gXCJhdXRvY29tcGxldGUueWFtbFwiO1xyXG5cdFx0Y29uc3QgY3VzdG9tX2F1dG9jb21wbGV0ZV9maWxlX3BhdGggPSBwYXRoLmpvaW4oZ2V0UGx1Z2luQWJzb2x1dGVQYXRoKHRoaXMpLCBjdXN0b21fYXV0b2NvbXBsZXRlX2ZpbGVfbmFtZSk7XHJcblxyXG5cdFx0aWYgKGZzLmV4aXN0c1N5bmMoY3VzdG9tX2F1dG9jb21wbGV0ZV9maWxlX3BhdGgpKSB7XHJcblx0XHRcdGRlYnVnTG9nKFwibG9hZEN1c3RvbUF1dG9jb21wbGV0ZUxpc3QoKTogXCIgKyBjdXN0b21fYXV0b2NvbXBsZXRlX2ZpbGVfbmFtZSArIFwiIGV4aXN0cywgd2lsbCBsb2FkIGl0IG5vdy5cIik7XHJcblx0XHRcdGNvbnN0IGN1c3RvbV9hdXRvY29tcGxldGVfY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhjdXN0b21fYXV0b2NvbXBsZXRlX2ZpbGVfcGF0aCkudG9Mb2NhbGVTdHJpbmcoKTtcclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gYWRkQ3VzdG9tQXV0b2NvbXBsZXRlSXRlbXMoY3VzdG9tX2F1dG9jb21wbGV0ZV9jb250ZW50KVxyXG5cdFx0XHRpZiAodHJ1ZSA9PT0gcmVzdWx0KSB7XHJcblx0XHRcdFx0Ly8gT0tcclxuXHRcdFx0XHRkZWJ1Z0xvZyhcImxvYWRDdXN0b21BdXRvY29tcGxldGVMaXN0KCk6IFwiICsgY3VzdG9tX2F1dG9jb21wbGV0ZV9maWxlX25hbWUgKyBcIiBsb2FkZWQuXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIEFuIGVycm9yIGhhcyBvY2N1cnJlZC5cclxuXHRcdFx0XHRkZWJ1Z0xvZyhcImxvYWRDdXN0b21BdXRvY29tcGxldGVMaXN0KCk6IFwiICsgcmVzdWx0KTtcclxuXHRcdFx0XHR0aGlzLm5ld0Vycm9yKFwiU2hlbGwgY29tbWFuZHM6IFVuYWJsZSB0byBwYXJzZSBcIiArIGN1c3RvbV9hdXRvY29tcGxldGVfZmlsZV9uYW1lICsgXCI6IFwiICsgcmVzdWx0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGVidWdMb2coXCJsb2FkQ3VzdG9tQXV0b2NvbXBsZXRlTGlzdCgpOiBcIiArIGN1c3RvbV9hdXRvY29tcGxldGVfZmlsZV9uYW1lICsgXCIgZG9lcyBub3QgZXhpc3RzLCBzbyB3b24ndCBsb2FkIGl0LiBUaGlzIGlzIHBlcmZlY3RseSBvay5cIik7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBkaXNhYmxlUGx1Z2luKCkge1xyXG5cdFx0Ly8gVGhpcyB1bmZvcnR1bmF0ZWx5IGFjY2Vzc2VzIGEgcHJpdmF0ZSBBUEkuXHJcblx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRhd2FpdCB0aGlzLmFwcC5wbHVnaW5zLmRpc2FibGVQbHVnaW4odGhpcy5tYW5pZmVzdC5pZCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0UGx1Z2luSWQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYW5pZmVzdC5pZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRQbHVnaW5OYW1lKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFuaWZlc3QubmFtZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBuZXdFcnJvcihcclxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgICAgICAgdGltZW91dDogbnVtYmVyID0gdGhpcy5nZXRFcnJvck1lc3NhZ2VEdXJhdGlvbk1zKCksXHJcbiAgICApIHtcclxuXHRcdHJldHVybiBuZXcgTm90aWNlKG1lc3NhZ2UsIHRpbWVvdXQpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIG5ld0Vycm9ycyhtZXNzYWdlczogc3RyaW5nW10pIHtcclxuXHRcdG1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG5cdFx0XHR0aGlzLm5ld0Vycm9yKG1lc3NhZ2UpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlXHJcbiAgICAgKiBAcGFyYW0gdGltZW91dCBDdXN0b20gdGltZW91dCBpbiBtaWxsaXNlY29uZHMuIElmIG5vdCBzZXQsIHRoZSB0aW1lb3V0IHdpbGwgYmUgZmV0Y2hlZCBmcm9tIHVzZXIgY29uZmlndXJhYmxlIHNldHRpbmdzLiBVc2UgMCBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRoZSB0aW1lb3V0LCBpLmUuIHNob3cgdGhlIG5vdGlmaWNhdGlvbiB1bnRpbCBpdCdzIGV4cGxpY2l0bHkgaGlkZGVuIGJ5IGNsaW5raW5nIGl0LCBvciB2aWEgY29kZS5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBuZXdOb3RpZmljYXRpb24oXHJcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nLFxyXG4gICAgICAgIHRpbWVvdXQgPSB0aGlzLmdldE5vdGlmaWNhdGlvbk1lc3NhZ2VEdXJhdGlvbk1zKCksXHJcbiAgICApIHtcclxuXHRcdHJldHVybiBuZXcgTm90aWNlKG1lc3NhZ2UsIHRpbWVvdXQpO1xyXG5cdH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Tm90aWZpY2F0aW9uTWVzc2FnZUR1cmF0aW9uTXMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5ub3RpZmljYXRpb25fbWVzc2FnZV9kdXJhdGlvbiAqIDEwMDA7IC8vICogMTAwMCA9IGNvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHMuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEVycm9yTWVzc2FnZUR1cmF0aW9uTXMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5lcnJvcl9tZXNzYWdlX2R1cmF0aW9uICogMTAwMDsgLy8gKiAxMDAwID0gY29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kcy5cclxuICAgIH1cclxuXHJcblx0cHVibGljIGdldERlZmF1bHRTaGVsbCgpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3Qgb3BlcmF0aW5nX3N5c3RlbSA9IGdldE9wZXJhdGluZ1N5c3RlbSgpO1xyXG5cdFx0bGV0IHNoZWxsX25hbWUgPSB0aGlzLnNldHRpbmdzLmRlZmF1bHRfc2hlbGxzW29wZXJhdGluZ19zeXN0ZW1dOyAvLyBDYW4gYWxzbyBiZSB1bmRlZmluZWQuXHJcblx0XHRpZiAodW5kZWZpbmVkID09PSBzaGVsbF9uYW1lKSB7XHJcblx0XHRcdHNoZWxsX25hbWUgPSBnZXRVc2Vyc0RlZmF1bHRTaGVsbCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHNoZWxsX25hbWU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY3JlYXRlQ3VzdG9tVmFyaWFibGVWaWV3KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpO1xyXG5cdFx0bGVhZi5zZXRWaWV3U3RhdGUoe1xyXG5cdFx0XHR0eXBlOiBDdXN0b21WYXJpYWJsZVZpZXcuVmlld1R5cGUsXHJcblx0XHRcdGFjdGl2ZTogdHJ1ZSxcclxuXHRcdH0pLnRoZW4oKTtcclxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gQ3VzdG9tVmFyaWFibGUgdmFsdWVzIGFyZSBjaGFuZ2VkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBhc3luYyB1cGRhdGVDdXN0b21WYXJpYWJsZVZpZXdzKCkge1xyXG5cdFx0Zm9yIChjb25zdCBsZWFmIG9mIHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoQ3VzdG9tVmFyaWFibGVWaWV3LlZpZXdUeXBlKSkge1xyXG5cdFx0XHRhd2FpdCAobGVhZi52aWV3IGFzIEN1c3RvbVZhcmlhYmxlVmlldykudXBkYXRlQ29udGVudCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgYnkgT3V0cHV0Q2hhbm5lbF9TdGF0dXNCYXIuXHJcbiAgICAgKiBUT0RPOiBNYWtlIGl0IHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgc3RhdHVzIGJhciBlbGVtZW50cy4gSXQgc2hvdWxkIGJlIGEgc2hlbGwgY29tbWFuZCBsZXZlbCBzZXR0aW5nLCB3aGVyZSBhIHNoZWxsIGNvbW1hbmQgb3B0cyBmb3IgZWl0aGVyIHRvIHVzZSB0aGVpciBvd24gc3RhdHVzIGJhciBlbGVtZW50LCBvciBhIGNvbW1vbiBvbmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXRTdGF0dXNCYXJFbGVtZW50KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNCYXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQmFyRWxlbWVudCA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNCYXJFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpY29uIGJ1dHRvbiB0aGF0IHdoZW4gY2xpY2tlZCwgd2lsbCBzZW5kIGEgcmVxdWVzdCB0byB0ZXJtaW5hdGUgc2hlbGwgY29tbWFuZCBleGVjdXRpb24gaW50ZXJtaXR0ZW50bHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lckVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBwcm9jZXNzVGVybWluYXRvciBBIGNhbGxiYWNrIHRoYXQgd2lsbCBhY3R1YWxseSB0ZXJtaW5hdGUgdGhlIHNoZWxsIGNvbW1hbmQgZXhlY3V0aW9uIHByb2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVSZXF1ZXN0VGVybWluYXRpbmdCdXR0b24oY29udGFpbmVyRWxlbWVudDogSFRNTEVsZW1lbnQsIHByb2Nlc3NUZXJtaW5hdG9yOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uID0gY29udGFpbmVyRWxlbWVudC5jcmVhdGVFbCgnYScsIHtcclxuICAgICAgICAgICAgcHJlcGVuZDogdHJ1ZSxcclxuICAgICAgICAgICAgYXR0cjoge1xyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiUmVxdWVzdCB0byB0ZXJtaW5hdGUgdGhlIHByb2Nlc3NcIixcclxuICAgICAgICAgICAgICAgIGNsYXNzOiBcIlNDLWljb24tdGVybWluYXRlLXByb2Nlc3NcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRJY29uKGJ1dHRvbiwgXCJwb3dlclwiKTtcclxuICAgICAgICBidXR0b24ub25jbGljayA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBwcm9jZXNzVGVybWluYXRvcigpO1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIk1vZGFsIiwiU2V0dGluZyIsIkZpbGVTeXN0ZW1BZGFwdGVyIiwicGF0aCIsInBsYXRmb3JtIiwiTWFya2Rvd25WaWV3Iiwibm9ybWFsaXplUGF0aCIsInNoZWxsIiwiY2xpcGJvYXJkIiwiTm90aWNlIiwibW9tZW50IiwiZ2V0QWxsVGFncyIsIlRGb2xkZXIiLCJURmlsZSIsIkVPTCIsIlBsYXRmb3JtIiwiZnMiLCJjaGlsZF9wcm9jZXNzIiwic3Bhd24iLCJ0aGlzIiwicGFyc2VZYW1sIiwiSXRlbVZpZXciLCJzZXRJY29uIiwiUGx1Z2luU2V0dGluZ1RhYiIsIlBsdWdpbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRztBQUtHLE1BQWdCLFFBQVMsU0FBUUEsY0FBSyxDQUFBO0FBSXhDLElBQUEsV0FBQSxDQUN1QixNQUFpQixFQUFBO0FBRXBDLFFBQUEsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUZDLElBQU0sQ0FBQSxNQUFBLEdBQU4sTUFBTSxDQUFXO1FBSGhDLElBQU8sQ0FBQSxPQUFBLEdBQUcsS0FBSyxDQUFDO0tBTXZCO0lBRU0sTUFBTSxHQUFBO0FBQ1QsUUFBQSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs7UUFHcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDOztBQUduRCxRQUFBLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsb0NBQW9DLEVBQUU7QUFDM0QsWUFBQSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBb0IsS0FBSTs7Z0JBRXRELElB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LE9BQU8sRUFBQyxRQUFRLEVBQUMsT0FBTyxFQUFDLGlCQUFpQixFQUFDLFdBQVcsRUFBQyxTQUFTLEVBQUMsT0FBTyxFQUFDLE9BQU8sRUFBQyxLQUFLLEVBQUMsT0FBTyxFQUFDLE1BQU0sRUFBQyxpQkFBaUIsRUFBQyxZQUFZLEVBQUMsWUFBWSxFQUFDLFVBQVUsRUFBQyxXQUFXLEVBQUMsa0JBQWtCLEVBQUMsUUFBUSxFQUFDLFFBQVEsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLE9BQU8sRUFBQyxNQUFNLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxFQUFDLGlCQUFpQixFQUFDLGVBQWUsRUFBQyxRQUFRLEVBQUMsWUFBWSxFQUFDLE1BQU0sRUFBQyxZQUFZLEVBQUMsVUFBVSxFQUFDLE1BQU0sRUFBQyxNQUFNLEVBQUMsWUFBWSxFQUFDLE9BQU8sRUFBQyxhQUFhLEVBQUMsU0FBUyxFQUFDLGFBQWEsRUFBQyxTQUFTLEVBQUMsTUFBTSxFQUFDLGFBQWEsRUFBQyxXQUFXLEVBQUMsWUFBWSxFQUFDLE9BQU8sRUFBQyxRQUFRLEVBQUMsT0FBTyxFQUFDLFFBQVEsRUFBQyxjQUFjLEVBQUMsVUFBVSxFQUFDLE1BQU0sRUFBQyxTQUFTLEVBQUMsV0FBVyxFQUFDLFFBQVEsRUFBQyxjQUFjLEVBQUMsS0FBSyxFQUFDLFVBQVUsRUFBQyxVQUFVLEVBQUMsV0FBVyxFQUFDLFVBQVUsRUFBQyxRQUFRLEVBQUMsY0FBYyxFQUFDLE9BQU8sRUFBQyxRQUFRLEVBQUMsa0JBQWtCLEVBQUMsYUFBYSxFQUFDLGFBQWEsRUFBQyxpQkFBaUIsRUFBQyxRQUFRLEVBQUMsU0FBUyxFQUFDLFdBQVcsRUFBQyxlQUFlLEVBQUMsV0FBVyxFQUFDLFlBQVksRUFBQyxRQUFRLEVBQUMsTUFBTSxFQUFDLFVBQVUsRUFBQyxhQUFhLEVBQUMsWUFBWSxFQUFDLGNBQWMsRUFBQyxXQUFXLEVBQUMsUUFBUSxFQUFDLE1BQU0sRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFDLGNBQWMsRUFBQyxZQUFZLEVBQUMsUUFBUSxFQUFDLE1BQU0sRUFBQyxRQUFRLEVBQUMsU0FBUyxFQUFDLE1BQU0sRUFBQyxTQUFTLEVBQUMsS0FBSyxFQUFDLFlBQVksRUFBQyxVQUFVLEVBQUMsV0FBVyxFQUFDLEtBQUssRUFBQyxNQUFNLEVBQUMsZ0JBQWdCLEVBQUMsZ0JBQWdCLEVBQUMsU0FBUyxFQUFDLEtBQUssRUFBQyxZQUFZLEVBQUMsVUFBVSxFQUFDLGNBQWMsRUFBQyxjQUFjLEVBQUMsT0FBTyxFQUFDLGFBQWEsRUFBQyxpQkFBaUIsRUFBQyxTQUFTLEVBQUMsTUFBTSxFQUFDLGlCQUFpQixFQUFDLGVBQWUsRUFBQyxlQUFlLEVBQUMsVUFBVSxFQUFDLGlCQUFpQixFQUFDLHFCQUFxQixFQUFDLGVBQWUsRUFBQyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsZUFBZSxFQUFDLGlCQUFpQixFQUFDLGVBQWUsRUFBQyxNQUFNLEVBQUMsT0FBTyxFQUFDLGNBQWMsRUFBQyxZQUFZLEVBQUMsU0FBUyxFQUFDLFNBQVMsRUFBQyxRQUFRLEVBQUMsU0FBUyxFQUFDLGVBQWUsRUFBQyxlQUFlLEVBQUMsY0FBYyxFQUFDLGdCQUFnQixFQUFDLFdBQVcsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLFVBQVUsRUFBQyxXQUFXLEVBQUMsY0FBYyxFQUFDLGVBQWUsRUFBQyxPQUFPLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBQyxTQUFTLEVBQUMsaUJBQWlCLEVBQUMsWUFBWSxFQUFDLGlCQUFpQixFQUFDLGdCQUFnQixFQUFDLGNBQWMsRUFBQyxXQUFXLEVBQUMsZ0JBQWdCLEVBQUMsT0FBTyxFQUFDLFdBQVcsRUFBQyxZQUFZLEVBQUMsS0FBSyxFQUFDLFNBQVMsRUFBQyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sRUFBQyxVQUFVLEVBQUMsYUFBYSxFQUFDLGFBQWEsRUFBQyxNQUFNLEVBQUMsUUFBUSxFQUFDLFNBQVMsRUFBQyxTQUFTLEVBQUMsZ0JBQWdCLEVBQUMsV0FBVyxFQUFDLE9BQU8sRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxPQUFPLEVBQUMsTUFBTSxFQUFDLGFBQWEsRUFBQyxZQUFZLEVBQUMsT0FBTyxFQUFDLFVBQVUsRUFBQyxRQUFRLEVBQUMsV0FBVyxFQUFDLE9BQU8sRUFBQyxRQUFRLEVBQUMsUUFBUSxFQUFDLGVBQWUsRUFBQyxZQUFZLEVBQUMsV0FBVyxFQUFDLEtBQUssRUFBQyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sRUFBQyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sRUFBQyxVQUFVLEVBQUMsa0JBQWtCLEVBQUMsY0FBYyxFQUFDLFFBQVEsRUFBQyxNQUFNLEVBQUMsc0JBQXNCLEVBQUMsb0JBQW9CLEVBQUMsY0FBYyxFQUFDLFlBQVksRUFBQyxRQUFRLEVBQUMsWUFBWSxFQUFDLFVBQVUsRUFBQyxTQUFTLEVBQUMsT0FBTyxFQUFDLE9BQU8sRUFBQyxjQUFjLEVBQUMsY0FBYyxFQUFDLGNBQWMsRUFBQyxZQUFZLEVBQUMsUUFBUSxFQUFDLE9BQU8sRUFBQyxjQUFjLEVBQUMsZUFBZSxFQUFDLFFBQVEsRUFBQyxRQUFRLEVBQUMsU0FBUyxFQUFDLGVBQWUsRUFBQyxjQUFjLEVBQUMsU0FBUyxFQUFDLE9BQU8sRUFBQyxhQUFhLEVBQUMsWUFBWSxFQUFDLGVBQWUsRUFBQyxhQUFhLEVBQUMsUUFBUSxFQUFDLFdBQVcsRUFBQyxjQUFjLEVBQUMsT0FBTyxFQUFDLE9BQU8sRUFBQyxPQUFPLEVBQUMsU0FBUyxFQUFDLHFCQUFxQixFQUFDLFlBQVksRUFBQyxPQUFPLEVBQUMsV0FBVyxFQUFDLFVBQVUsRUFBQyxXQUFXLEVBQUMsU0FBUyxFQUFDLFFBQVEsRUFBQyxRQUFRLEVBQUMsV0FBVyxFQUFDLE1BQU0sRUFBQyxhQUFhLEVBQUMsb0JBQW9CLEVBQUMsa0JBQWtCLEVBQUMsZUFBZSxFQUFDLFdBQVcsRUFBQyxLQUFLLEVBQUMsU0FBUyxFQUFDLFFBQVEsRUFBQyxhQUFhLEVBQUMsYUFBYSxFQUFDLGVBQWUsRUFBQyxPQUFPLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBQyxRQUFRLEVBQUMsTUFB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RUFBQyxZQUFZLEVBQUMsVUFBVSxFQUFDLFlBQVksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFDLFFBQVEsRUFBQyxNQUFNLEVBQUMsZ0JBQWdCLEVBQUMsY0FBYyxFQUFDLGNBQWMsRUFBQyxPQUFPLEVBQUMsY0FBYyxFQUFDLGVBQWUsRUFBQyxjQUFjLEVBQUMsY0FBYyxFQUFDLGVBQWUsRUFBQyxZQUFZLEVBQUMsa0JBQWtCLEVBQUMsZUFBZSxFQUFDLGVBQWUsRUFBQyxnQkFBZ0IsRUFBQyxrQkFBa0IsRUFBQyxhQUFhLEVBQUMsUUFBUSxFQUFDLGdCQUFnQixFQUFDLFFBQVEsRUFBQyxpQkFBaUIsRUFBQyxnQkFBZ0IsRUFBQyxnQkFBZ0IsRUFBQyxhQUFhLEVBQUMsV0FBVyxFQUFDLFNBQVMsRUFBQyxVQUFVLEVBQUMsVUFBVSxFQUFDLFVBQVUsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLFNBQVMsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLFNBQVMsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLGNBQWMsRUFBQyxlQUFlLEVBQUMsV0FBVyxFQUFDLFlBQVksRUFBQyxpQkFBaUIsRUFBQyxZQUFZLEVBQUMsV0FBVyxFQUFDLGlCQUFpQixFQUFDLFlBQVksRUFBQyxZQUFZLEVBQUMsV0FBVyxFQUFDLGNBQWMsRUFBQyxRQUFRLEVBQUMsUUFBUSxFQUFDLFFBQVEsRUFBQyxNQUFNLEVBQUMsU0FBUyxFQUFDLGFBQWEsRUFBQyxRQUFRLEVBQUMsT0FBTyxFQUFDLFNBQVMsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLFNBQVMsRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFDLE1BQU0sRUFBQyxVQUFVLEVBQUMsV0FBVyxFQUFDLGtCQUFrQixFQUFDLG1CQUFtQixFQUFDLGtCQUFrQixFQUFDLGdCQUFnQixFQUFDLG1CQUFtQixFQUFDLGlCQUFpQixFQUFDLGdCQUFnQixFQUFDLGlCQUFpQixFQUFDLEtBQUssRUFBQyxhQUFhLEVBQUMsTUFBTSxFQUFDLGNBQWMsRUFBQyxXQUFXLEVBQUMsT0FBTyxFQUFD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QUFhLEVBQUMsaUJBQWlCLEVBQUMsU0FBUyxFQUFDLE1BQU0sRUFBQyxpQkFBaUIsRUFBQyxlQUFlLEVBQUMsZUFBZSxFQUFDLFVBQVUsRUFBQyxpQkFBaUIsRUFBQyxxQkFBcUIsRUFBQyxlQUFlLEVBQUMsT0FBTyxFQUFDLGlCQUFpQixFQUFDLGVBQWUsRUFBQyxpQkFBaUIsRUFBQyxlQUFlLEVBQUMsTUFBTSxFQUFDLE9BQU8sRUFBQyxjQUFjLEVBQUMsWUFBWSxFQUFDLFNBQVMsRUFBQyxTQUFTLEVBQUMsUUFBUSxFQUFDLFNBQVMsRUFBQyxlQUFlLEVBQUMsZUFBZSxFQUFDLGNBQWMsRUFBQyxnQkFBZ0IsRUFBQyxXQUFXLEVBQUMsU0FBUyxFQUFDLFNBQVMsRUFBQyxVQUFVLEVBQUMsV0FBVyxFQUFDLGNBQWMsRUFBQyxlQUFlLEVBQUMsT0FBTyxFQUFDLFVBQVUsRUFBQyxlQUFlLEVBQUMsU0FBUyxFQUFDLGlCQUFpQixFQUFDLFlBQVksRUFBQyxpQkFBaUIsRUFBQyxnQkFBZ0IsRUFBQyxjQUFjLEVBQUMsV0FBVyxFQUFDLGdCQUFnQixFQUFDLE9BQU8sRUFBQyxXQUFXLEVBQUMsWUFBWSxFQUFDLFlBQVksRUFBQyxTQUFTLEVBQUMsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLEVBQUMsVUFBVSxFQUFDLGFBQWEsRUFBQyxhQUFhLEVBQUMsTUFBTSxFQUFDLFFBQVEsRUFBQyxTQUFTLEVBQUMsU0FBUyxFQUFDLGdCQUFnQixFQUFDLFdBQVcsRUFBQyxPQUFPLEVBQUMsU0FBUyxFQUFDLFNBQVMsRUFBQyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsT0FBTyxFQUFDLE1BQU0sRUFBQyxhQUFhLEVBQUMsWUFBWSxFQUFDLE9BQU8sRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFDLFdBQVcsRUFBQyxPQUFPLEVBQUMsUUFBUSxFQUFDLFFBQVEsRUFBQyxlQUFlLEVBQUMsWUFBWSxFQUFDLFdBQVcsRUFBQyxLQUFLLEVBQUMsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLEVBQUMsT0FBTyxFQUFDLFdBQVcs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
