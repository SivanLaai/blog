---
created: 2025-03-20T10:25:37 (UTC +08:00)
tags: []
source: https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150
author: 
---

# 80. 删除有序数组中的重复项 II - 力扣（LeetCode）

---
给你一个有序数组 `nums` ，请你 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**示例 1：**

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

-   `1 <= nums.length <= 3 * 10<sup>4</sup>`
-   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
-   `nums` 已按升序排列


## 思路1：双指针
-   使用快慢指针，快指针用于遍历数组，慢指针用于记录新数组的长度
-   慢指针初始值为2，因为前两个元素一定不会被删除
-   快指针从2开始遍历数组，每次遍历到一个元素时，判断该元素是否与慢指针前两个元素相同
-   如果相同，则说明该元素已经出现了三次，不需要保留，直接跳过
-   如果不同，则说明该元素没有出现三次，需要保留，将该元素复制到慢指针指向的位置，然后将慢指针向后移动一位
-   遍历结束后，慢指针指向的位置即为新数组的长度
-   时间复杂度：O(n)，其中n为数组的长度
-   空间复杂度：O(1)
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2)
            return nums.size();
        int slow = 2;
        int fast = 2;
        while (fast < nums.size()) {
            if (nums[slow-2]!=nums[fast++]) {
                nums[slow++] = nums[fast-1];
            }
        }
        return slow;
    }
};       
```
## 思路2：栈
-   因为题目要求是原地删除重复出现的元素，所以可以考虑把原先的数组看成栈来模拟删除操作
-   前两个元素一定不会被删除，所以栈的大小初始为2
-   从第三个元素开始遍历数组，每次遍历到一个元素时，判断该元素是否与栈顶的第2个元素相同
-   如果相同，则说明该元素已经出现了三次，不需要保留，直接跳过
-   如果不同，则说明该元素没有出现三次，需要保留，将该元素入栈，然后将栈的大小加1
-   遍历结束后，栈的大小即为新数组的长度
-   时间复杂度：O(n)，其中n为数组的长度
-   空间复杂度：O(1)
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int stack_size = 2;
        int n = nums.size();
        if (n <= 2)
            return n;
        for (int i=2; i<n; i++) {
            if (nums[i] != nums[stack_size-2]) {
                nums[stack_size++] = nums[i];
            }
        }
        return stack_size;
    }
};
```